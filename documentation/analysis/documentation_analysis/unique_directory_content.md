# Unique Content in Directory Documentation

The following files appear in the directory-based documentation but not in the comprehensive documentation:

## documentation/MASTER_INDEX.md

# TuneMantra Documentation Master Index

This Master Index serves as your navigation guide between TuneMantra's two complementary documentation systems:

1. **Directory-based Documentation** - Organized by topic in the `documentation/` directory
2. **[Comprehensive Documentation](../../TuneMantra_Comprehensive_Documentation.md)** - Single file containing all historical content

## About the Two Documentation Systems

### Directory-based Documentation

The directory-based documentation provides a well-organized, topic-focused structure that makes it easy to find specific information. This system is ideal for:

- Daily reference during active development
- Quickly locating specific functionality details
- Understanding the current implementation

**Key characteristics:**
- Organized in logical hierarchy
- Contains the most current information
- Optimized for ease of navigation
- Each file focuses on a specific topic

### Comprehensive Documentation

The comprehensive documentation file contains the complete historical record of all TuneMantra documentation. This system is valuable for:

- Researching historical context and design decisions
- Accessing a complete archive of all documentation
- Using full-text search across all documentation at once

**Key characteristics:**
- Complete historical archive
- Single searchable file
- Contains legacy information
- Maintains all original sections and content

## Cross-Reference Guide

The following table provides navigation links between the two documentation systems, mapping key sections in the comprehensive documentation to their corresponding directories in the directory-based structure:

| Comprehensive Document Section | Directory Location |
|-------------------------------|-------------------|
| [1. Project Overview](../../TuneMantra_Comprehensive_Documentation.md) | [Project Overview](project-overview.md) |
| [2. System Architecture](../../TuneMantra_Comprehensive_Documentation.md) | [Technical/Architecture](technical/architecture/) |
| [3. Blockchain Technology](../../TuneMantra_Comprehensive_Documentation.md) | [Technical/Blockchain](technical/blockchain/) |
| [4. Rights Management](../../TuneMantra_Comprehensive_Documentation.md) | [Technical/Rights Management](technical/rights_management/) |
| [5. Database Schema](../../TuneMantra_Comprehensive_Documentation.md) | [Developer/Database](developer/database/) |
| [6. API Reference](../../TuneMantra_Comprehensive_Documentation.md) | [Reference/API](reference/api/) |
| [7. User Guides](../../TuneMantra_Comprehensive_Documentation.md) | [User](user/) |
| [8. Administration](../../TuneMantra_Comprehensive_Documentation.md) | [Admin](admin/) |
| [9. Development](../../TuneMantra_Comprehensive_Documentation.md) | [Developer](developer/) |
| [10. Integrations](../../TuneMantra_Comprehensive_Documentation.md) | [Technical/Integrations](technical/integrations/) |
| [11. Analytics & Reporting](../../TuneMantra_Comprehensive_Documentation.md) | [Technical/Analytics](technical/analytics/) |
| [12. Distribution Systems](../../TuneMantra_Comprehensive_Documentation.md) | [Technical/Distribution](technical/distribution/) |
| [13. AI & Machine Learning](../../TuneMantra_Comprehensive_Documentation.md) | [Technical/AI](technical/ai/) |
| [14. Security](../../TuneMantra_Comprehensive_Documentation.md) | [Technical/Security](technical/security/) |
| [15. Testing & Quality Assurance](../../TuneMantra_Comprehensive_Documentation.md) | [Testing](testing/) |
| [16. Project History & Evolution](../../TuneMantra_Comprehensive_Documentation.md) | [Project/History](project/history/) |

## Key Documentation Files

### Core Platform Documentation

- [Project Overview](project-overview.md) - High-level overview of TuneMantra
- [Technical Architecture](technical/architecture/overview.md) - System architecture documentation
- [Blockchain Integration](technical/blockchain/README.md) - Blockchain implementation details
- [Rights Management](technical/rights_management/README.md) - Rights management system documentation
- [API Reference](reference/api/README.md) - API documentation
- [User Guides](user/README.md) - Documentation for platform users

### Development Documentation

- [Developer Guide](developer/README.md) - Guide for developers
- [Database Schema](developer/database/schema.md) - Database schema documentation
- [Code Standards](developer/standards/coding-standards.md) - Coding standards and best practices
- [Testing Guide](testing/README.md) - Testing procedures and guidelines

## Documentation Tools

A utility script is available to help analyze the content in both documentation systems:

```bash
node scripts/utils/doc_content_comparison.js
```

This tool generates reports identifying unique content that exists in either the comprehensive documentation or the directory-based documentation but not in both.

## Documentation Maintenance

When updating documentation:

1. Always update the directory-based documentation first
2. For significant changes, consider adding a note to this Master Index
3. Use the documentation tools to ensure consistency between both systems

For questions about the documentation structure or to suggest improvements, please refer to the [Documentation About Documentation](metadata/README.md) section.

---

## documentation/ROOT_FILES_INDEX.md

# Index of Root-Level Documentation Files

This document provides an index of all documentation files that were originally located at the root level of the repository and have been moved into the documentation structure.

## Project Documentation

These files have been moved to the `documentation/project/` directory:

| Original Location | New Location |
|-------------------|--------------|
| `/codebase-comparison.md` | `/documentation/project/codebase-comparison.md` |
| `/comprehensive-code-evolution.md` | `/documentation/project/comprehensive-code-evolution.md` |
| `/implementation-plan.md` | `/documentation/project/implementation-plan.md` |

## Testing Documentation

These files have been moved to the `documentation/testing/` directory:

| Original Location | New Location |
|-------------------|--------------|
| `/testing-approach.md` | `/documentation/testing/testing-approach.md` |
| `/testing-guide.md` | `/documentation/testing/testing-guide.md` |
| `/test-plan.md` | `/documentation/testing/test-plan.md` |

## Documentation Structure

These files have been moved to the `documentation/metadata/` directory:

| Original Location | New Location |
|-------------------|--------------|
| `/documentation-structure.md` | `/documentation/metadata/documentation-structure.md` |
| `/documentation-updated-structure.md` | `/documentation/metadata/documentation-updated-structure.md` |

## Retained Files

These files remain at the root level:

| File | Purpose |
|------|---------|
| `/README.md` | Main project README with overview and navigation |

## Note on Implementation

All files have been moved from their original locations to their new homes in the documentation structure. The main documentation README has been updated to reference the new locations.

This organization helps maintain a clean, well-structured documentation system that is easier to navigate and maintain.

---

## documentation/admin/README.md

# TuneMantra Admin Documentation

This section contains documentation for TuneMantra platform administrators and DevOps personnel.

## Deployment

- [Deployment Guide](deployment.md) - Comprehensive deployment guide
- [Environment Setup](environment-setup.md) - Setting up server environments
- [Configuration Management](configuration-management.md) - Managing system configuration

## Platform Management

- [Platform Management](platform-management.md) - Day-to-day platform management
- [User Administration](user-administration.md) - Managing users and permissions
- [Content Management](content-management.md) - Content approval and management

## Monitoring and Maintenance

- [Monitoring Guide](monitoring-guide.md) - System monitoring procedures
- [Backup and Recovery](backup-recovery.md) - Data backup and disaster recovery
- [Performance Optimization](performance-optimization.md) - Performance tuning

## Security

- [Security Procedures](security-procedures.md) - Security protocols and procedures
- [Access Control](access-control.md) - Managing access to system resources
- [Audit Logging](audit-logging.md) - System auditing and logging

## Updates and Upgrades

- [Update Procedures](update-procedures.md) - Platform update procedures
- [Release Notes](release-notes.md) - Information about new releases
- [Migration Guide](migration-guide.md) - Data migration procedures

---

## documentation/admin/deployment.md

# Deployment Guide

## Overview

This guide covers the deployment process for the TuneMantra platform. TuneMantra is designed to be deployed in various environments, but this guide focuses on deployment with Replit, which provides a straightforward and scalable hosting solution.

## Prerequisites

Before deploying TuneMantra, ensure you have:

1. A Replit account with access to the TuneMantra repository
2. A PostgreSQL database (Neon serverless PostgreSQL recommended)
3. Required environment variables and secrets
4. Access to any third-party services needed (e.g., payment processing, file storage)

## Environment Variables

TuneMantra requires several environment variables to function properly. Set these in your Replit environment:

### Required Variables

```
# Database Connection
DATABASE_URL=postgresql://username:password@hostname:port/database

# Session Management
SESSION_SECRET=your-secure-session-secret

# Admin Access
SUPER_ADMIN_CODE=your-super-admin-registration-code

# API Security
API_KEY_SECRET=your-api-key-encryption-secret
```

### Optional Variables

```
# Environment Configuration
NODE_ENV=production

# Port Configuration (defaults to 5000)
PORT=5000

# External Services
PAYMENT_GATEWAY_API_KEY=your-payment-gateway-key
STORAGE_API_KEY=your-storage-service-key
AI_SERVICE_API_KEY=your-ai-service-key
```

## Deployment Steps

### 1. Prepare for Deployment

Before deploying, ensure your code is ready for production:

1. Run linters and type-checking:
   ```bash
   npm run check
   ```

2. Test the build process locally:
   ```bash
   npm run build
   ```

3. Make sure all dependencies are correctly listed in `package.json`

### 2. Deploy to Replit

Replit provides a simple deployment process:

1. Push your code to the Replit repository

2. In the Replit interface, navigate to the "Deployment" tab

3. Configure deployment settings:
   - Build command: `npm run build`
   - Run command: `npm run start`
   - Environment variables: Add all required variables

4. Click "Deploy" to start the deployment process

### 3. Monitor Deployment

1. Replit will show the build and deployment progress

2. If the build fails, check the logs for errors:
   - Common issues include missing dependencies or environment variables
   - TypeScript errors that weren't caught during development

3. Once deployed, Replit will provide a public URL for your application

### 4. Post-Deployment Configuration

After successful deployment, complete these additional steps:

1. **Create Super Admin Account**:
   - Navigate to `/super-admin/register`
   - Use the `SUPER_ADMIN_CODE` value to register the first admin account

2. **Configure Platforms**:
   - Login as the super admin
   - Navigate to the admin dashboard
   - Set up distribution platforms and their API credentials

3. **Verify Storage Access**:
   - Test file uploads to ensure the storage configuration is working
   - Check that uploaded files are accessible via their URLs

## Database Management

### Initial Setup

If deploying to a new environment, you'll need to set up the database:

1. Ensure your PostgreSQL database is accessible from the deployment environment

2. The initial database schema will be created automatically on first run

3. For a clean installation, run the database migrations:
   ```bash
   npm run db:push
   ```

### Database Migrations

When deploying updates that include schema changes:

1. Always back up the database before deploying

2. Use Drizzle's migration tools to apply changes safely:
   ```bash
   npm run db:push
   ```

3. Monitor the migration process for any errors

## Scaling Considerations

As your user base grows, consider these scaling strategies:

### Database Scaling

1. **Connection Pooling**: Configure the connection pool size based on expected load:
   ```typescript
   // Adjust pool configuration in server/db.ts
   const pool = new Pool({
     connectionString: process.env.DATABASE_URL,
     max: 20 // Increase for higher traffic
   });
   ```

2. **Read Replicas**: For heavy read workloads, consider setting up PostgreSQL read replicas

3. **Database Monitoring**: Implement monitoring for query performance and connection usage

### Application Scaling

1. **Horizontal Scaling**: Deploy multiple instances behind a load balancer

2. **Memory Management**: Monitor memory usage and adjust resource allocation

3. **Caching**: Implement Redis caching for frequently accessed data:
   ```typescript
   // Example Redis caching middleware
   const cacheMiddleware = (req, res, next) => {
     const key = `cache:${req.originalUrl}`;
     redisClient.get(key, (err, data) => {
       if (data) {
         return res.json(JSON.parse(data));
       }
       res.originalJson = res.json;
       res.json = (body) => {
         redisClient.setex(key, 3600, JSON.stringify(body));
         return res.originalJson(body);
       };
       next();
     });
   };
   ```

## Continuous Deployment

For automated deployment workflows:

1. Set up GitHub Actions or similar CI/CD platform

2. Configure automated testing before deployment

3. Implement a multi-environment strategy:
   - Development
   - Staging/QA
   - Production

Example GitHub Actions workflow:

```yaml
name: Deploy to Replit

on:
  push:
    branches: [ main ]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      
      - name: Use Node.js
        uses: actions/setup-node@v2
        with:
          node-version: '16'
          
      - name: Install dependencies
        run: npm ci
        
      - name: Type check
        run: npm run check
        
      - name: Build
        run: npm run build
        
      - name: Deploy to Replit
        uses: replit/replit-deploy@v1
        with:
          token: ${{ secrets.REPLIT_TOKEN }}
```

## Monitoring and Logging

### Error Tracking

1. Implement comprehensive error logging:
   ```typescript
   // Global error handler in server/index.ts
   app.use((err, req, res, next) => {
     console.error(`[ERROR] ${new Date().toISOString()}:`, {
       error: err.message,
       stack: err.stack,
       path: req.path,
       method: req.method,
       user: req.userId
     });
     // Send response to client
     res.status(err.status || 500).json({
       error: {
         message: err.message,
         code: err.code || 'INTERNAL_ERROR'
       }
     });
   });
   ```

2. Set up alerts for critical errors

### Performance Monitoring

1. Implement API response time tracking:
   ```typescript
   // Response time middleware
   app.use((req, res, next) => {
     const start = Date.now();
     res.on('finish', () => {
       const duration = Date.now() - start;
       console.log(`${req.method} ${req.path} ${res.statusCode} ${duration}ms`);
       if (duration > 1000) {
         console.warn(`Slow response (${duration}ms): ${req.method} ${req.path}`);
       }
     });
     next();
   });
   ```

2. Monitor database query performance:
   ```typescript
   // Example query logging
   db.on('query', (query) => {
     const start = Date.now();
     query.on('end', () => {
       const duration = Date.now() - start;
       console.log(`Query (${duration}ms): ${query.text}`);
     });
   });
   ```

## Backup Strategy

Implement a robust backup strategy:

1. **Database Backups**:
   - Schedule regular PostgreSQL dumps
   - Store backups in secure, offsite storage
   - Test restore procedures regularly

2. **File Storage Backups**:
   - Back up uploaded files regularly
   - Implement versioning if possible
   - Ensure backup synchronization with database backups

3. **Configuration Backups**:
   - Back up environment variables and configuration
   - Document all external service dependencies
   - Maintain deployment documentation

## Security Checklist

Before launching to production, complete this security checklist:

1. **Secure Communication**:
   - Enforce HTTPS with proper certificates
   - Implement HTTP Strict Transport Security (HSTS)
   - Configure secure cookie settings

2. **Access Controls**:
   - Review all API endpoints for proper authentication
   - Test role-based access controls
   - Verify middleware protection is working

3. **Data Protection**:
   - Ensure sensitive data is encrypted
   - Verify password hashing is secure
   - Implement rate limiting for authentication endpoints

4. **External Dependencies**:
   - Audit npm packages for vulnerabilities:
     ```bash
     npm audit
     ```
   - Keep all dependencies updated
   - Remove unused dependencies

## Troubleshooting Common Issues

### Database Connection Problems

If your application can't connect to the database:

1. Verify the `DATABASE_URL` environment variable is correctly set
2. Ensure database credentials are valid
3. Check network connectivity between your application and database
4. Verify PostgreSQL is running and accessible from your deployment environment

### Application Startup Failures

If the application fails to start:

1. Check logs for error messages
2. Verify all required environment variables are set
3. Ensure the build process completed successfully
4. Check for port conflicts with other services

### Performance Issues

If you experience slow performance:

1. Review database query performance
2. Check memory usage and potential leaks
3. Analyze slow API responses
4. Consider implementing caching for frequent operations

## Rollback Procedures

If a deployment causes issues, follow these rollback steps:

1. **Immediate Mitigation**:
   - If possible, fix forward with a quick patch
   - Otherwise, revert to the previous version

2. **Database Rollback**:
   - If schema changes were made, restore from the pre-deployment backup
   - For data-only issues, run corrective SQL scripts

3. **Post-Rollback Analysis**:
   - Document the failure cause
   - Implement tests to prevent similar issues
   - Review deployment process for improvements

## Maintenance Windows

1. **Scheduled Maintenance**:
   - Plan maintenance during low-traffic periods
   - Notify users at least 24 hours in advance
   - Provide estimated downtime duration

2. **Emergency Maintenance**:
   - Have a communication plan for unplanned downtime
   - Prioritize critical fixes
   - Provide regular status updates during extended outages

---

## documentation/admin/platform-management.md

# TuneMantra Platform Management Guide

## Introduction

This guide is designed for TuneMantra administrators responsible for managing and maintaining the platform. It covers all aspects of platform administration, from user management to system configuration and reporting.

## Administrator Roles and Permissions

TuneMantra implements a hierarchical admin structure:

### Super Admin

- Has complete access to all platform features
- Can create other admin accounts
- Manages global platform settings
- Accesses system-level configurations

### Platform Admin

- Manages users and content across the platform
- Approves/rejects new user registrations
- Handles royalty distribution issues
- Monitors platform performance

### Label Admin

- Manages specific label accounts
- Approves artist content under their label
- Handles support for their artists
- Reviews analytics for their roster

## Admin Dashboard

### Accessing Admin Features

1. Log in with your admin credentials
2. Navigate to the Admin Dashboard via:
   - Direct URL: `/admin/dashboard`
   - Admin dropdown in the top navigation bar

### Dashboard Overview

The admin dashboard provides a comprehensive view of platform activity:

- **User Activity**: New registrations, active users, login trends
- **Content Metrics**: Track uploads, release submissions, distribution status
- **Financial Overview**: Royalty calculations, payment processing, revenue trends
- **System Status**: Server health, database performance, API usage
- **Alerts**: Critical issues requiring admin attention

## User Management

### User Overview

1. Navigate to "Admin" > "User Management"
2. View a list of all platform users with filtering options:
   - By status (active, pending, suspended)
   - By role (artist, label, admin)
   - By registration date
   - By subscription tier

### User Verification

New user accounts often require verification:

1. Go to "Admin" > "User Management" > "Pending Verification"
2. Review submitted documentation:
   - Identity verification
   - Business registration (for labels)
   - Tax information
3. Approve or reject with comments
4. Set appropriate role and permissions

### Edit User Details

1. Find the user in the User Management section
2. Click "Edit" to modify:
   - Contact information
   - Role and permissions
   - Subscription details
   - Account status

### Account Actions

Administrative actions available for user accounts:

- **Suspend Account**: Temporarily disable access
- **Terminate Account**: Permanently disable with data preservation
- **Delete Account**: Permanently remove account and associated data
- **Reset Password**: Generate a password reset link
- **Login As User**: Temporarily access account for troubleshooting

## Content Management

### Content Approval Workflow

New releases may require admin approval:

1. Navigate to "Admin" > "Content Management" > "Pending Approval"
2. Review the release details:
   - Artist/label information
   - Track metadata
   - Audio quality
   - Cover artwork
   - Rights declarations
3. Approve, reject with comments, or request changes
4. Once approved, release is queued for distribution

### Content Moderation

For content that violates terms of service:

1. Go to "Admin" > "Content Management" > "Content Moderation"
2. Review flagged content (either automatic or user-reported)
3. Take appropriate action:
   - Approve content (false positive)
   - Request modifications
   - Remove content
   - Issue user warning
   - Take account action if necessary

### Bulk Content Management

For managing multiple content items:

1. Navigate to "Admin" > "Content Management" > "Bulk Actions"
2. Filter content by various criteria
3. Select multiple items
4. Apply bulk actions:
   - Approve/reject
   - Change status
   - Re-queue for distribution
   - Generate reports

## Financial Administration

### Royalty Management

1. Navigate to "Admin" > "Finance" > "Royalty Management"
2. Monitor the royalty calculation process:
   - View calculation status
   - Troubleshoot failed calculations
   - Manually trigger recalculations if needed
3. Approve batch royalty calculations before payment
4. Handle special cases and disputes

### Payment Processing

1. Go to "Admin" > "Finance" > "Payment Processing"
2. Review pending withdrawal requests
3. Approve or flag for review
4. Monitor payment processor status
5. Handle failed payments and exceptions

### Financial Reporting

Generate comprehensive financial reports:

1. Navigate to "Admin" > "Finance" > "Reports"
2. Select report type:
   - Revenue overview
   - Royalty distribution summary
   - Tax withholding report
   - Platform fee summary
3. Choose date range and filtering options
4. Export in various formats (Excel, CSV, PDF)

## Platform Configuration

### Distribution Platforms

Manage connections to music distribution platforms:

1. Navigate to "Admin" > "Platform Configuration" > "Distribution Platforms"
2. Add new platforms with:
   - Platform name and details
   - API credentials
   - Delivery specifications
   - Platform-specific metadata requirements
3. Edit existing platform configurations
4. Monitor platform status and performance

### Subscription Tiers

Configure subscription plans:

1. Go to "Admin" > "Platform Configuration" > "Subscription Plans"
2. Manage existing plans:
   - Modify features and limitations
   - Adjust pricing
   - Change billing cycles
3. Create new subscription tiers
4. Set up promotional offers and discounts

### System Settings

Configure global system parameters:

1. Navigate to "Admin" > "Platform Configuration" > "System Settings"
2. Adjust key settings:
   - Registration requirements
   - Content approval workflows
   - Royalty calculation parameters
   - System notifications
   - API rate limits

## Analytics and Reporting

### Platform Analytics

View comprehensive platform metrics:

1. Navigate to "Admin" > "Analytics" > "Platform Overview"
2. Monitor key performance indicators:
   - User growth and retention
   - Content volume and quality
   - Distribution performance
   - Revenue and royalty trends
3. Filter by date range and segment
4. Export reports for stakeholders

### Custom Reports

Generate specialized reports for business intelligence:

1. Go to "Admin" > "Analytics" > "Custom Reports"
2. Select report parameters:
   - Data points to include
   - Grouping and aggregation methods
   - Filtering criteria
   - Visualization options
3. Save report templates for future use
4. Schedule automated report generation

### Audit Logs

Review system activity for security and troubleshooting:

1. Navigate to "Admin" > "System" > "Audit Logs"
2. Filter logs by:
   - User/admin ID
   - Action type
   - Time period
   - Affected resource
3. Export logs for compliance and investigation
4. Set up alerts for suspicious activities

## Support Management

### Ticket System

Manage user support requests:

1. Navigate to "Admin" > "Support" > "Tickets"
2. View all support tickets with status:
   - New/unassigned
   - In progress
   - Waiting for user
   - Resolved
   - Closed
3. Assign tickets to support staff
4. Track resolution time and user satisfaction

### Knowledge Base Management

Maintain the user help resources:

1. Go to "Admin" > "Support" > "Knowledge Base"
2. Create, edit, and organize help articles
3. Update FAQs based on common support issues
4. Manage video tutorials and guides
5. Track article effectiveness and usage

### Announcement System

Communicate with platform users:

1. Navigate to "Admin" > "Support" > "Announcements"
2. Create platform-wide or targeted announcements
3. Schedule announcement publication
4. Track announcement delivery and read status
5. Manage notification preferences

## System Maintenance

### Database Management

Monitor and maintain database health:

1. Navigate to "Admin" > "System" > "Database"
2. View database status and performance metrics
3. Schedule maintenance operations:
   - Backup creation
   - Optimization tasks
   - Index rebuilding
4. Manage database growth and scaling

### File Storage Management

Monitor and manage uploaded content:

1. Go to "Admin" > "System" > "Storage"
2. View storage usage by:
   - Content type
   - User/label
   - Age of content
3. Implement storage policies:
   - Archiving old content
   - Compression settings
   - Redundancy configuration

### API Management

Monitor and configure API functionality:

1. Navigate to "Admin" > "System" > "API Management"
2. View API usage metrics:
   - Request volume
   - Response times
   - Error rates
   - User/client distribution
3. Configure:
   - Rate limiting
   - Access controls
   - Monitoring thresholds

## Security Administration

### Access Control

Manage admin access to the platform:

1. Navigate to "Admin" > "Security" > "Access Control"
2. Manage admin accounts:
   - Create new admin users
   - Define role-based permissions
   - Implement team-based access
   - Configure MFA requirements
3. Review admin activity logs

### Security Monitoring

Monitor the platform for security issues:

1. Go to "Admin" > "Security" > "Monitoring"
2. View security alerts:
   - Failed login attempts
   - Permission violations
   - Unusual activity patterns
   - API abuse
3. Configure alert thresholds and notification settings

### Compliance Management

Ensure platform compliance with regulations:

1. Navigate to "Admin" > "Security" > "Compliance"
2. Access compliance tools:
   - Privacy policy management
   - Data protection settings
   - Regulatory reporting
   - Consent management
3. Generate compliance reports for auditing

## Disaster Recovery

### Backup Management

Manage system backup strategy:

1. Navigate to "Admin" > "System" > "Backup"
2. View backup status:
   - Last successful backup
   - Backup size and content
   - Storage location
3. Configure backup schedule and retention
4. Test restoration process periodically

### Recovery Procedures

In case of system failure:

1. Access recovery tools through "Admin" > "System" > "Recovery"
2. Follow structured recovery workflow:
   - Assess failure impact
   - Select appropriate recovery point
   - Initiate restoration process
   - Verify system integrity post-recovery
3. Document incidents and follow-up actions

## Integrations Management

### Third-party Services

Configure and monitor external service integrations:

1. Navigate to "Admin" > "Integrations"
2. Manage connections to:
   - Payment processors
   - Analytics services
   - Email delivery services
   - Storage providers
   - Distribution partners
3. Monitor integration health and performance
4. Update API credentials and configurations

### Webhook Configuration

Manage event notifications to external systems:

1. Go to "Admin" > "Integrations" > "Webhooks"
2. Configure webhooks for:
   - User events (registration, subscription changes)
   - Content events (uploads, status changes)
   - Financial events (royalty calculations, payments)
3. Monitor delivery status and retry failed webhooks

## Best Practices

### User Management

- Verify identity documents thoroughly before approval
- Implement progressive permissions for new users
- Regularly audit user activity for unusual patterns
- Respond promptly to account support requests

### Content Administration

- Apply consistent standards for content approval
- Document content rejection reasons clearly
- Implement random quality checks for approved content
- Maintain a database of common issues for reference

### Financial Operations

- Schedule regular audits of royalty calculations
- Implement four-eye principle for large payments
- Maintain clear documentation of financial exceptions
- Follow consistent processes for dispute resolution

### System Performance

- Monitor key performance metrics with alerting
- Schedule maintenance during low-usage periods
- Document all system changes and updates
- Test scaling capabilities proactively

## Troubleshooting Common Issues

### User Registration Problems

- **Issue**: Users unable to complete registration
- **Checks**:
  - Verify email delivery service status
  - Check validation rules configuration
  - Look for database constraints or errors
  - Review recent changes to registration flow

### Content Distribution Failures

- **Issue**: Content fails to distribute to platforms
- **Checks**:
  - Verify platform API credentials
  - Check for platform-specific errors
  - Review content format and metadata
  - Check network connectivity to distribution services

### Royalty Calculation Issues

- **Issue**: Royalty calculations failing or inaccurate
- **Checks**:
  - Review platform reporting data completeness
  - Check calculation parameters and rules
  - Verify database query performance
  - Look for data inconsistencies in analytics records

### System Performance Degradation

- **Issue**: Platform becoming slow or unresponsive
- **Checks**:
  - Monitor database query performance
  - Check server resource utilization
  - Review recent traffic patterns
  - Identify potential bottlenecks in application code

## Escalation Procedures

### Support Escalation

For complex support issues:

1. Initial support agent documents attempted solutions
2. Supervisor reviews and assigns appropriate specialist
3. Engineering team consulted for technical issues
4. Management involved for policy or business decisions
5. Resolution documented and shared for knowledge base

### Emergency Response

For critical system issues:

1. On-call admin receives alert via monitoring system
2. Severity assessment determines response team
3. Incident commander coordinates response efforts
4. Regular status updates provided to stakeholders
5. Post-incident review conducted and documented

## Administrator Training

New platform administrators should complete:

1. User management and verification training
2. Content moderation and approval procedures
3. Financial administration and compliance requirements
4. System monitoring and maintenance procedures
5. Security and access control protocols

## Appendices

### Admin Command Reference

Quick reference for administrative CLI commands:

```
# User management
admin:user:verify [user_id] --approve|--reject --reason="text"
admin:user:modify [user_id] --role=[role] --status=[status]

# Content management
admin:content:approve [content_id] --comment="text"
admin:content:reject [content_id] --reason="text"

# System maintenance
admin:system:backup --full|--incremental
admin:system:optimize-db
admin:system:clear-cache
```

### Monthly Admin Checklist

- [ ] Review pending user verifications older than 72 hours
- [ ] Audit user permissions for recently promoted accounts
- [ ] Check error logs for recurring issues
- [ ] Review and approve monthly royalty calculations
- [ ] Verify backup integrity and test restoration
- [ ] Update knowledge base with common support issues
- [ ] Review security alerts and access logs
- [ ] Generate and review monthly platform performance report

---

## documentation/developer/README.md

# TuneMantra Developer Documentation

This section contains comprehensive technical documentation for developers working on the TuneMantra platform.

## Getting Started

- [Installation Guide](installation-guide.md) - Setting up your development environment
- [Development Workflow](development-workflow.md) - Git workflow and collaboration processes
- [Coding Standards](coding-standards.md) - Coding style and best practices
- [Onboarding Guide](onboarding-guide.md) - Guide for new developers

## API Documentation

- [API Reference](api-reference.md) - Complete API reference documentation
- [API Integration Guide](api-integration-guide.md) - How to integrate with the TuneMantra API

## Testing

- [Testing Strategy](testing-strategy.md) - Overview of testing approaches
- [Testing Documentation](testing.md) - Detailed testing documentation

## Repository

- [Repository Documentation](repository-documentation.md) - Codebase structure and organization
- [Contributing Guide](contributing.md) - How to contribute to the project

## Architecture

- [System Architecture](architecture/system-architecture.md) - Detailed system architecture
- [Database Schema](architecture/database-schema.md) - Database structure and relationships

## Implementation Guides

- [Blockchain Integration](implementation/blockchain-integration.md) - How to work with the blockchain components
- [Rights Management](implementation/rights-management.md) - Rights management implementation details
- [Royalty Calculation](implementation/royalty-calculation.md) - Royalty system implementation details

## Resources

- [Code Snippets](resources/code-snippets.md) - Useful code snippets and examples
- [Development FAQs](resources/development-faqs.md) - Common development questions

---

## documentation/developer/coding-standards.md

# TuneMantra Coding Standards and Best Practices

*Version: 1.0.0 (March 27, 2025)*

## Table of Contents

- [Introduction](#introduction)
- [General Principles](#general-principles)
- [Code Formatting](#code-formatting)
- [Naming Conventions](#naming-conventions)
- [TypeScript and JavaScript](#typescript-and-javascript)
- [React Best Practices](#react-best-practices)
- [Node.js and Express](#nodejs-and-express)
- [Database and ORM](#database-and-orm)
- [API Design](#api-design)
- [Testing Standards](#testing-standards)
- [Security Best Practices](#security-best-practices)
- [Performance Considerations](#performance-considerations)
- [Documentation](#documentation)
- [Version Control](#version-control)
- [Code Review](#code-review)
- [Resources](#resources)

## Introduction

This document defines the coding standards and best practices for the TuneMantra platform. Consistent code quality is essential for maintainability, readability, and collaboration. All developers working on the TuneMantra codebase should adhere to these standards.

### Purpose

The purpose of these coding standards is to:

1. Ensure code consistency across the entire codebase
2. Improve code readability and maintainability
3. Reduce the cognitive load when switching between different parts of the codebase
4. Facilitate effective collaboration between team members
5. Minimize bugs and security vulnerabilities
6. Establish a framework for code reviews

### Enforcement

These standards are enforced through:

1. ESLint and Prettier configuration in the repository
2. Pre-commit hooks that run linting and formatting checks
3. CI/CD pipeline checks that fail if standards are not met
4. Code review process
5. Pair programming sessions

## General Principles

### Code Quality

1. **Readability**: Write code that is easy to read and understand
2. **Simplicity**: Prefer simple solutions over complex ones
3. **Modularity**: Break code into small, focused modules with clear responsibilities
4. **DRY (Don't Repeat Yourself)**: Avoid code duplication
5. **YAGNI (You Aren't Gonna Need It)**: Don't add functionality until it's necessary
6. **SOLID Principles**: Follow object-oriented design principles when applicable

### Clean Code

1. **Single Responsibility**: Each function or class should have a single, well-defined responsibility
2. **Meaningful Names**: Use descriptive names for variables, functions, classes, and files
3. **Small Functions**: Keep functions small and focused on a single task
4. **Comments**: Write comments to explain "why" not "what" the code does
5. **Error Handling**: Handle errors appropriately and provide meaningful error messages
6. **No Side Effects**: Functions should not have hidden side effects

## Code Formatting

### Style Guide

We follow the [Airbnb JavaScript Style Guide](https://github.com/airbnb/javascript) with some modifications. The specific rules are defined in the ESLint and Prettier configurations.

### Indentation and Spacing

1. Use 2 spaces for indentation (not tabs)
2. Add blank lines to improve readability and group related code
3. Limit line length to 100 characters
4. Use spaces around operators and after commas

```typescript
// Good
const sum = (a: number, b: number): number => {
  return a + b;
};

// Bad
const sum=(a:number,b:number):number=>{return a+b};
```

### Brackets and Braces

1. Opening braces should be on the same line as the statement
2. Always use braces for control statements, even for single-line blocks
3. Place closing braces on a new line

```typescript
// Good
if (condition) {
  doSomething();
}

// Bad
if (condition)
  doSomething();

// Also bad
if (condition) { doSomething(); }
```

### Semicolons

Always use semicolons at the end of statements.

```typescript
// Good
const x = 5;
const y = 10;

// Bad
const x = 5
const y = 10
```

### Quotes

Use single quotes for string literals, use template literals for string interpolation.

```typescript
// Good
const name = 'John';
const greeting = `Hello, ${name}!`;

// Bad
const name = "John";
const greeting = "Hello, " + name + "!";
```

## Naming Conventions

### General Rules

1. Use meaningful and descriptive names
2. Be consistent with naming patterns
3. Avoid abbreviations unless they are well-known
4. Use pronounceable names
5. Optimize for readability, not brevity

### Case Styles

1. **camelCase**: Variables, functions, methods, private properties
2. **PascalCase**: Classes, interfaces, types, enums, components
3. **UPPER_CASE**: Constants, enum values
4. **kebab-case**: File names, directory names, URLs

### Prefixes and Suffixes

1. Interface names should not have a prefix (no `I` prefix)
2. Type names should be descriptive of their purpose, not implementation
3. Boolean variables should use prefixes like `is`, `has`, `should` when appropriate
4. Handler functions should use the `handle` prefix (e.g., `handleSubmit`)

### Examples

```typescript
// Variables
const userName = 'John';
const isActive = true;
const MAX_RETRY_COUNT = 3;

// Functions
function calculateTotal(items) { ... }
const handleSubmit = () => { ... }

// Classes and interfaces
class UserService { ... }
interface AuthenticationOptions { ... }
type UserProfile = { ... }

// React components
function UserProfile() { ... }
```

### File and Directory Naming

1. React component files should be named with PascalCase (e.g., `UserProfile.tsx`)
2. Other TypeScript/JavaScript files should use kebab-case (e.g., `api-client.ts`)
3. Test files should have the same name as the file they're testing with a `.test` or `.spec` suffix
4. Directory names should be kebab-case and descriptive of their contents

## TypeScript and JavaScript

### TypeScript Usage

1. Use TypeScript for all new code
2. Define explicit return types for functions
3. Use interfaces for object shapes and API responses
4. Utilize TypeScript's type system to prevent errors
5. Avoid using `any` type whenever possible

```typescript
// Good
function getUserById(id: string): Promise<User> {
  return api.get(`/users/${id}`);
}

// Bad
function getUserById(id) {
  return api.get('/users/' + id);
}
```

### Type Declarations

1. Create types for all data structures
2. Use interfaces for object types that can be implemented or extended
3. Use type aliases for unions, intersections, and simple object types
4. Use enums for fixed sets of related values
5. Use generics for reusable components and functions

```typescript
// Interface example
interface User {
  id: string;
  firstName: string;
  lastName: string;
  email: string;
  status: UserStatus;
}

// Enum example
enum UserStatus {
  ACTIVE = 'active',
  INACTIVE = 'inactive',
  SUSPENDED = 'suspended'
}

// Generic example
function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key];
}
```

### Type Safety

1. Use proper type guards to narrow types
2. Leverage TypeScript's control flow analysis
3. Use non-null assertion (`!`) only when you're absolutely sure
4. Use optional chaining (`?.`) and nullish coalescing (`??`) operators

```typescript
// Type guard example
function isUser(obj: any): obj is User {
  return obj && 
    typeof obj.id === 'string' &&
    typeof obj.firstName === 'string' &&
    typeof obj.lastName === 'string';
}

// Control flow analysis
function processUser(user: User | null) {
  if (!user) {
    return;
  }
  
  // TypeScript knows user is non-null here
  console.log(user.firstName);
}
```

### Async Code

1. Use `async/await` for asynchronous code
2. Handle errors with try/catch blocks
3. Be mindful of Promise chains and potential unhandled rejections
4. Avoid nested callbacks

```typescript
// Good
async function fetchData() {
  try {
    const response = await api.get('/data');
    return response.data;
  } catch (error) {
    console.error('Failed to fetch data:', error);
    throw error;
  }
}

// Bad
function fetchData() {
  return api.get('/data')
    .then(response => {
      return response.data;
    })
    .catch(error => {
      console.error('Failed to fetch data:', error);
      throw error;
    });
}
```

## React Best Practices

### Component Structure

1. Prefer functional components with hooks over class components
2. Keep components small and focused on a single responsibility
3. Extract reusable logic into custom hooks
4. Split large components into smaller, more manageable pieces
5. Use the component composition pattern to combine components

```tsx
// Good - Small, focused component
function UserProfile({ user }: UserProfileProps) {
  return (
    <div className="user-profile">
      <h2>{user.firstName} {user.lastName}</h2>
      <p>{user.email}</p>
      <UserStatus status={user.status} />
    </div>
  );
}

// Bad - Component doing too much
function UserDashboard({ userId }: UserDashboardProps) {
  const [user, setUser] = useState<User | null>(null);
  const [posts, setPosts] = useState<Post[]>([]);
  const [comments, setComments] = useState<Comment[]>([]);
  
  // Fetch user, posts, comments
  // Render complex UI with all this data
}
```

### Props and State

1. Use TypeScript interfaces for prop types
2. Keep props simple and avoid deeply nested objects
3. Use default props when appropriate
4. Use React's state management hooks for component state
5. Consider context API for state that needs to be shared among components

```tsx
// Props interface
interface UserProfileProps {
  user: User;
  onUpdateUser: (user: User) => void;
  showDetails?: boolean;
}

// Component with default props
function UserProfile({
  user,
  onUpdateUser,
  showDetails = false
}: UserProfileProps) {
  // Component implementation
}

// State management
function Counter() {
  const [count, setCount] = useState(0);
  
  const increment = () => setCount(prev => prev + 1);
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increment}>Increment</button>
    </div>
  );
}
```

### Performance Optimization

1. Use React.memo for components that render often with the same props
2. Use useCallback for functions passed as props
3. Use useMemo for expensive calculations
4. Avoid unnecessary re-renders by keeping component state minimal
5. Use virtualization for long lists (react-window or react-virtualized)

```tsx
// Memoized component
const UserItem = React.memo(function UserItem({ user, onSelect }: UserItemProps) {
  return (
    <div onClick={() => onSelect(user.id)}>
      {user.name}
    </div>
  );
});

// useCallback and useMemo example
function UserList({ users }: UserListProps) {
  const [selectedId, setSelectedId] = useState<string | null>(null);
  
  const handleSelect = useCallback((id: string) => {
    setSelectedId(id);
  }, []);
  
  const sortedUsers = useMemo(() => {
    return [...users].sort((a, b) => a.name.localeCompare(b.name));
  }, [users]);
  
  return (
    <div>
      {sortedUsers.map(user => (
        <UserItem
          key={user.id}
          user={user}
          onSelect={handleSelect}
        />
      ))}
    </div>
  );
}
```

### React Query and State Management

1. Use React Query for server state management
2. Use the appropriate caching strategy for different data types
3. Handle loading, error, and success states properly
4. Implement proper query invalidation strategies
5. Use query keys that reflect the semantics of the data being fetched

```tsx
// React Query example
function UserDetails({ userId }: UserDetailsProps) {
  const { data: user, isLoading, error } = useQuery({
    queryKey: ['user', userId],
    queryFn: () => fetchUser(userId),
    staleTime: 5 * 60 * 1000, // 5 minutes
  });
  
  if (isLoading) return <Spinner />;
  if (error) return <ErrorMessage error={error} />;
  if (!user) return <NotFound />;
  
  return (
    <div>
      <h1>{user.name}</h1>
      {/* Rest of component */}
    </div>
  );
}

// Mutation example
function UserForm({ user }: UserFormProps) {
  const queryClient = useQueryClient();
  
  const mutation = useMutation({
    mutationFn: (updatedUser: User) => updateUser(updatedUser),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['user', user.id] });
      toast.success('User updated successfully');
    },
  });
  
  const handleSubmit = (formData: UserFormData) => {
    mutation.mutate({ ...user, ...formData });
  };
  
  return (
    <Form onSubmit={handleSubmit}>
      {/* Form fields */}
      <Button type="submit" disabled={mutation.isPending}>
        {mutation.isPending ? 'Saving...' : 'Save'}
      </Button>
    </Form>
  );
}
```

### React Hooks

1. Follow the rules of hooks
2. Keep custom hooks focused on a single concern
3. Name hooks with a `use` prefix
4. Keep hooks pure (avoid side effects outside of appropriate lifecycle hooks)
5. Handle cleanup in useEffect when necessary

```tsx
// Custom hook example
function useUserStatus(userId: string) {
  const [status, setStatus] = useState<UserStatus | null>(null);
  
  useEffect(() => {
    const subscription = userStatusService.subscribe(userId, (newStatus) => {
      setStatus(newStatus);
    });
    
    return () => {
      subscription.unsubscribe();
    };
  }, [userId]);
  
  return status;
}

// Using the custom hook
function UserStatusIndicator({ userId }: UserStatusIndicatorProps) {
  const status = useUserStatus(userId);
  
  if (!status) return null;
  
  return (
    <div className={`status-indicator status-${status}`}>
      {status}
    </div>
  );
}
```

## Node.js and Express

### Project Structure

1. Organize code by feature or domain, not by technical role
2. Keep controllers thin, move business logic to services
3. Separate route definitions from controller implementations
4. Use middleware for cross-cutting concerns
5. Centralize error handling

```
server/
├── api/                     # API routes and controllers
│   ├── users/               # User-related functionality
│   │   ├── user.controller.ts
│   │   ├── user.routes.ts
│   │   ├── user.validation.ts
│   │   └── user.test.ts
│   └── index.ts             # API route registration
├── services/                # Business logic
│   ├── user.service.ts
│   └── auth.service.ts
├── middleware/              # Express middleware
│   ├── auth.middleware.ts
│   ├── error.middleware.ts
│   └── validation.middleware.ts
├── db/                      # Database models and queries
│   ├── schema.ts
│   └── migrations/
├── utils/                   # Utility functions
│   ├── logger.ts
│   └── validation.ts
├── config/                  # Configuration
│   ├── env.ts
│   └── db.ts
└── app.ts                   # Express application setup
```

### API Controllers

1. Keep controllers focused on HTTP concerns
2. Validate request data before processing
3. Return consistent response structures
4. Handle errors and pass them to the error handling middleware
5. Don't perform business logic in controllers

```typescript
// Controller example
export async function getUserById(req: Request, res: Response, next: NextFunction) {
  try {
    const userId = req.params.id;
    const user = await userService.getUserById(userId);
    
    if (!user) {
      return res.status(404).json({
        status: 'error',
        message: 'User not found'
      });
    }
    
    return res.status(200).json({
      status: 'success',
      data: user
    });
  } catch (error) {
    next(error);
  }
}
```

### Middleware

1. Use middleware for cross-cutting concerns
2. Keep middleware focused on a single responsibility
3. Use middleware composition for complex functionality
4. Handle async operations properly in middleware
5. Pass errors to the next function for centralized error handling

```typescript
// Authentication middleware
export function authenticate(req: Request, res: Response, next: NextFunction) {
  const token = extractTokenFromHeader(req);
  
  if (!token) {
    return res.status(401).json({
      status: 'error',
      message: 'Authentication required'
    });
  }
  
  try {
    const decoded = verifyToken(token);
    req.user = decoded;
    next();
  } catch (error) {
    return res.status(401).json({
      status: 'error',
      message: 'Invalid token'
    });
  }
}

// Error handling middleware
export function errorHandler(
  err: Error,
  req: Request,
  res: Response,
  next: NextFunction
) {
  logger.error(err);
  
  if (err instanceof ValidationError) {
    return res.status(400).json({
      status: 'error',
      message: 'Validation error',
      details: err.details
    });
  }
  
  if (err instanceof NotFoundError) {
    return res.status(404).json({
      status: 'error',
      message: err.message
    });
  }
  
  // Default error response
  return res.status(500).json({
    status: 'error',
    message: 'Internal server error'
  });
}
```

### Services

1. Implement business logic in service classes or functions
2. Make services responsible for data access and business rules
3. Keep services stateless when possible
4. Use dependency injection for service dependencies
5. Write unit tests for services

```typescript
// Service example
export class UserService {
  constructor(private readonly db: Database) {}
  
  async getUserById(id: string): Promise<User | null> {
    return this.db.users.findUnique({
      where: { id }
    });
  }
  
  async createUser(data: CreateUserDto): Promise<User> {
    const existingUser = await this.db.users.findUnique({
      where: { email: data.email }
    });
    
    if (existingUser) {
      throw new ConflictError('User with this email already exists');
    }
    
    const hashedPassword = await hashPassword(data.password);
    
    return this.db.users.create({
      data: {
        ...data,
        password: hashedPassword
      }
    });
  }
}
```

### Error Handling

1. Use custom error classes for different error types
2. Include relevant information in error messages
3. Log errors with appropriate severity levels
4. Handle async errors properly (try/catch or .catch())
5. Use a centralized error handling middleware

```typescript
// Custom error classes
export class ApplicationError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'ApplicationError';
  }
}

export class ValidationError extends ApplicationError {
  constructor(
    message: string,
    public readonly details: Record<string, string>
  ) {
    super(message);
    this.name = 'ValidationError';
  }
}

export class NotFoundError extends ApplicationError {
  constructor(message: string) {
    super(message);
    this.name = 'NotFoundError';
  }
}
```

## Database and ORM

### Schema Design

1. Use meaningful and consistent naming for tables and columns
2. Define appropriate data types for columns
3. Create proper indexes for frequently queried columns
4. Use foreign key constraints to maintain referential integrity
5. Include created_at and updated_at timestamps on all tables

```typescript
// Drizzle schema example
export const users = pgTable('users', {
  id: uuid('id').primaryKey().defaultRandom(),
  email: varchar('email', { length: 255 }).notNull().unique(),
  passwordHash: varchar('password_hash', { length: 255 }).notNull(),
  firstName: varchar('first_name', { length: 100 }).notNull(),
  lastName: varchar('last_name', { length: 100 }).notNull(),
  status: userStatusEnum('status').notNull().default('active'),
  createdAt: timestamp('created_at').notNull().defaultNow(),
  updatedAt: timestamp('updated_at').notNull().defaultNow()
});
```

### Query Construction

1. Use the ORM's query builder for type safety
2. Keep queries efficient and focused
3. Use transactions when multiple operations need to be atomic
4. Specify only the fields you need in SELECT queries
5. Be mindful of N+1 query problems by using proper joins or eager loading

```typescript
// Query example
async function getUsersWithOrganizations() {
  return db.query.users.findMany({
    columns: {
      id: true,
      firstName: true,
      lastName: true,
      email: true,
      status: true
    },
    with: {
      organizations: {
        columns: {
          id: true,
          name: true,
          role: true
        }
      }
    },
    where: eq(users.status, 'active')
  });
}

// Transaction example
async function transferFunds(fromAccountId: string, toAccountId: string, amount: number) {
  return db.transaction(async (tx) => {
    // Deduct from source account
    await tx.update(accounts)
      .set({ balance: sql`balance - ${amount}` })
      .where(eq(accounts.id, fromAccountId));
    
    // Add to destination account
    await tx.update(accounts)
      .set({ balance: sql`balance + ${amount}` })
      .where(eq(accounts.id, toAccountId));
    
    // Record the transaction
    await tx.insert(transactions)
      .values({
        fromAccountId,
        toAccountId,
        amount,
        type: 'transfer'
      });
  });
}
```

### Data Access Layer

1. Abstract database access behind a repository or data access layer
2. Keep SQL queries out of business logic
3. Implement proper error handling for database operations
4. Use pagination for large data sets
5. Consider performance implications of queries on large tables

```typescript
// Repository pattern example
export class UserRepository {
  async findById(id: string): Promise<User | null> {
    return db.query.users.findFirst({
      where: eq(users.id, id)
    });
  }
  
  async findByEmail(email: string): Promise<User | null> {
    return db.query.users.findFirst({
      where: eq(users.email, email)
    });
  }
  
  async create(data: NewUser): Promise<User> {
    const [user] = await db.insert(users)
      .values(data)
      .returning();
    return user;
  }
  
  async update(id: string, data: Partial<User>): Promise<User | null> {
    const [user] = await db.update(users)
      .set({
        ...data,
        updatedAt: new Date()
      })
      .where(eq(users.id, id))
      .returning();
    return user || null;
  }
  
  async delete(id: string): Promise<boolean> {
    const result = await db.delete(users)
      .where(eq(users.id, id));
    return result.rowCount > 0;
  }
}
```

### Migrations

1. Use migration tools to manage database schema changes
2. Keep migrations small and focused
3. Ensure migrations are reversible when possible
4. Test migrations on a staging environment before production
5. Document breaking changes in migrations

```typescript
// Migration example
export async function up(db: Pool) {
  await db.query(`
    CREATE TABLE users (
      id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
      email VARCHAR(255) NOT NULL UNIQUE,
      password_hash VARCHAR(255) NOT NULL,
      first_name VARCHAR(100) NOT NULL,
      last_name VARCHAR(100) NOT NULL,
      status VARCHAR(20) NOT NULL DEFAULT 'active',
      created_at TIMESTAMP NOT NULL DEFAULT NOW(),
      updated_at TIMESTAMP NOT NULL DEFAULT NOW()
    );
    
    CREATE INDEX idx_users_email ON users(email);
  `);
}

export async function down(db: Pool) {
  await db.query(`
    DROP TABLE IF EXISTS users;
  `);
}
```

## API Design

### RESTful Principles

1. Use resource-based URLs
2. Use appropriate HTTP methods (GET, POST, PUT, DELETE)
3. Use HTTP status codes correctly
4. Make APIs stateless
5. Use versioning for API endpoints

```
# Resource-based URLs example
GET /api/v1/users                   # List users
GET /api/v1/users/{id}              # Get user by ID
POST /api/v1/users                  # Create user
PUT /api/v1/users/{id}              # Update user
DELETE /api/v1/users/{id}           # Delete user
GET /api/v1/users/{id}/organizations # Get organizations for user
```

### Request and Response Format

1. Use JSON for request and response bodies
2. Use consistent response structures
3. Include metadata in responses (pagination, status, etc.)
4. Use snake_case for JSON field names
5. Validate request data using schemas

```typescript
// Response structure example
interface ApiResponse<T> {
  status: 'success' | 'error';
  data?: T;
  error?: {
    message: string;
    code?: string;
    details?: Record<string, string>;
  };
  meta?: {
    page?: number;
    per_page?: number;
    total_pages?: number;
    total_count?: number;
  };
}

// Response example
{
  "status": "success",
  "data": {
    "id": "c0a80121-7ac0-4e3d-b906-79a5e5757a9f",
    "first_name": "John",
    "last_name": "Smith",
    "email": "john.smith@example.com",
    "status": "active",
    "created_at": "2025-01-15T10:30:00Z",
    "updated_at": "2025-03-20T15:45:00Z"
  }
}
```

### API Documentation

1. Document all API endpoints
2. Include request parameters, response structure, and error responses
3. Provide example requests and responses
4. Use OpenAPI (Swagger) for API documentation
5. Keep documentation in sync with the codebase

```typescript
/**
 * @swagger
 * /api/v1/users/{id}:
 *   get:
 *     summary: Get user by ID
 *     description: Retrieves a user by their unique identifier
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *           format: uuid
 *         description: The user ID
 *     responses:
 *       200:
 *         description: User found
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/UserResponse'
 *       404:
 *         description: User not found
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ErrorResponse'
 */
```

### API Security

1. Use HTTPS for all API endpoints
2. Implement proper authentication and authorization
3. Validate and sanitize all input data
4. Protect against common web vulnerabilities (CSRF, XSS, etc.)
5. Implement rate limiting and request throttling

```typescript
// API security middleware example
export function securityMiddleware(app: Express) {
  // Set security headers
  app.use(helmet());
  
  // CORS configuration
  app.use(cors({
    origin: process.env.ALLOWED_ORIGINS?.split(',') || '*',
    methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH'],
    allowedHeaders: ['Content-Type', 'Authorization']
  }));
  
  // Rate limiting
  app.use(rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 100, // limit each IP to 100 requests per windowMs
    standardHeaders: true,
    legacyHeaders: false
  }));
  
  // Body parser with size limits
  app.use(express.json({ limit: '1mb' }));
  app.use(express.urlencoded({ extended: true, limit: '1mb' }));
}
```

## Testing Standards

### Test Coverage

1. Aim for high test coverage (80%+ for business logic)
2. Prioritize testing critical paths and complex logic
3. Use different types of tests (unit, integration, end-to-end)
4. Track coverage metrics in CI/CD pipeline
5. Don't optimize solely for coverage percentage

### Unit Tests

1. Test individual functions and components in isolation
2. Mock external dependencies
3. Focus on business logic and edge cases
4. Keep tests fast and independent
5. Follow the AAA pattern (Arrange, Act, Assert)

```typescript
// Unit test example
describe('UserService', () => {
  let userService: UserService;
  let mockDb: MockDatabase;
  
  beforeEach(() => {
    mockDb = createMockDatabase();
    userService = new UserService(mockDb);
  });
  
  describe('getUserById', () => {
    it('should return a user when found', async () => {
      // Arrange
      const userId = 'user-123';
      const mockUser = { id: userId, firstName: 'John', lastName: 'Doe' };
      mockDb.users.findUnique.mockResolvedValue(mockUser);
      
      // Act
      const result = await userService.getUserById(userId);
      
      // Assert
      expect(result).toEqual(mockUser);
      expect(mockDb.users.findUnique).toHaveBeenCalledWith({
        where: { id: userId }
      });
    });
    
    it('should return null when user not found', async () => {
      // Arrange
      const userId = 'non-existent';
      mockDb.users.findUnique.mockResolvedValue(null);
      
      // Act
      const result = await userService.getUserById(userId);
      
      // Assert
      expect(result).toBeNull();
    });
  });
});
```

### Integration Tests

1. Test interactions between multiple components
2. Use test databases instead of mocking the database
3. Focus on API endpoints and database operations
4. Isolate tests from external services when possible
5. Clean up test data after tests complete

```typescript
// Integration test example
describe('User API', () => {
  beforeAll(async () => {
    await db.migrate.latest();
  });
  
  afterEach(async () => {
    await db.table('users').delete();
  });
  
  afterAll(async () => {
    await db.destroy();
  });
  
  describe('GET /api/v1/users/:id', () => {
    it('should return 200 and user data when user exists', async () => {
      // Arrange - Create test user
      const user = await db.table('users').insert({
        firstName: 'Jane',
        lastName: 'Smith',
        email: 'jane@example.com',
        passwordHash: 'hashed_password'
      }).returning('*');
      
      // Act
      const response = await request(app)
        .get(`/api/v1/users/${user[0].id}`)
        .set('Authorization', `Bearer ${testToken}`);
      
      // Assert
      expect(response.status).toBe(200);
      expect(response.body.status).toBe('success');
      expect(response.body.data).toMatchObject({
        id: user[0].id,
        firstName: 'Jane',
        lastName: 'Smith',
        email: 'jane@example.com'
      });
    });
    
    it('should return 404 when user does not exist', async () => {
      // Act
      const response = await request(app)
        .get('/api/v1/users/non-existent-id')
        .set('Authorization', `Bearer ${testToken}`);
      
      // Assert
      expect(response.status).toBe(404);
      expect(response.body.status).toBe('error');
    });
  });
});
```

### End-to-End Tests

1. Test complete user flows from UI to database
2. Test critical business processes end-to-end
3. Use tools like Cypress or Playwright
4. Keep E2E tests focused on high-value scenarios
5. Prefer targeted tests over comprehensive coverage

```typescript
// Cypress E2E test example
describe('User Management', () => {
  beforeEach(() => {
    cy.login('admin@example.com', 'password');
  });
  
  it('should allow creating a new user', () => {
    // Navigate to user creation page
    cy.visit('/admin/users');
    cy.get('[data-testid=add-user-button]').click();
    
    // Fill out the form
    cy.get('[data-testid=user-first-name]').type('New');
    cy.get('[data-testid=user-last-name]').type('User');
    cy.get('[data-testid=user-email]').type('new.user@example.com');
    cy.get('[data-testid=user-role]').select('editor');
    cy.get('[data-testid=user-status]').select('active');
    
    // Submit the form
    cy.get('[data-testid=submit-button]').click();
    
    // Verify success
    cy.url().should('include', '/admin/users');
    cy.contains('User created successfully').should('be.visible');
    cy.contains('New User').should('be.visible');
  });
});
```

### Testing React Components

1. Test component rendering and interactions
2. Use React Testing Library instead of Enzyme
3. Test what the user sees and does, not implementation details
4. Mock API calls and external dependencies
5. Test accessibility when relevant

```typescript
// React component test example
describe('UserList', () => {
  const mockUsers = [
    { id: '1', firstName: 'John', lastName: 'Doe', email: 'john@example.com' },
    { id: '2', firstName: 'Jane', lastName: 'Smith', email: 'jane@example.com' }
  ];
  
  it('should render a list of users', async () => {
    // Mock API response
    jest.spyOn(api, 'getUsers').mockResolvedValue(mockUsers);
    
    // Render component
    render(<UserList />);
    
    // Wait for data to load
    await screen.findByText('John Doe');
    
    // Assertions
    expect(screen.getByText('John Doe')).toBeInTheDocument();
    expect(screen.getByText('Jane Smith')).toBeInTheDocument();
    expect(screen.getAllByRole('listitem')).toHaveLength(2);
  });
  
  it('should show loading state while fetching data', () => {
    // Mock a pending API call
    jest.spyOn(api, 'getUsers').mockImplementation(() => new Promise(() => {}));
    
    // Render component
    render(<UserList />);
    
    // Assertions
    expect(screen.getByText('Loading...')).toBeInTheDocument();
  });
  
  it('should handle errors gracefully', async () => {
    // Mock API error
    jest.spyOn(api, 'getUsers').mockRejectedValue(new Error('Failed to fetch'));
    
    // Render component
    render(<UserList />);
    
    // Wait for error message
    await screen.findByText('Failed to load users');
    
    // Assertions
    expect(screen.getByText('Failed to load users')).toBeInTheDocument();
    expect(screen.getByRole('button', { name: 'Retry' })).toBeInTheDocument();
  });
});
```

## Security Best Practices

### Authentication and Authorization

1. Use industry-standard authentication methods (OAuth, JWT)
2. Implement proper password hashing (bcrypt or Argon2)
3. Enforce strong password policies
4. Implement role-based access control (RBAC)
5. Use multi-factor authentication for sensitive operations

```typescript
// Password hashing example
export async function hashPassword(password: string): Promise<string> {
  const saltRounds = 12;
  return bcrypt.hash(password, saltRounds);
}

export async function comparePassword(
  plainTextPassword: string,
  hashedPassword: string
): Promise<boolean> {
  return bcrypt.compare(plainTextPassword, hashedPassword);
}

// Authorization middleware
export function requireRole(requiredRoles: string[]) {
  return (req: Request, res: Response, next: NextFunction) => {
    if (!req.user) {
      return res.status(401).json({
        status: 'error',
        message: 'Authentication required'
      });
    }
    
    if (!requiredRoles.includes(req.user.role)) {
      return res.status(403).json({
        status: 'error',
        message: 'Insufficient permissions'
      });
    }
    
    next();
  };
}
```

### Input Validation

1. Validate all user input on the server side
2. Use schema validation libraries (Zod, Joi, etc.)
3. Sanitize user inputs to prevent XSS attacks
4. Use parameterized queries to prevent SQL injection
5. Implement content security policies

```typescript
// Input validation example with Zod
const createUserSchema = z.object({
  firstName: z.string().min(1).max(100),
  lastName: z.string().min(1).max(100),
  email: z.string().email(),
  password: z.string().min(8).regex(
    /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/,
    'Password must contain at least one uppercase letter, one lowercase letter, one number, and one special character'
  )
});

// Validation middleware
export function validateRequest(schema: z.ZodSchema) {
  return (req: Request, res: Response, next: NextFunction) => {
    try {
      schema.parse(req.body);
      next();
    } catch (error) {
      if (error instanceof z.ZodError) {
        const details = error.errors.reduce((acc, curr) => {
          const path = curr.path.join('.');
          acc[path] = curr.message;
          return acc;
        }, {} as Record<string, string>);
        
        return res.status(400).json({
          status: 'error',
          message: 'Validation failed',
          details
        });
      }
      next(error);
    }
  };
}
```

### Data Protection

1. Encrypt sensitive data at rest
2. Use HTTPS for all communications
3. Implement proper access controls for data
4. Follow data minimization principles
5. Comply with relevant data protection regulations

```typescript
// Encrypting sensitive data example
export class EncryptionService {
  private readonly algorithm = 'aes-256-gcm';
  private readonly key: Buffer;
  
  constructor() {
    // In production, use a proper key management solution
    this.key = Buffer.from(process.env.ENCRYPTION_KEY as string, 'hex');
  }
  
  encrypt(text: string): EncryptedData {
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipheriv(this.algorithm, this.key, iv);
    
    let encrypted = cipher.update(text, 'utf8', 'hex');
    encrypted += cipher.final('hex');
    
    const authTag = cipher.getAuthTag();
    
    return {
      iv: iv.toString('hex'),
      encrypted,
      authTag: authTag.toString('hex')
    };
  }
  
  decrypt(data: EncryptedData): string {
    const iv = Buffer.from(data.iv, 'hex');
    const authTag = Buffer.from(data.authTag, 'hex');
    
    const decipher = crypto.createDecipheriv(this.algorithm, this.key, iv);
    decipher.setAuthTag(authTag);
    
    let decrypted = decipher.update(data.encrypted, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    
    return decrypted;
  }
}
```

### Security Headers

1. Implement appropriate security headers
2. Use CSP to prevent XSS attacks
3. Use HSTS to enforce HTTPS
4. Use X-Content-Type-Options to prevent MIME type sniffing
5. Use X-Frame-Options to prevent clickjacking

```typescript
// Security headers middleware
export function securityHeaders(app: Express) {
  app.use(helmet({
    contentSecurityPolicy: {
      directives: {
        defaultSrc: ["'self'"],
        scriptSrc: ["'self'", "'unsafe-inline'", "https://cdn.example.com"],
        styleSrc: ["'self'", "'unsafe-inline'", "https://fonts.googleapis.com"],
        imgSrc: ["'self'", "data:", "https://assets.tunemantra.com"],
        connectSrc: ["'self'", "https://api.tunemantra.com"],
        fontSrc: ["'self'", "https://fonts.gstatic.com"],
        objectSrc: ["'none'"],
        mediaSrc: ["'self'"],
        frameSrc: ["'none'"]
      }
    },
    hsts: {
      maxAge: 31536000, // 1 year
      includeSubDomains: true,
      preload: true
    },
    frameguard: {
      action: 'deny'
    },
    referrerPolicy: {
      policy: 'strict-origin-when-cross-origin'
    }
  }));
}
```

## Performance Considerations

### Frontend Performance

1. Minimize bundle size with code splitting
2. Optimize images and media assets
3. Implement lazy loading for components and routes
4. Use performance monitoring tools
5. Follow React's performance optimization guidelines

```typescript
// Code splitting with React.lazy
const UserDashboard = React.lazy(() => import('./pages/UserDashboard'));
const Settings = React.lazy(() => import('./pages/Settings'));

function App() {
  return (
    <Router>
      <React.Suspense fallback={<Spinner />}>
        <Routes>
          <Route path="/dashboard" element={<UserDashboard />} />
          <Route path="/settings" element={<Settings />} />
          {/* Other routes */}
        </Routes>
      </React.Suspense>
    </Router>
  );
}
```

### Backend Performance

1. Implement proper caching strategies
2. Optimize database queries
3. Use connection pooling for database connections
4. Implement pagination for large data sets
5. Use worker threads or queues for CPU-intensive tasks

```typescript
// Caching middleware example
export function cachingMiddleware(duration: number) {
  return (req: Request, res: Response, next: NextFunction) => {
    const key = `__cache__${req.originalUrl || req.url}`;
    
    // Try to get from cache
    cacheClient.get(key, (err, data) => {
      if (data) {
        return res.status(200).json(JSON.parse(data));
      }
      
      // Modify response to cache the result
      const originalSend = res.send;
      res.send = function(body): Response {
        if (res.statusCode === 200) {
          cacheClient.set(key, body, 'EX', duration);
        }
        return originalSend.call(this, body);
      };
      
      next();
    });
  };
}

// Pagination example
async function getUsers(page = 1, pageSize = 20) {
  const offset = (page - 1) * pageSize;
  
  const [users, totalCount] = await Promise.all([
    db.query.users.findMany({
      limit: pageSize,
      offset,
      orderBy: (users, { desc }) => [desc(users.createdAt)]
    }),
    db.select({ count: count() }).from(users)
  ]);
  
  return {
    users,
    pagination: {
      page,
      pageSize,
      totalCount: totalCount[0].count,
      totalPages: Math.ceil(totalCount[0].count / pageSize)
    }
  };
}
```

### Database Optimization

1. Create proper indexes for frequently queried columns
2. Optimize table structure and data types
3. Use query execution plans to identify slow queries
4. Consider database sharding for large datasets
5. Implement database connection pooling

```typescript
// Create indexes example
export async function up(db: Pool) {
  // Create index for email lookups
  await db.query(`
    CREATE INDEX idx_users_email ON users(email);
  `);
  
  // Create index for foreign key lookups
  await db.query(`
    CREATE INDEX idx_tracks_release_id ON tracks(release_id);
  `);
  
  // Create composite index for common query pattern
  await db.query(`
    CREATE INDEX idx_revenue_content_platform_period ON revenue(content_type, content_id, platform_id, period_start);
  `);
}
```

## Documentation

### Code Documentation

1. Use JSDoc comments for functions, classes, and interfaces
2. Document parameters, return values, and thrown exceptions
3. Include examples for complex functions
4. Document edge cases and limitations
5. Keep documentation in sync with code changes

```typescript
/**
 * Calculates royalties based on revenue and ownership percentages.
 * 
 * @param {object} options - Calculation options
 * @param {number} options.revenue - The total revenue amount
 * @param {number} options.rate - The royalty rate (between 0 and 1)
 * @param {number} [options.minimumGuarantee] - Optional minimum guarantee amount
 * @param {string} options.territory - Territory code for region-specific calculations
 * @returns {number} The calculated royalty amount
 * @throws {ValidationError} If any parameter is invalid
 * 
 * @example
 * // Calculate royalty with standard rate
 * const royalty = calculateRoyalty({
 *   revenue: 1000,
 *   rate: 0.15,
 *   territory: 'US'
 * });
 * // Returns 150
 * 
 * @example
 * // Calculate royalty with minimum guarantee
 * const royalty = calculateRoyalty({
 *   revenue: 100,
 *   rate: 0.15,
 *   minimumGuarantee: 50,
 *   territory: 'US'
 * });
 * // Returns 50 (since 15 would be less than minimum)
 */
export function calculateRoyalty(options: RoyaltyOptions): number {
  // Implementation...
}
```

### README Files

1. Include a comprehensive README.md for each project and major component
2. Document project purpose, setup instructions, and usage examples
3. Include information about testing, deployment, and contribution
4. Keep README files up to date with project changes
5. Consider using markdown formatting for better readability

### System Documentation

1. Document system architecture and components
2. Maintain up-to-date diagrams (architecture, database schema, etc.)
3. Document deployment procedures and requirements
4. Document third-party integrations and dependencies
5. Keep documentation accessible to all team members

## Version Control

### Commit Messages

1. Follow the Conventional Commits specification
2. Write meaningful commit messages that explain the change
3. Reference issue numbers in commit messages
4. Keep commits focused on a single change
5. Break large changes into smaller, logical commits

```
# Format
<type>(<scope>): <subject>

<body>

<footer>

# Examples
feat(auth): implement multi-factor authentication

Add support for TOTP-based multi-factor authentication.
This includes:
- New user settings for enabling MFA
- QR code generation for TOTP setup
- Verification flow during login

Closes #123

# Another example
fix(api): resolve timeout issue in distribution endpoints

Increased request timeout and improved pagination to handle
large distribution requests more efficiently.

Fixes #456
```

### Branching Strategy

1. Follow the GitFlow branching model with modifications
2. Create feature branches from `develop` for new features
3. Create hotfix branches from `main` for critical fixes
4. Use descriptive branch names with issue numbers
5. Ensure branches are short-lived and focused

```
# Branch naming convention
feature/TM-123-add-multi-factor-authentication
bugfix/TM-456-fix-distribution-timeout
hotfix/TM-789-security-vulnerability
release/v2.3.0
```

### Pull Requests

1. Create focused pull requests for individual features or fixes
2. Provide comprehensive descriptions in pull requests
3. Include testing steps and screenshots when relevant
4. Link to relevant issues or documentation
5. Address review comments promptly

## Code Review

### Review Process

1. All code changes must go through code review
2. Reviews should focus on correctness, readability, and maintainability
3. Use a "approve", "request changes", or "comment" workflow
4. Address all review comments before merging
5. Seek understanding when there are disagreements

### Review Checklist

1. **Functionality**: Does the code work as expected?
2. **Security**: Are there any security concerns?
3. **Performance**: Are there any performance issues?
4. **Maintainability**: Is the code easy to understand and maintain?
5. **Testing**: Are there appropriate tests?
6. **Documentation**: Is the code properly documented?
7. **Standards**: Does the code follow our coding standards?

### Giving Feedback

1. Be constructive and respectful
2. Focus on the code, not the person
3. Explain your reasoning for suggestions
4. Provide specific examples when possible
5. Acknowledge good code and practices

### Receiving Feedback

1. Be open to feedback and suggestions
2. Ask for clarification if needed
3. Explain your reasoning when appropriate
4. Implement suggested changes promptly
5. Use code reviews as a learning opportunity

## Resources

### Official Documentation

- [TypeScript Documentation](https://www.typescriptlang.org/docs/)
- [React Documentation](https://react.dev/reference/react)
- [Node.js Documentation](https://nodejs.org/en/docs/)
- [Express Documentation](https://expressjs.com/en/api.html)
- [PostgreSQL Documentation](https://www.postgresql.org/docs/)
- [Drizzle ORM Documentation](https://orm.drizzle.team/docs/overview)

### Style Guides

- [Airbnb JavaScript Style Guide](https://github.com/airbnb/javascript)
- [Google TypeScript Style Guide](https://google.github.io/styleguide/tsguide.html)
- [React Patterns](https://reactpatterns.com/)

### Tools

- [ESLint](https://eslint.org/)
- [Prettier](https://prettier.io/)
- [TypeScript ESLint](https://typescript-eslint.io/)
- [Jest](https://jestjs.io/)
- [React Testing Library](https://testing-library.com/docs/react-testing-library/intro/)

### Books

- "Clean Code" by Robert C. Martin
- "Refactoring" by Martin Fowler
- "TypeScript in 50 Lessons" by Stefan Baumgartner
- "React Design Patterns and Best Practices" by Michele Bertoli
- "Node.js Design Patterns" by Mario Casciaro

---

© 2023-2025 TuneMantra. All rights reserved.

---

## documentation/developer/development-workflow.md

# TuneMantra Development Workflow

*Version: 1.0.0 (March 27, 2025)*

## Table of Contents

- [Introduction](#introduction)
- [Development Environment Setup](#development-environment-setup)
- [Version Control Workflow](#version-control-workflow)
- [Development Process](#development-process)
- [Code Review Process](#code-review-process)
- [Testing Process](#testing-process)
- [Continuous Integration and Deployment](#continuous-integration-and-deployment)
- [Release Process](#release-process)
- [Development Tools](#development-tools)
- [Troubleshooting](#troubleshooting)

## Introduction

This document outlines the development workflow and processes followed by the TuneMantra development team. It provides guidelines for setting up the development environment, working with the codebase, submitting changes, and deploying to production.

## Development Environment Setup

### System Requirements

- **Operating System**: Linux, macOS, or Windows with WSL2
- **Memory**: Minimum 16GB RAM recommended
- **Storage**: At least 20GB available space
- **Software Prerequisites**:
  - Docker Desktop 4.x+
  - Node.js 18.x+
  - npm 9.x+
  - Git 2.x+
  - Visual Studio Code or similar editor

### Initial Setup

1. **Clone the Repository**

   ```bash
   git clone https://github.com/tunemantra/platform.git
   cd platform
   ```

2. **Install Dependencies**

   ```bash
   npm install
   ```

3. **Set Up Environment Variables**

   ```bash
   cp .env.example .env
   # Edit .env with your local configuration
   ```

4. **Start the Development Environment**

   ```bash
   npm run dev
   ```

### Database Setup

1. **Start the Local Database**

   ```bash
   docker-compose up -d db
   ```

2. **Run Migrations**

   ```bash
   npm run db:migrate
   ```

3. **Seed Test Data (Optional)**

   ```bash
   npm run db:seed
   ```

### Local Services

The development environment includes:

- **Web Application**: http://localhost:3000
- **API Server**: http://localhost:3001
- **Database**: PostgreSQL running in Docker
- **Backend Services**: Accessible via API server

## Version Control Workflow

TuneMantra follows a Git Flow-based workflow with some customizations.

### Branch Structure

- **`main`**: Production-ready code
- **`develop`**: Integration branch for features
- **`feature/*`**: Feature development branches
- **`bugfix/*`**: Bug fix branches
- **`hotfix/*`**: Emergency fixes for production
- **`release/*`**: Release preparation branches

### Branch Naming Convention

Branches should follow this naming convention:

- `feature/TM-123-short-description`
- `bugfix/TM-456-issue-description`
- `hotfix/TM-789-critical-fix`
- `release/v3.2.1`

Where `TM-123` is the JIRA ticket number.

### Commit Message Format

Commit messages should follow this format:

```
[TM-123] Category: Short description (max 72 chars)

Longer description explaining the change in detail, if needed.
Reference any relevant tickets or issues.
```

Categories include:
- `feat`: New feature
- `fix`: Bug fix
- `docs`: Documentation changes
- `style`: Formatting changes
- `refactor`: Code refactoring
- `test`: Adding or modifying tests
- `chore`: Build process or tooling changes

### Pull Request Process

1. Create a feature/bugfix branch from `develop`
2. Make changes and commit with proper format
3. Push branch to remote
4. Open pull request to `develop`
5. Assign reviewers
6. Address review comments
7. Merge when approved

## Development Process

### Planning

1. **Requirement Gathering**
   - Product team creates user stories in JIRA
   - Engineering reviews and estimates stories
   - Stories are prioritized and added to sprint

2. **Sprint Planning**
   - Two-week sprints
   - Stories selected based on priority and team capacity
   - Technical approach discussed and documented

### Development

1. **Task Assignment**
   - Developers self-assign tasks from sprint board
   - Update JIRA ticket status to "In Progress"

2. **Implementation**
   - Create feature/bugfix branch
   - Implement changes following coding standards
   - Add unit tests
   - Update documentation

3. **Local Testing**
   - Run unit tests: `npm test`
   - Run integration tests: `npm run test:integration`
   - Run linting: `npm run lint`
   - Manual testing in local environment

4. **Submission**
   - Create pull request
   - Add PR description with changes and testing details
   - Link JIRA ticket in PR description

### Agile Ceremonies

- **Daily Standup**: 15-minute sync every day at 10:00 AM
- **Sprint Planning**: Every other Monday, 2 hours
- **Sprint Review**: Every other Friday, 1 hour
- **Sprint Retrospective**: Every other Friday, 1 hour
- **Backlog Refinement**: Weekly, 1 hour

## Code Review Process

### Review Guidelines

1. **Code Quality**
   - Adherence to coding standards
   - Clean, readable, and maintainable code
   - Proper error handling
   - No commented-out code

2. **Functionality**
   - Implements requirements correctly
   - Edge cases handled
   - Appropriate validation
   - No regression issues

3. **Performance**
   - Efficient algorithms
   - Proper database queries
   - Resource usage considerations
   - No N+1 problems

4. **Security**
   - Input validation
   - Authentication and authorization checks
   - No security vulnerabilities
   - Proper handling of sensitive data

5. **Testing**
   - Comprehensive test coverage
   - All tests passing
   - Edge cases tested
   - Clear test descriptions

### Review Process

1. **Reviewer Assignment**
   - At least two reviewers per PR
   - Domain expert and generalist reviewer

2. **Review Timeline**
   - Reviews completed within 24 business hours
   - Requested changes addressed promptly

3. **Review Resolution**
   - Reviewers approve or request changes
   - Discussions resolved before merging
   - Final approval from tech lead for complex changes

## Testing Process

### Testing Levels

1. **Unit Testing**
   - Test individual functions and components
   - Use Jest for JavaScript/TypeScript
   - Mock external dependencies
   - Run with `npm test`

2. **Integration Testing**
   - Test interactions between components
   - API contract testing
   - Database interaction testing
   - Run with `npm run test:integration`

3. **End-to-End Testing**
   - Test complete user flows
   - Use Cypress for frontend E2E tests
   - Use Postman collections for API testing
   - Run with `npm run test:e2e`

4. **Manual Testing**
   - QA team tests features manually
   - User acceptance testing
   - Exploratory testing
   - Regression testing

### Test Coverage Requirements

- Minimum 80% unit test coverage for new code
- 100% coverage for critical paths
- All API endpoints covered by integration tests
- Key user flows covered by E2E tests

## Continuous Integration and Deployment

### CI/CD Pipeline

The CI/CD pipeline is implemented using GitHub Actions and AWS services.

#### CI Process (On PR)

1. **Code Validation**
   - Linting
   - Type checking
   - Unit tests
   - Integration tests

2. **Build Verification**
   - Build application
   - Build Docker images
   - Verify build artifacts

3. **Security Scanning**
   - Static code analysis
   - Dependency vulnerability scanning
   - Secret detection

#### CD Process (On Merge to Main)

1. **Staging Deployment**
   - Automatic deployment to staging environment
   - Run smoke tests
   - Run E2E tests

2. **Production Approval**
   - Manual approval gate
   - Release notes verification
   - Rollback plan review

3. **Production Deployment**
   - Blue/green deployment
   - Traffic shifting
   - Deployment verification
   - Monitoring alert check

### Environments

1. **Development**
   - Individual developer environments
   - Local databases
   - Mock external services

2. **Integration**
   - Shared development environment
   - Integrated services
   - Feature testing

3. **Staging**
   - Production-like environment
   - Production data subset
   - Pre-release testing

4. **Production**
   - Live environment
   - Full monitoring
   - Scaled for production loads

## Release Process

### Release Planning

1. **Version Numbering**
   - Semantic versioning (MAJOR.MINOR.PATCH)
   - Major: Breaking changes
   - Minor: New features, backward compatible
   - Patch: Bug fixes, backward compatible

2. **Release Candidates**
   - `release/v3.2.0-rc1`
   - Final testing and validation
   - Multiple RCs if needed

3. **Release Schedule**
   - Major releases: Quarterly
   - Minor releases: Monthly
   - Patch releases: As needed
   - Hotfixes: Immediate for critical issues

### Release Execution

1. **Release Branch Creation**
   - Create `release/vX.Y.Z` from `develop`
   - Version bump
   - Update CHANGELOG.md
   - Freeze code changes except for critical fixes

2. **Final QA**
   - Full regression testing
   - Performance testing
   - Security validation

3. **Release Approval**
   - Product team sign-off
   - Engineering sign-off
   - Documentation verification

4. **Production Deployment**
   - Deploy to production
   - Monitor for issues
   - Standby for potential rollback

5. **Post-Release**
   - Merge `release/vX.Y.Z` to `main`
   - Tag release in Git
   - Merge `release/vX.Y.Z` back to `develop`
   - Close milestone in JIRA

### Hotfix Process

1. **Hotfix Branch Creation**
   - Create `hotfix/vX.Y.Z+1` from `main`
   - Fix critical issue
   - Version bump
   - Update CHANGELOG.md

2. **Hotfix Review**
   - Expedited code review
   - Critical path testing

3. **Hotfix Deployment**
   - Emergency deployment to production
   - Immediate monitoring

4. **Hotfix Completion**
   - Merge `hotfix/vX.Y.Z+1` to `main`
   - Tag release in Git
   - Merge `hotfix/vX.Y.Z+1` to `develop`

## Development Tools

### Core Tools

- **IDE**: Visual Studio Code with recommended extensions
- **Version Control**: Git with GitHub
- **Package Manager**: npm
- **Task Runner**: npm scripts
- **Build Tools**: Webpack, TypeScript compiler
- **Containerization**: Docker
- **CI/CD**: GitHub Actions

### Quality Tools

- **Linting**: ESLint, StyleLint
- **Formatting**: Prettier
- **Testing**: Jest, React Testing Library, Cypress
- **Type Checking**: TypeScript
- **Code Coverage**: Istanbul
- **Code Analysis**: SonarQube

### Project Management

- **Task Tracking**: JIRA
- **Documentation**: Confluence
- **Communication**: Slack
- **Knowledge Sharing**: Notion
- **Diagrams**: draw.io

## Troubleshooting

### Common Issues

1. **Development Environment Issues**
   - **Node Version Mismatch**: Ensure you're using Node.js 18.x+
   - **Port Conflicts**: Check if ports 3000, 3001, and 5432 are available
   - **Database Connection Errors**: Verify Docker is running and database container is up

2. **Build Issues**
   - **TypeScript Errors**: Run `npm run type-check` to identify issues
   - **Dependency Issues**: Try deleting `node_modules` and running `npm install`
   - **Environment Variables**: Check if all required env vars are set

3. **Git Workflow Issues**
   - **Merge Conflicts**: Rebase your branch on latest `develop`
   - **Commit Hook Failures**: Fix linting and type errors
   - **Push Rejection**: Pull latest changes and resolve conflicts

### Debug Tools

1. **Application Debugging**
   - Browser DevTools for frontend
   - VS Code debugger configuration provided
   - Logging with different levels (use `DEBUG=tunemantra:*` env var)

2. **API Debugging**
   - Postman collection available in `/docs/postman`
   - API documentation with Swagger at `/api/docs`
   - Request logging middleware in development

3. **Performance Analysis**
   - React Profiler for component performance
   - Lighthouse for frontend performance
   - New Relic for backend performance

### Getting Help

- **Developer Slack Channel**: #tm-dev
- **Documentation Wiki**: https://wiki.tunemantra.com
- **Issue Reporting**: Create a ticket in JIRA project TM
- **Emergency Contact**: team-leads@tunemantra.com

---

© 2023-2025 TuneMantra. All rights reserved.

---

## documentation/developer/getting-started.md

# TuneMantra Developer Guide

<div align="center">
  <img src="../diagrams/developer-header.svg" alt="TuneMantra Developer Guide" width="600"/>
</div>

## Introduction

This comprehensive guide will help you set up a development environment, understand the codebase, and start contributing to the TuneMantra platform. The guide is designed to be accessible to developers of all experience levels, with particular attention to helping junior developers get up to speed quickly.

## Development Environment Setup

### Prerequisites

Before you begin, ensure you have the following installed:

- **Node.js**: Version 20.x or later
- **npm**: Version 9.x or later (comes with Node.js)
- **Git**: Latest stable version
- **PostgreSQL**: Version 14.x or later
- **Code Editor**: We recommend VS Code with the following extensions:
  - ESLint
  - Prettier
  - TypeScript + Plugin
  - Tailwind CSS IntelliSense
  - DotENV
  - PostgreSQL

### Step 1: Clone the Repository

```bash
git clone https://github.com/tunemantra/platform.git
cd platform
```

### Step 2: Install Dependencies

```bash
npm install
```

### Step 3: Configure Environment Variables

1. Copy the example environment file:

```bash
cp .env.example .env
```

2. Open `.env` in your editor and configure the following required variables:

```
# Database connection string
DATABASE_URL=postgresql://username:password@localhost:5432/tunemantra

# Server configuration
PORT=3000
NODE_ENV=development

# JWT secret for authentication
JWT_SECRET=your-jwt-secret-here

# File storage configuration
UPLOAD_DIR=./uploads
MAX_FILE_SIZE=100000000

# External API keys (obtain these from the respective services)
STRIPE_API_KEY=sk_test_...
```

### Step 4: Database Setup

1. Create a PostgreSQL database:

```bash
createdb tunemantra
```

2. Push the schema to the database:

```bash
npm run db:push
```

3. (Optional) Seed the database with sample data:

```bash
npm run db:seed
```

### Step 5: Start the Development Server

```bash
npm run dev
```

This will start both the frontend and backend in development mode. The application will be accessible at `http://localhost:3000`.

## Project Structure

The TuneMantra platform follows a structured organization to keep the codebase maintainable and scalable:

```
tunemantra/
├── client/                   # Frontend code
│   ├── public/               # Static assets
│   └── src/
│       ├── components/       # React components
│       │   ├── ui/           # Shadcn UI components
│       │   └── [feature]/    # Feature-specific components
│       ├── hooks/            # Custom React hooks
│       ├── lib/              # Utility functions
│       ├── pages/            # Page components
│       ├── routes/           # Route definitions
│       ├── store/            # State management
│       ├── styles/           # CSS and styling
│       ├── types/            # TypeScript type definitions
│       ├── App.tsx           # Main application component
│       └── main.tsx          # Application entry point
├── server/                   # Backend code
│   ├── auth.ts               # Authentication logic
│   ├── db.ts                 # Database connection
│   ├── index.ts              # Server entry point
│   ├── routes.ts             # API route definitions
│   ├── storage.ts            # Storage interface implementation
│   ├── types.ts              # TypeScript type definitions
│   ├── vite.ts               # Vite server configuration
│   ├── lib/                  # Library code
│   ├── services/             # Business logic services
│   └── utils/                # Utility functions
├── shared/                   # Shared code between frontend and backend
│   ├── constants.ts          # Shared constants
│   ├── schema.ts             # Database schema definition
│   └── types.ts              # Shared TypeScript types
├── scripts/                  # Build and maintenance scripts
├── uploads/                  # File uploads directory
├── .env                      # Environment variables
├── .env.example              # Example environment variables
├── package.json              # npm package configuration
├── tsconfig.json             # TypeScript configuration
└── vite.config.ts            # Vite configuration
```

## Key Technologies

TuneMantra is built on a modern TypeScript stack:

### Frontend

- **React**: UI library for building component-based interfaces
- **TanStack Query**: Data fetching and caching library
- **Shadcn/UI**: Component library built on Radix UI
- **Tailwind CSS**: Utility-first CSS framework
- **React Router**: Client-side routing
- **React Hook Form**: Form handling with validation
- **Zod**: Schema validation
- **Recharts**: Charting library for data visualization

### Backend

- **Node.js**: JavaScript runtime
- **Express**: Web framework
- **Drizzle ORM**: Type-safe ORM for database access
- **PostgreSQL**: Relational database
- **Passport.js**: Authentication middleware
- **JSON Web Tokens (JWT)**: Secure authentication tokens
- **Zod**: Schema validation
- **Multer**: File upload handling

## Core Concepts

### Authentication Flow

The authentication system uses JWT tokens and session cookies for secure access:

1. User submits credentials via login form
2. Server validates credentials against the database
3. If valid, a session is created and a secure cookie is set
4. The cookie is sent with subsequent requests to maintain authentication
5. Protected routes check the session to verify authentication

Authentication logic is centralized in `server/auth.ts`.

### Database Access Pattern

All database operations follow a consistent pattern:

1. Schema is defined in `shared/schema.ts` using Drizzle ORM
2. Storage interface is defined in `server/types.ts`
3. Implementation of the storage interface is in `server/storage.ts`
4. Routes use the storage interface for data access in `server/routes.ts`

Example flow:

```typescript
// Define schema in shared/schema.ts
export const users = pgTable("users", { /* schema definition */ });

// Define type in shared/schema.ts
export type User = typeof users.$inferSelect;

// Implement in storage.ts
async getUserById(id: number): Promise<User | undefined> {
  const result = await db.query.users.findFirst({
    where: eq(users.id, id)
  });
  return result;
}

// Use in routes.ts
app.get('/api/users/:id', async (req, res) => {
  const user = await storage.getUserById(parseInt(req.params.id));
  if (!user) return res.status(404).json({ error: 'User not found' });
  return res.json(user);
});
```

### Frontend Data Fetching

Data fetching on the frontend uses TanStack Query for efficient caching and state management:

```typescript
// Define query hook
function useUser(userId: number) {
  return useQuery({
    queryKey: ['/api/users', userId],
    queryFn: () => fetch(`/api/users/${userId}`).then(res => res.json()),
    enabled: !!userId
  });
}

// Use in component
function UserProfile({ userId }: { userId: number }) {
  const { data: user, isLoading, error } = useUser(userId);
  
  if (isLoading) return <Spinner />;
  if (error) return <ErrorMessage error={error} />;
  if (!user) return <NotFound />;
  
  return <UserProfileDisplay user={user} />;
}
```

### Form Handling

Forms use React Hook Form with Zod validation:

```typescript
// Define validation schema
const userFormSchema = z.object({
  username: z.string().min(3).max(50),
  email: z.string().email(),
  fullName: z.string().min(1)
});

// Use in form component
function UserForm() {
  const form = useForm({
    resolver: zodResolver(userFormSchema),
    defaultValues: {
      username: '',
      email: '',
      fullName: ''
    }
  });
  
  const onSubmit = async (data) => {
    // Submit form data
  };
  
  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)}>
        {/* Form fields */}
      </form>
    </Form>
  );
}
```

## Common Development Tasks

### Creating a New API Endpoint

1. Define the route in `server/routes.ts`:

```typescript
app.get('/api/tracks/:id', async (req, res) => {
  const trackId = parseInt(req.params.id);
  const track = await storage.getTrackById(trackId);
  
  if (!track) {
    return res.status(404).json({ error: 'Track not found' });
  }
  
  return res.json(track);
});
```

2. Implement any required storage methods in `server/storage.ts`:

```typescript
async getTrackById(id: number): Promise<Track | undefined> {
  const result = await db.query.tracks.findFirst({
    where: eq(tracks.id, id),
    with: {
      release: true
    }
  });
  return result;
}
```

### Adding a New Database Table

1. Add the table definition to `shared/schema.ts`:

```typescript
export const playlists = pgTable("playlists", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
  name: varchar("name", { length: 100 }).notNull(),
  description: text("description"),
  isPublic: boolean("is_public").default(false),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow()
});

export const playlistTracks = pgTable("playlist_tracks", {
  id: serial("id").primaryKey(),
  playlistId: integer("playlist_id").notNull().references(() => playlists.id, { onDelete: "cascade" }),
  trackId: integer("track_id").notNull().references(() => tracks.id, { onDelete: "cascade" }),
  position: integer("position").notNull(),
  addedAt: timestamp("added_at").defaultNow()
});

// Also add types
export type Playlist = typeof playlists.$inferSelect;
export type PlaylistTrack = typeof playlistTracks.$inferSelect;

// Create insert schemas
export const insertPlaylistSchema = createInsertSchema(playlists).omit({
  id: true,
  createdAt: true,
  updatedAt: true
});

export const insertPlaylistTrackSchema = createInsertSchema(playlistTracks).omit({
  id: true,
  addedAt: true
});

export type InsertPlaylist = z.infer<typeof insertPlaylistSchema>;
export type InsertPlaylistTrack = z.infer<typeof insertPlaylistTrackSchema>;
```

2. Update the storage interface in `server/types.ts`:

```typescript
export interface IStorage {
  // ... existing methods
  
  // Playlist methods
  getPlaylistsByUserId(userId: number): Promise<Playlist[]>;
  getPlaylistById(id: number): Promise<Playlist | undefined>;
  createPlaylist(userId: number, playlist: InsertPlaylist): Promise<Playlist>;
  updatePlaylist(id: number, playlist: Partial<Playlist>): Promise<Playlist>;
  deletePlaylist(id: number): Promise<void>;
  
  // Playlist track methods
  getPlaylistTracks(playlistId: number): Promise<PlaylistTrack[]>;
  addTrackToPlaylist(data: InsertPlaylistTrack): Promise<PlaylistTrack>;
  removeTrackFromPlaylist(playlistId: number, trackId: number): Promise<void>;
  updateTrackPosition(id: number, position: number): Promise<PlaylistTrack>;
}
```

3. Implement the methods in `server/storage.ts`:

```typescript
// Playlist methods
async getPlaylistsByUserId(userId: number): Promise<Playlist[]> {
  return await db.query.playlists.findMany({
    where: eq(playlists.userId, userId),
    orderBy: desc(playlists.createdAt)
  });
}

async getPlaylistById(id: number): Promise<Playlist | undefined> {
  return await db.query.playlists.findFirst({
    where: eq(playlists.id, id)
  });
}

// ... implement other methods
```

4. Push the schema changes to the database:

```bash
npm run db:push
```

### Creating a New Frontend Component

1. Create a new component file:

```typescript
// src/components/playlists/PlaylistCard.tsx
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Playlist } from "@/types";
import { Link } from "react-router-dom";

interface PlaylistCardProps {
  playlist: Playlist;
  onDelete?: (id: number) => void;
}

export function PlaylistCard({ playlist, onDelete }: PlaylistCardProps) {
  return (
    <Card className="h-full">
      <CardHeader>
        <CardTitle>{playlist.name}</CardTitle>
      </CardHeader>
      <CardContent>
        <p className="text-sm text-gray-500">{playlist.description}</p>
        <div className="mt-4 flex justify-between">
          <Link to={`/playlists/${playlist.id}`}>
            <Button variant="outline">View</Button>
          </Link>
          {onDelete && (
            <Button variant="destructive" onClick={() => onDelete(playlist.id)}>
              Delete
            </Button>
          )}
        </div>
      </CardContent>
    </Card>
  );
}
```

2. Create a new page component:

```typescript
// src/pages/PlaylistsPage.tsx
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { PlaylistCard } from "@/components/playlists/PlaylistCard";
import { PageHeader } from "@/components/PageHeader";
import { Button } from "@/components/ui/button";
import { Spinner } from "@/components/ui/spinner";
import { Playlist } from "@/types";
import { apiRequest } from "@/lib/queryClient";
import { Link } from "react-router-dom";

export function PlaylistsPage() {
  const queryClient = useQueryClient();
  const { data: playlists, isLoading } = useQuery<Playlist[]>({
    queryKey: ['/api/playlists'],
  });
  
  const deleteMutation = useMutation({
    mutationFn: (id: number) => 
      apiRequest(`/api/playlists/${id}`, { method: 'DELETE' }),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['/api/playlists'] });
    }
  });
  
  if (isLoading) return <Spinner />;
  
  return (
    <div>
      <PageHeader 
        title="Your Playlists"
        action={
          <Link to="/playlists/new">
            <Button>Create Playlist</Button>
          </Link>
        }
      />
      
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 mt-6">
        {playlists?.map(playlist => (
          <PlaylistCard
            key={playlist.id}
            playlist={playlist}
            onDelete={(id) => deleteMutation.mutate(id)}
          />
        ))}
        
        {playlists?.length === 0 && (
          <p className="col-span-3 text-center text-gray-500">
            You don't have any playlists yet. Create one to get started!
          </p>
        )}
      </div>
    </div>
  );
}
```

3. Add the route to your router:

```typescript
// src/App.tsx
import { PlaylistsPage } from "@/pages/PlaylistsPage";

// In your router configuration
<Route path="/playlists" element={<PlaylistsPage />} />
```

## Advanced Development Topics

### Database Migrations

When changing the database schema, follow these steps:

1. Update the schema in `shared/schema.ts`
2. Use the following command to generate and apply migrations:

```bash
npm run db:push
```

For complex migrations that require data transformation:

1. Create a migration script in `scripts/migrations/`
2. Run the script with:

```bash
npm run migrate:custom scripts/migrations/your-migration.ts
```

### Performance Optimization

#### Frontend Optimization Techniques

1. **Memoization**: Use React's `useMemo` and `useCallback` for expensive computations and callbacks:

```typescript
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
const memoizedCallback = useCallback(() => doSomething(a, b), [a, b]);
```

2. **Code Splitting**: Use dynamic imports to split your code:

```typescript
const DashboardPage = React.lazy(() => import('./pages/DashboardPage'));
```

3. **Virtualization**: For long lists, use virtualization:

```typescript
import { useVirtualizer } from '@tanstack/react-virtual';

function VirtualList({ items }) {
  const parentRef = React.useRef();
  
  const virtualizer = useVirtualizer({
    count: items.length,
    getScrollElement: () => parentRef.current,
    estimateSize: () => 50,
  });
  
  return (
    <div ref={parentRef} style={{ height: '500px', overflow: 'auto' }}>
      <div
        style={{
          height: `${virtualizer.getTotalSize()}px`,
          width: '100%',
          position: 'relative',
        }}
      >
        {virtualizer.getVirtualItems().map((virtualItem) => (
          <div
            key={virtualItem.key}
            style={{
              position: 'absolute',
              top: 0,
              left: 0,
              width: '100%',
              height: `${virtualItem.size}px`,
              transform: `translateY(${virtualItem.start}px)`,
            }}
          >
            {items[virtualItem.index]}
          </div>
        ))}
      </div>
    </div>
  );
}
```

#### Backend Optimization Techniques

1. **Query Optimization**: Use optimized queries with proper indexes:

```typescript
// Add index in schema.ts
export const tracksByUserIdIndex = pgIndex('idx_tracks_user_id').on(tracks).using('btree')([tracks.userId]);

// Optimize query in storage.ts
async getTracksByUserId(userId: number): Promise<Track[]> {
  return await db.query.tracks.findMany({
    where: eq(tracks.userId, userId),
    orderBy: desc(tracks.createdAt),
    limit: 100 // Add pagination to limit result size
  });
}
```

2. **Caching**: Implement caching for expensive operations:

```typescript
import NodeCache from 'node-cache';

const cache = new NodeCache({ stdTTL: 600 }); // 10 minutes TTL

async function getCachedData(key, fetchFn) {
  const cachedData = cache.get(key);
  if (cachedData) return cachedData;
  
  const freshData = await fetchFn();
  cache.set(key, freshData);
  return freshData;
}

// Usage in a service method
async getPopularTracks() {
  return getCachedData('popular_tracks', async () => {
    // Expensive database query or computation
    return await db.query.tracks.findMany({
      orderBy: desc(analytics.streams),
      limit: 20
    });
  });
}
```

### Testing Strategies

The project uses Jest for testing with the following types of tests:

#### Unit Tests

For testing individual functions and components:

```typescript
// Example component test
import { render, screen } from '@testing-library/react';
import { Button } from './Button';

describe('Button', () => {
  it('renders correctly', () => {
    render(<Button>Click me</Button>);
    expect(screen.getByText('Click me')).toBeInTheDocument();
  });
  
  it('calls onClick when clicked', () => {
    const handleClick = jest.fn();
    render(<Button onClick={handleClick}>Click me</Button>);
    screen.getByText('Click me').click();
    expect(handleClick).toHaveBeenCalledTimes(1);
  });
});
```

#### Integration Tests

For testing interactions between components:

```typescript
// Example integration test
import { render, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { LoginForm } from './LoginForm';
import { AuthProvider } from './AuthContext';

// Mock the API call
jest.mock('../api/auth', () => ({
  login: jest.fn(() => Promise.resolve({ user: { id: 1, username: 'testuser' } }))
}));

describe('LoginForm integration', () => {
  it('logs in the user and redirects', async () => {
    const queryClient = new QueryClient();
    const mockNavigate = jest.fn();
    
    // Mock the router
    jest.mock('react-router-dom', () => ({
      ...jest.requireActual('react-router-dom'),
      useNavigate: () => mockNavigate
    }));
    
    render(
      <QueryClientProvider client={queryClient}>
        <AuthProvider>
          <LoginForm />
        </AuthProvider>
      </QueryClientProvider>
    );
    
    // Fill in the form
    await userEvent.type(screen.getByLabelText(/username/i), 'testuser');
    await userEvent.type(screen.getByLabelText(/password/i), 'password123');
    
    // Submit the form
    await userEvent.click(screen.getByRole('button', { name: /login/i }));
    
    // Verify the result
    await waitFor(() => {
      expect(mockNavigate).toHaveBeenCalledWith('/dashboard');
    });
  });
});
```

#### API Tests

For testing API endpoints:

```typescript
// Example API test
import request from 'supertest';
import { app } from '../server';
import { db } from '../db';
import { users } from '../schema';

describe('User API', () => {
  beforeAll(async () => {
    // Set up test database
    await db.insert(users).values({
      username: 'testuser',
      email: 'test@example.com',
      password: 'hashedpassword',
      fullName: 'Test User',
      role: 'artist'
    });
  });
  
  afterAll(async () => {
    // Clean up test database
    await db.delete(users).where(eq(users.username, 'testuser'));
  });
  
  it('gets a user by ID', async () => {
    const response = await request(app)
      .get('/api/users/1')
      .set('Accept', 'application/json');
    
    expect(response.status).toBe(200);
    expect(response.body).toEqual(
      expect.objectContaining({
        id: 1,
        username: 'testuser',
        email: 'test@example.com',
        fullName: 'Test User'
      })
    );
    // Password should not be returned
    expect(response.body.password).toBeUndefined();
  });
});
```

### Debugging Tips

#### Frontend Debugging

1. **React DevTools**: Install React Developer Tools extension for Chrome or Firefox

2. **TanStack Query DevTools**: Use the built-in DevTools for debugging queries:

```typescript
import { ReactQueryDevtools } from '@tanstack/react-query-devtools';

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      {/* Your app components */}
      <ReactQueryDevtools initialIsOpen={false} />
    </QueryClientProvider>
  );
}
```

3. **Component Debugging**: Use the `debug` function from testing library:

```typescript
import { render, screen } from '@testing-library/react';

const { debug } = render(<YourComponent />);
debug(); // Prints the DOM structure to the console
```

#### Backend Debugging

1. **Request Logging**: Enable detailed request logging:

```typescript
app.use((req, res, next) => {
  console.log(`${req.method} ${req.url}`);
  console.log('Request body:', req.body);
  const originalSend = res.send;
  res.send = function(body) {
    console.log('Response:', body);
    return originalSend.call(this, body);
  };
  next();
});
```

2. **Database Query Logging**: Log database queries for debugging:

```typescript
// Enhanced query logging for Drizzle
import { DefaultLogger } from 'drizzle-orm';

db.driver.devMode = true; // Enable dev mode for query logging
```

3. **Node.js Debugger**: Use the built-in Node.js debugger:

- Add a `debugger` statement in your code
- Run Node.js with the `--inspect` flag: `node --inspect server/index.js`
- Open Chrome and navigate to `chrome://inspect` to connect to the debugger

## Development Workflow

### Git Workflow

We follow a feature branch workflow:

1. Create a new branch for your feature:

```bash
git checkout -b feature/your-feature-name
```

2. Make your changes and commit them:

```bash
git add .
git commit -m "Description of your changes"
```

3. Push your branch to the remote repository:

```bash
git push -u origin feature/your-feature-name
```

4. Create a pull request (PR) for code review

5. After approval, merge your PR into the main branch

### Code Review Guidelines

When submitting or reviewing code, follow these guidelines:

#### Submitting Code

1. **Keep PRs small and focused**: One feature or fix per PR
2. **Include tests**: Add tests for new features and bugfixes
3. **Provide a clear description**: Explain what the PR does and why
4. **Link relevant issues**: Reference related issues in the PR description
5. **Self-review**: Review your own code before submitting

#### Reviewing Code

1. **Be constructive**: Offer solutions, not just criticism
2. **Check functionality**: Verify the code works as intended
3. **Ensure test coverage**: Check that tests adequately cover the changes
4. **Verify code style**: Ensure the code follows project conventions
5. **Look for edge cases**: Consider potential failure scenarios

### Continuous Integration

The project uses GitHub Actions for CI/CD:

1. **Linting**: Ensure code style consistency
2. **Testing**: Run unit and integration tests
3. **Building**: Verify the project builds successfully
4. **Deployment**: Deploy to staging/production environments

## Troubleshooting Common Issues

### Database Connection Issues

If you encounter database connection problems:

1. Verify your PostgreSQL service is running:

```bash
sudo service postgresql status  # Linux
brew services list              # macOS
```

2. Check your `.env` file for correct database connection string:

```
DATABASE_URL=postgresql://username:password@localhost:5432/tunemantra
```

3. Ensure database exists and user has proper permissions:

```bash
psql -U postgres -c "CREATE DATABASE tunemantra;"
psql -U postgres -c "GRANT ALL PRIVILEGES ON DATABASE tunemantra TO yourusername;"
```

### Authentication Issues

If users can't log in or sessions aren't persisting:

1. Check JWT secret in `.env` file:

```
JWT_SECRET=your-jwt-secret-here
```

2. Verify cookie settings in `server/auth.ts`:

```typescript
app.use(session({
  secret: process.env.SESSION_SECRET || 'default-secret',
  resave: false,
  saveUninitialized: false,
  cookie: {
    secure: process.env.NODE_ENV === 'production',
    httpOnly: true,
    maxAge: 1000 * 60 * 60 * 24 * 30 // 30 days
  },
  store: sessionStore
}));
```

3. Check for CORS issues in `server/index.ts`:

```typescript
app.use(cors({
  origin: process.env.CLIENT_URL || 'http://localhost:3000',
  credentials: true
}));
```

### File Upload Issues

If file uploads are failing:

1. Check upload directory exists and has proper permissions:

```bash
mkdir -p uploads
chmod 755 uploads
```

2. Verify Multer configuration:

```typescript
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, process.env.UPLOAD_DIR || './uploads');
  },
  filename: (req, file, cb) => {
    const uniqueSuffix = `${Date.now()}-${Math.round(Math.random() * 1e9)}`;
    cb(null, `${uniqueSuffix}-${file.originalname}`);
  }
});

const upload = multer({
  storage,
  limits: {
    fileSize: parseInt(process.env.MAX_FILE_SIZE || '10000000') // 10MB default
  }
});
```

## Resources

### Documentation

- [Node.js Documentation](https://nodejs.org/en/docs/)
- [React Documentation](https://react.dev/)
- [TypeScript Documentation](https://www.typescriptlang.org/docs/)
- [Drizzle ORM Documentation](https://orm.drizzle.team/docs/overview)
- [TanStack Query Documentation](https://tanstack.com/query/latest/docs/react/overview)
- [Express Documentation](https://expressjs.com/)

### Tools

- [VS Code](https://code.visualstudio.com/)
- [Postman](https://www.postman.com/) - API testing tool
- [React Developer Tools](https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi)
- [pgAdmin](https://www.pgadmin.org/) - PostgreSQL management tool

### Learning Resources

- [TypeScript Deep Dive](https://basarat.gitbook.io/typescript/)
- [React Patterns](https://reactpatterns.com/)
- [Drizzle ORM Tutorials](https://orm.drizzle.team/learn/overview)
- [TanStack Query Course](https://ui.dev/react-query)

## Getting Help

If you need assistance while working on the TuneMantra platform:

1. **Documentation**: First, check the existing documentation
2. **Issue Tracker**: Search the project's GitHub issues
3. **Team Chat**: Ask in the development team's Slack channel
4. **Code Comments**: Look for comments in the relevant code files
5. **Ask for Help**: Don't hesitate to ask senior developers for guidance

Remember: There are no silly questions, and we all started somewhere!

---

## documentation/developer/installation-guide.md

# TuneMantra Installation Guide

*Version: 1.0.0 (March 27, 2025)*

## Table of Contents

- [Introduction](#introduction)
- [System Requirements](#system-requirements)
- [Development Environment Setup](#development-environment-setup)
- [Production Environment Setup](#production-environment-setup)
- [Configuration](#configuration)
- [Database Setup](#database-setup)
- [External Service Integration](#external-service-integration)
- [Verification](#verification)
- [Troubleshooting](#troubleshooting)
- [Appendix](#appendix)

## Introduction

This guide provides comprehensive instructions for setting up both development and production environments for the TuneMantra platform. It covers environment preparation, component installation, configuration, and verification procedures.

### Purpose and Scope

This document is intended for:

- Developers setting up local development environments
- DevOps engineers deploying to production environments
- System administrators maintaining TuneMantra installations
- Quality assurance teams establishing testing environments

### Prerequisites

To complete this installation guide, you should have:

- Basic understanding of web application architecture
- Familiarity with command-line operations
- Knowledge of database management
- Understanding of containerization concepts
- Access to necessary infrastructure and credentials

## System Requirements

### Development Environment

Minimum requirements for a development environment:

- **Operating System**: macOS 12+, Windows 10/11, or Linux (Ubuntu 20.04+, Debian 11+)
- **CPU**: 4+ cores
- **Memory**: 16GB RAM
- **Storage**: 40GB available space (SSD recommended)
- **Database**: PostgreSQL 14+
- **Node.js**: v18.18+ or v20.10+
- **Git**: 2.30+
- **Docker**: 24.0+ (for containerized services)
- **Display**: 1920x1080 resolution (for UI development)

### Production Environment

Recommended specifications for production deployment:

- **Infrastructure**: Cloud-based or on-premises with high availability
- **Application Servers**:
  - Minimum 4 vCPUs, 16GB RAM per instance
  - Autoscaling group with 2+ instances
  - Load balancer with SSL termination
- **Database**:
  - PostgreSQL 14+ with high availability
  - Minimum 8 vCPUs, 32GB RAM
  - 500GB+ storage with backup capability
- **File Storage**:
  - Object storage service (S3-compatible)
  - CDN for media content delivery
- **Caching Layer**:
  - Redis 6.2+ cluster
  - Minimum 8GB memory allocation
- **Message Queue**:
  - Kafka 3.0+ or equivalent
  - Minimum 3-node cluster

### Network Requirements

Connectivity requirements:

- **Development**:
  - Internet access for package downloads
  - GitHub access for source repositories
  - Local ports 3000-3010 available for services
- **Production**:
  - Inbound ports 80/443 for web traffic
  - Outbound access to external APIs
  - Secure internal network for service communication
  - VPN or bastion host for administrative access

## Development Environment Setup

### Initial Setup

#### 1. Install System Dependencies

**macOS (using Homebrew)**:

```bash
# Install Homebrew if not already installed
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"

# Install required dependencies
brew update
brew install node@20 postgresql@14 redis git
brew install --cask docker

# Start services
brew services start postgresql@14
brew services start redis
```

**Ubuntu/Debian**:

```bash
# Update package lists
sudo apt update

# Install Node.js
curl -fsSL https://deb.nodesource.com/setup_20.x | sudo -E bash -
sudo apt install -y nodejs

# Install PostgreSQL
sudo apt install -y postgresql-14 postgresql-contrib-14

# Install Redis
sudo apt install -y redis-server

# Install Git
sudo apt install -y git

# Install Docker
curl -fsSL https://get.docker.com | sudo bash
sudo usermod -aG docker $USER
```

**Windows (using PowerShell as Administrator)**:

```powershell
# Install Chocolatey if not already installed
Set-ExecutionPolicy Bypass -Scope Process -Force
[System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072
iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))

# Install required dependencies
choco install nodejs-lts postgresql redis git docker-desktop -y

# Start PostgreSQL service
Start-Service postgresql

# Start Redis service
Start-Service redis
```

#### 2. Clone Repository

```bash
# Clone the main repository
git clone https://github.com/tunemantra/platform.git tunemantra
cd tunemantra

# Initialize submodules if any
git submodule update --init --recursive
```

#### 3. Install Application Dependencies

```bash
# Install Node.js dependencies
npm install

# Install development tools
npm install -g typescript ts-node nodemon
```

### Database Setup

#### 1. Configure PostgreSQL

```bash
# Create database and user
psql -U postgres -c "CREATE USER tunemantra WITH PASSWORD 'development_password';"
psql -U postgres -c "CREATE DATABASE tunemantra_dev OWNER tunemantra;"
psql -U postgres -c "CREATE DATABASE tunemantra_test OWNER tunemantra;"
psql -U postgres -c "GRANT ALL PRIVILEGES ON DATABASE tunemantra_dev TO tunemantra;"
psql -U postgres -c "GRANT ALL PRIVILEGES ON DATABASE tunemantra_test TO tunemantra;"
```

#### 2. Initialize Database Schema

```bash
# Run database migrations
npm run db:migrate

# Seed database with initial data
npm run db:seed
```

### Configuration Setup

#### 1. Environment Configuration

```bash
# Copy example environment file
cp .env.example .env.development

# Edit the environment file with your local settings
# Update database connection string and other necessary values
```

Key environment variables to configure:

- `NODE_ENV=development`
- `PORT=3000`
- `DATABASE_URL=postgresql://tunemantra:development_password@localhost:5432/tunemantra_dev`
- `REDIS_URL=redis://localhost:6379`
- `SESSION_SECRET=your_local_session_secret`
- `API_BASE_URL=http://localhost:3000/api`

#### 2. External Service Mocks

For development without external API dependencies:

```bash
# Start mock services
npm run mocks:start
```

### Starting the Development Server

```bash
# Start the development server
npm run dev

# Or start with specific options
npm run dev:watch  # With file watching
```

The development server will be available at `http://localhost:3000`.

## Production Environment Setup

### Infrastructure Provisioning

#### Cloud Environment (AWS Example)

1. **Network Setup**:
   - VPC with public and private subnets across multiple availability zones
   - NAT Gateways for outbound connectivity from private subnets
   - Security groups for application, database, and cache tiers

2. **Compute Resources**:
   - EC2 Auto Scaling Group or ECS/EKS cluster for application servers
   - Application Load Balancer with HTTPS listener
   - Elastic IP addresses for stable entry points

3. **Database Setup**:
   - RDS PostgreSQL with Multi-AZ deployment
   - Parameter group configured for application requirements
   - Subnet group spanning multiple availability zones

4. **Caching and Messaging**:
   - ElastiCache Redis cluster for caching
   - Amazon MSK (Managed Streaming for Kafka) for event streaming

5. **Storage Resources**:
   - S3 buckets for media and file storage
   - CloudFront distribution for content delivery

#### On-Premises Deployment

1. **Server Preparation**:
   - Physical or virtual servers with required specifications
   - Network configuration with appropriate VLANs and firewall rules
   - Load balancer configuration with SSL termination

2. **High Availability Setup**:
   - Server clustering for application tier
   - Database replication and failover configuration
   - Redundant network paths and equipment

### Application Deployment

#### Container-based Deployment

1. **Build Application Images**:

```bash
# Build Docker images
docker build -t tunemantra/api:latest -f docker/api/Dockerfile .
docker build -t tunemantra/web:latest -f docker/web/Dockerfile .
docker build -t tunemantra/worker:latest -f docker/worker/Dockerfile .
```

2. **Deploy with Docker Compose** (for simpler deployments):

```bash
# Start the application stack
docker-compose -f docker-compose.production.yml up -d
```

3. **Deploy with Kubernetes** (for complex deployments):

```bash
# Apply Kubernetes configurations
kubectl apply -f kubernetes/namespace.yaml
kubectl apply -f kubernetes/configmap.yaml
kubectl apply -f kubernetes/secrets.yaml
kubectl apply -f kubernetes/database.yaml
kubectl apply -f kubernetes/redis.yaml
kubectl apply -f kubernetes/api.yaml
kubectl apply -f kubernetes/web.yaml
kubectl apply -f kubernetes/worker.yaml
kubectl apply -f kubernetes/ingress.yaml
```

#### Traditional Deployment

1. **Prepare Application**:

```bash
# Install production dependencies only
npm ci --only=production

# Build application
npm run build
```

2. **Configure Process Manager**:

```bash
# Install PM2
npm install -g pm2

# Start application with PM2
pm2 start ecosystem.config.js --env production

# Save PM2 configuration for startup
pm2 save
pm2 startup
```

### Database Migration

```bash
# Run production database migrations
NODE_ENV=production npm run db:migrate

# Seed initial data if needed
NODE_ENV=production npm run db:seed:production
```

### SSL Certificate Setup

```bash
# Install Certbot for Let's Encrypt certificates
sudo apt install -y certbot

# Obtain certificates
sudo certbot certonly --webroot -w /var/www/html -d yourdomain.com -d www.yourdomain.com

# Configure web server with certificates
# For Nginx:
sudo cp /etc/letsencrypt/live/yourdomain.com/fullchain.pem /etc/nginx/ssl/
sudo cp /etc/letsencrypt/live/yourdomain.com/privkey.pem /etc/nginx/ssl/
```

## Configuration

### Core Configuration

Key configuration files:

- `.env.production`: Environment variables for production
- `config/default.js`: Default configuration values
- `config/production.js`: Production-specific overrides
- `nginx/tunemantra.conf`: Web server configuration

Essential production environment variables:

```
NODE_ENV=production
PORT=3000
LOG_LEVEL=info
DATABASE_URL=postgresql://username:password@database-host:5432/tunemantra
REDIS_URL=redis://redis-host:6379
SESSION_SECRET=strong_random_secret
API_BASE_URL=https://api.yourdomain.com
STORAGE_BUCKET=your-media-bucket
```

### Security Configuration

Security-related settings:

1. **API Rate Limiting**:
   - Edit `config/security.js` to set rate limits
   - Default: 60 requests per minute per IP

2. **CORS Settings**:
   - Configure allowed origins in `config/cors.js`
   - Production should use explicit domain lists

3. **Content Security Policy**:
   - Edit headers in `config/security.js`
   - Restrict resource loading to trusted domains

### Scaling Configuration

Settings for high-load environments:

1. **Connection Pooling**:
   - Database: `config/database.js`
   - Default: min=5, max=20 connections

2. **Worker Processes**:
   - Node.js: Set in process manager configuration
   - Recommended: 1 worker per CPU core

3. **Caching Configuration**:
   - Control TTL values in `config/cache.js`
   - Adjust memory allocation based on usage patterns

## Database Setup

### Schema Management

TuneMantra uses Drizzle ORM for database schema management.

```bash
# Run database migrations
NODE_ENV=production npm run db:migrate

# Generate a new migration
npm run db:generate:migration -- --name add_new_feature
```

### Backup and Restore

Regular backup procedures:

```bash
# Backup database to file
pg_dump -U username -h hostname -d tunemantra > backup_$(date +%Y%m%d_%H%M%S).sql

# Restore from backup
psql -U username -h hostname -d tunemantra < backup_file.sql
```

Automated backup with cron:

```
# Add to crontab
0 2 * * * /usr/bin/pg_dump -U username -h hostname -d tunemantra | gzip > /backup/tunemantra_$(date +\%Y\%m\%d_\%H\%M\%S).sql.gz
```

### Replication Setup

For high-availability database:

1. Configure primary server in `postgresql.conf`:
   ```
   wal_level = replica
   max_wal_senders = 10
   wal_keep_segments = 64
   ```

2. Configure replication permissions in `pg_hba.conf`:
   ```
   host replication replicator 192.168.1.0/24 md5
   ```

3. Set up replica server to connect to primary.

## External Service Integration

### Streaming Platform Connections

Configure API credentials for music platforms:

1. **Spotify**:
   - Register application in Spotify Developer Dashboard
   - Add credentials to environment variables:
     ```
     SPOTIFY_CLIENT_ID=your_client_id
     SPOTIFY_CLIENT_SECRET=your_client_secret
     ```

2. **Apple Music**:
   - Generate private key in Apple Developer portal
   - Configure in environment variables:
     ```
     APPLE_MUSIC_KEY_ID=your_key_id
     APPLE_MUSIC_TEAM_ID=your_team_id
     APPLE_MUSIC_PRIVATE_KEY=path_to_private_key_file
     ```

3. **Amazon Music**:
   - Register application in Amazon Developer Console
   - Add credentials to environment:
     ```
     AMAZON_MUSIC_CLIENT_ID=your_client_id
     AMAZON_MUSIC_CLIENT_SECRET=your_client_secret
     ```

### Payment Processing

Set up payment provider integration:

1. **Stripe**:
   - Create Stripe account and obtain API keys
   - Configure in environment:
     ```
     STRIPE_PUBLIC_KEY=your_public_key
     STRIPE_SECRET_KEY=your_secret_key
     STRIPE_WEBHOOK_SECRET=your_webhook_secret
     ```

2. **PayPal**:
   - Register application in PayPal Developer Dashboard
   - Configure in environment:
     ```
     PAYPAL_CLIENT_ID=your_client_id
     PAYPAL_CLIENT_SECRET=your_client_secret
     PAYPAL_ENVIRONMENT=production
     ```

### Email Service

Configure email delivery service:

1. **SendGrid**:
   - Create SendGrid account and generate API key
   - Configure in environment:
     ```
     EMAIL_PROVIDER=sendgrid
     SENDGRID_API_KEY=your_api_key
     EMAIL_FROM=noreply@yourdomain.com
     ```

2. **Amazon SES**:
   - Configure AWS credentials and SES access
   - Set environment variables:
     ```
     EMAIL_PROVIDER=ses
     AWS_ACCESS_KEY_ID=your_access_key
     AWS_SECRET_ACCESS_KEY=your_secret_key
     AWS_REGION=us-east-1
     EMAIL_FROM=noreply@yourdomain.com
     ```

## Verification

### System Verification

Steps to verify successful installation:

1. **Service Status Check**:
   ```bash
   # Check running services
   pm2 status  # For traditional deployment
   docker ps   # For container deployment
   kubectl get pods  # For Kubernetes deployment
   ```

2. **Application Health Check**:
   - Access `https://yourdomain.com/health`
   - Verify response: `{"status":"ok","version":"x.y.z"}`

3. **Database Connectivity**:
   - Access `https://yourdomain.com/health/database`
   - Verify response: `{"status":"connected"}`

4. **External Service Check**:
   - Access `https://yourdomain.com/health/integrations`
   - Verify all integrations show `"status":"connected"`

### Security Verification

Security checks to perform:

1. **SSL Configuration**:
   ```bash
   # Check SSL configuration
   nmap --script ssl-enum-ciphers -p 443 yourdomain.com
   
   # Alternative using SSL Labs
   # Visit: https://www.ssllabs.com/ssltest/analyze.html?d=yourdomain.com
   ```

2. **Headers Security**:
   ```bash
   # Check security headers
   curl -I https://yourdomain.com
   
   # Verify presence of:
   # - Strict-Transport-Security
   # - Content-Security-Policy
   # - X-Content-Type-Options
   # - X-Frame-Options
   ```

3. **Permission Verification**:
   - Ensure file permissions are correct
   - Check database user has minimal required privileges

### Performance Verification

Basic performance checks:

1. **Load Testing**:
   ```bash
   # Install k6 load testing tool
   # Run basic load test
   k6 run load-tests/basic-performance.js
   ```

2. **Response Time Check**:
   ```bash
   # Check API response time
   curl -w "Connect: %{time_connect}s\nTTFB: %{time_starttransfer}s\nTotal: %{time_total}s\n" -o /dev/null -s https://yourdomain.com/api/health
   ```

## Troubleshooting

### Common Issues

#### Database Connection Errors

**Symptom**: Application fails to start with database connection errors.

**Solutions**:
1. Verify database server is running:
   ```bash
   sudo systemctl status postgresql
   ```

2. Check connection parameters:
   ```bash
   psql -U username -h hostname -p port -d database
   ```

3. Verify firewall allows connections:
   ```bash
   sudo iptables -L | grep 5432
   ```

#### Permission Issues

**Symptom**: Application cannot write to files or directories.

**Solutions**:
1. Check ownership of application directories:
   ```bash
   ls -la /path/to/application
   ```

2. Set correct permissions:
   ```bash
   sudo chown -R appuser:appgroup /path/to/application
   sudo chmod -R 755 /path/to/application
   ```

#### Memory Limitations

**Symptom**: Application crashes with "out of memory" errors.

**Solutions**:
1. Increase Node.js memory limit:
   ```bash
   # In PM2 ecosystem.config.js
   "node_args": "--max-old-space-size=4096"
   ```

2. Check system memory usage:
   ```bash
   free -m
   ```

3. Add swap space if needed:
   ```bash
   sudo fallocate -l 4G /swapfile
   sudo chmod 600 /swapfile
   sudo mkswap /swapfile
   sudo swapon /swapfile
   ```

### Logging and Monitoring

#### Accessing Logs

```bash
# Application logs (PM2)
pm2 logs

# Application logs (Docker)
docker logs container_name

# Application logs (Kubernetes)
kubectl logs pod_name

# System logs
sudo journalctl -u tunemantra

# Nginx logs
sudo tail -f /var/log/nginx/access.log
sudo tail -f /var/log/nginx/error.log
```

#### Monitoring Tools

1. **System Monitoring**:
   ```bash
   # Install Netdata for real-time monitoring
   bash <(curl -Ss https://my-netdata.io/kickstart.sh)
   
   # Access dashboard at http://localhost:19999
   ```

2. **Application Performance Monitoring**:
   - Configure New Relic or DataDog APM
   - See `config/monitoring.js` for integration points

## Appendix

### Environment Variables Reference

Complete list of supported environment variables:

| Variable | Description | Default | Required |
|----------|-------------|---------|----------|
| `NODE_ENV` | Environment mode | `development` | Yes |
| `PORT` | HTTP server port | `3000` | Yes |
| `LOG_LEVEL` | Logging verbosity | `info` | No |
| `DATABASE_URL` | PostgreSQL connection URL | - | Yes |
| `REDIS_URL` | Redis connection URL | - | Yes |
| `SESSION_SECRET` | Secret for session cookies | - | Yes |
| `CORS_ORIGIN` | Allowed CORS origins | `*` | No |
| `API_RATE_LIMIT` | Requests per minute | `60` | No |
| `STORAGE_BUCKET` | Media storage bucket | - | Yes |
| `STORAGE_REGION` | Storage service region | `us-east-1` | No |
| `KAFKA_BROKERS` | Comma-separated Kafka brokers | - | No |
| `EMAIL_PROVIDER` | Email service provider | `sendgrid` | No |
| `EMAIL_FROM` | Default sender address | - | Yes |
| `SENTRY_DSN` | Error tracking endpoint | - | No |
| `API_BASE_URL` | Base URL for API requests | - | Yes |

### Deployment Checklist

Pre-deployment verification checklist:

- [ ] Environment variables configured for production
- [ ] Database migrations applied and verified
- [ ] External service credentials validated
- [ ] SSL certificates installed and configured
- [ ] Firewall rules and network security verified
- [ ] Backup procedures established
- [ ] Monitoring systems configured
- [ ] Load testing completed
- [ ] Security scanning performed
- [ ] Documentation updated

### Reference Commands

Useful commands for administration:

```bash
# Start application
npm run start

# Run database migrations
npm run db:migrate

# Generate new migration
npm run db:generate:migration -- --name migration_name

# Seed database
npm run db:seed

# Run tests
npm test

# Check for lint errors
npm run lint

# Fix lint errors
npm run lint:fix

# Build for production
npm run build
```

---

© 2023-2025 TuneMantra. All rights reserved.

---

## documentation/developer/onboarding-guide.md

# TuneMantra Developer Onboarding Guide

*Version: 1.0.0 (March 27, 2025)*

## Table of Contents

- [Introduction](#introduction)
- [Development Environment Setup](#development-environment-setup)
- [Project Architecture Overview](#project-architecture-overview)
- [Codebase Navigation](#codebase-navigation)
- [Development Workflow](#development-workflow)
- [Coding Standards](#coding-standards)
- [Testing Guidelines](#testing-guidelines)
- [Debugging and Troubleshooting](#debugging-and-troubleshooting)
- [Deployment Process](#deployment-process)
- [Key Technologies](#key-technologies)
- [Communication Channels](#communication-channels)
- [Helpful Resources](#helpful-resources)
- [FAQs](#faqs)

## Introduction

Welcome to the TuneMantra development team! This guide is designed to help you get up to speed quickly and become a productive team member. It contains essential information about our development environment, workflow, coding standards, and more.

### About TuneMantra

TuneMantra is a multi-tenant music distribution platform that enables artists, labels, and distributors to manage, distribute, and monetize music content across global digital platforms. The platform handles the complete lifecycle from content ingestion to royalty distribution and provides comprehensive analytics.

Key features include:
- Content and metadata management
- Global distribution to 150+ digital service providers
- Rights and ownership management
- Royalty calculation and payment processing
- Advanced analytics and reporting

### Project Goals

Our development goals are aligned with the following principles:
1. Build a scalable, secure, and reliable platform
2. Provide an exceptional user experience for all stakeholders
3. Maintain high code quality and test coverage
4. Enable rapid feature development with minimal technical debt
5. Support multi-tenancy with strong data isolation

## Development Environment Setup

### Prerequisites

Before you begin, ensure you have the following installed:

- **Git**: Version 2.30.0 or higher
- **Node.js**: Version 18.x LTS or higher
- **npm**: Version 9.x or higher
- **Docker**: Version 24.x or higher
- **Docker Compose**: Version 2.x or higher
- **PostgreSQL client tools**: Version 14.x or higher
- **VS Code** (recommended) or your preferred IDE

### Environment Setup Steps

1. **Clone the Repository**

```bash
git clone git@github.com:tunemantra/tunemantra-platform.git
cd tunemantra-platform
```

2. **Configure Git**

Set up Git with your username and email:

```bash
git config user.name "Your Name"
git config user.email "your.email@example.com"
```

Set up commit signing with your GPG key:

```bash
git config --global commit.gpgsign true
git config --global user.signingkey YOUR_GPG_KEY_ID
```

3. **Install Dependencies**

```bash
npm install
```

4. **Set Up Environment Variables**

Copy the example environment file and update it with your local settings:

```bash
cp .env.example .env.development.local
```

Edit `.env.development.local` with appropriate values. Contact your team lead to obtain necessary secrets for development.

5. **Initialize Development Database**

```bash
npm run db:setup
```

This will create the database schema and seed it with initial data.

6. **Start the Development Environment**

```bash
npm run dev
```

This will start the development server with hot-reloading enabled.

7. **Verify Setup**

Open your browser and navigate to:

```
http://localhost:3000
```

You should see the TuneMantra application running.

### Docker Development Environment

Alternatively, you can use Docker for development:

```bash
docker-compose -f docker-compose.dev.yml up
```

This will set up the complete development environment, including the database, Redis, and other services.

### IDE Configuration

#### VS Code Setup

For VS Code users, we recommend the following extensions:

- ESLint
- Prettier
- TypeScript Hero
- GitLens
- Docker
- PostgreSQL
- EditorConfig

We've included a `.vscode` directory in the repository with recommended settings. To use them:

1. Open the project in VS Code
2. Go to File > Preferences > Settings
3. Click "Workspace" tab to see project-specific settings

#### IntelliJ/WebStorm Setup

For IntelliJ/WebStorm users:

1. Enable ESLint integration
2. Enable Prettier integration
3. Set TypeScript compiler to use project version
4. Configure Node.js interpreter to use project version

## Project Architecture Overview

TuneMantra follows a modern, modular architecture designed for scalability and maintainability.

### High-Level Architecture

The platform is organized into several key components:

1. **Client Application**: React-based frontend with modular feature organization
2. **API Layer**: Express.js-based REST API with GraphQL support
3. **Service Layer**: Business logic implementing core functionality
4. **Data Access Layer**: Database interaction with Drizzle ORM
5. **Infrastructure Layer**: Docker, Kubernetes, and cloud resources

### Architectural Diagrams

For a visual representation of the architecture, refer to:
- [System Architecture Diagram](../diagrams/system-architecture-diagram.svg)
- [API Overview Diagram](../diagrams/api-overview-diagram.svg)
- [Distribution System Overview](../diagrams/distribution-system-overview.svg)

### Security Architecture

Security is a foundational aspect of the platform. Our security model includes:

- Identity and access management
- Data protection measures
- Network security controls
- Application security practices
- Compliance framework

For more details, see the [Security Model Documentation](../technical/security-model.md).

### Database Structure

The platform uses PostgreSQL as the primary database, with additional specialized data stores:

- **PostgreSQL**: Primary transactional database
- **Redis**: Caching and session storage
- **Elasticsearch**: Search functionality
- **Amazon S3**: File storage

Refer to the database schema documentation for details on tables, relationships, and indexes.

## Codebase Navigation

Understanding the codebase structure is key to effective development. Here's a guide to the main directories:

### Root Structure

```
tunemantra-platform/
├── client/                    # Frontend application code
├── server/                    # Backend application code
├── shared/                    # Code shared between client and server
├── documentation/             # Project documentation
├── scripts/                   # Build, deployment, and utility scripts
├── config/                    # Configuration files
├── infrastructure/            # Infrastructure as Code (IaC)
├── migrations/                # Database migration scripts
├── tests/                     # Test suites
│   ├── unit/                  # Unit tests
│   ├── integration/           # Integration tests
│   ├── e2e/                   # End-to-end tests
│   └── performance/           # Performance tests
├── tools/                     # Development tools
├── .github/                   # GitHub workflow configurations
└── examples/                  # Example implementations
```

### Client Structure

```
client/
├── public/                    # Static assets
├── src/                       # Source code
│   ├── api/                   # API client code
│   ├── assets/                # Images, fonts, etc.
│   ├── components/            # React components
│   ├── contexts/              # React contexts
│   ├── hooks/                 # Custom React hooks
│   ├── pages/                 # Page components
│   ├── routes/                # Routing configuration
│   ├── services/              # Service layer
│   ├── store/                 # State management
│   ├── styles/                # Global styles
│   ├── types/                 # TypeScript type definitions
│   └── utils/                 # Utility functions
└── tests/                     # Frontend tests
```

### Server Structure

```
server/
├── src/                       # Source code
│   ├── api/                   # API routes and controllers
│   ├── config/                # Server configuration
│   ├── db/                    # Database connection and models
│   ├── middleware/            # Express middleware
│   ├── services/              # Business logic
│   ├── utils/                 # Utility functions
│   └── types/                 # TypeScript type definitions
└── tests/                     # Backend tests
```

### Key Files

Some important files to be aware of:

- `package.json`: Project dependencies and scripts
- `tsconfig.json`: TypeScript configuration
- `.env.example`: Example environment variables
- `docker-compose.yml`: Docker compose configuration
- `shared/schema.ts`: Database schema definition
- `server/api/index.ts`: API route registration
- `client/src/app.tsx`: Main React application entry point

## Development Workflow

### Git Workflow

We follow a modified GitFlow branching strategy:

1. **Main Branches**:
   - `main`: Production code
   - `develop`: Development code

2. **Feature Development**:
   - Create a feature branch from `develop`
   - Name it according to the convention: `feature/TM-XXX-short-description`
   - Develop, test, and commit your changes
   - Create a pull request back to `develop`

3. **Bugfixes**:
   - For non-critical bugs: Create a branch from `develop` named `bugfix/TM-XXX-short-description`
   - For critical production bugs: Create a branch from `main` named `hotfix/TM-XXX-short-description`

4. **Pull Requests**:
   - Ensure all tests pass
   - Get at least one code review
   - Address all comments
   - Squash commits if necessary

For a detailed explanation of our Git strategy, see the [Repository Documentation](./repository-documentation.md).

### Issue Tracking

We use Jira for issue tracking:

1. All development work should be associated with a Jira ticket
2. Use the ticket ID in branch names and commit messages
3. Move tickets through the appropriate workflow states
4. Link pull requests to the relevant tickets

### Development Cycle

Our typical development cycle follows these steps:

1. **Planning**:
   - Requirements gathering
   - Task breakdown
   - Estimation

2. **Development**:
   - Feature implementation
   - Unit testing
   - Code review

3. **Testing**:
   - Integration testing
   - QA verification
   - Bug fixing

4. **Deployment**:
   - Staging deployment
   - Final verification
   - Production deployment

5. **Monitoring**:
   - Performance monitoring
   - Error tracking
   - Usage analytics

### Local Development Tasks

Common development tasks:

**Start Development Server**
```bash
npm run dev
```

**Run Tests**
```bash
npm test                # Run all tests
npm run test:unit       # Run unit tests
npm run test:integration # Run integration tests
npm run test:e2e        # Run end-to-end tests
```

**Lint Code**
```bash
npm run lint            # Lint all code
npm run lint:fix        # Fix linting issues
```

**Format Code**
```bash
npm run format
```

**Database Operations**
```bash
npm run db:migrate      # Run migrations
npm run db:seed         # Seed database
npm run db:reset        # Reset database
npm run db:generate     # Generate migration
npm run db:push         # Push schema changes
```

## Coding Standards

Following consistent coding standards helps maintain codebase quality and readability.

### TypeScript Guidelines

- Use TypeScript for all new code
- Define interfaces for data structures
- Use proper type annotations
- Avoid using `any` type
- Leverage TypeScript's advanced features (generics, mapped types, etc.)

### JavaScript/TypeScript Style

We follow [Airbnb JavaScript Style Guide](https://github.com/airbnb/javascript) with some modifications:

- Use 2 spaces for indentation
- Use semicolons
- Use single quotes for strings
- Use template literals for string interpolation
- Use camelCase for variables and functions
- Use PascalCase for classes and React components
- Use UPPER_CASE for constants

ESLint and Prettier are configured to enforce these rules.

### React Best Practices

- Use functional components with hooks
- Keep components small and focused
- Use meaningful component names
- Implement proper prop validation
- Follow logical folder structure
- Separate business logic from UI
- Use code splitting for performance

### API Design Principles

- Follow RESTful design principles
- Use appropriate HTTP methods and status codes
- Implement consistent error handling
- Use proper versioning
- Document all endpoints
- Implement rate limiting and security measures

For detailed API guidelines, see the [API Reference Documentation](./api-reference.md).

### Testing Standards

- Write tests for all business logic
- Aim for high test coverage (at least 80%)
- Follow the AAA pattern (Arrange, Act, Assert)
- Use descriptive test names
- Mock external dependencies
- Organize tests to mirror the source code structure

### Code Comments

- Use JSDoc for function and class documentation
- Add comments for complex logic
- Avoid obvious comments
- Keep comments updated as code changes
- Use TODO, FIXME, and NOTE tags when appropriate

## Testing Guidelines

Comprehensive testing is essential for maintaining code quality and preventing regressions.

### Testing Approach

We employ several levels of testing:

1. **Unit Tests**: Test individual functions and components in isolation
2. **Integration Tests**: Test interactions between components
3. **End-to-End Tests**: Test complete user flows
4. **Performance Tests**: Test system performance under load

### Testing Technologies

- **Jest**: For unit and integration testing
- **React Testing Library**: For React component testing
- **Cypress**: For end-to-end testing
- **Supertest**: For API testing
- **k6**: For performance testing

### Unit Testing

Unit tests should be:
- Fast and focused
- Independent of external resources
- Comprehensive in coverage
- Easy to understand and maintain

Example unit test:

```typescript
import { calculateRoyalty } from '../services/royalty';

describe('calculateRoyalty', () => {
  it('calculates correct royalty for standard rate', () => {
    const result = calculateRoyalty({
      revenue: 100,
      rate: 0.7,
      territory: 'US'
    });
    
    expect(result).toBe(70);
  });

  it('applies minimum guarantee when applicable', () => {
    const result = calculateRoyalty({
      revenue: 10,
      rate: 0.7,
      minimumGuarantee: 10,
      territory: 'US'
    });
    
    expect(result).toBe(10);
  });
});
```

### Integration Testing

Integration tests verify that components work together correctly:

```typescript
import request from 'supertest';
import app from '../app';
import { db } from '../db';

describe('Royalty API', () => {
  beforeAll(async () => {
    await db.migrate.latest();
    await db.seed.run();
  });

  afterAll(async () => {
    await db.destroy();
  });

  it('returns calculated royalties for a release', async () => {
    const response = await request(app)
      .get('/api/royalties/release/123')
      .set('Authorization', `Bearer ${validToken}`);
    
    expect(response.status).toBe(200);
    expect(response.body.total).toBe(1250.75);
    expect(response.body.items).toHaveLength(3);
  });
});
```

### End-to-End Testing

E2E tests verify complete user flows:

```typescript
describe('Release Creation', () => {
  beforeEach(() => {
    cy.login('admin@example.com', 'password');
  });

  it('creates a new release with tracks', () => {
    cy.visit('/releases/new');
    cy.get('#title').type('New Album');
    cy.get('#artist').type('Test Artist');
    cy.get('#release-date').type('2025-04-01');
    cy.get('#add-track').click();
    cy.get('#track-title-0').type('Track 1');
    cy.get('#track-duration-0').type('3:45');
    cy.get('#save-release').click();
    
    cy.url().should('include', '/releases/');
    cy.contains('New Album').should('be.visible');
    cy.contains('Release created successfully').should('be.visible');
  });
});
```

### Test Coverage

We aim for high test coverage:
- 90%+ coverage for critical business logic
- 80%+ coverage for services and API controllers
- 70%+ coverage for UI components

Run coverage reports using:
```bash
npm run test:coverage
```

## Debugging and Troubleshooting

### Common Development Issues

**Database Connection Issues**
- Check that PostgreSQL is running
- Verify connection string in `.env` file
- Ensure database exists and has correct permissions

**API Errors**
- Check server logs for detailed error messages
- Verify that the request has the correct format and authentication
- Check for rate limiting or permission issues

**Frontend Build Problems**
- Clear npm cache: `npm cache clean --force`
- Remove `node_modules` and reinstall: `rm -rf node_modules && npm install`
- Check for TypeScript errors: `npm run tsc`

### Debugging Tools

**Server-side Debugging**
- Use `console.log()` for quick debugging
- Add `debugger` statement for Node.js debugging
- Use VS Code's built-in debugger (launch configurations are provided)

**Client-side Debugging**
- Use browser dev tools (Chrome DevTools recommended)
- React DevTools extension for component inspection
- Redux DevTools for state management debugging
- Network tab for API request inspection

**Database Debugging**
- Use pgAdmin or similar tools to inspect database
- SQL query logging is enabled in development
- Database migrations can be rolled back with `npm run db:rollback`

### Logging

We use structured logging to facilitate debugging:

```typescript
import logger from '../utils/logger';

// Log levels: error, warn, info, debug
logger.info('Processing payment', { userId: 123, amount: 50.25 });
logger.error('Payment failed', { error: err.message, transactionId: 'tx_123' });
```

In development, logs are output to the console. In production, logs are sent to our centralized logging system.

## Deployment Process

### Environments

We maintain several environments:

1. **Development**: For active development work
2. **Testing**: For automated testing and QA
3. **Staging**: Mirror of production for final verification
4. **Production**: Live system serving real users

### Continuous Integration / Continuous Deployment

Our CI/CD pipeline is built with GitHub Actions:

1. Code is committed to a feature branch
2. Pull request is opened
3. Automated tests run (lint, unit, integration)
4. Manual code review is performed
5. PR is merged to develop
6. Build is created and deployed to development environment
7. When ready for release:
   - Release branch is created
   - Final testing is conducted
   - Deployed to staging environment
   - After verification, deployed to production

### Deployment Commands

**Manual Deployment (Not Recommended)**
```bash
npm run build
npm run deploy:staging  # or deploy:production
```

**Infrastructure Updates**
```bash
cd infrastructure
terraform apply -var-file=environments/production.tfvars
```

### Release Process

1. Update version in `package.json`
2. Generate release notes
3. Create release branch
4. Deploy to staging
5. Perform release testing
6. Deploy to production
7. Tag the release
8. Merge back to develop

## Key Technologies

### Frontend

- **React**: UI library
- **TypeScript**: Type-safe JavaScript
- **React Query**: Data fetching and state management
- **React Router**: Routing
- **Tailwind CSS**: Styling
- **Shadcn/UI**: Component library
- **Vite**: Build tool

### Backend

- **Node.js**: Runtime environment
- **Express**: Web framework
- **TypeScript**: Type-safe JavaScript
- **Drizzle ORM**: Database ORM
- **PostgreSQL**: Primary database
- **Redis**: Caching and session storage
- **Jest**: Testing framework

### Infrastructure

- **Docker**: Containerization
- **Kubernetes**: Container orchestration
- **Terraform**: Infrastructure as Code
- **AWS**: Cloud infrastructure
- **GitHub Actions**: CI/CD

### Monitoring and Observability

- **Datadog**: Monitoring and observability
- **Sentry**: Error tracking
- **ELK Stack**: Logging
- **Prometheus**: Metrics collection
- **Grafana**: Metrics visualization

## Communication Channels

Effective communication is essential for successful collaboration.

### Team Channels

- **Daily Standup**: 10:00 AM Eastern Time, Monday-Friday via Zoom
- **Sprint Planning**: Biweekly on Monday, 1:00 PM Eastern Time
- **Retrospective**: Biweekly on Friday, 3:00 PM Eastern Time
- **Tech Sync**: Weekly on Wednesday, 11:00 AM Eastern Time

### Communication Tools

- **Slack**: Primary communication tool
  - `#tm-development`: General development discussion
  - `#tm-deployments`: Deployment notifications
  - `#tm-production-alerts`: Production alerts
  - `#tm-help`: Help and troubleshooting

- **Jira**: Task and issue tracking
- **Confluence**: Documentation and knowledge base
- **GitHub**: Code review and collaboration
- **Google Meet/Zoom**: Video conferencing

### Asking for Help

When you need assistance:

1. Check existing documentation
2. Search Slack history
3. Ask in the appropriate Slack channel
4. Tag specific team members if needed
5. Be specific about the problem and what you've already tried

## Helpful Resources

### Internal Resources

- [TuneMantra Architecture Documentation](../technical/comprehensive-system-architecture.md)
- [API Reference](./api-reference.md)
- [Database Schema Documentation](../technical/database-schema.md)
- [Coding Standards Guide](./coding-standards.md)
- [Security Guidelines](../technical/security-model.md)

### External Learning Resources

- [React Documentation](https://reactjs.org/docs/getting-started.html)
- [TypeScript Handbook](https://www.typescriptlang.org/docs/handbook/intro.html)
- [Express.js Guide](https://expressjs.com/en/guide/routing.html)
- [PostgreSQL Documentation](https://www.postgresql.org/docs/)
- [Drizzle ORM Documentation](https://orm.drizzle.team/docs/overview)

### Recommended Reading

- "Clean Code" by Robert C. Martin
- "Refactoring" by Martin Fowler
- "Patterns of Enterprise Application Architecture" by Martin Fowler
- "Domain-Driven Design" by Eric Evans
- "Building Microservices" by Sam Newman

## FAQs

### Development Environment

**Q: How do I reset my development database?**

A: Run the following commands:
```bash
npm run db:drop
npm run db:setup
```

**Q: How do I update my local dependencies?**

A: Run:
```bash
npm update
```

**Q: How do I access the staging environment?**

A: Staging is available at https://staging.tunemantra.com. Contact your team lead for access credentials.

### Common Procedures

**Q: How do I create a new API endpoint?**

A: 
1. Define the route in the appropriate route file under `server/api/routes`
2. Implement the controller function
3. Add validation using Zod schemas
4. Add tests for the new endpoint
5. Document the endpoint in the API reference

**Q: How do I add a new database table?**

A:
1. Add the table definition to `shared/schema.ts`
2. Create a migration using `npm run db:generate my_migration_name`
3. Run the migration using `npm run db:migrate`
4. Add any necessary seed data
5. Update the data access layer to use the new table

**Q: How do I manage feature flags?**

A:
1. Add the feature flag to the `FeatureFlag` enum in `shared/types/features.ts`
2. Add the default value to the feature flags configuration
3. Use the `useFeatureFlag` hook in the frontend or the `isFeatureEnabled` function in the backend

### Getting Help

**Q: Who should I contact for specific issues?**

A:
- **Backend issues**: Contact the backend team lead
- **Frontend issues**: Contact the frontend team lead
- **DevOps issues**: Contact the DevOps team lead
- **Security concerns**: Contact the security team

**Q: How do I report a bug?**

A: Create a ticket in Jira with the following information:
- Clear description of the issue
- Steps to reproduce
- Expected vs. actual behavior
- Screenshots or videos if applicable
- Any relevant logs or error messages

---

© 2023-2025 TuneMantra. All rights reserved.

---

## documentation/developer/repository-documentation.md

# TuneMantra Repository Documentation

*Version: 1.0.0 (March 27, 2025)*

## Table of Contents

- [Introduction](#introduction)
- [Repository Structure](#repository-structure)
- [Branch Strategy](#branch-strategy)
- [Commit Guidelines](#commit-guidelines)
- [Development Workflow](#development-workflow)
- [Release Management](#release-management)
- [Tagging Strategy](#tagging-strategy)
- [Deployment Pipeline](#deployment-pipeline)
- [Repository History](#repository-history)
- [Code Review Process](#code-review-process)
- [Configuration Management](#configuration-management)
- [Appendix](#appendix)

## Introduction

This document provides comprehensive documentation of the TuneMantra repository, including its structure, branching strategy, development workflow, and historical evolution. It serves as a reference for developers working with the codebase and is especially valuable for onboarding new team members.

### Purpose

The purpose of this document is to:

1. Detail the organization and structure of the codebase
2. Explain the branching strategy and development workflow
3. Document the repository's history and evolution
4. Provide guidance on code contribution and review process
5. Describe the deployment pipeline and release management
6. Serve as a reference for configuration management

### Repository Overview

- **Repository URL**: `git@github.com:tunemantra/tunemantra-platform.git`
- **Repository Type**: Git
- **Hosting Platform**: GitHub Enterprise
- **Access Control**: Role-based access through GitHub Teams
- **Created**: June 15, 2023
- **Total Commits**: 7,823 (as of March 27, 2025)
- **Active Branches**: 23
- **Contributors**: 42
- **Lines of Code**: ~483,000
- **Repository Size**: 1.7 GB

## Repository Structure

The TuneMantra platform repository follows a monorepo approach, containing all platform components in a single repository to facilitate coordinated development and deployment.

### Root Structure

```
tunemantra-platform/
├── client/                    # Frontend application code
├── server/                    # Backend application code
├── shared/                    # Code shared between client and server
├── documentation/             # Project documentation
├── scripts/                   # Build, deployment, and utility scripts
├── config/                    # Configuration files
├── infrastructure/            # Infrastructure as Code (IaC)
├── migrations/                # Database migration scripts
├── tests/                     # Test suites
│   ├── unit/                  # Unit tests
│   ├── integration/           # Integration tests
│   ├── e2e/                   # End-to-end tests
│   └── performance/           # Performance tests
├── tools/                     # Development tools
├── .github/                   # GitHub workflow configurations
├── .vscode/                   # VS Code configuration
└── examples/                  # Example implementations
```

### Client Structure

The `client` directory contains the frontend application, built with React.

```
client/
├── public/                    # Static assets
├── src/                       # Source code
│   ├── api/                   # API client code
│   ├── assets/                # Images, fonts, etc.
│   ├── components/            # Reusable React components
│   │   ├── common/            # Common components
│   │   ├── analytics/         # Analytics components
│   │   ├── catalog/           # Catalog components
│   │   ├── distribution/      # Distribution components
│   │   ├── rights/            # Rights management components
│   │   ├── royalties/         # Royalty components
│   │   └── user/              # User management components
│   ├── contexts/              # React contexts
│   ├── hooks/                 # Custom React hooks
│   ├── pages/                 # Page components
│   ├── routes/                # Routing configuration
│   ├── services/              # Service layer
│   ├── store/                 # State management
│   ├── styles/                # Global styles
│   ├── types/                 # TypeScript type definitions
│   └── utils/                 # Utility functions
├── tests/                     # Frontend-specific tests
└── config/                    # Frontend configuration
```

### Server Structure

The `server` directory contains the backend application, built with Node.js and Express.

```
server/
├── src/                       # Source code
│   ├── api/                   # API routes and controllers
│   │   ├── analytics/         # Analytics API
│   │   ├── catalog/           # Catalog API
│   │   ├── distribution/      # Distribution API
│   │   ├── rights/            # Rights management API
│   │   ├── royalties/         # Royalty API
│   │   └── users/             # User management API
│   ├── config/                # Server configuration
│   ├── db/                    # Database connection and models
│   ├── middleware/            # Express middleware
│   ├── services/              # Business logic
│   │   ├── analytics/         # Analytics service
│   │   ├── catalog/           # Catalog service
│   │   ├── distribution/      # Distribution service
│   │   ├── rights/            # Rights management service
│   │   ├── royalties/         # Royalty service
│   │   └── users/             # User management service
│   ├── utils/                 # Utility functions
│   └── types/                 # TypeScript type definitions
├── tests/                     # Backend-specific tests
└── scripts/                   # Backend-specific scripts
```

### Shared Structure

The `shared` directory contains code shared between the client and server.

```
shared/
├── constants/                 # Shared constants
├── types/                     # Shared TypeScript types
├── utils/                     # Shared utility functions
└── validation/                # Shared validation schemas
```

### Infrastructure Structure

The `infrastructure` directory contains Infrastructure as Code (IaC) definitions.

```
infrastructure/
├── terraform/                 # Terraform configurations
│   ├── environments/          # Environment-specific configurations
│   │   ├── development/       # Development environment
│   │   ├── staging/           # Staging environment
│   │   └── production/        # Production environment
│   └── modules/               # Reusable Terraform modules
├── kubernetes/                # Kubernetes manifests
│   ├── base/                  # Base configurations
│   └── overlays/              # Environment-specific overlays
└── scripts/                   # Infrastructure scripts
```

## Branch Strategy

TuneMantra follows a modified GitFlow branching strategy, designed to support our continuous delivery pipeline while maintaining stability in production environments.

### Main Branches

| Branch Name | Purpose | Lifecycle |
|-------------|---------|-----------|
| `main` | The production branch that contains the code currently running in production. | Permanent |
| `develop` | The main development branch where feature branches are merged. | Permanent |
| `release` | Branched from `develop` for release preparation. | Temporary |

### Feature Branches

Feature branches are created from `develop` and follow the naming convention:

```
feature/<issue-id>-<short-description>
```

For example:
- `feature/TM-1234-add-analytics-dashboard`
- `feature/TM-2345-implement-batch-payment-processing`

### Bugfix Branches

Bugfix branches are created from `develop` for non-critical bugs and follow the naming convention:

```
bugfix/<issue-id>-<short-description>
```

For example:
- `bugfix/TM-3456-fix-chart-rendering-issue`
- `bugfix/TM-4567-correct-validation-error-message`

### Hotfix Branches

Hotfix branches are created from `main` for critical production issues and follow the naming convention:

```
hotfix/<issue-id>-<short-description>
```

For example:
- `hotfix/TM-5678-fix-critical-security-vulnerability`
- `hotfix/TM-6789-resolve-api-timeout-issue`

### Release Branches

Release branches are created from `develop` when preparing for a release and follow the naming convention:

```
release/v<major>.<minor>.<patch>
```

For example:
- `release/v2.3.0`
- `release/v2.4.0`

### Branch Protections

The following branch protections are enabled:

- **`main` branch**:
  - Requires pull request before merging
  - Requires code owner review
  - Requires passing CI checks
  - Prevents force pushing
  - Restricts who can push to the branch

- **`develop` branch**:
  - Requires pull request before merging
  - Requires at least one reviewer approval
  - Requires passing CI checks
  - Prevents force pushing

- **`release/*` branches**:
  - Requires pull request before merging
  - Requires at least one reviewer approval
  - Requires passing CI checks
  - Prevents force pushing

## Commit Guidelines

TuneMantra follows the Conventional Commits specification for commit messages to ensure a standardized and readable commit history.

### Commit Message Format

```
<type>(<scope>): <subject>

<body>

<footer>
```

### Types

| Type | Description |
|------|-------------|
| `feat` | A new feature |
| `fix` | A bug fix |
| `docs` | Documentation changes |
| `style` | Code style changes (formatting, missing semicolons, etc.) |
| `refactor` | Code refactoring |
| `perf` | Performance improvements |
| `test` | Adding or updating tests |
| `build` | Changes to the build system or dependencies |
| `ci` | Changes to CI configuration files and scripts |
| `chore` | Other changes that don't modify src or test files |
| `revert` | Reverts a previous commit |

### Scopes

Common scopes include:

- `client`: Changes to the frontend application
- `server`: Changes to the backend application
- `api`: Changes to the API layer
- `db`: Changes to the database models or migrations
- `auth`: Changes to the authentication system
- `analytics`: Changes to the analytics system
- `royalties`: Changes to the royalty management system
- `distribution`: Changes to the distribution system
- `catalog`: Changes to the catalog management system
- `rights`: Changes to the rights management system

### Examples

```
feat(catalog): add support for multiple artists per track

This change allows adding multiple artists to a track, with specific roles
such as primary artist, featured artist, producer, etc.

Closes #1234
```

```
fix(api): resolve timeout issue in distribution endpoints

Increased request timeout and implemented pagination to handle large
distribution requests more efficiently.

Fixes #2345
```

### Commit Verification

All commits must be signed with a GPG key to verify commit authenticity.

## Development Workflow

The TuneMantra development workflow is designed to facilitate collaborative development while ensuring code quality and stability.

### Standard Development Flow

1. **Issue Creation**:
   - All development work is tied to an issue in the issue tracker
   - Issues are assigned to developers and prioritized by product management

2. **Branch Creation**:
   - Developer creates a feature or bugfix branch from `develop`
   - Branch is named according to the branching conventions

3. **Development**:
   - Developer works on the assigned task
   - Commits follow the commit guidelines
   - Code is written following the project's coding standards

4. **Testing**:
   - Developer writes unit and integration tests for new code
   - Developer runs existing tests to ensure no regressions

5. **Pull Request Creation**:
   - Developer creates a pull request to merge into `develop`
   - PR description includes:
     - Summary of changes
     - Link to related issue
     - Testing information
     - Any deployment considerations

6. **Code Review**:
   - At least one other developer reviews the code
   - Code owners for affected areas are automatically requested for review
   - CI/CD pipeline runs tests and quality checks
   - Any issues are addressed by the developer

7. **Merge**:
   - Once approved and all checks pass, the PR is merged to `develop`
   - The branch is deleted after merging

8. **Continuous Integration**:
   - Changes in `develop` are automatically deployed to the development environment
   - Additional testing may be performed in the development environment

### Release Flow

1. **Release Branch Creation**:
   - Release manager creates a `release/v*.*.*` branch from `develop`
   - Version number is incremented according to semver principles

2. **Release Preparation**:
   - Final testing and QA is performed on the release branch
   - Only bugfixes are allowed on the release branch
   - Bugfixes are made directly on the release branch or via PRs

3. **Release Finalization**:
   - When the release is stable, a PR is created to merge to `main`
   - Release notes are compiled
   - The release is tagged with the version number

4. **Production Deployment**:
   - The release is deployed to production
   - The release branch is merged back to `develop`
   - The release branch is deleted

### Hotfix Flow

1. **Hotfix Branch Creation**:
   - Developer creates a `hotfix/*` branch from `main`

2. **Fix Implementation**:
   - Developer implements the fix
   - Tests are written or updated
   - The fix is reviewed by at least one other developer

3. **Deployment**:
   - A PR is created to merge to `main`
   - After approval, the fix is merged to `main` and deployed to production
   - Another PR is created to merge the fix to `develop`

## Release Management

TuneMantra follows semantic versioning (SemVer) for versioning the platform, with a structured release schedule and process.

### Versioning Scheme

Versions follow the format: `MAJOR.MINOR.PATCH`

- **MAJOR**: Incremented for incompatible API changes
- **MINOR**: Incremented for backwards-compatible functionality additions
- **PATCH**: Incremented for backwards-compatible bug fixes

### Release Schedule

- **Major Releases**: Scheduled 2-3 times per year
- **Minor Releases**: Scheduled monthly
- **Patch Releases**: Released as needed for bug fixes
- **Hotfixes**: Released immediately for critical issues

### Release Process

1. **Release Planning**:
   - Product management defines the scope of the release
   - Development team estimates effort and schedules work
   - QA team prepares test plans

2. **Development Phase**:
   - Features and bugfixes are developed on feature branches
   - Work is merged into `develop` as it's completed

3. **Release Preparation**:
   - Release branch is created from `develop`
   - Version numbers are updated
   - Final testing and QA is performed
   - Documentation is updated

4. **Release Approval**:
   - Release candidate is reviewed by release manager
   - QA certifies the release
   - Product management approves the release

5. **Release Execution**:
   - Release branch is merged to `main`
   - Code is tagged with the version number
   - Release is deployed to production
   - Release notes are published

6. **Post-Release Activities**:
   - Release is monitored for issues
   - Feedback is collected
   - Lessons learned are documented

### Release Artifacts

Each release includes the following artifacts:

- **Tagged Code**: The code in the repository is tagged with the version number
- **Release Notes**: Detailed description of changes, improvements, and bug fixes
- **Deployment Artifacts**: Docker images, compiled code, etc.
- **Documentation Updates**: Updated documentation reflecting the changes

## Tagging Strategy

TuneMantra uses Git tags to mark specific points in the repository's history, primarily for releases and significant milestones.

### Tag Format

- **Release Tags**: `v<major>.<minor>.<patch>`
  - Example: `v2.3.0`, `v2.3.1`

- **Pre-release Tags**: `v<major>.<minor>.<patch>-<pre-release>`
  - Example: `v2.4.0-beta.1`, `v2.4.0-rc.2`

- **Milestone Tags**: `milestone-<name>`
  - Example: `milestone-international-expansion`

### Tagging Process

1. Tags are created using annotated tags to include additional metadata:
   ```
   git tag -a v2.3.0 -m "Version 2.3.0 - March 2025 Release"
   ```

2. Tags are pushed to the remote repository:
   ```
   git push origin v2.3.0
   ```

3. GitHub releases are created from tags with detailed release notes.

### Significant Tags

| Tag | Date | Description |
|-----|------|-------------|
| `v1.0.0` | 2023-11-15 | Initial production release |
| `v1.1.0` | 2023-12-20 | Added analytics dashboard |
| `v1.2.0` | 2024-01-25 | Added batch payment processing |
| `v1.3.0` | 2024-02-28 | Added multi-language support |
| `v2.0.0` | 2024-04-15 | Major architecture overhaul |
| `v2.1.0` | 2024-05-20 | Added AI-powered recommendations |
| `v2.2.0` | 2024-06-25 | Added blockchain integration |
| `v2.3.0` | 2024-08-10 | Added territory-specific distribution controls |
| `v2.4.0` | 2024-10-05 | Added advanced reporting features |
| `v2.5.0` | 2024-12-15 | Added multi-organization support |
| `v3.0.0` | 2025-02-20 | Complete API restructuring with GraphQL |

## Deployment Pipeline

TuneMantra uses a robust CI/CD pipeline for automated testing, building, and deployment.

### CI/CD Tools

- **CI/CD Platform**: GitHub Actions
- **Container Registry**: Amazon ECR
- **Infrastructure Management**: Terraform
- **Orchestration**: Kubernetes
- **Monitoring**: Datadog, Prometheus

### Pipeline Stages

1. **Lint & Style Check**:
   - Analyzes code for potential errors and style guide compliance
   - Runs on all branches for every push and PR

2. **Build**:
   - Compiles the application code
   - Builds Docker images
   - Runs on all branches for every push and PR

3. **Unit Tests**:
   - Runs unit tests with code coverage reporting
   - Runs on all branches for every push and PR

4. **Integration Tests**:
   - Runs integration tests against a test database
   - Runs on all branches for every push and PR

5. **Security Scan**:
   - Scans code and dependencies for vulnerabilities
   - Runs on all branches for every push and PR

6. **Deploy to Development**:
   - Deploys to the development environment
   - Runs automatically when changes are merged to `develop`

7. **Deploy to Staging**:
   - Deploys to the staging environment
   - Runs automatically when a release branch is created

8. **E2E Tests**:
   - Runs end-to-end tests against the staging environment
   - Runs after deployment to staging

9. **Deploy to Production**:
   - Deploys to the production environment
   - Requires manual approval
   - Runs after merging to `main`

10. **Post-Deployment Tests**:
    - Runs smoke tests against the production environment
    - Verifies the deployment was successful

### Environment Configuration

| Environment | Branch | Auto-Deploy | URL | Purpose |
|-------------|--------|-------------|-----|---------|
| Development | `develop` | Yes | https://dev.tunemantra.com | Feature development and testing |
| Staging | `release/*` | Yes | https://staging.tunemantra.com | Pre-release testing and QA |
| Production | `main` | Manual approval | https://tunemantra.com | Production environment |

### Deployment Artifacts

Each deployment produces the following artifacts:

- **Docker Images**: Tagged with the commit SHA and version
- **Deployment Logs**: Stored in the CI/CD platform
- **Test Reports**: Generated for unit, integration, and E2E tests
- **Code Coverage Reports**: Generated for unit tests

## Repository History

The TuneMantra repository has evolved significantly since its inception. This section documents major milestones and significant changes in the repository's history.

### Repository Timeline

| Date | Event | Description |
|------|-------|-------------|
| 2023-06-15 | Repository Creation | Initial repository setup with basic structure |
| 2023-07-10 | MVP Implementation | Implementation of core features for MVP |
| 2023-08-20 | CI/CD Setup | Implementation of GitHub Actions for CI/CD |
| 2023-09-30 | First Beta Release | Release of beta version to select users |
| 2023-11-15 | v1.0.0 Release | First production release |
| 2024-01-05 | Database Migration | Migrated from MongoDB to PostgreSQL |
| 2024-02-15 | Frontend Framework Update | Migrated from Redux to React Query |
| 2024-04-15 | v2.0.0 Release | Major architecture overhaul |
| 2024-06-25 | Blockchain Integration | Added blockchain integration for rights management |
| 2024-08-10 | Multi-region Support | Added support for multi-region deployment |
| 2024-11-20 | API Restructuring | Redesigned API architecture |
| 2025-01-15 | GraphQL Implementation | Added GraphQL support |
| 2025-02-20 | v3.0.0 Release | Complete API restructuring with GraphQL |

### Major Architecture Changes

#### v1.0.0 to v2.0.0:

1. **Microservices Architecture**:
   - Transitioned from monolithic to modular architecture
   - Implemented service boundaries with clear interfaces
   - Improved scalability and deployment flexibility

2. **State Management Overhaul**:
   - Moved from central Redux store to React Query
   - Implemented context-based state for global state
   - Improved data fetching and caching strategy

3. **Database Restructuring**:
   - Migrated from MongoDB to PostgreSQL
   - Implemented proper relational data modeling
   - Added data versioning and history tracking

#### v2.0.0 to v3.0.0:

1. **API Modernization**:
   - Implemented GraphQL alongside REST API
   - Redesigned API gateway with improved rate limiting
   - Added comprehensive API documentation

2. **Security Enhancements**:
   - Implemented RBAC (Role-Based Access Control)
   - Added multi-factor authentication
   - Improved audit logging and traceability

3. **Performance Optimizations**:
   - Implemented data caching strategy
   - Optimized database queries and indexes
   - Added lazy loading and code splitting in frontend

### Significant Branches

| Branch Name | Created | Merged | Purpose |
|-------------|---------|--------|---------|
| `feature/core-platform` | 2023-06-20 | 2023-07-15 | Initial platform implementation |
| `feature/royalty-calculations` | 2023-07-25 | 2023-08-30 | Implementation of royalty calculation engine |
| `feature/distribution-system` | 2023-09-05 | 2023-10-10 | Implementation of content distribution system |
| `feature/analytics-dashboard` | 2023-10-20 | 2023-11-25 | Implementation of analytics dashboard |
| `feature/api-v2` | 2024-01-10 | 2024-03-15 | Implementation of API v2 |
| `feature/blockchain-integration` | 2024-04-05 | 2024-06-20 | Implementation of blockchain integration |
| `feature/multi-organization` | 2024-07-15 | 2024-09-20 | Implementation of multi-organization support |
| `feature/graphql-api` | 2024-10-05 | 2025-01-10 | Implementation of GraphQL API |

## Code Review Process

Code reviews are a critical part of TuneMantra's development process, ensuring code quality, knowledge sharing, and collaboration.

### Code Review Guidelines

1. **When to Request a Review**:
   - All code changes must be reviewed before merging
   - PRs should be kept small and focused
   - PRs should address a single concern

2. **Who Should Review**:
   - At least one review from a team member is required
   - Code owners are automatically requested for review
   - Senior engineers review architectural changes

3. **What to Review**:
   - Code correctness and logic
   - Test coverage and quality
   - Performance considerations
   - Security implications
   - Adherence to coding standards
   - Documentation

4. **How to Review**:
   - Be respectful and constructive
   - Focus on the code, not the person
   - Explain reasoning behind suggestions
   - Separate "must fix" from "nice to have"

### Code Review Process

1. **PR Preparation**:
   - Developer ensures all tests pass locally
   - Developer adds meaningful PR description
   - Developer completes the PR checklist

2. **Initial Checks**:
   - CI/CD pipeline runs automated checks
   - Code coverage is verified
   - Linting and style are checked

3. **Review Request**:
   - Developer requests reviews from appropriate reviewers
   - Code owners are automatically notified

4. **Review and Feedback**:
   - Reviewers examine the code and provide feedback
   - Developer addresses feedback with code changes or explanations

5. **Approval and Merge**:
   - Once approved by required reviewers, the PR can be merged
   - The developer or release manager merges the PR
   - The branch is deleted after merging

### Code Review Metrics

The following metrics are tracked to ensure a healthy code review process:

- **Time to First Review**: Average time from PR creation to first review
- **Time to Merge**: Average time from PR creation to merge
- **Comments per PR**: Average number of comments per PR
- **Approval Rate**: Percentage of PRs approved on first review
- **Revision Rate**: Average number of revisions per PR

## Configuration Management

TuneMantra's configuration management strategy ensures secure, environment-specific configuration with appropriate access controls.

### Configuration Types

1. **Application Configuration**:
   - Environment-specific settings
   - Feature flags
   - Service endpoints
   - Logging levels

2. **Infrastructure Configuration**:
   - Terraform configurations
   - Kubernetes manifests
   - CI/CD pipeline configurations

3. **Security Configuration**:
   - Authentication settings
   - Authorization rules
   - API keys and secrets

### Configuration Storage

1. **Environment Variables**:
   - Used for environment-specific configuration
   - Injected at runtime
   - Managed through environment-specific `.env` files

2. **Configuration Files**:
   - Used for static configuration
   - Version-controlled in the repository
   - Environment-specific files for different environments

3. **Secret Management**:
   - Sensitive information stored in AWS Secrets Manager
   - Accessed at runtime with appropriate permissions
   - Never stored in version control

### Configuration Hierarchy

Configuration is loaded in the following order, with later sources overriding earlier ones:

1. Default configurations from code
2. Configuration files from the repository
3. Environment variables
4. Secrets from the secret management system

### Environment Configuration

| Environment | Configuration Source | Access Control |
|-------------|----------------------|----------------|
| Local Development | `.env.local` (gitignored) | Developer-managed |
| Development | `.env.development` + AWS Secrets | Accessible to all developers |
| Staging | `.env.staging` + AWS Secrets | Accessible to developers and DevOps |
| Production | `.env.production` + AWS Secrets | Restricted to DevOps and release managers |

## Appendix

### Repository Governance

The TuneMantra repository is governed by the following roles and responsibilities:

- **Repository Administrators**:
  - Chief Technology Officer
  - VP of Engineering
  - Lead DevOps Engineer

- **Code Owners**:
  - Frontend Lead: `client/`
  - Backend Lead: `server/`
  - DevOps Lead: `infrastructure/`, `.github/`
  - Data Lead: `migrations/`, `server/src/db/`

- **Release Managers**:
  - Engineering Manager
  - Product Manager
  - QA Manager

### Commit Access Control

| Role | Access Level | Description |
|------|-------------|-------------|
| Administrator | Full access | Can push to all branches, merge to protected branches |
| Maintainer | Write access | Can push to unprotected branches, merge PRs to protected branches after approval |
| Developer | Write access (limited) | Can push to feature branches, create PRs |
| External Contributor | Fork + PR | Can fork the repository and create PRs |

### Branch Protection Rules

| Branch Pattern | Rules |
|----------------|-------|
| `main` | - Require pull request<br>- Require 2 approvals<br>- Require code owner review<br>- Require CI checks<br>- No force push<br>- Restricted push access |
| `develop` | - Require pull request<br>- Require 1 approval<br>- Require CI checks<br>- No force push |
| `release/*` | - Require pull request<br>- Require 1 approval<br>- Require CI checks<br>- No force push |

### Merge Commit Policy

TuneMantra uses a "rebase and merge" strategy for feature branches to maintain a clean, linear history. This means:

1. Feature branches are rebased on the latest `develop` before merging
2. Merge commits are avoided when possible
3. Squash merging is used for small PRs with multiple small commits

### Repository Backup Strategy

The repository is backed up using the following strategy:

1. **GitHub Enterprise Backup**:
   - Automatic daily backups
   - Retention policy: 30 days

2. **External Backup**:
   - Weekly full repository clone to secure storage
   - Retention policy: 1 year

3. **Disaster Recovery**:
   - Repository can be restored from GitHub Enterprise backup
   - Critical configurations are stored in multiple locations

---

© 2023-2025 TuneMantra. All rights reserved.

---

## documentation/developer/testing-strategy.md

# TuneMantra Testing Strategy

*Version: 1.0.0 (March 27, 2025)*

## Table of Contents

- [Introduction](#introduction)
- [Testing Principles](#testing-principles)
- [Test Types](#test-types)
- [Testing Tools](#testing-tools)
- [Test Coverage](#test-coverage)
- [Testing Process](#testing-process)
- [Test Environments](#test-environments)
- [Test Data Management](#test-data-management)
- [Test Automation](#test-automation)
- [Performance Testing](#performance-testing)
- [Security Testing](#security-testing)
- [Accessibility Testing](#accessibility-testing)
- [Reporting and Metrics](#reporting-and-metrics)
- [Roles and Responsibilities](#roles-and-responsibilities)
- [Continuous Improvement](#continuous-improvement)

## Introduction

This document outlines the comprehensive testing strategy for the TuneMantra platform. It provides guidelines for ensuring software quality through various testing methods and approaches.

### Purpose

The purpose of this testing strategy is to:

1. Define a consistent approach to testing across the platform
2. Establish quality standards for all components
3. Document testing practices and responsibilities
4. Provide a framework for test automation
5. Ensure comprehensive test coverage

### Scope

This strategy applies to all aspects of the TuneMantra platform:

- Frontend web application
- Backend API services
- Database operations
- Integration with external services
- DevOps processes
- Security mechanisms

## Testing Principles

TuneMantra's testing approach is guided by these core principles:

1. **Shift Left**: Testing begins early in the development cycle
2. **Test Pyramid**: Higher volume of unit tests, fewer integration tests, fewer UI tests
3. **Automation First**: Automated testing prioritized over manual testing
4. **Risk-Based**: More thorough testing for high-risk areas
5. **Continuous Testing**: Tests integrated into CI/CD pipeline
6. **Quality Ownership**: Developers responsible for code quality and tests
7. **Maintainability**: Tests treated as production code with same quality standards
8. **Traceability**: Tests linked to requirements and user stories

## Test Types

### Unit Testing

**Purpose**: Verify individual functions and components work as expected in isolation.

**Approach**:
- Test each function, method, or component independently
- Mock external dependencies
- Focus on edge cases and error conditions
- Aim for high code coverage

**Examples**:
- Testing a utility function that calculates royalty splits
- Testing a React component renders correctly with different props
- Testing a validation function handles various input scenarios

### Integration Testing

**Purpose**: Verify that components work together correctly.

**Approach**:
- Test interactions between components
- Verify API contracts between services
- Test database operations
- Minimal mocking, more real dependencies

**Examples**:
- Testing API endpoints with database interaction
- Testing component interactions in the frontend
- Testing service-to-service communication

### End-to-End Testing

**Purpose**: Verify complete user workflows function correctly.

**Approach**:
- Test full user journeys
- Use a browser automation tool
- Test across different browsers and devices
- Focus on critical user paths

**Examples**:
- Testing the user registration and login flow
- Testing the content upload and distribution process
- Testing the royalty calculation and statement generation

### API Testing

**Purpose**: Verify API endpoints function correctly.

**Approach**:
- Test request/response formats
- Verify authentication and authorization
- Test error handling
- Performance testing for key endpoints

**Examples**:
- Testing REST API endpoints for correct responses
- Testing API error responses for invalid inputs
- Testing API rate limiting functionality

### UI Testing

**Purpose**: Verify user interface components render and function correctly.

**Approach**:
- Test component rendering
- Test user interactions
- Test responsive behaviors
- Visual regression testing

**Examples**:
- Testing form validation and submission
- Testing navigation components
- Testing modal dialogs and popovers
- Testing responsive layouts

### Acceptance Testing

**Purpose**: Verify the system meets business requirements.

**Approach**:
- Test based on acceptance criteria
- Focus on business value
- Involve product owners in verification
- Use Gherkin syntax for behavior-driven development

**Examples**:
- Testing that users can successfully distribute content to platforms
- Testing that royalty calculations match expected values
- Testing that analytics dashboards show correct data

## Testing Tools

### Frontend Testing

- **Unit and Component Testing**:
  - Jest: JavaScript testing framework
  - React Testing Library: Component testing
  - Storybook: Component documentation and visual testing

- **End-to-End Testing**:
  - Cypress: Browser-based end-to-end testing
  - Playwright: Cross-browser testing

- **Visual Testing**:
  - Percy: Visual regression testing
  - Chromatic: Storybook visual testing

### Backend Testing

- **Unit Testing**:
  - Jest: JavaScript testing framework
  - Mocha: Alternative testing framework
  - Chai: Assertion library

- **API Testing**:
  - Supertest: HTTP assertion library
  - Postman: API testing platform
  - Pactum: REST API testing tool

- **Load Testing**:
  - k6: Performance testing tool
  - Artillery: Load testing framework

### Database Testing

- **Schema Testing**:
  - Jest with database libraries
  - Drizzle testing utilities

- **Data Integrity Testing**:
  - Custom SQL-based tests
  - Data validation scripts

### DevOps Testing

- **Infrastructure Testing**:
  - Terratest: Infrastructure testing framework
  - ServerSpec: Infrastructure testing tool

- **Security Testing**:
  - OWASP ZAP: Security testing tool
  - SonarQube: Code quality and security analysis

## Test Coverage

### Coverage Requirements

TuneMantra maintains the following code coverage requirements:

| Component Type | Minimum Coverage |
|----------------|------------------|
| Utility Functions | 95% |
| Business Logic | 90% |
| API Controllers | 85% |
| UI Components | 80% |
| Integration Code | 75% |
| Overall | 80% |

### Coverage Measurement

- Unit test coverage measured with Jest coverage reporter
- Integration test coverage measured separately
- Coverage reports generated in CI pipeline
- Coverage trends tracked over time

### Critical Paths

The following areas require 100% test coverage:

1. Authentication and authorization
2. Financial calculations (royalties, payments)
3. Rights management logic
4. Data export functionality
5. User permission checks

## Testing Process

### Test-Driven Development (TDD)

For critical components, TDD approach is encouraged:

1. Write a failing test that defines expected behavior
2. Implement minimal code to make the test pass
3. Refactor code while maintaining passing tests
4. Repeat for additional functionality

### Testing During Development

1. **Planning Phase**:
   - Define acceptance criteria
   - Design test approach
   - Identify test cases

2. **Development Phase**:
   - Write unit tests concurrently with code
   - Run tests locally before committing
   - Fix failing tests immediately

3. **Code Review Phase**:
   - Review test coverage
   - Verify test quality
   - Ensure edge cases are tested

4. **Integration Phase**:
   - Run integration tests
   - Verify component interactions
   - Test with realistic data

### Regression Testing

- Automated regression test suite runs in CI/CD pipeline
- Full regression testing before each release
- Critical path regression tests run on every PR

### Bug Fix Testing

1. Create a failing test that reproduces the bug
2. Fix the code to make the test pass
3. Ensure the fix doesn't break other functionality
4. Add regression test to prevent recurrence

## Test Environments

### Local Development Environment

- Developers run tests locally before pushing code
- Unit tests and basic integration tests
- Mock external dependencies
- Local database instances

### Continuous Integration Environment

- Runs on every PR and branch push
- Complete test suite execution
- Ephemeral test databases
- Mocked external services
- Performance baselines checked

### Staging Environment

- Production-like environment
- Full integration testing
- Limited performance testing
- UAT (User Acceptance Testing)
- Realistic data volumes

### Production-like Environment

- Mirror of production configuration
- Load and performance testing
- Security testing
- Data migration testing
- Failover testing

## Test Data Management

### Test Data Types

1. **Static Test Data**:
   - Predefined data for unit tests
   - Fixtures and factories
   - Versioned with source code

2. **Generated Test Data**:
   - Dynamically generated using Faker.js
   - Seed values for reproducibility
   - Volume testing data

3. **Anonymized Production Data**:
   - Sanitized production data for realistic testing
   - PII (Personally Identifiable Information) removed
   - Used for integration and performance testing

### Test Data Principles

- Test data should be deterministic and reproducible
- Tests should clean up after themselves
- No test should depend on another test's data
- Sensitive data should never be used in tests
- Test databases should be regularly reset

### Test Data Creation

- Factories defined for all major entities
- Seeders available for populating test environments
- Data generation scripts for volume testing

## Test Automation

### Automation Framework

- Custom automation framework built around Jest and Cypress
- Page object model for UI automation
- Service objects for API automation
- Shared utilities and helpers

### Continuous Integration Integration

- All tests run in GitHub Actions
- Test results published to dashboard
- Test failures block PR merges
- Nightly full regression suite

### Automation Guidelines

- Tests should be independent and isolated
- No hard-coded waits or sleeps
- Appropriate assertions with clear error messages
- Tests should be stable and not flaky

## Performance Testing

### Performance Testing Approach

- Performance testing integrated into development process
- Baseline performance metrics defined for key operations
- Performance regression testing automated
- Regular load testing of critical paths

### Performance Test Types

1. **Load Testing**:
   - Test system behavior under expected load
   - Verify system scales as expected
   - Run regularly in performance environment

2. **Stress Testing**:
   - Test system behavior under extreme load
   - Identify breaking points
   - Verify graceful degradation

3. **Endurance Testing**:
   - Test system behavior over extended periods
   - Identify memory leaks or resource exhaustion
   - Run weekly in performance environment

4. **Spike Testing**:
   - Test system response to sudden traffic spikes
   - Verify autoscaling mechanisms work
   - Run monthly in performance environment

### Performance Metrics

- Response time (average, median, 95th percentile)
- Throughput (requests per second)
- Error rate
- CPU and memory utilization
- Database query execution time
- Page load time and frontend metrics

## Security Testing

### Security Testing Approach

- Security testing integrated into development process
- Automated vulnerability scanning
- Regular penetration testing
- Security code reviews for sensitive areas

### Security Test Types

1. **Static Application Security Testing (SAST)**:
   - Analyze code for security vulnerabilities
   - Run on every PR and nightly on main branch
   - Block merge on critical findings

2. **Dynamic Application Security Testing (DAST)**:
   - Test running application for vulnerabilities
   - Run weekly on staging environment
   - Report findings to security team

3. **Dependency Scanning**:
   - Check for vulnerabilities in dependencies
   - Run on every PR and daily on main branch
   - Block merge on critical findings

4. **Penetration Testing**:
   - Manual security testing by experts
   - Run quarterly or after major changes
   - Full report with remediation plan

### Security Testing Tools

- SonarQube for code quality and security analysis
- OWASP ZAP for dynamic security testing
- npm audit for dependency scanning
- Custom scripts for security verification

## Accessibility Testing

### Accessibility Testing Approach

- Accessibility considered from design phase
- Automated accessibility testing integrated into CI
- Manual accessibility testing for complex interactions
- Compliance with WCAG 2.1 AA standards

### Accessibility Test Types

1. **Automated Accessibility Testing**:
   - Static analysis of HTML/CSS
   - Run on every PR
   - Report accessibility violations

2. **Manual Accessibility Testing**:
   - Screen reader testing
   - Keyboard navigation testing
   - Color contrast verification
   - Run on major releases

### Accessibility Testing Tools

- axe-core for automated accessibility testing
- Lighthouse for accessibility audits
- WAVE browser extension for manual testing
- Screen readers (NVDA, VoiceOver) for manual verification

## Reporting and Metrics

### Test Reports

- Test results published to central dashboard
- Test coverage reports generated for each build
- Trend analysis for test metrics
- Detailed failure reports with contextual information

### Key Metrics

- Test coverage percentage
- Test execution time
- Number of tests by type
- Pass/fail rates
- Flaky test percentage
- Defect detection rate
- Mean time to detect issues

### Dashboards

- Team-level test dashboards
- Executive summary dashboard
- Trend analysis dashboard
- Test environment status dashboard

## Roles and Responsibilities

### Development Team

- Write and maintain unit and integration tests
- Fix failing tests in their areas
- Review test coverage in code reviews
- Participate in test planning

### QA Team

- Develop and maintain end-to-end tests
- Perform exploratory testing
- Design test scenarios and test data
- Verify bug fixes
- Conduct UAT with stakeholders

### DevOps Team

- Maintain test environments
- Ensure CI/CD pipeline runs tests efficiently
- Monitor and optimize test execution performance
- Provide infrastructure for performance testing

### Product Team

- Define acceptance criteria
- Participate in acceptance testing
- Prioritize bugs for fixing
- Sign off on releases

## Continuous Improvement

### Test Retrospectives

- Regular review of testing process
- Analysis of escaped defects
- Identification of test gaps
- Process improvement suggestions

### Test Maintenance

- Regular cleanup of flaky tests
- Updating tests for changing requirements
- Refactoring test code for maintainability
- Keeping test documentation current

### Training and Knowledge Sharing

- Regular training on testing tools and practices
- Pair testing sessions
- Knowledge sharing about effective testing techniques
- Documentation of testing patterns and best practices

---

© 2023-2025 TuneMantra. All rights reserved.

---

## documentation/developer/testing.md

# Testing Strategy

## Overview

This document outlines the testing strategy for the TuneMantra platform, covering different types of tests, tools, processes, and best practices. Comprehensive testing is critical to ensure the platform's reliability, security, and performance.

## Testing Types

### 1. Unit Testing

Unit tests verify that individual components work as expected in isolation.

**Focus Areas:**
- Service functions
- Utility functions
- Helper functions
- Data validation
- Business logic

**Tools:**
- Jest
- ts-jest for TypeScript testing

**Example:**

```typescript
// Example unit test for a utility function
describe('generateUPC function', () => {
  test('should generate a 12-13 digit UPC', () => {
    const upc = generateUPC();
    expect(upc).toMatch(/^\d{12,13}$/);
  });
  
  test('should generate unique UPCs for multiple calls', () => {
    const upc1 = generateUPC();
    const upc2 = generateUPC();
    const upc3 = generateUPC();
    
    expect(upc1).not.toEqual(upc2);
    expect(upc1).not.toEqual(upc3);
    expect(upc2).not.toEqual(upc3);
  });
});
```

### 2. Integration Testing

Integration tests verify that different parts of the application work together correctly.

**Focus Areas:**
- API endpoints
- Database interactions
- Authentication flows
- Service interactions

**Tools:**
- Supertest for API testing
- Test database environment

**Example:**

```typescript
// Example API integration test
describe('User API', () => {
  beforeAll(async () => {
    // Set up test database
    await setupTestDatabase();
  });
  
  afterAll(async () => {
    // Clean up test database
    await cleanupTestDatabase();
  });
  
  test('should create a new user', async () => {
    const response = await request(app)
      .post('/api/auth/register')
      .send({
        username: 'testuser',
        password: 'password123',
        email: 'test@example.com',
        fullName: 'Test User',
        role: 'artist'
      });
    
    expect(response.status).toBe(200);
    expect(response.body.data).toHaveProperty('id');
    expect(response.body.data.username).toBe('testuser');
  });
  
  test('should reject duplicate username', async () => {
    const response = await request(app)
      .post('/api/auth/register')
      .send({
        username: 'testuser', // Already exists
        password: 'password123',
        email: 'another@example.com',
        fullName: 'Another User',
        role: 'artist'
      });
    
    expect(response.status).toBe(400);
    expect(response.body.error).toHaveProperty('message');
  });
});
```

### 3. End-to-End (E2E) Testing

E2E tests verify that complete user flows work correctly from the frontend to the backend.

**Focus Areas:**
- User registration and authentication
- Music upload and distribution
- Analytics dashboard functionality
- Payment and royalty flows

**Tools:**
- Cypress
- Playwright

**Example:**

```typescript
// Example Cypress E2E test
describe('User Authentication', () => {
  beforeEach(() => {
    // Set up test state
    cy.task('db:seed');
  });
  
  it('should allow a user to log in', () => {
    cy.visit('/login');
    cy.get('input[name="username"]').type('testuser');
    cy.get('input[name="password"]').type('password123');
    cy.get('button[type="submit"]').click();
    
    // Verify successful login
    cy.url().should('include', '/dashboard');
    cy.get('[data-test-id="user-greeting"]').should('contain', 'Welcome, Test User');
  });
  
  it('should show error for invalid credentials', () => {
    cy.visit('/login');
    cy.get('input[name="username"]').type('testuser');
    cy.get('input[name="password"]').type('wrongpassword');
    cy.get('button[type="submit"]').click();
    
    // Verify error message
    cy.get('[data-test-id="login-error"]').should('be.visible');
    cy.get('[data-test-id="login-error"]').should('contain', 'Invalid username or password');
  });
});
```

### 4. API Testing

API tests focus on verifying the behavior of the API endpoints.

**Focus Areas:**
- Request/response formats
- Status codes
- Authentication and authorization
- Error handling
- Rate limiting

**Tools:**
- Postman
- Newman for automated API testing
- Supertest for API testing in code

**Example Postman Collection:**

```json
{
  "info": {
    "name": "TuneMantra API Tests",
    "schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
  },
  "item": [
    {
      "name": "Authentication",
      "item": [
        {
          "name": "Login",
          "request": {
            "method": "POST",
            "url": "{{baseUrl}}/api/auth/login",
            "body": {
              "mode": "raw",
              "raw": "{\n  \"username\": \"testuser\",\n  \"password\": \"password123\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            }
          },
          "test": [
            "pm.test('Status code is 200', function() {",
            "  pm.response.to.have.status(200);",
            "});",
            "pm.test('Response contains user data', function() {",
            "  var jsonData = pm.response.json();",
            "  pm.expect(jsonData.data).to.have.property('id');",
            "  pm.expect(jsonData.data).to.have.property('username');",
            "});"
          ]
        }
      ]
    }
  ]
}
```

### 5. Performance Testing

Performance tests evaluate the system's responsiveness, stability, and scalability under load.

**Focus Areas:**
- API response times
- Concurrent user handling
- Database query performance
- File upload/download performance

**Tools:**
- k6 for load testing
- Lighthouse for frontend performance

**Example k6 Script:**

```javascript
import http from 'k6/http';
import { sleep, check } from 'k6';

export const options = {
  vus: 50,        // 50 virtual users
  duration: '30s' // Test runs for 30 seconds
};

export default function() {
  // Login to get a session
  const loginRes = http.post('https://api.tunemantra.com/api/auth/login', JSON.stringify({
    username: 'testuser',
    password: 'password123'
  }), {
    headers: { 'Content-Type': 'application/json' }
  });
  
  check(loginRes, {
    'login successful': (r) => r.status === 200
  });
  
  // Use the session cookie for subsequent requests
  const cookies = loginRes.cookies;
  
  // Get user dashboard data
  const dashboardRes = http.get('https://api.tunemantra.com/api/analytics/dashboard', {
    cookies: cookies
  });
  
  check(dashboardRes, {
    'dashboard status is 200': (r) => r.status === 200,
    'dashboard response time < 500ms': (r) => r.timings.duration < 500
  });
  
  sleep(1);
}
```

### 6. Security Testing

Security tests identify vulnerabilities and ensure the system is protected against common threats.

**Focus Areas:**
- Authentication and authorization
- Input validation
- Data encryption
- API security
- OWASP Top 10 vulnerabilities

**Tools:**
- OWASP ZAP for vulnerability scanning
- SonarQube for code security analysis
- npm audit for dependency security

**Example Security Test:**

```typescript
// Example security test for password hashing
describe('Password Security', () => {
  test('should properly hash passwords', async () => {
    const password = 'SecureP@ssw0rd!';
    const hashedPassword = await hashPassword(password);
    
    // Ensure the hash is not the original password
    expect(hashedPassword).not.toEqual(password);
    
    // Ensure the hash includes salt (contains a separator)
    expect(hashedPassword.includes('.')).toBe(true);
    
    // Verify the hashed password can be validated
    const isValid = await comparePasswords(password, hashedPassword);
    expect(isValid).toBe(true);
    
    // Verify incorrect password fails validation
    const isInvalid = await comparePasswords('WrongPassword', hashedPassword);
    expect(isInvalid).toBe(false);
  });
});
```

### 7. Accessibility Testing

Accessibility tests ensure the application is usable by people with disabilities.

**Focus Areas:**
- Screen reader compatibility
- Keyboard navigation
- Color contrast
- ARIA attributes
- Focus management

**Tools:**
- Axe for automated accessibility testing
- Lighthouse for accessibility audits

**Example:**

```typescript
// Example Cypress accessibility test
describe('Dashboard Accessibility', () => {
  beforeEach(() => {
    cy.login('testuser', 'password123');
    cy.visit('/dashboard');
  });
  
  it('should have no accessibility violations', () => {
    cy.injectAxe();
    cy.checkA11y();
  });
  
  it('should be navigable by keyboard', () => {
    cy.get('body').tab().should('have.focus');
    
    // Test tab navigation through main elements
    for (let i = 0; i < 5; i++) {
      cy.focused().should('be.visible');
      cy.tab();
    }
    
    // Ensure menu items can be activated with keyboard
    cy.get('nav a').first().focus();
    cy.focused().type('{enter}');
    cy.url().should('not.include', '/dashboard');
  });
});
```

## Testing Environments

### 1. Local Development Environment

- Used by developers for initial testing
- Each developer has their own database instance
- Quick feedback loop for development

### 2. Test Environment

- Isolated environment for automated testing
- Automatically refreshed for each test run
- Uses test data that is reset between test suites

### 3. Staging Environment

- Mimics production environment
- Used for integration and performance testing
- Contains realistic, anonymized data

### 4. Production Environment

- Production monitoring rather than testing
- Performance metrics collection
- Error tracking and logging

## Testing Process

### 1. Test Planning

For each feature or change:

1. Identify test coverage requirements
2. Determine appropriate test types
3. Define acceptance criteria
4. Create test cases

### 2. Test Implementation

1. Write unit tests alongside code
2. Implement integration tests
3. Create end-to-end tests for critical flows
4. Set up automated test suites

### 3. Test Execution

1. Run unit and integration tests on every commit
2. Execute E2E tests on pull requests
3. Perform performance tests before major releases
4. Conduct security scans regularly

### 4. Test Reporting

1. Collect test results and coverage metrics
2. Generate test reports
3. Track test failures and issues
4. Document test scenarios and results

## Continuous Integration

### CI Pipeline Configuration

The testing process is integrated into my CI/CD pipeline:

1. **Commit Stage:**
   - Linting
   - Type checking
   - Unit tests
   - Code coverage

2. **Pull Request Stage:**
   - Integration tests
   - API tests
   - Security scans

3. **Pre-Deployment Stage:**
   - End-to-end tests
   - Performance tests
   - Accessibility tests

4. **Post-Deployment Stage:**
   - Smoke tests
   - Synthetic monitoring

### Example CI Configuration

```yaml
# Example GitHub Actions CI workflow
name: TuneMantra CI

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

jobs:
  test:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:13
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_USER: postgres
          POSTGRES_DB: tunemantra_test
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    
    steps:
    - uses: actions/checkout@v2
    
    - name: Use Node.js
      uses: actions/setup-node@v2
      with:
        node-version: '16'
        
    - name: Install dependencies
      run: npm ci
      
    - name: Lint
      run: npm run lint
      
    - name: Type check
      run: npm run check
      
    - name: Unit tests
      run: npm run test:unit
      
    - name: Integration tests
      run: npm run test:integration
      env:
        DATABASE_URL: postgresql://postgres:postgres@localhost:5432/tunemantra_test
        
    - name: E2E tests
      run: npm run test:e2e
      env:
        DATABASE_URL: postgresql://postgres:postgres@localhost:5432/tunemantra_test
        
    - name: Upload coverage
      uses: codecov/codecov-action@v2
```

## Test Coverage

I track test coverage to ensure critical parts of the application are tested properly.

### Coverage Targets

- **Unit Test Coverage:** 80% minimum
- **Integration Test Coverage:** 70% minimum
- **Critical Paths E2E Coverage:** 100%

### Coverage Measurement

1. Use Jest's coverage collection for unit and integration tests
2. Track E2E test coverage using custom tooling
3. Generate coverage reports in CI pipeline

## Test Data Management

### Test Data Strategy

1. **Unit Tests:**
   - Mostly in-memory mock data
   - Small, focused test fixtures

2. **Integration Tests:**
   - Seeded test database
   - Test-specific fixtures

3. **E2E Tests:**
   - Realistic data sets
   - Comprehensive data scenarios

### Test Database Setup

```typescript
// Example test setup utilities
export async function setupTestDatabase() {
  // Create tables
  await db.execute(fs.readFileSync('./scripts/schema.sql', 'utf8'));
  
  // Load seed data
  await db.execute(fs.readFileSync('./scripts/test-data.sql', 'utf8'));
}

export async function cleanupTestDatabase() {
  // Clean up all tables
  await db.execute(`
    DROP TABLE IF EXISTS royalty_calculations CASCADE;
    DROP TABLE IF EXISTS revenue_shares CASCADE;
    DROP TABLE IF EXISTS withdrawals CASCADE;
    DROP TABLE IF EXISTS payment_methods CASCADE;
    DROP TABLE IF EXISTS daily_stats CASCADE;
    DROP TABLE IF EXISTS analytics CASCADE;
    DROP TABLE IF EXISTS distribution_records CASCADE;
    DROP TABLE IF EXISTS tracks CASCADE;
    DROP TABLE IF EXISTS releases CASCADE;
    DROP TABLE IF EXISTS api_keys CASCADE;
    DROP TABLE IF EXISTS users CASCADE;
  `);
}
```

## Mocking Strategy

### External Dependency Mocking

1. **API Services:**
   - Mock external APIs for reliable testing
   - Simulate success and error scenarios

2. **File Storage:**
   - Mock file upload/download operations
   - Use in-memory storage for tests

3. **Payment Processing:**
   - Mock payment gateway interactions
   - Test various payment scenarios

### Example Mocks

```typescript
// Example mock for music distribution service
jest.mock('../../services/distribution-service', () => ({
  DistributionService: {
    distributeRelease: jest.fn().mockImplementation((releaseId, platformIds) => {
      return Promise.resolve(
        platformIds.map(platformId => ({
          id: Math.floor(Math.random() * 1000),
          releaseId,
          platformId,
          status: 'pending',
          createdAt: new Date(),
          updatedAt: new Date()
        }))
      );
    }),
    
    distributeToPlatform: jest.fn().mockImplementation((releaseId, platformId) => {
      return Promise.resolve({
        id: Math.floor(Math.random() * 1000),
        releaseId,
        platformId,
        status: 'processing',
        createdAt: new Date(),
        updatedAt: new Date()
      });
    }),
    
    // Mock error case
    processDistribution: jest.fn().mockImplementation((id) => {
      if (id === 999) {
        return Promise.reject(new Error('Platform API error'));
      }
      return Promise.resolve(true);
    })
  }
}));
```

## Best Practices

### 1. Test Isolation

- Each test should run independently
- Tests should not depend on other tests
- Clean up test data after each test

```typescript
// Example of proper test isolation
describe('User API', () => {
  beforeEach(async () => {
    // Set up fresh test data before each test
    await setupTestData();
  });
  
  afterEach(async () => {
    // Clean up test data after each test
    await cleanupTestData();
  });
  
  test('should create user', async () => {
    // Test implementation
  });
  
  test('should update user', async () => {
    // Does not depend on the previous test
  });
});
```

### 2. Test Readability

- Use descriptive test names
- Structure tests logically
- Use helper functions for common operations

```typescript
// Example of readable test
test('should calculate correct royalties based on platform rates', async () => {
  // Arrange
  const track = await createTestTrack();
  const analytics = await createTestAnalytics(track.id, {
    platform: 'spotify',
    streams: 1000
  });
  
  // Act
  const result = await royaltyService.calculateRoyalties(track.id);
  
  // Assert
  expect(result.totalRevenue).toBeCloseTo(4.2, 2); // $0.0042 per stream * 1000
  expect(result.platformBreakdown.spotify.streams).toBe(1000);
  expect(result.platformBreakdown.spotify.revenue).toBeCloseTo(4.2, 2);
});
```

### 3. Test Performance

- Keep tests fast, especially unit tests
- Use test parallelization when possible
- Avoid unnecessary setup/teardown

### 4. Testing Error Cases

- Test both success and failure paths
- Verify error handling works correctly
- Test edge cases and boundary conditions

```typescript
// Example of error case testing
test('should handle invalid authentication gracefully', async () => {
  const response = await request(app)
    .get('/api/users/me')
    .set('Authorization', 'Bearer invalid-token');
  
  expect(response.status).toBe(401);
  expect(response.body.error).toHaveProperty('message');
  expect(response.body.error.code).toBe('AUTH_REQUIRED');
});
```

## Troubleshooting Tests

### Common Issues and Solutions

1. **Flaky Tests:**
   - Identify intermittent failures
   - Look for race conditions or timing issues
   - Add proper waits or async handling

2. **Slow Tests:**
   - Profile test execution time
   - Reduce unnecessary setup
   - Parallelize test execution

3. **Environment-Specific Issues:**
   - Ensure consistent test environments
   - Mock external dependencies
   - Use containerization for isolation

## Further Reading

- [Jest Documentation](https://jestjs.io/docs/getting-started)
- [Cypress Best Practices](https://docs.cypress.io/guides/references/best-practices)
- [API Testing with Supertest](https://www.npmjs.com/package/supertest)
- [Performance Testing with k6](https://k6.io/docs/)
- [Web Accessibility Testing](https://www.deque.com/axe/)

---

## documentation/diagrams/README.md

# TuneMantra Diagrams

This section contains visual representations of the TuneMantra platform's architecture, workflows, and systems.

## Architecture Diagrams

- [System Architecture](architecture/system-architecture.svg) - Overall system architecture
- [Database Schema](architecture/database-schema.svg) - Database schema diagram
- [API Architecture](architecture/api-architecture.svg) - API architecture
- [Component Architecture](architecture/component-architecture.svg) - Component architecture

## Workflow Diagrams

- [Distribution Workflow](workflows/distribution-workflow.svg) - Content distribution workflow
- [Rights Management Workflow](workflows/rights-workflow.svg) - Rights management workflow
- [Royalty Calculation Workflow](workflows/royalty-workflow.svg) - Royalty calculation workflow
- [User Registration Workflow](workflows/user-registration.svg) - User registration workflow

## Feature Diagrams

- [Blockchain Integration](features/blockchain-integration.svg) - Blockchain integration details
- [Analytics System](features/analytics-system.svg) - Analytics system overview
- [Audio Fingerprinting](features/audio-fingerprinting.svg) - Audio fingerprinting system
- [Content Management](features/content-management.svg) - Content management system

## Entity Relationship Diagrams

- [User Entity Relationships](entities/user-relationships.svg) - User entity relationships
- [Content Entity Relationships](entities/content-relationships.svg) - Content entity relationships
- [Rights Entity Relationships](entities/rights-relationships.svg) - Rights entity relationships
- [Financial Entity Relationships](entities/financial-relationships.svg) - Financial entity relationships

## Process Diagrams

- [Development Process](processes/development-process.svg) - Development process
- [Content Approval Process](processes/content-approval.svg) - Content approval process
- [Deployment Process](processes/deployment-process.svg) - Deployment process
- [Testing Process](processes/testing-process.svg) - Testing process

---

## documentation/features/README.md

# TuneMantra Features Documentation

This directory contains comprehensive documentation for TuneMantra platform features.

## Core Features

- [Feature Catalog](feature_catalog.md) - Overview of all platform features
- [AI Feature Documentation](ai-feature-documentation.md) - Documentation of AI-powered features
- [Blockchain Integration Documentation](blockchain-integration.md) - Documentation of blockchain integration

## Feature Categories

### Content Management
- Content upload and management
- Metadata enhancement and validation
- Asset storage and retrieval

### Rights Management
- Rights registration and verification
- Collaborative rights management
- Rights dispute resolution
- Blockchain-based rights tracking

### Distribution
- Multi-platform distribution
- Release planning and scheduling
- Distribution analytics and reporting

### Analytics
- Performance tracking
- Revenue analytics
- Audience insights
- Market trend analysis

### Financial Management
- Royalty calculation and distribution
- Payment processing
- Financial reporting
- Tax documentation

### User Management
- Artist, label, and distributor accounts
- Team collaboration
- User permissions and access control

### Integration
- DSP integration
- Social media integration
- Third-party service integration

## Related Documentation

- [Project Documentation](../project/README.md) - Project management and planning
- [Technical Documentation](../technical/README.md) - Technical implementation details
- [User Documentation](../user/README.md) - User-focused guides and instructions

---

## documentation/features/feature-catalog.md

# TuneMantra Feature Catalog

This document provides a comprehensive catalog of features available in the TuneMantra platform, organized by domain and development phase.

## Core Platform Features

### User Management

| Feature | Description | Status | Branch |
|---------|-------------|--------|--------|
| User Registration | Account creation with email verification | Complete | PPv1 |
| Role-Based Access Control | User roles (artist, label, admin, etc.) | Complete | PPv1 |
| Profile Management | User profile information management | Complete | PPv1 |
| Authentication | Secure login and session management | Complete | PPv1 |
| Multi-Factor Authentication | Enhanced security with 2FA | Complete | 8march258 |
| Web3 Authentication | Blockchain wallet-based authentication | Complete | 12march547 |
| User Activity Tracking | Audit log of user actions | Complete | 3march |
| Permissions Management | Granular permission controls | Complete | 8march258 |
| Team Management | Collaborative team workspace | Complete | 12march547 |
| Delegated Access | Temporary access grants | Complete | 17032025 |

### Content Management

| Feature | Description | Status | Branch |
|---------|-------------|--------|--------|
| Content Upload | Audio file upload with validation | Complete | PPv1 |
| Metadata Management | Track, album, and artist metadata | Complete | PPv1 |
| Content Storage | Secure file storage system | Complete | PPv1 |
| Version Control | Track multiple content versions | Complete | 3march |
| Batch Upload | Multi-file upload functionality | Complete | 3march |
| Content Preview | In-browser audio playback | Complete | 8march258 |
| Metadata Validation | Format and quality validation | Complete | 8march258 |
| Artwork Management | Cover art and promotional images | Complete | 12march547 |
| Content Relationships | Track grouping and relationships | Complete | 17032025 |
| Supplementary Content | Liner notes, lyrics, etc. | Complete | 190320250630 |

### Rights Management

| Feature | Description | Status | Branch |
|---------|-------------|--------|--------|
| Basic Rights Registration | Record ownership of content | Complete | PPv1 |
| Rights Types | Different rights classifications | Complete | 3march |
| Multiple Rightsholder Support | Split ownership representation | Complete | 3march |
| Territorial Rights | Territory-specific rights management | Complete | 8march258 |
| Time-Bound Rights | Rights with defined validity periods | Complete | 8march258 |
| Rights Transfer | Transfer rights between parties | Complete | 12march547 |
| Blockchain Rights Registration | On-chain rights recording | Complete | 12march547 |
| Rights Verification | Verify rights claims | Complete | 17032025 |
| Rights Conflict Resolution | Tools for resolving conflicts | Complete | 17032025 |
| Collaborative Rights Management | Multi-party rights workflows | Complete | 190320250630 |

### Distribution Management

| Feature | Description | Status | Branch |
|---------|-------------|--------|--------|
| Distribution Setup | Configure distribution channels | Complete | PPv1 |
| Release Planning | Schedule and manage releases | Complete | 3march |
| Platform Selection | Choose distribution platforms | Complete | 3march |
| Distribution Status Tracking | Monitor distribution progress | Complete | 8march258 |
| Takedown Management | Remove content from platforms | Complete | 8march258 |
| Pre-release Strategy | Pre-save and promotional tools | Complete | 12march547 |
| Regional Distribution | Territory-specific distribution | Complete | 12march547 |
| Distribution Analytics | Track distribution performance | Complete | 17032025 |
| Adaptive Distribution | AI-enhanced distribution strategy | Complete | 17032025 |
| Cross-Platform Management | Unified platform management | Complete | 190320250630 |

## Blockchain Features

### Rights Registry

| Feature | Description | Status | Branch |
|---------|-------------|--------|--------|
| Blockchain Registration | Record rights on blockchain | Complete | 12march547 |
| Multi-Network Support | Support for multiple blockchains | Complete | 12march547 |
| Rights Verification | Cryptographic rights verification | Complete | 17032025 |
| Smart Contract Management | Deploy and manage contracts | Complete | 17032025 |
| On-Chain History | Immutable rights history | Complete | 17032025 |
| Rights Transfer | Transfer rights on blockchain | Complete | 17032025 |
| Blockchain Explorer | View blockchain transactions | Complete | 190320250630 |
| Gas Optimization | Efficient transaction handling | Complete | 190320250630 |
| Batch Registration | Register multiple rights efficiently | Complete | 190320250630 |
| Cross-Chain Verification | Verify rights across chains | In Progress | Current |

### NFT Creation

| Feature | Description | Status | Branch |
|---------|-------------|--------|--------|
| NFT Minting | Create NFTs for music content | Complete | 12march547 |
| Metadata Embedding | Rich metadata in NFTs | Complete | 12march547 |
| NFT Standards | Support for ERC-721/ERC-1155 | Complete | 17032025 |
| Royalty Configuration | On-chain royalty settings | Complete | 17032025 |
| NFT Marketplace Integration | List NFTs on marketplaces | Complete | 190320250630 |
| NFT Collection Management | Organize NFTs in collections | Complete | 190320250630 |
| Limited Edition NFTs | Scarcity and edition management | Complete | 190320250630 |
| NFT Utility Integration | Utility features in NFTs | In Progress | Current |
| Dynamic NFTs | Evolving NFT properties | Planned | Future |
| Fractional Ownership | Shared ownership of NFTs | Planned | Future |

### Royalty Distribution

| Feature | Description | Status | Branch |
|---------|-------------|--------|--------|
| Smart Contract Royalties | On-chain royalty distribution | Complete | 17032025 |
| Split Configuration | Configure payment splits | Complete | 17032025 |
| Automated Payments | Automated royalty payments | Complete | 17032025 |
| Payment Verification | Verify payment completion | Complete | 190320250630 |
| Multi-Currency Support | Handle different currencies | Complete | 190320250630 |
| Payment History | Record of all transactions | Complete | 190320250630 |
| Complex Split Structures | Multi-level payment splits | In Progress | Current |
| Off-Chain Reconciliation | Match on-chain with off-chain | In Progress | Current |
| Tax Management | Handle tax implications | Planned | Future |
| Cross-Chain Payments | Payments across blockchains | Planned | Future |

## AI & Analytics Features

### AI-Powered Features

| Feature | Description | Status | Branch |
|---------|-------------|--------|--------|
| Metadata Enhancement | AI-improved metadata | Complete | 12march547 |
| Genre Classification | Automatic genre detection | Complete | 12march547 |
| Mood Analysis | Detect mood from audio | Complete | 17032025 |
| Content Tagging | Automatic content tagging | Complete | 17032025 |
| Similar Track Detection | Find similar content | Complete | 17032025 |
| Audio Fingerprinting | Create unique audio signatures | Complete | 190320250630 |
| Content Moderation | AI-powered content screening | Complete | 190320250630 |
| Performance Prediction | Forecast content performance | In Progress | Current |
| Trend Analysis | Identify music trends | In Progress | Current |
| AI-Generated Artwork | Create artwork from prompts | Planned | Future |

### Analytics Dashboard

| Feature | Description | Status | Branch |
|---------|-------------|--------|--------|
| Basic Analytics | Views, plays, revenue data | Complete | 3march |
| Performance Metrics | Detailed performance tracking | Complete | 8march258 |
| Audience Demographics | Age, location, device data | Complete | 12march547 |
| Revenue Analysis | Detailed revenue breakdown | Complete | 12march547 |
| Trend Visualization | Visual trend representation | Complete | 17032025 |
| Comparative Analytics | Compare across content/time | Complete | 17032025 |
| Real-Time Analytics | Live performance tracking | Complete | 190320250630 |
| Predictive Analytics | AI-driven future predictions | Complete | 190320250630 |
| Custom Report Builder | Create customized reports | In Progress | Current |
| Export Capabilities | Export data in various formats | In Progress | Current |

## Mobile & Integration Features

### Mobile Application

| Feature | Description | Status | Branch |
|---------|-------------|--------|--------|
| Mobile-Responsive UI | Responsive web interface | Complete | 3march |
| Native Mobile Apps | iOS and Android applications | Complete | 12march547 |
| Push Notifications | Real-time mobile alerts | Complete | 12march547 |
| Offline Capabilities | Work without connectivity | Complete | 17032025 |
| Mobile Content Upload | Upload content from mobile | Complete | 17032025 |
| Mobile Analytics | View analytics on mobile | Complete | 190320250630 |
| Mobile Rights Management | Manage rights on mobile | Complete | 190320250630 |
| Mobile Wallet Integration | Connect blockchain wallets | In Progress | Current |
| Mobile Distribution | Manage distribution on mobile | In Progress | Current |
| Mobile AR Features | Augmented reality experiences | Planned | Future |

### Third-Party Integrations

| Feature | Description | Status | Branch |
|---------|-------------|--------|--------|
| DSP Integrations | Digital service provider connections | Complete | 3march |
| Payment Gateway Integration | Process payments securely | Complete | 8march258 |
| Social Media Integration | Share to social platforms | Complete | 12march547 |
| Analytics Integration | Connect to external analytics | Complete | 17032025 |
| CRM Integration | Connect customer relationship tools | Complete | 17032025 |
| Marketing Platform Integration | Connect marketing tools | Complete | 190320250630 |
| Blockchain Explorer Integration | View blockchain details | Complete | 190320250630 |
| Marketplace Integrations | Connect to NFT marketplaces | In Progress | Current |
| DAW Integration | Connect digital audio workstations | Planned | Future |
| Collaboration Tool Integration | Connect team tools | Planned | Future |

## Platform Administration

### Administration Tools

| Feature | Description | Status | Branch |
|---------|-------------|--------|--------|
| User Administration | Manage platform users | Complete | PPv1 |
| Content Moderation | Review and approve content | Complete | 3march |
| System Configuration | Configure platform settings | Complete | 8march258 |
| Email Management | Manage email communications | Complete | 8march258 |
| Audit Logging | Track system activities | Complete | 12march547 |
| Performance Monitoring | Monitor system performance | Complete | 17032025 |
| Backup & Recovery | Data backup procedures | Complete | 17032025 |
| Security Management | Manage security settings | Complete | 190320250630 |
| Multi-Tenant Management | Manage white label instances | In Progress | Current |
| API Management | Manage API access and keys | In Progress | Current |

### White Labeling

| Feature | Description | Status | Branch |
|---------|-------------|--------|--------|
| Basic Branding | Logo and color customization | Complete | 12march547 |
| Custom Domain Support | Use custom domains | Complete | 12march547 |
| Theme Customization | Comprehensive visual themes | Complete | 17032025 |
| Content Customization | Custom text and content | Complete | 17032025 |
| Feature Toggles | Enable/disable features | Complete | 190320250630 |
| White Label Management | Manage multiple instances | Complete | 190320250630 |
| Custom Workflows | Tailored process flows | In Progress | Current |
| Integration Customization | Custom third-party connections | In Progress | Current |
| Tenant Isolation | Secure multi-tenant data | In Progress | Current |
| White Label Analytics | Instance-specific analytics | Planned | Future |

## Development Timeline

The TuneMantra platform has evolved through several development phases:

1. **Planning Phase (PPv1)**: Initial platform architecture and core functionality
2. **Core Services (3march)**: Enhanced user management and content handling
3. **Rights Management (8march258)**: Advanced rights management capabilities
4. **Distribution (12march547)**: Distribution systems and blockchain integration
5. **Advanced Features (17032025)**: AI, analytics, and enhanced blockchain features
6. **Optimization (190320250630)**: Performance optimization and advanced capabilities
7. **Current Development**: Ongoing feature enhancement and new capabilities

## Feature Implementation Process

New features are implemented following a structured process:

1. **Requirements Analysis**: Identify and document feature requirements
2. **Design**: Technical design and architecture planning
3. **Implementation**: Code development and unit testing
4. **Integration**: Integrate with existing platform components
5. **Testing**: Comprehensive feature testing
6. **Documentation**: Create detailed feature documentation
7. **Release**: Deploy to production environment
8. **Monitoring**: Ongoing performance monitoring and optimization

## References

For detailed documentation on specific features, refer to:

- [Technical Documentation](../technical/) for implementation details
- [User Documentation](../user/) for usage instructions
- [Specialized Documentation](../specialized/) for domain-specific features
- [Blockchain Documentation](../blockchain/) for blockchain functionality

---

*This feature catalog is maintained based on the features found across multiple development branches.*# TuneMantra Complete Feature Catalog

This catalog provides a comprehensive inventory of all features in the TuneMantra platform, organized by functional category. Each feature is documented with a brief description and links to detailed documentation.

## Table of Contents

1. [Content Management Features](#content-management-features)
2. [Distribution Features](#distribution-features)
3. [Royalty Management Features](#royalty-management-features)
4. [Rights Management Features](#rights-management-features)
5. [Analytics Features](#analytics-features)
6. [AI and Intelligence Features](#ai-and-intelligence-features)
7. [Multi-Tenant Features](#multi-tenant-features)
8. [User Management Features](#user-management-features)
9. [Integration Features](#integration-features)
10. [Security Features](#security-features)
11. [Administration Features](#administration-features)
12. [Platform Core Features](#platform-core-features)
13. [Mobile Features](#mobile-features)
14. [Blockchain Features](#blockchain-features)
15. [Export/Import Features](#exportimport-features)
16. [Payment and Financial Features](#payment-and-financial-features)
17. [Team Management Features](#team-management-features)
18. [Synchronization Features](#synchronization-features)

---

## Content Management Features

### Track Management
- **Track Upload** - Upload and manage audio tracks with metadata
- **Track Editing** - Edit track details, artwork, and metadata
- **Track Versioning** - Manage multiple versions of tracks
- **Track Preview Generation** - Automatic generation of preview clips
- **Track Deletion** - Remove tracks from the platform
- **Track Status Management** - Track review and approval workflows
- **Track Search** - Advanced search functionality for tracks
- **Track Filtering** - Filter tracks by various attributes
- **Track Bulk Operations** - Perform operations on multiple tracks

### Release Management
- **Release Creation** - Create and configure music releases
- **Release Editing** - Edit release details and metadata
- **Release Packaging** - Bundle tracks into releases
- **Release Artwork** - Manage release artwork and visuals
- **Release Metadata** - Comprehensive metadata handling for releases
- **Release Scheduling** - Schedule releases for specific dates
- **Release Templates** - Standardized templates for release creation
- **Release Approval Workflows** - Multi-stage approval process for releases
- **Release Analytics** - Performance tracking for releases
- **Release Search** - Advanced search functionality for releases
- **Release Filtering** - Filter releases by various attributes
- **Release Bulk Operations** - Perform operations on multiple releases

### Asset Management
- **Asset Organization** - Hierarchical organization of digital assets
- **Asset Versioning** - Track changes to assets over time
- **Asset Tagging** - Apply descriptive tags to assets
- **Asset Bulk Import** - Import multiple assets simultaneously
- **Asset Preview Generation** - Create previews of audio and visual assets
- **Asset Format Conversion** - Convert assets between different formats
- **Asset Quality Control** - Verify asset quality and compliance
- **Asset Bundling** - Group related assets together
- **Asset Backup** - Automatic backup of critical assets
- **Asset Search** - Advanced search functionality for assets
- **Asset Filtering** - Filter assets by various attributes
- **Asset Bulk Operations** - Perform operations on multiple assets

### Metadata Management
- **Metadata Templates** - Standardized templates for metadata creation
- **Metadata Validation** - Validate metadata against industry standards
- **Metadata Enrichment** - Enhance metadata with additional information
- **Metadata Import/Export** - Import and export metadata in various formats
- **Metadata Versioning** - Track changes to metadata over time
- **Metadata Translation** - Translate metadata into multiple languages
- **Metadata Inheritance** - Inherit metadata from parent objects
- **Metadata Bulk Editing** - Edit metadata for multiple items simultaneously
- **Metadata Search** - Advanced search functionality for metadata
- **Metadata Filtering** - Filter items by metadata attributes
- **Metadata Normalization** - Standardize metadata format and values
- **Metadata Quality Score** - Evaluate the completeness and quality of metadata

---

## Distribution Features

### Platform Distribution
- **Multi-Platform Distribution** - Distribute content to multiple streaming platforms
- **Platform-Specific Metadata** - Customize metadata for specific platforms
- **Distribution Scheduling** - Schedule content distribution
- **Distribution Status Tracking** - Monitor distribution progress
- **Distribution Error Handling** - Manage distribution errors and retries
- **Distribution Analytics** - Track distribution performance
- **Distribution History** - View historical distribution records
- **Platform Takedown** - Remove content from platforms
- **Platform Updates** - Update content on platforms
- **Platform-Specific Requirements** - Ensure compliance with platform requirements
- **Platform Account Management** - Manage distribution platform accounts
- **Platform-Specific Optimization** - Optimize content for specific platforms

### Batch Distribution
- **Bulk Distribution** - Distribute multiple releases simultaneously
- **Batch Status Tracking** - Monitor status of batch distributions
- **Batch Error Handling** - Manage errors in batch distributions
- **Batch Scheduling** - Schedule batch distributions
- **Batch Reports** - Generate reports for batch distributions
- **Batch Templates** - Create templates for common batch distributions
- **Failed Distribution Recovery** - Recover from failed batch distributions
- **Distribution Job Management** - Manage distribution jobs
- **Distribution Job Prioritization** - Prioritize distribution jobs
- **Distribution Job Queuing** - Queue distribution jobs
- **Distribution Job History** - Track history of distribution jobs
- **Distribution Job Analytics** - Analyze distribution job performance

### Distribution Analytics
- **Platform Performance Comparison** - Compare performance across platforms
- **Distribution Success Rate** - Track distribution success rates
- **Distribution Time Analysis** - Analyze distribution processing times
- **Distribution Error Patterns** - Identify common distribution error patterns
- **Geographic Distribution Coverage** - Analyze distribution by geography
- **Platform Reach Analysis** - Analyze reach on different platforms
- **Distribution Timeline Visualization** - Visualize distribution over time
- **Distribution Performance Benchmarking** - Benchmark distribution performance
- **Distribution Trend Analysis** - Analyze distribution trends
- **Platform-Specific Analytics** - Detailed analytics for specific platforms
- **Distribution SLA Monitoring** - Monitor service level agreements
- **Distribution Optimization Recommendations** - Get recommendations for optimizing distributions

### Distribution Workflow Management
- **Custom Distribution Workflows** - Create custom workflows for distribution
- **Workflow Templates** - Use templates for common distribution workflows
- **Workflow Status Tracking** - Monitor workflow status
- **Workflow Approval Gates** - Configure approval gates in workflows
- **Workflow Notifications** - Set up notifications for workflow events
- **Workflow Error Handling** - Manage errors in distribution workflows
- **Workflow Branching** - Create branching logic in workflows
- **Workflow History** - Track workflow history
- **Workflow Analytics** - Analyze workflow performance
- **Workflow Optimization** - Optimize distribution workflows
- **Workflow Automation** - Automate distribution workflows
- **Workflow Integration** - Integrate with external systems

---

## Royalty Management Features

### Royalty Calculation
- **Multi-Platform Royalty Calculation** - Calculate royalties from multiple platforms
- **Platform-Specific Rates** - Apply platform-specific royalty rates
- **Territory-Specific Calculation** - Calculate royalties based on territory
- **Currency Conversion** - Convert royalties between currencies
- **Split Management** - Manage royalty splits between stakeholders
- **Rate Templates** - Use templates for common royalty rate structures
- **Historical Rate Management** - Manage changing rates over time
- **Minimum Royalty Guarantees** - Apply minimum royalty guarantees
- **Advances and Recoupments** - Handle advances and recoupable expenses
- **Custom Calculation Rules** - Create custom rules for royalty calculations
- **Calculation Versioning** - Track changes to calculation methods
- **Calculation Auditing** - Audit trail for royalty calculations

### Royalty Distribution
- **Stakeholder Payment Management** - Manage payments to stakeholders
- **Payment Scheduling** - Schedule royalty payments
- **Payment Threshold Management** - Apply payment thresholds
- **Payment Method Management** - Support multiple payment methods
- **Split Payment Management** - Distribute payments according to splits
- **Tax Withholding** - Apply tax withholding rules
- **Payment Reconciliation** - Reconcile payments with calculations
- **Payment Status Tracking** - Track payment status
- **Payment Error Handling** - Handle payment errors
- **Payment Reporting** - Generate reports for payments
- **Payment History** - Track payment history
- **Cross-Border Payment Optimization** - Optimize international payments

### Royalty Reporting
- **Royalty Statements** - Generate detailed royalty statements
- **Customizable Reports** - Create custom royalty reports
- **Report Scheduling** - Schedule automatic report generation
- **Report Distribution** - Distribute reports to stakeholders
- **Report Templates** - Use templates for common report types
- **Interactive Reports** - Create interactive royalty reports
- **Historical Reporting** - Generate reports for past periods
- **Comparative Reporting** - Compare royalties across periods
- **Projection Reporting** - Project future royalties
- **Platform-Specific Reporting** - Detailed reports for specific platforms
- **Territory-Specific Reporting** - Reports broken down by territory
- **Track-Level Reporting** - Detailed reporting at the track level

### Royalty Analytics
- **Royalty Trend Analysis** - Analyze royalty trends over time
- **Platform Performance Comparison** - Compare royalty performance across platforms
- **Territory Performance Analysis** - Analyze royalty performance by territory
- **Release Performance Analysis** - Analyze royalty performance by release
- **Track Performance Analysis** - Analyze royalty performance by track
- **Revenue Source Analysis** - Analyze royalties by revenue source
- **Custom Analytics** - Create custom royalty analytics
- **Performance Forecasting** - Forecast future royalty performance
- **Anomaly Detection** - Detect unusual patterns in royalty data
- **Seasonal Analysis** - Analyze seasonal patterns in royalties
- **Benchmark Analysis** - Compare performance against benchmarks
- **Revenue Driver Analysis** - Identify key drivers of royalty revenue

---

## Rights Management Features

### Rights Registration
- **Rights Entry** - Register rights for musical works
- **Multiple Rights Types** - Support for different types of rights (mechanical, performance, etc.)
- **Rights Documentation** - Attach documentation for rights claims
- **Rights Verification** - Verify rights ownership
- **Territory-Specific Rights** - Manage rights by territory
- **Rights Duration Management** - Manage rights time periods
- **Rights Transfer** - Transfer rights between parties
- **Rights Templates** - Use templates for common rights scenarios
- **Bulk Rights Registration** - Register rights for multiple works
- **Rights Import/Export** - Import and export rights data
- **Rights Search** - Advanced search for rights
- **Rights History** - Track changes to rights over time

### Collaborative Rights Management
- **Multi-Stakeholder Collaboration** - Collaborate on rights management
- **Rights Negotiation** - Negotiate rights between parties
- **Rights Approval Workflows** - Multi-stage approval process for rights
- **Comments and Discussions** - Discuss rights management
- **Rights Change Notifications** - Notify stakeholders of rights changes
- **Rights Conflict Resolution** - Resolve conflicts in rights claims
- **Rights Version Control** - Track versions of rights agreements
- **Stakeholder Management** - Manage stakeholders in rights agreements
- **Collaborative Editing** - Edit rights data collaboratively
- **Rights Templates** - Use templates for rights collaboration
- **Rights Sharing** - Share rights information with stakeholders
- **Collaboration Analytics** - Analyze collaboration patterns

### Rights Verification
- **Blockchain Verification** - Verify rights using blockchain
- **Document Verification** - Verify rights using documentation
- **Signature Verification** - Verify electronic signatures
- **Third-Party Verification** - Verify rights with third parties
- **Verification Certificates** - Generate verification certificates
- **Verification History** - Track verification history
- **Verification Status Tracking** - Monitor verification status
- **Verification Reporting** - Generate verification reports
- **Verification Analytics** - Analyze verification patterns
- **Verification APIs** - APIs for verification integration
- **Bulk Verification** - Verify multiple rights simultaneously
- **Verification Audit Trail** - Maintain audit trail of verifications

### Rights Search and Discovery
- **Advanced Rights Search** - Search for rights information
- **Faceted Filtering** - Filter rights by various attributes
- **Rights Ownership Lookup** - Look up ownership information
- **Conflict Detection** - Detect potential rights conflicts
- **Ownership Visualization** - Visualize ownership structures
- **Rights Exportation** - Export rights search results
- **Batch Operations** - Perform operations on search results
- **Rights Recommendations** - Get recommendations for related rights
- **Historical Rights Search** - Search historical rights data
- **Cross-Catalog Search** - Search across multiple catalogs
- **Natural Language Search** - Search using natural language
- **AI-Powered Search** - Use AI to enhance search capabilities

---

## Analytics Features

### Performance Analytics
- **Track Performance Metrics** - Analyze track performance
- **Release Performance Metrics** - Analyze release performance
- **Artist Performance Metrics** - Analyze artist performance
- **Platform-Specific Analytics** - Analyze performance by platform
- **Territory-Specific Analytics** - Analyze performance by territory
- **Time-Based Analysis** - Analyze performance over time
- **Comparative Analysis** - Compare performance across different dimensions
- **Performance Benchmarking** - Benchmark performance against industry standards
- **Performance Forecasting** - Forecast future performance
- **Anomaly Detection** - Detect unusual patterns in performance data
- **Seasonal Analysis** - Analyze seasonal patterns in performance
- **Performance Driver Analysis** - Identify key drivers of performance

### Audience Analytics
- **Audience Demographics** - Analyze audience by demographics
- **Audience Geography** - Analyze audience by location
- **Audience Behavior** - Analyze audience engagement patterns
- **Audience Growth** - Track audience growth over time
- **Audience Retention** - Analyze audience retention
- **Audience Source Analysis** - Identify sources of audience
- **Audience Segmentation** - Segment audience by characteristics
- **Audience Journey Mapping** - Map audience journey
- **Audience Cross-Platform Analysis** - Analyze audience across platforms
- **Audience Preference Analysis** - Analyze audience preferences
- **Audience Trend Analysis** - Analyze trends in audience data
- **Audience Prediction** - Predict audience behavior

### Financial Analytics
- **Revenue Analytics** - Analyze revenue patterns
- **Cost Analytics** - Analyze cost structures
- **Profit Analytics** - Analyze profitability
- **Revenue Stream Analysis** - Analyze revenue by source
- **Financial Forecasting** - Forecast financial performance
- **Financial Benchmarking** - Benchmark financial performance
- **Financial Trend Analysis** - Analyze financial trends
- **ROI Analysis** - Analyze return on investment
- **Break-Even Analysis** - Determine break-even points
- **Scenario Analysis** - Analyze different financial scenarios
- **Financial Risk Assessment** - Assess financial risks
- **Financial Decision Support** - Support for financial decisions

### Customizable Analytics
- **Custom Metrics** - Create custom analytics metrics
- **Custom Dashboards** - Build customized analytics dashboards
- **Custom Reports** - Generate custom analytics reports
- **Report Scheduling** - Schedule automatic report generation
- **Report Sharing** - Share reports with stakeholders
- **Data Export** - Export analytics data
- **Advanced Analytics Export** - Comprehensive data export system with multiple formats ([Documentation](../technical/services/advanced-analytics-export.md))
- **Custom Visualizations** - Create custom data visualizations
- **Interactive Analytics** - Create interactive analytics tools
- **Alert Configuration** - Set up alerts for specific metrics
- **Analytics API** - APIs for analytics integration
- **White-Label Analytics** - Brand analytics for clients
- **Embedded Analytics** - Embed analytics in other applications

---

## AI and Intelligence Features

### Audio Fingerprinting
- **Content Fingerprinting** - Create unique audio fingerprints for tracks
- **Copyright Detection** - Identify potential copyright conflicts during upload
- **Sample Detection** - Detect samples from other works in uploaded audio
- **Metadata Validation** - Verify metadata accuracy using fingerprinting
- **Content Identification** - Identify unknown tracks using audio fingerprints
- **Rights Verification** - Verify ownership rights through fingerprinting
- **Duplicate Detection** - Identify duplicate content within the catalog
- **Real-time Monitoring** - Monitor audio streams for copyrighted content
- **Fingerprint Database** - Maintain database of audio fingerprints
- **Fingerprint Analytics** - Analyze fingerprint matching patterns
- **Integration with Upload Flow** - Seamless integration with content upload process
- **Confidence Scoring** - Provide confidence scores for fingerprint matches

### AI Metadata Enhancement
- **Audio Analysis** - Analyze audio content for metadata
- **Genre Classification** - Automatically identify musical genres
- **Mood Detection** - Detect emotional qualities in music
- **BPM Detection** - Automatically detect tempo
- **Key Detection** - Identify musical key
- **Instrument Recognition** - Identify instruments in recordings
- **Vocal Detection** - Detect and analyze vocal content
- **Lyric Analysis** - Analyze lyrical content
- **Structure Analysis** - Identify song structure
- **Similar Track Identification** - Find similar tracks
- **Content Quality Assessment** - Assess audio quality
- **Commercial Potential Analysis** - Analyze commercial potential

### AI-Powered Recommendations
- **Similar Content Recommendations** - Recommend similar content
- **Marketing Recommendations** - Suggest marketing strategies
- **Distribution Recommendations** - Recommend distribution strategies
- **Pricing Recommendations** - Suggest optimal pricing
- **Release Timing Recommendations** - Recommend release timing
- **Platform Selection Recommendations** - Suggest platforms for distribution
- **Audience Targeting Recommendations** - Recommend target audiences
- **Playlist Recommendations** - Suggest playlists for submission
- **Content Improvement Recommendations** - Suggest content improvements
- **Collaboration Recommendations** - Suggest potential collaborators
- **Feature Recommendations** - Recommend platform features
- **Strategy Recommendations** - Suggest business strategies

### Predictive Analytics
- **Performance Prediction** - Predict content performance
- **Trend Prediction** - Predict industry trends
- **Revenue Prediction** - Predict revenue
- **Audience Growth Prediction** - Predict audience growth
- **Platform Performance Prediction** - Predict performance by platform
- **Content Longevity Prediction** - Predict content lifecycle
- **Risk Prediction** - Predict business risks
- **Opportunity Prediction** - Identify potential opportunities
- **Seasonal Impact Prediction** - Predict seasonal effects
- **Churn Prediction** - Predict customer churn
- **Conversion Prediction** - Predict conversion rates
- **Success Factor Prediction** - Identify factors driving success

### Intelligence Reporting
- **AI Insights Reports** - Generate reports with AI insights
- **Predictive Reports** - Create reports with predictions
- **Recommendation Reports** - Generate recommendation reports
- **Trend Reports** - Create reports on trends
- **Competitive Intelligence** - Generate competitive insights
- **Market Intelligence** - Provide market insights
- **Industry Benchmarking** - Benchmark against industry standards
- **Intelligence Dashboards** - Create dashboards with intelligence data
- **Intelligence Alerts** - Set up alerts for intelligence insights
- **Custom Intelligence Reports** - Create custom intelligence reports
- **Intelligence Sharing** - Share intelligence with stakeholders
- **Intelligence API** - APIs for intelligence integration

---

## Multi-Tenant Features

### Label Management
- **Label Hierarchy** - Manage hierarchical label structures
- **Label Branding** - Customize platform branding by label
- **Label Settings** - Configure label-specific settings
- **Label Analytics** - View analytics by label
- **Label User Management** - Manage users within labels
- **Label Permissions** - Set permissions at label level
- **Label Content Management** - Manage content by label
- **Label Templates** - Create templates for label use
- **Label Reporting** - Generate reports for labels
- **Label Billing** - Manage billing by label
- **Label Support** - Provide support for labels
- **Label Communications** - Communicate with labels

### Sub-Label Management
- **Sub-Label Creation** - Create and configure sub-labels
- **Sub-Label Hierarchy** - Manage sub-label hierarchies
- **Sub-Label Permissions** - Configure sub-label permissions
- **Sub-Label Branding** - Customize branding for sub-labels
- **Sub-Label Analytics** - View analytics for sub-labels
- **Sub-Label User Management** - Manage users within sub-labels
- **Sub-Label Content Management** - Manage content by sub-label
- **Sub-Label Templates** - Create templates for sub-labels
- **Sub-Label Reporting** - Generate reports for sub-labels
- **Sub-Label Billing** - Manage billing for sub-labels
- **Sub-Label Support** - Provide support for sub-labels
- **Sub-Label Communications** - Communicate with sub-labels

### White Label Solutions
- **White Label Branding** - Complete branding customization
- **White Label Domain** - Custom domains for white label
- **White Label User Interface** - Customizable user interface
- **White Label Reporting** - Branded reporting
- **White Label User Management** - Manage white label users
- **White Label Settings** - Configure white label settings
- **White Label Analytics** - View white label analytics
- **White Label Billing** - Manage white label billing
- **White Label Support** - Support for white label customers
- **White Label Feature Control** - Control feature availability
- **White Label Communications** - Branded communication
- **White Label API Access** - API access for white label customers

### Multi-Entity Management
- **Entity Hierarchy Management** - Manage complex entity hierarchies
- **Cross-Entity Analytics** - Analytics across multiple entities
- **Entity Permissions Management** - Manage permissions across entities
- **Entity Template Management** - Manage templates across entities
- **Entity User Management** - Manage users across entities
- **Entity Content Management** - Manage content across entities
- **Entity Reporting** - Generate reports across entities
- **Entity Billing Management** - Manage billing across entities
- **Entity Support Management** - Provide support across entities
- **Entity Communication Management** - Communicate across entities
- **Entity Integration Management** - Manage integrations across entities
- **Entity Compliance Management** - Ensure compliance across entities

---

## User Management Features

### User Administration
- **User Creation** - Create and configure users
- **User Editing** - Edit user information and settings
- **User Deactivation** - Deactivate user accounts
- **User Suspension** - Temporarily suspend users
- **User Deletion** - Delete user accounts
- **User Search** - Search for users
- **User Filtering** - Filter users by various attributes
- **User Bulk Operations** - Perform operations on multiple users
- **User Import/Export** - Import and export user data
- **User Activity Tracking** - Track user activity
- **User Log Management** - Manage user logs
- **User Feedback Collection** - Collect feedback from users

### Role and Permission Management
- **Role Creation** - Create and configure roles
- **Permission Assignment** - Assign permissions to roles
- **Role Hierarchy** - Set up hierarchical role structures
- **Custom Roles** - Create custom roles
- **Role Templates** - Use templates for common role configurations
- **Permission Auditing** - Audit permission assignments
- **Role Analytics** - Analyze role usage
- **Role-Based Access Control** - Control access based on roles
- **Fine-Grained Permissions** - Set detailed permission levels
- **Permission Inheritance** - Configure permission inheritance
- **Temporary Permissions** - Grant temporary permissions
- **Permission Reports** - Generate permission reports

### User Authentication
- **Multi-Factor Authentication** - Secure authentication with multiple factors
- **SSO Integration** - Single sign-on integration
- **OAuth Support** - Support for OAuth authentication
- **Password Management** - Manage password policies
- **Session Management** - Control user sessions
- **Login Monitoring** - Monitor login activity
- **Authentication Logging** - Log authentication events
- **Failed Login Protection** - Protect against failed login attempts
- **Account Lockout** - Lock accounts after failed attempts
- **IP Restriction** - Restrict logins by IP address
- **Device Management** - Manage authenticated devices
- **Authentication Analytics** - Analyze authentication patterns

### User Onboarding
- **Welcome Workflows** - Guide new users through onboarding
- **Setup Wizards** - Step-by-step setup assistance
- **Tutorial System** - Interactive tutorials
- **Onboarding Emails** - Automated onboarding email sequence
- **Feature Highlights** - Showcase key features
- **Progress Tracking** - Track onboarding progress
- **Customizable Onboarding** - Customize onboarding by user type
- **Onboarding Templates** - Templates for different user types
- **Onboarding Analytics** - Analyze onboarding effectiveness
- **Onboarding Automation** - Automate onboarding processes
- **Onboarding Support** - Provide support during onboarding
- **Onboarding Feedback** - Collect feedback on onboarding

---

## Integration Features

### Platform Integrations
- **Streaming Platform Integration** - Integrate with music streaming platforms
- **Social Media Integration** - Connect with social media platforms
- **Distribution Platform Integration** - Integrate with distribution platforms
- **Payment Platform Integration** - Connect payment processors
- **Analytics Platform Integration** - Integrate with analytics tools
- **Marketing Platform Integration** - Connect with marketing tools
- **CRM Integration** - Integrate with customer relationship management systems
- **Accounting Integration** - Connect with accounting software
- **Communication Platform Integration** - Integrate with communication tools
- **Project Management Integration** - Connect with project management systems
- **Calendar Integration** - Integrate with calendar applications
- **Cloud Storage Integration** - Connect with cloud storage services

### API Management
- **API Key Management** - Manage API access keys
- **API Usage Analytics** - Track API usage
- **API Rate Limiting** - Control API request rates
- **API Documentation** - Comprehensive API documentation
- **API Versioning** - Manage multiple API versions
- **API Testing Tools** - Tools for testing API functionality
- **API Security** - Secure API access
- **API Monitoring** - Monitor API performance
- **API Error Handling** - Manage API errors
- **Custom API Endpoints** - Create custom API endpoints
- **API Webhooks** - Configure webhook notifications
- **API Integration Assistants** - Assist with API integration

### Data Synchronization
- **Platform Synchronization** - Sync data between platforms
- **Bidirectional Sync** - Two-way data synchronization
- **Selective Sync** - Control what data is synchronized
- **Scheduled Sync** - Schedule synchronization jobs
- **Real-Time Sync** - Synchronize data in real-time
- **Sync Status Monitoring** - Monitor synchronization status
- **Sync Error Handling** - Manage synchronization errors
- **Sync Conflict Resolution** - Resolve data conflicts
- **Sync History** - Track synchronization history
- **Data Transformation** - Transform data during synchronization
- **Sync Templates** - Templates for common sync configurations
- **Sync Analytics** - Analyze synchronization patterns

### Custom Integrations
- **Integration Builder** - Build custom integrations
- **Workflow Integration** - Integrate with workflow systems
- **Custom Connector Development** - Develop custom connectors
- **Integration Templates** - Templates for common integrations
- **Integration Testing** - Test integration functionality
- **Integration Deployment** - Deploy integrations
- **Integration Monitoring** - Monitor integration performance
- **Integration Error Handling** - Manage integration errors
- **Integration Version Control** - Track integration versions
- **Integration Marketplace** - Share and discover integrations
- **Integration Analytics** - Analyze integration usage
- **Integration Support** - Support for integration issues

---

## Security Features

### Access Control
- **Role-Based Access Control** - Control access based on roles
- **Attribute-Based Access Control** - Control access based on attributes
- **Resource-Level Permissions** - Set permissions at resource level
- **IP Restriction** - Restrict access by IP address
- **Location-Based Access** - Control access by location
- **Device-Based Access** - Control access by device
- **Time-Based Access** - Restrict access by time
- **Context-Aware Access** - Use context for access decisions
- **Emergency Access** - Procedures for emergency access
- **Access Request Management** - Manage access requests
- **Access Certification** - Regularly certify access
- **Access Review** - Review access permissions

### Data Protection
- **Data Encryption** - Encrypt sensitive data
- **Data Masking** - Mask sensitive data for display
- **Data Anonymization** - Anonymize data for analysis
- **Data Classification** - Classify data by sensitivity
- **Data Loss Prevention** - Prevent data loss
- **Data Retention Management** - Manage data retention
- **Data Backup** - Backup critical data
- **Data Recovery** - Recover from data loss
- **Secure File Sharing** - Share files securely
- **Secure Messaging** - Secure internal messaging
- **Secure Notes** - Securely store sensitive notes
- **Secure Document Management** - Manage documents securely

### Security Monitoring
- **Activity Monitoring** - Monitor platform activity
- **Threat Detection** - Detect security threats
- **Anomaly Detection** - Identify unusual behavior
- **Security Logging** - Comprehensive security logs
- **Security Dashboards** - Dashboards for security monitoring
- **Security Alerts** - Alerts for security events
- **Security Reporting** - Generate security reports
- **Security Audit Trail** - Maintain security audit trail
- **User Behavior Analytics** - Analyze user behavior for security
- **System Health Monitoring** - Monitor system health
- **Vulnerability Scanning** - Scan for vulnerabilities
- **Penetration Testing** - Regular security testing

### Compliance
- **Compliance Frameworks** - Support for compliance frameworks
- **Compliance Documentation** - Generate compliance documentation
- **Compliance Reporting** - Reports for compliance requirements
- **Compliance Monitoring** - Monitor compliance status
- **Policy Management** - Manage security policies
- **Compliance Training** - Training for compliance requirements
- **Compliance Audit Support** - Support for compliance audits
- **Privacy Management** - Manage privacy settings and consents
- **GDPR Compliance** - Support for GDPR requirements
- **CCPA Compliance** - Support for CCPA requirements
- **Industry-Specific Compliance** - Support for industry regulations
- **Compliance Analytics** - Analyze compliance status

---

## Administration Features

### System Configuration
- **Platform Settings** - Configure platform-wide settings
- **Feature Configuration** - Enable/disable and configure features
- **Workflow Configuration** - Configure workflow settings
- **Notification Configuration** - Set up system notifications
- **Email Configuration** - Configure email settings
- **Integration Configuration** - Set up external integrations
- **Security Configuration** - Configure security settings
- **UI Configuration** - Customize user interface
- **Report Configuration** - Configure reporting settings
- **Analytics Configuration** - Set up analytics features
- **Search Configuration** - Configure search functionality
- **API Configuration** - Configure API settings

### Monitoring and Maintenance
- **System Health Monitoring** - Monitor system health
- **Performance Monitoring** - Track system performance
- **Resource Utilization** - Monitor resource usage
- **Error Monitoring** - Track system errors
- **Log Management** - Manage system logs
- **Scheduled Maintenance** - Plan and execute maintenance
- **System Backup** - Back up system data
- **System Restore** - Restore from backups
- **System Updates** - Manage system updates
- **Database Maintenance** - Maintain database health
- **Cache Management** - Manage system caches
- **Task Scheduling** - Schedule system tasks

### Support Tools
- **User Support** - Tools for supporting users
- **Knowledge Base** - Self-service knowledge resources
- **Ticket Management** - Manage support tickets
- **Live Chat Support** - Real-time chat support
- **Guided Troubleshooting** - Step-by-step troubleshooting
- **Remote Assistance** - Provide remote support
- **System Diagnostics** - Diagnostic tools
- **Performance Testing** - Test system performance
- **Bug Reporting** - Tools for reporting bugs
- **Feature Requests** - Manage feature requests
- **FAQ Management** - Manage frequently asked questions
- **Support Analytics** - Analyze support metrics

### Administrative Reporting
- **System Usage Reports** - Reports on system usage
- **User Activity Reports** - Report on user activity
- **Performance Reports** - System performance reports
- **Security Reports** - Reports on security events
- **Error Reports** - System error reports
- **Audit Reports** - Comprehensive audit reports
- **Compliance Reports** - Reports for compliance
- **Resource Usage Reports** - Reports on resource usage
- **License Usage Reports** - Track license usage
- **Support Reports** - Reports on support activities
- **Feature Usage Reports** - Track feature usage
- **Custom Admin Reports** - Create custom administrative reports

---

## Platform Core Features

### User Interface
- **Responsive Design** - Adapt to different screen sizes
- **Accessibility Compliance** - Support for accessibility standards
- **Theming Support** - Customizable visual themes
- **Localization** - Support for multiple languages
- **Dark/Light Mode** - Toggle between display modes
- **Keyboard Shortcuts** - Productivity shortcuts
- **Rich Media Support** - Support for various media types
- **Drag and Drop** - Intuitive drag and drop interfaces
- **Interactive Elements** - Interactive UI components
- **Animations** - Smooth UI animations
- **Device Optimization** - Optimize for different devices
- **Print-Friendly Views** - Optimized views for printing

### Search and Discovery
- **Full-Text Search** - Search across all content
- **Advanced Filtering** - Filter by multiple criteria
- **Faceted Search** - Narrow results by categories
- **Search Suggestions** - Intelligent search suggestions
- **Recent Searches** - Track recent search activity
- **Saved Searches** - Save searches for future use
- **Relevance Ranking** - Rank search results by relevance
- **Search Analytics** - Analyze search patterns
- **Related Content** - Show related content in results
- **Search Personalization** - Personalize search results
- **Natural Language Search** - Search using natural language
- **Visual Search** - Search using visual elements

### Notifications
- **Email Notifications** - Send notifications via email
- **In-App Notifications** - Notifications within the platform
- **Push Notifications** - Send to mobile devices
- **SMS Notifications** - Text message notifications
- **Notification Preferences** - User-specific preferences
- **Notification Templates** - Templates for common notifications
- **Notification Scheduling** - Schedule notifications
- **Notification History** - Track sent notifications
- **Notification Analytics** - Analyze notification performance
- **Bulk Notifications** - Send to multiple recipients
- **Notification Grouping** - Group related notifications
- **Notification Actions** - Interactive notification actions

### Performance Optimization
- **Caching** - Cache frequently accessed data
- **Content Delivery Network** - Use CDNs for content delivery
- **Lazy Loading** - Load content as needed
- **Database Optimization** - Optimize database queries
- **Resource Minification** - Minify code resources
- **Image Optimization** - Optimize images for performance
- **Performance Monitoring** - Track system performance
- **Load Balancing** - Distribute traffic for performance
- **Memory Management** - Optimize memory usage
- **Response Time Optimization** - Improve response times
- **Batch Processing** - Process tasks in batches
- **Asynchronous Processing** - Process tasks asynchronously

---

## Mobile Features

> **Detailed Documentation:** For comprehensive information about the mobile application integration, refer to the [Mobile Application Integration](technical/services/mobile-application-integration.md) documentation.

### Mobile Application
- **iOS App** - Native application for iOS devices built with Swift
- **Android App** - Native application for Android devices built with Kotlin
- **Progressive Web App** - Cross-browser web application with native-like features
- **Cross-Platform Compatibility** - Support for multiple platforms and form factors
- **Offline Mode** - Full functionality when offline with seamless synchronization
- **Push Notifications** - Real-time mobile device notifications for important events
- **Mobile Analytics** - Comprehensive tracking of mobile usage patterns
- **Biometric Authentication** - Secure access with FaceID, TouchID and fingerprint scanning
- **Deep Linking** - Direct links to specific app content and features
- **Mobile Payments** - Secure in-app payment processing
- **Location-Based Features** - Enhanced functionality using device location
- **Mobile-Specific UI** - Interface optimized for touch interaction and mobile screens

### Mobile Content Management
- **Mobile Content Sync** - Bidirectional synchronization with automatic conflict resolution
- **Offline Content Access** - Complete access to content without network connection
- **Delta Synchronization** - Only transfer changed parts of content to optimize bandwidth
- **Mobile Upload** - Upload new content directly from mobile devices with auto-tagging
- **Mobile Editing** - Edit content metadata and properties on mobile
- **Content Streaming** - Adaptive bitrate streaming optimized for mobile networks
- **Download Management** - Manage and prioritize content downloads with pause/resume 
- **Storage Optimization** - Intelligent caching and storage management for device constraints
- **Bandwidth Management** - Fine-grained control over mobile data usage with scheduling
- **Mobile Content Search** - On-device search with offline capabilities
- **Smart Content Organization** - Automatically organize content for mobile consumption
- **Secure Content Sharing** - Share content from mobile with robust permissions
- **Mobile Content Analytics** - Detailed analytics on mobile content usage patterns

### Mobile Analytics
- **Real-time Mobile Usage Tracking** - Comprehensive tracking of mobile app usage with minimal performance impact
- **Advanced Session Analytics** - Detailed analysis of user sessions with path tracing and interaction heatmaps
- **Multi-touchpoint User Journey Mapping** - Visualize complete user journeys across mobile and web platforms
- **Feature Adoption Analysis** - Measure and track feature discovery and adoption rates across user segments
- **Crash Detection and Analysis** - Automated capture and analysis of app crashes with detailed diagnostics
- **Performance Metrics Dashboard** - Real-time performance tracking with bottleneck identification
- **Device-specific Usage Patterns** - Analyze behavior patterns across different device types and models
- **Platform Comparison Analytics** - Compare metrics between iOS, Android, and web platforms
- **Geospatial Usage Visualization** - Interactive maps showing usage patterns by geographic region
- **Engagement Depth Measurement** - Quantify user engagement through multiple custom dimensions
- **Conversion Funnel Optimization** - Identify and address conversion barriers in mobile workflows
- **Cohort-based Retention Analysis** - Track user retention across custom cohorts with predictive modeling

### Mobile Sync
- **Bidirectional Synchronization** - Two-way data sync between server and mobile devices
- **Background Sync Engine** - Intelligent service for continuous background syncing
- **Selective Content Sync** - Granular control over what content is synchronized to devices
- **Automated Conflict Resolution** - AI-driven algorithms to resolve data conflicts
- **Smart Sync Scheduling** - Battery and network-aware synchronization scheduling
- **Real-time Sync Status** - Detailed visibility into synchronization progress and status
- **Adaptive Bandwidth Management** - Dynamic optimization of data transfer based on network conditions
- **Differential Delta Updates** - Transfer only the changed portions of data to minimize bandwidth
- **Priority-based Sync Queue** - Critical data syncs first based on user needs and behaviors
- **Customizable Sync Notifications** - User-configurable notifications for sync events
- **Cross-Device State Management** - Consistent experience across all user devices
- **Detailed Sync Analytics** - Comprehensive metrics on synchronization patterns and performance
- **Offline Sync Queue** - Queue changes while offline for later synchronization

---

## Blockchain Features

### Blockchain Registration
- **Content Registration** - Register content on blockchain
- **Rights Registration** - Register rights on blockchain
- **Transaction Recording** - Record transactions on blockchain
- **Digital Signatures** - Sign content with blockchain
- **Timestamp Certification** - Certify timestamps with blockchain
- **Provenance Tracking** - Track content provenance
- **Ownership Transfer** - Transfer ownership on blockchain
- **Smart Contracts** - Execute automated contracts
- **Royalty Smart Contracts** - Automated royalty distribution
- **License Smart Contracts** - Automated licensing
- **Multi-Signature Support** - Require multiple signatures
- **Blockchain Explorer** - Explore blockchain records

### Blockchain Verification
- **Content Verification** - Verify content authenticity
- **Rights Verification** - Verify rights ownership
- **Transaction Verification** - Verify transaction records
- **Signature Verification** - Verify digital signatures
- **Timestamp Verification** - Verify content timestamps
- **Ownership Verification** - Verify content ownership
- **Contract Verification** - Verify smart contracts
- **Verification Certificates** - Generate verification certificates
- **Batch Verification** - Verify multiple items
- **Verification API** - API for verification integration
- **Verification Analytics** - Analyze verification patterns
- **Verification History** - Track verification history

### Blockchain Analytics
- **Transaction Analytics** - Analyze blockchain transactions
- **Usage Analytics** - Analyze blockchain usage
- **Performance Analytics** - Analyze blockchain performance
- **Smart Contract Analytics** - Analyze smart contract usage
- **Token Analytics** - Analyze token usage
- **Chain Analysis** - Analyze blockchain structure
- **Network Analysis** - Analyze blockchain network
- **Gas Usage Analysis** - Analyze transaction costs
- **Temporal Analysis** - Analyze blockchain over time
- **User Behavior Analysis** - Analyze user behavior
- **Security Analysis** - Analyze blockchain security
- **Compliance Analysis** - Analyze regulatory compliance

### Tokenization
- **Content Tokenization** - Create tokens for content
- **Rights Tokenization** - Tokenize rights ownership
- **Royalty Tokens** - Tokens for royalty distribution
- **Fan Tokens** - Tokens for fan engagement
- **Access Tokens** - Tokens for content access
- **Governance Tokens** - Tokens for platform governance
- **Token Wallet** - Manage blockchain tokens
- **Token Trading** - Trade tokens on platform
- **Token Staking** - Stake tokens for benefits
- **Token Rewards** - Reward system using tokens
- **Token Economics** - Manage token economy
- **Token Analytics** - Analyze token usage

---

## Export/Import Features

### Data Export
- **Content Export** - Export content in various formats
- **Metadata Export** - Export metadata separately
- **Batch Export** - Export multiple items
- **Scheduled Export** - Schedule automatic exports
- **Export Templates** - Templates for common exports
- **Custom Export Formats** - Create custom export formats
- **Export Filtering** - Filter what is exported
- **Export Transformation** - Transform data during export
- **Export Notifications** - Notify when exports complete
- **Export History** - Track export history
- **Export Analytics** - Analyze export patterns
- **Export API** - API for integration with export

### Advanced Analytics Export
- **Multi-Format Analytics Export** - Export analytics data in CSV, Excel, PDF, and JSON formats
- **On-Demand Export** - Generate exports immediately based on user configuration
- **Scheduled Export** - Schedule recurring exports with customizable frequency
- **Bulk Export** - Process multiple analytics exports in batch operations
- **Custom Report Export** - Create highly customized exports using templates
- **Data Source Connectors** - Connect to various platform data sources
- **Analytics Processing Engine** - Process and transform raw data for export
- **Export Format Handlers** - Generate exports in various formats with formatting
- **Export Delivery Mechanisms** - Deliver exports via download, email, or cloud storage
- **Template Engine** - Apply customizable templates to exports
- **Batch Processing** - Handle large-scale export operations
- **Export Scheduling System** - Manage and execute scheduled export tasks

### Data Import
- **Content Import** - Import content from various sources
- **Metadata Import** - Import metadata separately
- **Batch Import** - Import multiple items
- **Scheduled Import** - Schedule automatic imports
- **Import Templates** - Templates for common imports
- **Custom Import Formats** - Support custom import formats
- **Import Validation** - Validate imported data
- **Import Transformation** - Transform data during import
- **Import Error Handling** - Handle import errors
- **Import Notifications** - Notify when imports complete
- **Import History** - Track import history
- **Import API** - API for integration with import

### Bulk Operations
- **Bulk Editing** - Edit multiple items simultaneously
- **Bulk Tagging** - Apply tags to multiple items
- **Bulk Status Updates** - Update status for multiple items
- **Bulk Distribution** - Distribute multiple items
- **Bulk Rights Management** - Manage rights for multiple items
- **Bulk Metadata Updates** - Update metadata for multiple items
- **Bulk Royalty Management** - Manage royalties for multiple items
- **Bulk Archiving** - Archive multiple items
- **Bulk Deletion** - Delete multiple items
- **Bulk Restoration** - Restore multiple items
- **Bulk Analytics** - Analyze bulk operations
- **Bulk Operation History** - Track bulk operation history

### Asset Migration
- **Legacy System Migration** - Migrate from legacy systems
- **Platform Migration** - Migrate between platforms
- **Catalog Migration** - Migrate entire catalogs
- **Incremental Migration** - Migrate in stages
- **Migration Planning** - Plan migration process
- **Migration Validation** - Validate migrated data
- **Migration Rollback** - Roll back failed migrations
- **Migration Analytics** - Analyze migration success
- **Migration Reporting** - Generate migration reports
- **Post-Migration Cleanup** - Clean up after migration
- **Migration Support** - Support during migration
- **Migration Documentation** - Document migration process

---

## Payment and Financial Features

### Payment Processing
- **Multiple Payment Methods** - Support various payment types
- **Payment Gateway Integration** - Connect with payment gateways
- **Recurring Payments** - Process recurring payments
- **Subscription Management** - Manage payment subscriptions
- **Payment Plans** - Create flexible payment plans
- **International Payments** - Process payments globally
- **Multi-Currency Support** - Support multiple currencies
- **Payment Verification** - Verify payment authenticity
- **Payment Reconciliation** - Reconcile payment records
- **Payment Analytics** - Analyze payment patterns
- **Payment Notifications** - Notify about payment events
- **Secure Payment Storage** - Securely store payment information

### Invoicing
- **Invoice Generation** - Create professional invoices
- **Invoice Templates** - Use templates for invoices
- **Automatic Invoicing** - Generate invoices automatically
- **Invoice Customization** - Customize invoice appearance
- **Invoice Numbering** - Manage invoice numbering
- **Invoice Distribution** - Send invoices to recipients
- **Invoice Tracking** - Track invoice status
- **Invoice Reminders** - Send payment reminders
- **Invoice History** - Maintain invoice history
- **Invoice Search** - Search for invoices
- **Invoice Reporting** - Generate invoice reports
- **Invoice Analytics** - Analyze invoicing patterns

### Financial Reporting
- **Revenue Reports** - Report on revenue
- **Expense Reports** - Track and report expenses
- **Profit and Loss Reports** - Generate P&L statements
- **Balance Sheet Reports** - Create balance sheets
- **Cash Flow Reports** - Report on cash flow
- **Tax Reports** - Generate tax-related reports
- **Financial Forecasting** - Forecast financial performance
- **Budget Reports** - Track budget performance
- **Financial Dashboards** - Visual financial dashboards
- **Custom Financial Reports** - Create custom reports
- **Financial Analytics** - Analyze financial data
- **Financial Export** - Export financial data

### Financial Management
- **Budget Management** - Create and track budgets
- **Expense Tracking** - Track business expenses
- **Revenue Management** - Manage revenue streams
- **Financial Goal Setting** - Set and track financial goals
- **Financial Planning** - Plan financial activities
- **Cost Center Management** - Manage cost centers
- **Asset Management** - Track financial assets
- **Liability Management** - Manage financial liabilities
- **Tax Management** - Manage tax obligations
- **Financial Alerts** - Set up financial alerts
- **Financial Calendar** - Track financial events
- **Financial Document Management** - Manage financial documents

---

## Team Management Features

### Team Organization
- **Team Creation** - Create and configure teams
- **Team Hierarchy** - Establish team hierarchies
- **Team Roles** - Define roles within teams
- **Team Permissions** - Set team-level permissions
- **Team Member Management** - Add/remove team members
- **Team Settings** - Configure team settings
- **Team Templates** - Use templates for common team structures
- **Team Analytics** - Analyze team performance
- **Team Search** - Search for teams and members
- **Team Directory** - Browse team directory
- **Team Export** - Export team information
- **Team History** - Track team changes

### Collaboration Tools
- **Team Chat** - Real-time team communication
- **Discussion Boards** - Threaded discussions
- **Shared Documents** - Collaborative document editing
- **Task Assignment** - Assign tasks to team members
- **Project Collaboration** - Collaborate on projects
- **Knowledge Sharing** - Share knowledge within teams
- **Team Calendar** - Shared team calendar
- **Team Meetings** - Schedule and manage meetings
- **Activity Feeds** - Track team activity
- **Comment Systems** - Comment on work items
- **Feedback Tools** - Provide team feedback
- **Collaborative Editing** - Edit content collaboratively

### Workflow Management
- **Workflow Creation** - Create custom workflows
- **Workflow Templates** - Use templates for common workflows
- **Task Management** - Manage tasks within workflows
- **Status Tracking** - Track workflow status
- **Workflow Assignments** - Assign workflow responsibilities
- **Workflow Notifications** - Notify about workflow events
- **Workflow Analytics** - Analyze workflow performance
- **Workflow Optimization** - Improve workflow efficiency
- **Workflow Integration** - Integrate with external systems
- **Workflow Export** - Export workflow data
- **Workflow History** - Track workflow changes
- **Workflow Visualization** - Visualize workflow progress

### Team Analytics
- **Team Performance Metrics** - Measure team performance
- **Team Activity Analysis** - Analyze team activity
- **Workload Analysis** - Analyze team workload
- **Collaboration Analysis** - Analyze collaboration patterns
- **Efficiency Metrics** - Measure team efficiency
- **Contribution Analysis** - Analyze individual contributions
- **Team Comparison** - Compare team performance
- **Team Trend Analysis** - Analyze team trends
- **Team Health Metrics** - Measure team health
- **Resource Utilization** - Analyze resource usage
- **Team Reporting** - Generate team reports
- **Team Benchmarking** - Benchmark against standards

---

## Synchronization Features

### Music Sync Licensing
- **Sync License Management** - Manage synchronization licenses
- **Sync Opportunity Listings** - List sync opportunities
- **Sync Marketplace** - Marketplace for sync deals
- **Sync Deal Management** - Manage synchronization deals
- **Sync License Templates** - Templates for sync licenses
- **Sync Rights Verification** - Verify rights for sync usage
- **Sync Usage Tracking** - Track synchronization usage
- **Sync Revenue Management** - Manage sync revenue
- **Sync Analytics** - Analyze sync performance
- **Sync Deal Search** - Search for sync opportunities
- **Sync Negotiations** - Facilitate sync negotiations
- **Sync Partner Management** - Manage sync partnerships

### Visual Media Integration
- **Film Integration** - Integration with film production
- **TV Integration** - Integration with television
- **Advertising Integration** - Integration with advertising
- **Game Integration** - Integration with video games
- **Visual Project Management** - Manage visual media projects
- **Music Supervision Tools** - Tools for music supervisors
- **Visual Media Templates** - Templates for visual media
- **Media Matching** - Match music to visual content
- **Visual Timeline Integration** - Integrate with visual timelines
- **Media Approval Workflows** - Workflows for media approval
- **Visual Media Analytics** - Analyze visual media usage
- **Visual Media Reporting** - Report on visual media projects

### Sync Rights Management
- **Sync Rights Registration** - Register sync rights
- **Sync Rights Verification** - Verify sync rights
- **Sync Rights Search** - Search for sync rights
- **Sync License Generation** - Generate sync licenses
- **Sync Rights Analytics** - Analyze sync rights usage
- **Territory-Based Rights** - Manage rights by territory
- **Sync Usage Tracking** - Track sync usage
- **Sync Rights Expiration** - Manage rights expiration
- **Sync Rights Renewal** - Renew sync rights
- **Sync Rights Conflict Resolution** - Resolve rights conflicts
- **Sync Rights History** - Track rights history
- **Sync Rights Reporting** - Generate rights reports

### Sync Pitching
- **Pitch Creation** - Create music pitches
- **Pitch Templates** - Templates for common pitches
- **Pitch Submission** - Submit pitches to opportunities
- **Pitch Tracking** - Track pitch status
- **Pitch Analytics** - Analyze pitch performance
- **Pitch Feedback** - Collect pitch feedback
- **Batch Pitching** - Pitch multiple tracks
- **Pitch Customization** - Customize pitches for opportunities
- **Pitch Collaboration** - Collaborate on pitches
- **Pitch Presentation** - Create pitch presentations
- **Pitch History** - Track pitch history
- **Pitch Reporting** - Generate pitch reports

---

This catalog serves as a comprehensive reference for all features in the TuneMantra platform. Each feature is organized by category and includes a brief description to provide context. For more detailed information on specific features, refer to the linked documentation.

*Last Updated: March 26, 2025*

---

## documentation/features/feature-guide.md

# TuneMantra Feature Guide

*Version: 1.0.0 (March 27, 2025)*

## Table of Contents

- [Introduction](#introduction)
- [Core Platform Components](#core-platform-components)
- [User Management Features](#user-management-features)
- [Organization Management Features](#organization-management-features)
- [Content Management Features](#content-management-features)
- [Distribution Management Features](#distribution-management-features)
- [Rights Management Features](#rights-management-features)
- [Royalty Management Features](#royalty-management-features)
- [Financial Management Features](#financial-management-features)
- [Analytics and Reporting Features](#analytics-and-reporting-features)
- [Integration Features](#integration-features)
- [Additional Features](#additional-features)

## Introduction

TuneMantra is a comprehensive multi-tenant music distribution platform designed to help artists, labels, and distributors manage their music catalog, distribute content to digital service providers (DSPs), manage rights, track royalties, and analyze performance data.

This document provides an overview of all the implemented features in the TuneMantra platform, organized by functional area.

## Core Platform Components

The TuneMantra platform consists of these core components:

### Web Application
- Single-page React application with responsive design
- Role-based user interfaces
- Real-time data updates
- Comprehensive dashboard views

### API Gateway
- Central entry point for all client requests
- Authentication and authorization
- Request validation
- Rate limiting
- Request routing

### Backend Services
- Microservices architecture
- Business logic implementation
- Data processing
- External integrations

### Data Storage
- PostgreSQL database for relational data
- Redis for caching and temporary data
- S3-compatible storage for media assets
- Elasticsearch for search and analytics

## User Management Features

### User Authentication
- Username/password authentication
- Multi-factor authentication
- Single sign-on (SSO) capabilities
- Password reset functionality
- Session management

### User Profile Management
- User profile creation and editing
- Contact information management
- Communication preferences
- Password management
- Account deactivation

### User Roles and Permissions
- Role-based access control
- Custom permission sets
- Organization-specific roles
- Resource-level permissions
- Role assignment management

### User Activity Tracking
- Login history
- Action auditing
- User session tracking
- Security event logging
- Activity reports

## Organization Management Features

### Organization Administration
- Organization creation and configuration
- Organization profile management
- Branding customization
- Organization settings management
- Organization structure management

### Multi-Tenant Architecture
- Complete data isolation between organizations
- Shared infrastructure with isolated data
- Organization-specific configurations
- Cross-organization capabilities for distributors
- White-label capabilities

### Organization Hierarchy
- Parent-child organization relationships
- Sub-label management
- Imprint management
- Organization group reporting
- Cross-organization reporting

### Organization User Management
- User assignment to organizations
- Organization-specific role assignment
- User invitation system
- Access management
- User removal

## Content Management Features

### Catalog Management
- Release creation and management
- Track management
- Artist information management
- Album/single/EP classification
- Release scheduling

### Metadata Management
- Comprehensive metadata fields
- Metadata validation
- Bulk metadata editing
- Metadata templates
- Metadata import/export

### Media Asset Management
- Audio file management
- Cover art management
- Promotional image management
- Media quality validation
- Asset version control

### Content Workflow
- Content creation workflow
- Review and approval processes
- Content status tracking
- Release preparation checklist
- Content update management

### Content Search and Discovery
- Full-text search capabilities
- Advanced filtering options
- Saved searches
- Recent content access
- Content categorization

## Distribution Management Features

### DSP Management
- Support for 150+ digital service providers
- DSP-specific delivery specifications
- DSP account management
- DSP delivery credentials
- DSP status monitoring

### Distribution Planning
- Release scheduling
- Territory selection
- DSP selection
- Pre-order configuration
- Release date management

### Distribution Execution
- Automated content delivery
- Delivery status tracking
- Delivery confirmation
- Error handling and resolution
- Delivery retries

### Takedown Management
- Content takedown requests
- Partial takedowns (territory/DSP specific)
- Takedown scheduling
- Takedown confirmation
- Takedown reporting

### Distribution Reporting
- Delivery status reports
- Live status tracking
- Distribution history
- Error reports
- DSP availability confirmation

## Rights Management Features

### Rights Definition
- Rights type classification
- Territory-specific rights
- Rights duration management
- Rights ownership documentation
- Rights history tracking

### Ownership Management
- Rights holder management
- Ownership percentage configuration
- Split sheet management
- Ownership documentation
- Ownership history tracking

### Rights Conflicts
- Conflict detection
- Conflict resolution workflow
- Dispute documentation
- Resolution tracking
- Rights verification

### Licensing Management
- License type configuration
- License terms management
- License renewal tracking
- License agreement documentation
- License territory management

## Royalty Management Features

### Royalty Configuration
- Royalty rate definition
- Split configuration
- Territory-specific rates
- DSP-specific rates
- Minimum guarantee configuration

### Revenue Import
- DSP revenue data import
- Revenue data validation
- Revenue data normalization
- Historical revenue management
- Revenue source tracking

### Royalty Calculation
- Automated royalty calculations
- Split application
- Fee and deduction processing
- Exchange rate handling
- Tax withholding calculation

### Statement Generation
- Royalty statement creation
- Statement delivery
- Statement history
- Statement reconciliation
- Statement corrections

## Financial Management Features

### Payment Processing
- Payment batch creation
- Payment method management
- Payment execution
- Payment confirmation
- Payment history tracking

### Financial Reporting
- Revenue reports
- Royalty reports
- Payment reports
- Financial dashboards
- Customizable financial reports

### Tax Management
- Tax rate configuration
- Withholding tax management
- Tax documentation
- Tax reporting
- Tax compliance monitoring

### Financial Controls
- Payment approval workflows
- Financial reconciliation tools
- Audit trails
- Financial security controls
- Fraud detection

## Analytics and Reporting Features

### Performance Analytics
- Content performance tracking
- Trend analysis
- Comparative performance
- Performance forecasting
- Audience demographics

### Revenue Analytics
- Revenue trend analysis
- Revenue source analysis
- Revenue projection
- Revenue comparison
- Revenue anomaly detection

### Operational Analytics
- System usage statistics
- User activity analysis
- Workflow efficiency metrics
- Process bottleneck identification
- Operational improvement recommendations

### Custom Reporting
- Report builder
- Scheduled reports
- Report sharing
- Report export
- Report templates

### Dashboards
- Executive dashboards
- Operational dashboards
- Financial dashboards
- Content dashboards
- Customizable dashboards

## Integration Features

### API Access
- RESTful API endpoints
- API authentication
- API documentation
- API rate limiting
- API versioning

### Webhook Support
- Event-based notifications
- Webhook configuration
- Webhook delivery monitoring
- Webhook security
- Delivery retry mechanisms

### Data Import/Export
- Bulk data import capabilities
- Data export functionality
- Scheduled data exports
- Export format options
- Data transformation options

### Third-Party Integrations
- Accounting system integration
- Payment processor integration
- CRM integration
- Marketing platform integration
- Analytics platform integration

## Additional Features

### System Administration
- System configuration
- Feature enablement
- System monitoring
- Performance tuning
- Maintenance scheduling

### Security Features
- Data encryption
- Access controls
- Security monitoring
- Vulnerability management
- Compliance management

### Notification System
- Email notifications
- In-app notifications
- Notification preferences
- Notification history
- Notification templates

### Audit and Compliance
- Activity logging
- Change tracking
- Compliance reporting
- Audit trails
- Data retention management

### Help and Support
- In-app documentation
- Context-sensitive help
- Support ticket creation
- Knowledge base
- Training resources

---

This feature guide provides an overview of the currently implemented capabilities in the TuneMantra platform. For detailed documentation on each feature, please refer to the specific documentation sections in this repository.

For information about potential future expansions, see the [Theoretical Expansions](/documentation/theoretical_expansions/README.md) documentation.

---

© 2023-2025 TuneMantra. All rights reserved.

---

## documentation/guides/README.md

# TuneMantra Guides

This section contains step-by-step guides for common tasks and workflows in the TuneMantra platform.

## Quick Start Guides

- [User Quick Start](quickstart/user-quickstart.md) - Get started as a platform user
- [Developer Quick Start](quickstart/developer-quickstart.md) - Get started as a developer
- [Admin Quick Start](quickstart/admin-quickstart.md) - Get started as a platform administrator

## User Task Guides

- [Content Upload Guide](tasks/content-upload.md) - How to upload content
- [Rights Registration Guide](tasks/rights-registration.md) - How to register rights
- [Distribution Setup Guide](tasks/distribution-setup.md) - How to set up distribution
- [Analytics Report Generation](tasks/analytics-report.md) - How to generate analytics reports

## Developer Task Guides

- [API Integration Guide](development/api-integration.md) - How to integrate with the API
- [Feature Development Guide](development/feature-development.md) - How to develop new features
- [Testing Guide](development/testing.md) - How to test the platform
- [Deployment Guide](development/deployment.md) - How to deploy the platform

## Administrative Task Guides

- [User Management Guide](administration/user-management.md) - How to manage users
- [Content Approval Guide](administration/content-approval.md) - How to approve content
- [System Monitoring Guide](administration/monitoring.md) - How to monitor the system
- [Backup and Recovery Guide](administration/backup-recovery.md) - How to perform backups

## Workflow Guides

- [Content Distribution Workflow](workflows/distribution-workflow.md) - End-to-end distribution process
- [Rights Management Workflow](workflows/rights-workflow.md) - Rights management process
- [Royalty Calculation Workflow](workflows/royalty-workflow.md) - Royalty calculation process
- [Dispute Resolution Workflow](workflows/dispute-workflow.md) - Dispute resolution process

---

## documentation/metadata/DOCUMENTATION_SYSTEMS.md

# TuneMantra Documentation Systems

This document explains the organization and purpose of TuneMantra's dual documentation systems and provides guidance on when to use each system.

## Two Complementary Documentation Systems

TuneMantra's documentation is maintained in two different but complementary forms:

1. **Directory-based Documentation** (`documentation/` directory)
2. **Comprehensive Documentation** (`TuneMantra_Comprehensive_Documentation.md`)

Each system serves different purposes and has different strengths. Together, they provide a complete documentation solution that addresses different user needs.

## Directory-based Documentation

### Structure and Organization

The directory-based documentation is organized into a logical hierarchy of directories and files. Each file focuses on a specific topic, and directories group related topics together.

The top-level directories include:

- `admin/` - Administration and deployment documentation
- `developer/` - Technical documentation for developers
- `user/` - User guides and documentation
- `technical/` - Technical specifications and implementation details
- `reference/` - API reference and other reference materials
- And several others for specific aspects of the platform

### Purpose and Use Cases

The directory-based documentation is designed for:

- **Daily reference**: Finding specific information quickly during active development
- **Onboarding**: Helping new team members understand the project structure
- **Structured learning**: Progressing through documentation in a logical order
- **Task-oriented documentation**: Finding how to accomplish specific tasks

### When to Use

Use the directory-based documentation when:

- You need specific information about a particular aspect of the platform
- You're actively working on the platform and need quick reference
- You want to understand the current state of a system or feature
- You prefer to navigate through a structured hierarchy of topics

## Comprehensive Documentation

### Structure and Organization

The comprehensive documentation is a single markdown file containing all historical documentation for TuneMantra. It's organized into 16 major sections, each covering a broad area of the platform.

The main sections include:

1. Project Overview
2. System Architecture
3. Blockchain Technology
4. Rights Management
5. Database Schema
6. API Reference
7. And 10 other major platform areas

### Purpose and Use Cases

The comprehensive documentation serves as:

- **Historical archive**: A complete record of all documentation created for the project
- **Full-text searchable resource**: Ability to search across all documentation at once
- **Context preservation**: Maintains original documentation context and organization
- **Reference for evolution**: Shows how systems have evolved over time

### When to Use

Use the comprehensive documentation when:

- You want to search across all documentation at once
- You need historical context for design decisions
- You're researching the evolution of a feature or system
- You need to access legacy information that may not be in the current directory-based docs

## Navigation Between Systems

The [Master Index](../MASTER_INDEX.md) serves as a bridge between the two documentation systems, providing cross-references that allow you to find corresponding information in each system.

## Documentation Maintenance Guidelines

### Updating Existing Documentation

When updating documentation:

1. **Always update the directory-based documentation first** - This ensures the most current information is in the structured documentation.

2. **Consider both systems** - For significant changes, think about whether the comprehensive documentation should be updated or if a cross-reference between systems is sufficient.

3. **Use the documentation tools** - The content comparison tool can help identify gaps between the two systems.

### Adding New Documentation

When adding new documentation:

1. **Add to the directory-based structure first** - Place new documentation in the appropriate directory based on its topic.

2. **Update navigation** - Ensure new documentation is referenced from appropriate README files and indexes.

3. **Consider updating the Master Index** - For significant new content, add appropriate cross-references to the Master Index.

## Content Comparison Tool

A utility script is available to help maintain consistency between both documentation systems:

```bash
node scripts/utils/doc_content_comparison.js
```

This tool:

1. Identifies unique content that exists in the comprehensive documentation but not in the directory-based documentation
2. Identifies unique content that exists in the directory-based documentation but not in the comprehensive documentation
3. Generates reports to help documentation maintainers ensure completeness

## Future Documentation Evolution

As the TuneMantra platform evolves, the documentation systems may need to evolve as well. Potential future improvements include:

1. **Automated cross-referencing** - Tools to automatically generate and maintain cross-references between the two systems
2. **Interactive navigation** - Enhanced navigation tools to move between systems seamlessly
3. **Content synchronization** - Automated tools to help keep both systems in sync
4. **Versioned documentation** - Version control for documentation to track changes over time

For questions or suggestions about the documentation systems, please contact the documentation team.

---

## documentation/metadata/README.md

# Documentation Metadata

This directory contains metadata about the TuneMantra documentation system itself, including structure, organization, and versioning information.

## Contents

- [Documentation Structure](documentation-structure.md) - Original documentation structure
- [Updated Documentation Structure](documentation-updated-structure.md) - Current documentation structure
- [Reorganization Summary](REORGANIZATION_SUMMARY.md) - Summary of the documentation reorganization process


---

## documentation/metadata/REORGANIZATION_SUMMARY.md

# Documentation Reorganization Summary

This document summarizes the reorganization of TuneMantra's documentation structure completed on March 30, 2025.

## Overview

The goal of this reorganization was to establish a well-structured, hierarchical documentation system that organizes all documentation files into logical categories while maintaining accessibility and cross-references.

## Key Changes

1. **Established Hierarchical Structure**: Created a comprehensive directory structure with specialized folders for different aspects of the platform (admin, developer, technical, user, etc.)

2. **Organized Root-Level Files**: Moved documentation files from the root directory into appropriate topic-based folders:
   - Project documentation (codebase analysis, implementation plans) → `documentation/project/`
   - Testing documentation (test plans, testing guides) → `documentation/testing/`
   - Documentation structure files → `documentation/metadata/`

3. **Technical Documentation Organization**: Created specialized subdirectories within the technical documentation area:
   - Blockchain documentation → `documentation/technical/blockchain/`
   - Rights management documentation → `documentation/technical/rights_management/`
   - Audio processing documentation → `documentation/technical/audio/`
   - And many others...

4. **Created Navigation Aids**:
   - Added README files in each directory with context and navigation information
   - Created a root files index to track the movement of documentation files
   - Updated main documentation README with references to new sections

5. **Completed Clean Migration**:
   - Moved all files from the root directory to their appropriate locations in the documentation structure
   - Updated all references to point to the new file locations

## Directory Structure

The complete documentation directory structure now includes:

- `documentation/`
  - `admin/` - Administration and deployment documentation
  - `developer/` - Technical documentation for developers
  - `user/` - User guides and documentation
  - `technical/` - Implementation details and specifications
  - `reference/` - API reference and other reference materials
  - `diagrams/` - Visual representations of system architecture
  - `guides/` - Step-by-step guides for common tasks
  - `resources/` - Additional resources and templates
  - `project/` - Project-level documentation (code evolution, implementation plans)
  - `testing/` - Testing strategies, plans, and guides
  - `metadata/` - Documentation about the documentation structure itself

## File Movement Summary

See the [Root Files Index](../ROOT_FILES_INDEX.md) for a detailed mapping of which files were moved and to which locations.

## Future Recommendations

1. **Update References**: Update any remaining references to the original file locations to point to the new structure.

2. **Use README Files**: Continue to maintain README files in each directory to provide context and navigation.

3. **Maintain the Structure**: Follow the established structure when adding new documentation.

4. **Archive Old Versions**: Consider archiving obsolete documentation rather than deleting it.

5. **Document Updates**: Keep the metadata documentation updated with any structural changes.

## Conclusion

This reorganization has established a clean, intuitive documentation structure that will scale with the project's growth while maintaining accessibility to all existing content.

---

## documentation/metadata/documentation-structure.md

documentation/admin/deployment.md
documentation/admin/platform-management.md
documentation/admin/README.md
documentation/developer/code-style.md
documentation/developer/coding-standards.md
documentation/developer/contributing.md
documentation/developer/development-workflow.md
documentation/developer/getting-started.md
documentation/developer/handoff-guide.md
documentation/developer/installation-guide.md
documentation/developer/onboarding-guide.md
documentation/developer/README.md
documentation/developer/repository-documentation.md
documentation/developer/testing.md
documentation/developer/testing-strategy.md
documentation/diagrams/README.md
documentation/features/feature-catalog.md
documentation/features/feature_catalog.md
documentation/features/feature_guide.md
documentation/features/README.md
documentation/guides/quickstart/developer-quickstart.md
documentation/guides/README.md
documentation/README.md
documentation/reference/api/api-reference.md
documentation/reference/glossary.md
documentation/reference/README.md
documentation/resources/README.md
documentation/technical/advanced/README.md
documentation/technical/analytics/analytics-system.md
documentation/technical/analytics/README.md
documentation/technical/api/api-docs.md
documentation/technical/api/api-reference.md
documentation/technical/api/README.md
documentation/technical/architecture/comprehensive_architecture.md
documentation/technical/architecture/comprehensive-system-architecture.md
documentation/technical/architecture/README.md
documentation/technical/audio/audio-fingerprinting.md
documentation/technical/audio/README.md
documentation/technical/blockchain/implementation-guide.md
documentation/technical/blockchain/integration-guide.md
documentation/technical/blockchain/overview-architecture.md
documentation/technical/blockchain/README.md
documentation/technical/blockchain/smart-contracts.md
documentation/technical/blockchain/testing-guide.md
documentation/technical/comprehensive-system-architecture.md
documentation/technical/core/backend.md
documentation/technical/core/frontend.md
documentation/technical/core/README.md
documentation/technical/database/database-schema.md
documentation/technical/database/data-models.md
documentation/technical/database/migrations.md
documentation/technical/database/optimization.md
documentation/technical/database/README.md
documentation/technical/database-schema.md
documentation/technical/distribution/distribution-system.md
documentation/technical/distribution/manual-distribution.md
documentation/technical/distribution/README.md
documentation/technical/IMPLEMENTATION_ROADMAP.md
documentation/technical/integration/README.md
documentation/technical/operations/deployment-guide.md
documentation/technical/operations/README.md
documentation/technical/operations/security-procedures.md
documentation/technical/platforms/mobile-application.md
documentation/technical/platforms/mobile-application-technical-specification.md
documentation/technical/platforms/multi-tenant-system.md
documentation/technical/platforms/README.md
documentation/technical/README.md
documentation/technical/repository/documentation-archive-index.md
documentation/technical/rights_management/README.md
documentation/technical/rights_management/royalty-management-system.md
documentation/technical/royalty/README.md
documentation/technical/security/authentication.md
documentation/technical/security-model.md
documentation/technical/security/README.md
documentation/technical/security/security.md
documentation/technical/security/security-model.md
documentation/technical/services/advanced-analytics-export.md
documentation/technical/services/ai-metadata-enhancement.md
documentation/technical/services/analytics-service.md
documentation/technical/services/blockchain-integration.md
documentation/technical/services/collaborative-rights-management.md
documentation/technical/services/content-management.md
documentation/technical/services/distribution-service.md
documentation/technical/services/integration-service.md
documentation/technical/services/README.md
documentation/technical/services/rights-management-service.md
documentation/technical/services/user-management.md
documentation/user/account-settings-guide.md
documentation/user/administration-guide.md
documentation/user/analytics-guide.md
documentation/user/artist-guide.md
documentation/user/audio-fingerprinting-guide.md
documentation/user/distribution-guide.md
documentation/user/getting-started.md
documentation/user/label-guide.md
documentation/user/README.md
documentation/user/reporting-guide.md
documentation/user/rights-management-guide.md
documentation/user/royalty-management-guide.md
documentation/user/user_guide.md


---

## documentation/metadata/documentation-updated-structure.md

documentation/admin/deployment.md
documentation/admin/platform-management.md
documentation/admin/README.md
documentation/developer/code-style.md
documentation/developer/coding-standards.md
documentation/developer/contributing.md
documentation/developer/development-workflow.md
documentation/developer/getting-started.md
documentation/developer/handoff-guide.md
documentation/developer/installation-guide.md
documentation/developer/onboarding-guide.md
documentation/developer/README.md
documentation/developer/repository-documentation.md
documentation/developer/testing.md
documentation/developer/testing-strategy.md
documentation/diagrams/README.md
documentation/features/feature-catalog.md
documentation/features/feature-guide.md
documentation/features/README.md
documentation/guides/quickstart/developer-quickstart.md
documentation/guides/README.md
documentation/README.md
documentation/reference/api/api-reference.md
documentation/reference/glossary.md
documentation/reference/README.md
documentation/resources/README.md
documentation/technical/advanced/README.md
documentation/technical/analytics/analytics-system.md
documentation/technical/analytics/README.md
documentation/technical/api/api-docs.md
documentation/technical/api/api-reference.md
documentation/technical/api/README.md
documentation/technical/architecture/comprehensive-system-architecture.md
documentation/technical/architecture/README.md
documentation/technical/audio/audio-fingerprinting.md
documentation/technical/audio/README.md
documentation/technical/blockchain/implementation-guide.md
documentation/technical/blockchain/integration-guide.md
documentation/technical/blockchain/overview-architecture.md
documentation/technical/blockchain/README.md
documentation/technical/blockchain/smart-contracts.md
documentation/technical/blockchain/testing-guide.md
documentation/technical/core/backend.md
documentation/technical/core/frontend.md
documentation/technical/core/README.md
documentation/technical/database/database-schema.md
documentation/technical/database/data-models.md
documentation/technical/database/migrations.md
documentation/technical/database/optimization.md
documentation/technical/database/README.md
documentation/technical/database-schema.md
documentation/technical/distribution/distribution-system.md
documentation/technical/distribution/manual-distribution.md
documentation/technical/distribution/README.md
documentation/technical/IMPLEMENTATION_ROADMAP.md
documentation/technical/integration/README.md
documentation/technical/operations/deployment-guide.md
documentation/technical/operations/README.md
documentation/technical/operations/security-procedures.md
documentation/technical/platforms/mobile-application.md
documentation/technical/platforms/mobile-application-technical-specification.md
documentation/technical/platforms/multi-tenant-system.md
documentation/technical/platforms/README.md
documentation/technical/README.md
documentation/technical/repository/documentation-archive-index.md
documentation/technical/rights_management/README.md
documentation/technical/rights_management/royalty-management-system.md
documentation/technical/royalty/README.md
documentation/technical/security/authentication.md
documentation/technical/security/README.md
documentation/technical/security/security-model.md
documentation/technical/security/security-overview.md
documentation/technical/services/advanced-analytics-export.md
documentation/technical/services/ai-metadata-enhancement.md
documentation/technical/services/analytics-service.md
documentation/technical/services/blockchain-integration.md
documentation/technical/services/collaborative-rights-management.md
documentation/technical/services/content-management.md
documentation/technical/services/distribution-service.md
documentation/technical/services/integration-service.md
documentation/technical/services/README.md
documentation/technical/services/rights-management-service.md
documentation/technical/services/user-management.md
documentation/user/account-settings-guide.md
documentation/user/administration-guide.md
documentation/user/analytics-guide.md
documentation/user/artist-guide.md
documentation/user/audio-fingerprinting-guide.md
documentation/user/distribution-guide.md
documentation/user/getting-started.md
documentation/user/label-guide.md
documentation/user/README.md
documentation/user/reporting-guide.md
documentation/user/rights-management-guide.md
documentation/user/royalty-management-guide.md
documentation/user/user-guide.md


---

## documentation/project/README.md

# TuneMantra Project Documentation

This directory contains project-level documentation for TuneMantra, including implementation plans, code evolution analyses, and project roadmaps.

## Contents

- [Codebase Comparison](codebase-comparison.md) - Analysis of codebase differences across branches
- [Code Evolution Analysis](comprehensive-code-evolution.md) - Detailed analysis of code evolution
- [Implementation Plan](implementation-plan.md) - Step-by-step implementation strategy


---

## documentation/project/codebase-comparison.md

# TuneMantra Codebase Evolution Analysis

This document provides an accurate, code-based analysis of TuneMantra's evolution across branches, examining specific code implementations and technical patterns.

## Branch Sequence

The comparison follows the chronological branch sequence:

1. PPv1 (Initial platform planning)
2. 3march (Early March development)
3. 8march258 (March 8 development)
4. 12march547 (March 12 development)
5. 17032025 (March 17 development)
6. 190320250630 (March 19 development)
7. Current (Latest codebase)

## Database Schema Evolution

### Documentation Patterns

**PPv1**: Comprehensive documentation with detailed comments:
```typescript
/**
 * Database Schema Definition
 * 
 * This file defines the structure of our PostgreSQL database using Drizzle ORM.
 * The schema defines tables, columns, relationships, and types for our database.
 * 
 * Key concepts:
 * - pgTable: Creates a new database table
 * - pgEnum: Creates a PostgreSQL enum type (a list of allowed values)
 * - Relations: Defines how tables are connected to each other
 * - Zod schemas: Provides validation for data insertion
 */
```

**3march**: Significantly reduced documentation:
```typescript
import { relations } from "drizzle-orm";
import { pgTable, serial, text, timestamp, integer, boolean, json, pgEnum, numeric } from "drizzle-orm/pg-core";
import { z } from "zod";
import { createInsertSchema } from "drizzle-zod";

// Define user role enum for access control
export const userRoleEnum = pgEnum('user_role', [
  'admin',             // Complete system access (platform owner)
  'label',             // Manage label settings, create sub-labels (6000 INR/year)
  // Other roles...
]);
```

**190320250630**: Reintroduced comprehensive documentation:
```typescript
/**
 * Database Schema Definition
 * 
 * This file defines the structure of our PostgreSQL database using Drizzle ORM.
 * The schema defines tables, columns, relationships, and types for our database.
 * 
 * Key concepts:
 * - pgTable: Creates a new database table
 * - pgEnum: Creates a PostgreSQL enum type (a list of allowed values)
 * - Relations: Defines how tables are connected to each other
 * - Zod schemas: Provides validation for data insertion
 */
```

### Critical Schema Changes

**12march547**: Removed SuperAdmin table in favor of consolidated roles:
```diff
- // Super Admin Schema
- export const superAdmins = pgTable("super_admins", {
-   id: serial("id").primaryKey(),
-   username: text("username").notNull().unique(),
-   password: text("password").notNull(),
-   email: text("email").notNull(),
-   createdAt: timestamp("created_at").defaultNow(),
-   lastLogin: timestamp("last_login"),
- });
- 
- export type SuperAdmin = typeof superAdmins.$inferSelect;
- export type InsertSuperAdmin = typeof superAdmins.$inferInsert;

+ // Note: SuperAdmin table has been removed in favor of consolidated 'admin' role
+ // All administrator accounts are now managed through the users table with role='admin'
```

**17032025**: Added complex rights management tables:
```typescript
export const rightsCollaborations = pgTable("rights_collaborations", {
  id: serial("id").primaryKey(),
  rightId: integer("right_id").notNull(),
  collaboratorId: integer("collaborator_id").notNull(),
  contributionType: text("contribution_type").notNull(), // "composer", "lyricist", etc.
  sharePercentage: numeric("share_percentage").notNull(),
  status: text("status").notNull().default("pending"),
  approvalDate: timestamp("approval_date"),
  approvedById: integer("approved_by_id"),
  approvalWorkflow: json("approval_workflow").notNull(), // Tracks the approval steps
  blockchainReference: text("blockchain_reference"),
  createdAt: timestamp("created_at").notNull().defaultNow(),
  updatedAt: timestamp("updated_at").notNull().defaultNow(),
});
```

**190320250630**: Added comprehensive royalty management:
```typescript
export const royaltyCalculations = pgTable("royalty_calculations", {
  id: serial("id").primaryKey(),
  // Foreign keys for related data
  distributionRecordId: integer("distribution_record_id").notNull(),
  releaseId: integer("release_id").notNull(),
  trackId: integer("track_id").notNull(),
  userId: integer("user_id").notNull(),
  
  // Calculation financial data
  amount: numeric("amount").notNull(), // calculated royalty amount
  streamCount: integer("stream_count").notNull().default(0), // number of streams
  ratePerStream: numeric("rate_per_stream"), // calculated rate
  
  // Additional fields...
});
```

**Current**: Changed 'sharePercentage' to 'splitPercentage' for consistency:
```diff
export const revenueShares = pgTable("revenue_shares", {
  id: serial("id").primaryKey(),
  releaseId: integer("release_id").notNull(),
  userId: integer("user_id").notNull(),
-  sharePercentage: numeric("share_percentage").notNull(),
+  splitPercentage: numeric("split_percentage").notNull(),
  isConfirmed: boolean("is_confirmed").notNull().default(false),
  createdAt: timestamp("created_at").notNull().defaultNow(),
  updatedAt: timestamp("updated_at").notNull().defaultNow(),
});
```

**Current**: Added event tracking to analytics:
```diff
export const analytics = pgTable("analytics", {
  id: serial("id").primaryKey(),
  trackId: integer("track_id").notNull(),
+  releaseId: integer("release_id"),
  date: timestamp("date").notNull(),
  platform: text("platform").notNull(),
  streams: integer("streams").notNull().default(0),
  revenue: numeric("revenue").notNull().default("0"),
-  country: text("country").notNull(),
-  city: text("city").notNull(),
+  country: text("country").default("unknown"),
+  city: text("city").default("unknown"),
  playlistAdds: integer("playlist_adds").default(0),
  saves: integer("saves").default(0),
  shares: integer("shares").default(0),
  avgPlayTime: numeric("avg_play_time").default("0"),
+  event: text("event"),
+  eventDetails: json("event_details"),
  demographics: json("demographics").default({
    // Demographics structure
  }),
});
```

### Authentication Evolution

The authentication system (`server/auth.ts`) shows the following progression:

| Branch | Key Changes |
|--------|-------------|
| PPv1   | Comprehensive authentication with detailed comments explaining security, sessions, and login flow. |
| 3march | Simplified authentication with reduced documentation. Base functionality remained. |
| 8march258 | No significant changes from previous branch. |
| 12march547 | No significant changes from previous branch. |
| 17032025 | No significant changes from previous branch. |
| 190320250630 | Major enhancement: Reintroduced comprehensive documentation, new middleware for role-based access, enhanced security features, admin authentication flow. |
| Current | Small refinements to the latest authentication system, retaining core structure from 190320250630. |

### API Routes Evolution

The API routes (`server/routes.ts`) show the following progression:

| Branch | Key Changes |
|--------|-------------|
| PPv1   | Initial comprehensive API structure with well-documented routes organized by feature area. |
| 3march | Simplified route structure with core functionality. Reduced documentation. |
| 8march258 | Added new endpoints for analytics and metrics tracking. |
| 12march547 | Major expansion: Added extensive rights management, royalty calculation, and distribution endpoints. |
| 17032025 | Enhanced with AI-driven features, content analysis, and recommendation endpoints. |
| 190320250630 | Complete overhaul: Restructured with comprehensive middleware, validation, error handling. New endpoints for all platform features including blockchain integration. |
| Current | Refinements to latest API structure with performance optimizations and cleanup. |

### Frontend Components Evolution

The main frontend components (`client/src/App.tsx`) show the following progression:

| Branch | Key Changes |
|--------|-------------|
| PPv1   | Initial comprehensive UI structure with detailed comments on routing, authentication, layouts. |
| 3march | Simplified frontend structure. Stripped down to core functionality. |
| 8march258 | Added analytics dashboard components and performance metrics visualization. |
| 12march547 | Enhanced with rights management UI, royalty displays, and distribution tracking. |
| 17032025 | Added AI feature interfaces, content analysis tools, and recommendation systems. |
| 190320250630 | Complete UI overhaul: New design system, comprehensive component library, advanced user flows for all platform features. |
| Current | Refinements to UI with performance optimizations and accessibility improvements. |

## Feature Evolution

### Blockchain Integration

| Branch | Key Changes |
|--------|-------------|
| PPv1   | Conceptual planning only, no implementation. |
| 3march | Basic blockchain connectivity framework established. Initial setup of connector service. |
| 8march258 | Added initial smart contract interfaces. Integrated Ethers.js library for blockchain interactions. |
| 12march547 | Implemented rights tracking contracts and basic verification. Created NFT minting capabilities for tracks. |
| 17032025 | Enhanced with token-based ownership and verification system. Added multi-network support. |
| 190320250630 | Full integration with comprehensive rights management, ownership verification, and royalty distribution via blockchain. Implemented blockchain-based rights registration process with verification. |
| Current | Optimized blockchain interactions with better error handling and gas fee management. Added bulk operations and enhanced token management. |

#### Key Blockchain Features in Current Version:

1. **NFT Minting for Tracks**: API routes and services for creating NFTs representing music tracks on blockchain networks.

2. **Rights Verification with Blockchain**: System to verify copyright and usage rights through blockchain transactions.

3. **Multi-Network Support**: Integration with multiple blockchain networks (Ethereum, Polygon, etc.).

4. **Rights Registration with Blockchain**: Complete workflow for registering rights with blockchain verification.

5. **Wallet Connection**: API endpoints for connecting Web3 wallets to user accounts.

6. **Token Management**: System for creating and tracking tokens representing rights ownership.

Example blockchain routes:
```typescript
// Get supported blockchain networks
router.get('/networks', requireAuth, async (_req: Request, res: Response) => {...});

// Mint an NFT for a track
router.post('/mint-nft', requireAuth, validateRequest(mintNFTSchema), async (req: Request, res: Response) => {...});

// Get NFT details
router.get('/nft/:tokenId', requireAuth, async (req: Request, res: Response) => {...});

// Connect wallet
router.post('/connect-wallet', requireAuth, async (req: Request, res: Response) => {...});

// Verify rights with blockchain
router.post('/verify-rights', requireAuth, validateRequest(verifyRightsSchema), async (req: Request, res: Response) => {...});

// Register rights with blockchain (combined operation)
router.post('/register-rights', requireAuth, validateRequest(registerRightsSchema), async (req: Request, res: Response) => {...});
```

### Rights Management

| Branch | Key Changes |
|--------|-------------|
| PPv1   | Basic conceptual model only. |
| 3march | Simple rights table structure. |
| 8march258 | Added attribution and ownership fields. |
| 12march547 | Comprehensive rights management system with inheritance and transfer capabilities. |
| 17032025 | Enhanced with collaborative rights management between multiple parties. |
| 190320250630 | Complete system with territorial rights, time-based expiration, and complex split arrangements. |
| Current | Optimized performance and added dispute resolution mechanisms. |

### Audio Processing

| Branch | Key Changes |
|--------|-------------|
| PPv1   | No implementation, conceptual only. |
| 3march | Basic audio metadata extraction. |
| 8march258 | Added waveform generation and basic fingerprinting. |
| 12march547 | Implemented advanced audio fingerprinting for copyright detection. |
| 17032025 | Enhanced with AI-driven audio analysis and feature extraction. |
| 190320250630 | Complete audio processing pipeline with quality assessment, mastering suggestions, and duplicate detection. |
| Current | Optimized processing with batch capabilities and parallel processing. |

### AI Components

| Branch | Key Changes |
|--------|-------------|
| PPv1   | No implementation, conceptual only. |
| 3march | No AI components. |
| 8march258 | Basic metadata enhancement suggestions. Initial OpenAI integration planning. |
| 12march547 | Added content-based recommendation framework. Implemented initial metadata tagging using AI. |
| 17032025 | Implemented comprehensive AI analysis for content, market fit, and audience matching. Added AI-driven audio analysis. |
| 190320250630 | Full AI suite with metadata enhancement, content analysis, audience prediction, and automated tagging. Integrated OpenAI API with structured response handling. |
| Current | Enhanced models with performance optimization and more accurate predictions. Added fallback mechanisms for when AI services are unavailable. |

#### Key AI Features in Current Version:

1. **Content Analysis and Tagging**: AI-powered system for analyzing tracks and automatically generating tags like genre, mood, themes, and languages.

2. **Quality Assessment**: AI evaluation of audio quality with suggestions for improvements.

3. **Metadata Enhancement**: Intelligent system for improving and standardizing track metadata.

4. **Content Moderation**: AI detection of explicit or problematic content with automatic warning generation.

5. **Audience Matching**: AI-driven analysis to match content with potential audience demographics.

6. **Mastering Suggestions**: AI-generated recommendations for mastering and production improvements.

Example AI analysis module:
```typescript
/**
 * Generate content tags and analysis using AI
 * 
 * This function:
 * 1. Takes basic information about a piece of content (title, artist, type)
 * 2. Sends this information to OpenAI's API for analysis
 * 3. Processes the response into structured metadata
 * 4. Returns standardized tags and analysis information
 */
export async function generateContentTags(
  title: string,
  artistName: string,
  type: "audio" | "video"
): Promise<{ tags: ContentTags; analysis: AIAnalysis }> {
  // Return default data if OpenAI API key is not configured
  if (!process.env.OPENAI_API_KEY) {
    console.log("OpenAI API key not configured, returning default analysis data");
    return mockAnalysis;
  }

  try {
    // Initialize OpenAI client with API key from environment
    const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
    
    // Request AI analysis from OpenAI
    const response = await openai.chat.completions.create({
      model: "gpt-4o",  // Using GPT-4o for enhanced media understanding
      messages: [
        // System prompt defines the AI's role and capabilities
        {
          role: "system",
          content: `You are an expert music and video content analyzer...`,
        },
        // User prompt contains the content information to analyze
        {
          role: "user",
          content: `Please analyze this ${type} content:\nTitle: ${title}\nArtist: ${artistName}`,
        },
      ],
      // Request JSON response format for reliable parsing
      response_format: { type: "json_object" },
    });

    // Process response...
  } catch (error) {
    // Log error and return fallback data
    return mockAnalysis;
  }
}
```

## Summary of Major Changes

The TuneMantra platform has evolved from a basic conceptual framework in PPv1 to a comprehensive music distribution system with advanced features:

1. **Database Evolution**: 
   - Started with basic tables and evolved to a complex schema supporting multi-tenant architecture
   - Added sophisticated rights management and financial tracking capabilities
   - Removed specialized tables (like SuperAdmin) in favor of role-based approach in consolidated tables
   - Enhanced analytics tracking with event-based monitoring
   - Added blockchain verification records and integration points

2. **Authentication System**: 
   - Progressed from simple login to comprehensive role-based access control
   - Enhanced security with better password handling and session management
   - Added detailed documentation in later branches after simplification in early branches
   - Implemented specialized authentication flows for different user types (artists, labels, admins)
   - Integrated with blockchain wallet authentication

3. **API Structure**: 
   - Expanded from basic CRUD operations to a rich API supporting all platform features
   - Implemented consistent validation, error handling, and response formatting
   - Added specialized endpoints for blockchain operations, rights management, and AI analysis
   - Structured routes by functional domain with proper middleware attachment
   - Added performance optimizations and security enhancements

4. **UI Development**: 
   - Advanced from a simple interface to a comprehensive design system
   - Created specialized dashboards for different user roles (artists, labels, admins)
   - Implemented visualizations for analytics and performance metrics
   - Added AI-powered content analysis interfaces
   - Integrated blockchain wallet connection and rights management UIs

5. **Advanced Feature Growth**:
   - **Blockchain Integration**:
     - Evolved from basic connectivity to full NFT minting and rights verification
     - Added support for multiple blockchain networks
     - Implemented token-based ownership tracking
     - Created comprehensive rights registration with blockchain verification

   - **Rights Management**:
     - Developed from simple attribution to complex territorial and time-based rights
     - Added support for multiple rights holders with percentage splits
     - Implemented inheritance and transfer capabilities 
     - Created dispute resolution mechanisms

   - **Audio Processing**:
     - Built comprehensive pipeline for audio analysis and fingerprinting
     - Added quality assessment and mastering suggestions
     - Implemented duplicate detection and copyright verification
     - Enhanced with batch processing capabilities

   - **AI Capabilities**:
     - Expanded from basic metadata suggestions to comprehensive content analysis
     - Added audience matching and predictive analytics
     - Implemented automated content tagging and categorization
     - Created fallback mechanisms for API unavailability

The current codebase represents a mature platform with all core features implemented and optimized for performance and usability. The evolution from PPv1 to the current version shows a logical progression of features, with each branch building upon the previous one to create an increasingly sophisticated system.

## Development Patterns & Best Implementation Recommendations

### Development Patterns Observed

Throughout the codebase evolution, several consistent patterns emerge:

1. **Documentation Cycles**: 
   - **Pattern**: Initial branches (PPv1) had comprehensive documentation which was significantly reduced in middle branches (3march, 8march258) before being reintroduced in later versions (190320250630).
   - **Evidence**: Multi-line JSDoc comments in PPv1 and 190320250630 versus minimal single-line comments in middle branches.

2. **Consolidation of Features**: 
   - **Pattern**: The team frequently refactored specialized implementations into more general-purpose solutions.
   - **Evidence**: SuperAdmin table removal in 12march547 in favor of role-based access in the users table.

3. **Progressive Feature Complexity**: 
   - **Pattern**: Features evolved from simple implementations to sophisticated systems with error handling and optimizations.
   - **Evidence**: Evolution of blockchain integration from basic connectivity in 3march to optimized gas fee management in Current.

4. **Security Enhancement Cycles**: 
   - **Pattern**: Authentication security was periodically strengthened throughout development.
   - **Evidence**: Password validation becoming increasingly sophisticated from 8march258 to Current.

5. **Performance Optimization Phase**: 
   - **Pattern**: Later branches (particularly Current) focus on performance improvements.
   - **Evidence**: Addition of caching, batch processing, and parallel execution in Current branch.

### Best Implementation Recommendations

Based on precise code analysis, here are the optimal implementations by component:

#### 1. Database Schema
**Recommendation**: Use Current branch schema with specific tables from 190320250630

**Implementation Details**:
```typescript
// Current branch analytics with event tracking
export const analytics = pgTable("analytics", {
  id: serial("id").primaryKey(),
  trackId: integer("track_id").notNull(),
  releaseId: integer("release_id"), // Current branch addition
  // Other fields...
  event: text("event"), // Current branch addition
  eventDetails: json("event_details"), // Current branch addition
});

// 190320250630 royalty tables
export const royaltyCalculations = pgTable("royalty_calculations", {
  id: serial("id").primaryKey(),
  // Comprehensive financial fields...
});

// Current branch split percentage naming
export const revenueShares = pgTable("revenue_shares", {
  // Fields...
  splitPercentage: numeric("split_percentage").notNull(), // Better naming from Current
});
```

#### 2. Authentication System
**Recommendation**: Use 190320250630 role system with Current's security enhancements

**Implementation Example**:
```typescript
// Current branch enhanced password validation
function validatePassword(password: string): boolean {
  if (password.length < 10) return false;
  if (!/[A-Z]/.test(password)) return false;
  if (!/[a-z]/.test(password)) return false;
  if (!/[0-9]/.test(password)) return false;
  if (!/[^A-Za-z0-9]/.test(password)) return false;
  return true;
}

// 190320250630 role-based access control
function hasPermission(userRole: string, requiredPermission: string): boolean {
  const permissions = {
    admin: ['all'],
    label: ['manage_label', 'view_analytics', /* other permissions */],
    // Other roles...
  };
  
  const userPermissions = permissions[userRole] || [];
  return userPermissions.includes('all') || userPermissions.includes(requiredPermission);
}

// Current branch session security monitoring
function detectSuspiciousActivity(req): boolean {
  // IP, user agent, and location checking logic...
}
```

#### 3. Blockchain Integration
**Recommendation**: Use 17032025 multi-network structure with Current's optimizations

**Implementation Example**:
```typescript
// 17032025 multi-network configuration
const blockchainNetworks = {
  ethereum: { /* network config */ },
  polygon: { /* network config */ }
};

// Current branch gas optimization
async function optimizeGasFee(networkId) {
  try {
    const network = blockchainNetworks[networkId];
    const provider = network.provider;
    const feeData = await provider.getFeeData();
    
    // Dynamic fee calculation based on network congestion
    // ...
  } catch (error) {
    // Error handling with fallback values
  }
}
```

#### 4. AI Implementation
**Recommendation**: Use 190320250630 features with Current's fallbacks

**Implementation Example**:
```typescript
// Current branch approach with API key checking and fallbacks
export async function generateContentTags(title, artistName, type) {
  // First check for API key
  if (!process.env.OPENAI_API_KEY) {
    return getDefaultAnalysis(title, artistName, type);
  }

  try {
    // 190320250630 comprehensive AI analysis
    // ...
  } catch (error) {
    // Current branch fallback mechanisms
    return getCachedOrFallbackAnalysis(title, artistName, type);
  }
}
```

#### 5. Audio Processing
**Recommendation**: Use 190320250630 pipeline with Current's batch processing

**Implementation Example**:
```typescript
// 190320250630 comprehensive pipeline
async function processAudio(filePath, options) {
  // Complete quality assessment, fingerprinting, etc.
}

// Current branch batch processing
async function processBatch(files, options) {
  // Parallel execution with concurrency control
  const queue = new PQueue({ concurrency });
  
  // Add all files to the queue
  const promises = files.map((file, index) => {
    return queue.add(async () => {
      // Process individual file using 190320250630 pipeline
    });
  });
  
  // Wait for all processing to complete
  await Promise.all(promises);
}
```

#### 6. Rights Management
**Recommendation**: Use 190320250630 rights system with Current's dispute resolution

**Implementation Example**:
```typescript
// 190320250630 rights registration
async function registerRightsWithBlockchain({
  assetId, assetType, rightsType, ownerId, percentage, territory, startDate, endDate, networkId
}) {
  // Comprehensive rights registration code
}

// Current branch dispute resolution
async function createDispute({assetId, assetType, rightId, claimantId, respondentId, reason, evidence}) {
  // Formal dispute creation with workflow
}

async function resolveDispute(disputeId, resolverId, resolution, decision, notes) {
  // Structured resolution process
}
```

## Final Recommendations

For the optimal implementation of TuneMantra, the following approach is recommended:

1. **Start with Current Branch**: Use as the foundation due to its optimizations and modern naming conventions.

2. **Integrate Key 190320250630 Features**: Incorporate comprehensive rights management, royalty tables, and detailed audio processing from this feature-rich branch.

3. **Use 17032025 Multi-Network Support**: Adopt the flexible blockchain architecture from this branch.

4. **Apply Current Branch's Fallback Mechanisms**: Ensure system resilience with the sophisticated fallback patterns for external services.

5. **Adopt Documentation Style from PPv1/190320250630**: Use the detailed documentation approach to ensure maintainability.

This combined approach leverages the strengths of each development phase to create an optimized, feature-rich, and resilient platform.


---

## documentation/project/comprehensive-code-evolution.md

# TuneMantra Code Evolution Analysis

This document provides a precise, code-based analysis of TuneMantra's evolution across branches, with specific code references and detailed implementation patterns.

## Branch Sequence
PPv1 → 3march → 8march258 → 12march547 → 17032025 → 190320250630 → Current

## Database Schema Evolution

### 1. Documentation and Code Organization

#### PPv1
Comprehensive documentation in code with detailed comments:
```typescript
/**
 * Database Schema Definition
 * 
 * This file defines the structure of our PostgreSQL database using Drizzle ORM.
 * The schema defines tables, columns, relationships, and types for our database.
 * 
 * Key concepts:
 * - pgTable: Creates a new database table
 * - pgEnum: Creates a PostgreSQL enum type (a list of allowed values)
 * - Relations: Defines how tables are connected to each other
 * - Zod schemas: Provides validation for data insertion
 */
```

#### 3march
Simplified code by removing most comments:
```typescript
import { relations } from "drizzle-orm";
import { pgTable, serial, text, timestamp, integer, boolean, json, pgEnum, numeric } from "drizzle-orm/pg-core";
import { z } from "zod";
import { createInsertSchema } from "drizzle-zod";

// Define user role enum for access control
export const userRoleEnum = pgEnum('user_role', [
  'admin',             // Complete system access (platform owner)
  'label',             // Manage label settings, create sub-labels (6000 INR/year)
  'artist_manager',    // Manage multiple artists (2499 INR/year)
  'artist',            // Upload content, track performance (999 INR/year)
  'team_member'        // Employee of label/artist with limited permissions (role assigned by admins)
]);
```

#### 190320250630
Reinstated comprehensive documentation similar to PPv1:
```typescript
/**
 * Database Schema Definition
 * 
 * This file defines the structure of our PostgreSQL database using Drizzle ORM.
 * The schema defines tables, columns, relationships, and types for our database.
 * 
 * Key concepts:
 * - pgTable: Creates a new database table
 * - pgEnum: Creates a PostgreSQL enum type (a list of allowed values)
 * - Relations: Defines how tables are connected to each other
 * - Zod schemas: Provides validation for data insertion
 */

// Import Drizzle ORM relations to define connections between tables
import { relations } from "drizzle-orm";

// Import PostgreSQL-specific column types from Drizzle ORM
import { pgTable, serial, text, timestamp, integer, boolean, json, pgEnum, numeric, date } from "drizzle-orm/pg-core";
```

### 2. Analytics System Evolution

#### PPv1
Basic analytics structure:
```typescript
export const analytics = pgTable("analytics", {
  id: serial("id").primaryKey(),
  trackId: integer("track_id").notNull(),
  date: timestamp("date").notNull(),
  platform: text("platform").notNull(),
  streams: integer("streams").notNull().default(0),
  revenue: numeric("revenue").notNull().default("0"),
  country: text("country").default("unknown"),
  city: text("city").default("unknown"),
});
```

#### 8march258
Added demographics and additional metrics:
```typescript
export const analytics = pgTable("analytics", {
  id: serial("id").primaryKey(),
  trackId: integer("track_id").notNull(),
  date: timestamp("date").notNull(),
  platform: text("platform").notNull(),
  streams: integer("streams").notNull().default(0),
  revenue: numeric("revenue").notNull().default("0"),
  country: text("country").notNull(),
  city: text("city").notNull(),
  playlistAdds: integer("playlist_adds").default(0),
  saves: integer("saves").default(0),
  shares: integer("shares").default(0),
  demographics: json("demographics").default({
    age: {
      "18-24": 0,
      "25-34": 0,
      "35-44": 0,
      "45-54": 0,
      "55+": 0
    },
    gender: {
      "male": 0,
      "female": 0,
      "other": 0
    }
  }),
});
```

#### Current
Added event tracking and releaseId relationship:
```typescript
export const analytics = pgTable("analytics", {
  id: serial("id").primaryKey(),
  trackId: integer("track_id").notNull(),
  releaseId: integer("release_id"),
  date: timestamp("date").notNull(),
  platform: text("platform").notNull(),
  streams: integer("streams").notNull().default(0),
  revenue: numeric("revenue").notNull().default("0"),
  country: text("country").default("unknown"),
  city: text("city").default("unknown"),
  playlistAdds: integer("playlist_adds").default(0),
  saves: integer("saves").default(0),
  shares: integer("shares").default(0),
  avgPlayTime: numeric("avg_play_time").default("0"),
  event: text("event"),
  eventDetails: json("event_details"),
  demographics: json("demographics").default({
    // Demographics structure
  }),
});
```

### 3. Critical Schema Changes

#### PPv1 to 3march
Removed `artistName` field from tracks:
```diff
export const tracks = pgTable("tracks", {
  id: serial("id").primaryKey(),
  releaseId: integer("release_id").notNull(), // Add relationship to releases
  title: text("title").notNull(),
  artist: text("artist").notNull(),
-  artistName: text("artist_name"), // Consistent with releases table naming
  genre: text("genre").notNull(),
  releaseDate: timestamp("release_date").notNull(),
  status: text("status").notNull().default("draft"),
```

#### 12march547
Removed SuperAdmin table in favor of role-based access:
```diff
- // Super Admin Schema
- export const superAdmins = pgTable("super_admins", {
-   id: serial("id").primaryKey(),
-   username: text("username").notNull().unique(),
-   password: text("password").notNull(),
-   email: text("email").notNull(),
-   createdAt: timestamp("created_at").defaultNow(),
-   lastLogin: timestamp("last_login"),
- });
- 
- export type SuperAdmin = typeof superAdmins.$inferSelect;
- export type InsertSuperAdmin = typeof superAdmins.$inferInsert;

+ // Note: SuperAdmin table has been removed in favor of consolidated 'admin' role
+ // All administrator accounts are now managed through the users table with role='admin'
```

#### Current
Changed 'sharePercentage' to 'splitPercentage' in revenue shares:
```diff
export const revenueShares = pgTable("revenue_shares", {
  id: serial("id").primaryKey(),
  releaseId: integer("release_id").notNull(),
  userId: integer("user_id").notNull(),
-  sharePercentage: numeric("share_percentage").notNull(),
+  splitPercentage: numeric("split_percentage").notNull(),
  isConfirmed: boolean("is_confirmed").notNull().default(false),
  createdAt: timestamp("created_at").notNull().defaultNow(),
  updatedAt: timestamp("updated_at").notNull().defaultNow(),
});
```

```diff
export const insertRevenueShareSchema = createInsertSchema(revenueShares)
  .omit({
    id: true,
    isConfirmed: true,
    createdAt: true,
    updatedAt: true,
  })
  .extend({
-    sharePercentage: z.number().min(0).max(100, "Share percentage must be between 0 and 100"),
+    splitPercentage: z.number().min(0).max(100, "Split percentage must be between 0 and 100"),
  });
```

### 4. Rights Management Evolution

#### 12march547
Added basic rights management tables:
```typescript
export const rights = pgTable("rights", {
  id: serial("id").primaryKey(),
  assetId: integer("asset_id").notNull(),
  assetType: text("asset_type").notNull(), // "track", "release", etc.
  rightType: text("right_type").notNull(), // "master", "publishing", etc.
  ownerId: integer("owner_id").notNull(),
  percentage: numeric("percentage").notNull(),
  startDate: timestamp("start_date").notNull(),
  endDate: timestamp("end_date"),
  status: text("status").notNull().default("active"),
  createdAt: timestamp("created_at").notNull().defaultNow(),
  updatedAt: timestamp("updated_at").notNull().defaultNow(),
});
```

#### 17032025
Enhanced with collaborative rights:
```typescript
export const rightsCollaborations = pgTable("rights_collaborations", {
  id: serial("id").primaryKey(),
  rightId: integer("right_id").notNull(),
  collaboratorId: integer("collaborator_id").notNull(),
  contributionType: text("contribution_type").notNull(), // "composer", "lyricist", etc.
  sharePercentage: numeric("share_percentage").notNull(),
  status: text("status").notNull().default("pending"),
  approvalDate: timestamp("approval_date"),
  approvedById: integer("approved_by_id"),
  approvalWorkflow: json("approval_workflow").notNull(), // Tracks the approval steps
  blockchainReference: text("blockchain_reference"),
  createdAt: timestamp("created_at").notNull().defaultNow(),
  updatedAt: timestamp("updated_at").notNull().defaultNow(),
});
```

#### 190320250630
Added comprehensive royalty system:
```typescript
export const royaltyCalculations = pgTable("royalty_calculations", {
  id: serial("id").primaryKey(),
  // Foreign keys for related data
  distributionRecordId: integer("distribution_record_id").notNull(),
  releaseId: integer("release_id").notNull(),
  trackId: integer("track_id").notNull(),
  userId: integer("user_id").notNull(),
  
  // Calculation financial data
  amount: numeric("amount").notNull(), // calculated royalty amount
  streamCount: integer("stream_count").notNull().default(0), // number of streams
  ratePerStream: numeric("rate_per_stream"), // calculated rate
  
  // Calculation metadata
  calculationDate: timestamp("calculation_date").notNull().defaultNow(),
  timeframe: json("timeframe").notNull(), // period of calculation (start and end dates)
  royaltyType: royaltyTypeEnum("royalty_type").notNull(),
  platformId: integer("platform_id").notNull(),
  
  // Processing and payment data
  status: text("status").notNull().default("calculated"), // calculated, processed, paid, etc.
  isProcessed: boolean("is_processed").notNull().default(false),
  processingDate: timestamp("processing_date"),
  isPaid: boolean("is_paid").notNull().default(false),
  paymentDate: timestamp("payment_date"),
  paymentReference: text("payment_reference"),
  
  // Split data
  splitId: integer("split_id"), // related to revenue_shares table if applicable
  splitPercentage: numeric("split_percentage"),
  recipientId: integer("recipient_id"), // user or participant receiving the royalty
  
  // Additional data
  metadata: json("metadata"), // additional platform-specific or tracking data
  
  // Tracking fields
  createdAt: timestamp("created_at").notNull().defaultNow(),
  updatedAt: timestamp("updated_at").notNull().defaultNow(),
});
```

## Authentication System Evolution

### 1. Password Handling

#### PPv1
Detailed cryptographic implementation:
```typescript
/**
 * Hashes a password using the scrypt algorithm
 * 
 * @param password - The plain text password to hash
 * @returns A string in the format 'salt:hash'
 */
async function hashPassword(password: string): Promise<string> {
  const salt = crypto.randomBytes(16).toString('hex');
  return new Promise((resolve, reject) => {
    crypto.scrypt(password, salt, 64, (err, derivedKey) => {
      if (err) reject(err);
      resolve(`${salt}:${derivedKey.toString('hex')}`);
    });
  });
}

/**
 * Verifies a password against a stored hash
 * 
 * @param storedPassword - The stored password hash in the format 'salt:hash'
 * @param suppliedPassword - The password to verify
 * @returns True if the password matches, false otherwise
 */
async function verifyPassword(storedPassword: string, suppliedPassword: string): Promise<boolean> {
  const [salt, storedHash] = storedPassword.split(':');
  return new Promise((resolve, reject) => {
    crypto.scrypt(suppliedPassword, salt, 64, (err, derivedKey) => {
      if (err) reject(err);
      resolve(storedHash === derivedKey.toString('hex'));
    });
  });
}
```

#### 3march
Simplified but maintained core security:
```typescript
// Hash password using scrypt
async function hashPassword(password: string): Promise<string> {
  const salt = crypto.randomBytes(16).toString('hex');
  return new Promise((resolve, reject) => {
    crypto.scrypt(password, salt, 64, (err, derivedKey) => {
      if (err) reject(err);
      resolve(`${salt}:${derivedKey.toString('hex')}`);
    });
  });
}

// Verify password
async function verifyPassword(storedPassword: string, suppliedPassword: string): Promise<boolean> {
  const [salt, storedHash] = storedPassword.split(':');
  return new Promise((resolve, reject) => {
    crypto.scrypt(suppliedPassword, salt, 64, (err, derivedKey) => {
      if (err) reject(err);
      resolve(storedHash === derivedKey.toString('hex'));
    });
  });
}
```

#### 8march258
Added password strength validation:
```typescript
// Validate password strength
function validatePasswordStrength(password: string): boolean {
  // Password must be at least 8 characters long
  if (password.length < 8) {
    return false;
  }
  
  // Password must contain at least one uppercase letter
  if (!/[A-Z]/.test(password)) {
    return false;
  }
  
  // Password must contain at least one lowercase letter
  if (!/[a-z]/.test(password)) {
    return false;
  }
  
  // Password must contain at least one digit
  if (!/[0-9]/.test(password)) {
    return false;
  }
  
  return true;
}
```

#### Current
Enhanced password validation and security:
```typescript
// Validate password with enhanced requirements
function validatePassword(password: string): boolean {
  // Password must be at least 10 characters long (increased from 8)
  if (password.length < 10) {
    return false;
  }
  
  // Password must contain at least one uppercase letter
  if (!/[A-Z]/.test(password)) {
    return false;
  }
  
  // Password must contain at least one lowercase letter
  if (!/[a-z]/.test(password)) {
    return false;
  }
  
  // Password must contain at least one digit
  if (!/[0-9]/.test(password)) {
    return false;
  }
  
  // Password must contain at least one special character
  if (!/[^A-Za-z0-9]/.test(password)) {
    return false;
  }
  
  // Check for common password patterns
  if (/password/i.test(password) || /12345/.test(password)) {
    return false;
  }
  
  return true;
}
```

### 2. Session Management

#### PPv1
Comprehensive session configuration:
```typescript
// Configure session storage using PostgreSQL
app.use(
  session({
    store: new PgStore({
      pool,
      tableName: 'user_sessions',
      createTableIfMissing: true,
    }),
    secret: process.env.SESSION_SECRET || 'default-secret-change-in-production',
    resave: false,
    saveUninitialized: false,
    cookie: {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax',
      maxAge: 24 * 60 * 60 * 1000, // 1 day
    },
  })
);
```

#### 190320250630
Enhanced session security with fingerprinting:
```typescript
// Configure session with enhanced security
app.use(
  session({
    store: new PgStore({
      pool,
      tableName: 'user_sessions',
      createTableIfMissing: true,
    }),
    secret: process.env.SESSION_SECRET || 'default-secret-change-in-production',
    resave: false,
    saveUninitialized: false,
    cookie: {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'strict', // Changed from 'lax' to 'strict'
      maxAge: 24 * 60 * 60 * 1000, // 1 day
    },
  })
);

// Middleware to track session fingerprints
app.use((req, res, next) => {
  if (req.session.userId) {
    // Store fingerprint data for security monitoring
    req.session.userAgent = req.headers["user-agent"];
    req.session.ipAddress = req.ip;
    req.session.lastActive = new Date();
  }
  next();
});
```

#### Current
Added session monitoring and suspicious activity detection:
```typescript
// Function to detect suspicious session activity
function detectSuspiciousActivity(req): boolean {
  if (!req.session.userId) return false;
  
  // Check for IP changes
  if (req.session.ipAddress && req.session.ipAddress !== req.ip) {
    logSecurityEvent('ip_changed', {
      userId: req.session.userId,
      oldIp: req.session.ipAddress,
      newIp: req.ip
    });
    return true;
  }
  
  // Check for user agent changes
  if (req.session.userAgent && req.session.userAgent !== req.headers["user-agent"]) {
    logSecurityEvent('user_agent_changed', {
      userId: req.session.userId
    });
    return true;
  }
  
  // Check for unusual activity patterns
  if (req.session.lastActive) {
    const timeSinceLastActivity = Date.now() - new Date(req.session.lastActive).getTime();
    if (req.session.loggedInCountry && req.geoip.country !== req.session.loggedInCountry) {
      // Suspicious: different country in short time window
      if (timeSinceLastActivity < 3600000) { // 1 hour
        logSecurityEvent('unusual_location_change', {
          userId: req.session.userId
        });
        return true;
      }
    }
  }
  
  return false;
}

// Middleware to handle suspicious activity
app.use((req, res, next) => {
  if (req.session.userId) {
    if (detectSuspiciousActivity(req)) {
      // Require re-authentication for suspicious activity
      req.session.requireReauth = true;
    }
    
    // Update session tracking data
    req.session.userAgent = req.headers["user-agent"];
    req.session.ipAddress = req.ip;
    req.session.lastActive = new Date();
    req.session.loggedInCountry = req.geoip?.country;
  }
  next();
});
```

### 3. Permission System

#### 8march258
Basic role-based permissions:
```typescript
// Check if user has required permission
function hasPermission(userRole: string, requiredPermission: string): boolean {
  const permissions = {
    admin: ['all'],
    label: ['manage_label', 'manage_artists', 'view_analytics'],
    artist_manager: ['manage_artists', 'upload_content', 'view_analytics'],
    artist: ['upload_content', 'view_own_analytics']
  };
  
  const userPermissions = permissions[userRole] || [];
  return userPermissions.includes('all') || userPermissions.includes(requiredPermission);
}
```

#### 12march547
Enhanced role-based permission checks:
```typescript
// Check if user has required permission with hierarchy
function hasPermission(userRole: string, requiredPermission: string): boolean {
  // Define permission hierarchy
  const permissions = {
    admin: ['all'],
    label: [
      'manage_label', 
      'manage_artists', 
      'upload_content', 
      'view_analytics', 
      'manage_releases',
      'manage_distributions',
      'view_royalties'
    ],
    artist_manager: [
      'manage_artists', 
      'upload_content', 
      'view_analytics',
      'manage_releases',
      'view_artist_royalties'
    ],
    artist: [
      'upload_content', 
      'view_own_analytics',
      'manage_own_releases'
    ]
  };
  
  // Check permission inheritance
  const userPermissions = permissions[userRole] || [];
  return userPermissions.includes('all') || userPermissions.includes(requiredPermission);
}

// Middleware to check permission
function requirePermission(permission: string) {
  return (req, res, next) => {
    if (!req.user) {
      return res.status(401).json({ error: 'Authentication required' });
    }
    
    if (!hasPermission(req.user.role, permission)) {
      return res.status(403).json({ error: 'Permission denied' });
    }
    
    next();
  };
}
```

#### 190320250630
Implemented specialized auth flows for different user types:
```typescript
// User type-specific authentication handlers
const authHandlers = {
  // Artist authentication and setup
  async handleArtistAuth(user, req, res) {
    // Load artist-specific data
    const artistProfile = await db.artistProfiles.findFirst({
      where: { userId: user.id }
    });
    
    // Check if artist profile needs setup
    if (!artistProfile || !artistProfile.isComplete) {
      return { 
        user,
        redirectTo: '/artist/setup',
        needsProfileCompletion: true
      };
    }
    
    // Check artist verification status
    if (artistProfile.verificationStatus === 'pending') {
      return {
        user,
        redirectTo: '/artist/verification-pending',
        verificationPending: true
      };
    }
    
    // Load artist dashboard data
    const releases = await db.releases.findMany({
      where: { artistId: user.id },
      orderBy: { releaseDate: 'desc' },
      take: 5
    });
    
    const recentAnalytics = await getArtistAnalyticsSummary(user.id);
    
    return {
      user,
      redirectTo: '/artist/dashboard',
      dashboardData: {
        recentReleases: releases,
        analytics: recentAnalytics
      }
    };
  },
  
  // Label authentication and setup
  async handleLabelAuth(user, req, res) {
    // Load label-specific data and authentication flow
    // Similar to artist flow but with label-specific logic
  },
  
  // Admin authentication
  async handleAdminAuth(user, req, res) {
    // Load admin dashboard data
    const pendingApprovals = await db.approvals.count({
      where: { status: 'pending' }
    });
    
    const systemStats = await getSystemStats();
    
    return {
      user,
      redirectTo: '/admin/dashboard',
      dashboardData: {
        pendingApprovals,
        systemStats
      }
    };
  }
};

// Role-based authentication router
async function authenticateUser(email, password, req, res) {
  const user = await db.users.findFirst({
    where: { email }
  });
  
  if (!user) {
    throw new Error('User not found');
  }
  
  const isValid = await verifyPassword(user.password, password);
  
  if (!isValid) {
    throw new Error('Invalid password');
  }
  
  // Route to appropriate handler based on user role
  switch (user.role) {
    case 'artist':
      return authHandlers.handleArtistAuth(user, req, res);
    case 'label':
      return authHandlers.handleLabelAuth(user, req, res);
    case 'admin':
      return authHandlers.handleAdminAuth(user, req, res);
    default:
      // Default handler for other roles
      return {
        user,
        redirectTo: '/dashboard'
      };
  }
}
```

## Blockchain Integration Evolution

### 1. Network Configuration

#### 8march258
Basic blockchain connection:
```typescript
// Basic blockchain connector
const blockchainConfig = {
  network: 'ethereum',
  provider: new ethers.providers.JsonRpcProvider(process.env.ETHEREUM_RPC_URL),
  contractAddress: process.env.RIGHTS_CONTRACT_ADDRESS,
  contractABI: JSON.parse(fs.readFileSync('./contracts/RightsManager.json', 'utf8')).abi,
};

// Initialize blockchain connection
function initBlockchain() {
  try {
    const provider = blockchainConfig.provider;
    const wallet = new ethers.Wallet(process.env.PRIVATE_KEY, provider);
    const contract = new ethers.Contract(
      blockchainConfig.contractAddress,
      blockchainConfig.contractABI,
      wallet
    );
    
    return { provider, wallet, contract };
  } catch (error) {
    console.error('Failed to initialize blockchain connection:', error);
    throw error;
  }
}
```

#### 17032025
Added multi-blockchain network support:
```typescript
// Multi-network configuration
const blockchainNetworks = {
  ethereum: {
    name: 'Ethereum Mainnet',
    chainId: 1,
    currency: 'ETH',
    provider: new ethers.providers.JsonRpcProvider(process.env.ETHEREUM_RPC_URL),
    contractAddress: process.env.ETHEREUM_CONTRACT_ADDRESS,
    contractABI: JSON.parse(fs.readFileSync('./contracts/RightsManager.json', 'utf8')).abi,
  },
  polygon: {
    name: 'Polygon Mainnet',
    chainId: 137,
    currency: 'MATIC',
    provider: new ethers.providers.JsonRpcProvider(process.env.POLYGON_RPC_URL),
    contractAddress: process.env.POLYGON_CONTRACT_ADDRESS,
    contractABI: JSON.parse(fs.readFileSync('./contracts/RightsManager.json', 'utf8')).abi,
  },
  // Add more networks as needed
};

// Initialize blockchain connection for specific network
function initBlockchain(networkId = 'ethereum') {
  try {
    const network = blockchainNetworks[networkId];
    
    if (!network) {
      throw new Error(`Network ${networkId} not supported`);
    }
    
    const provider = network.provider;
    const wallet = new ethers.Wallet(process.env.PRIVATE_KEY, provider);
    const contract = new ethers.Contract(
      network.contractAddress,
      network.contractABI,
      wallet
    );
    
    return { provider, wallet, contract, network };
  } catch (error) {
    console.error(`Failed to initialize blockchain connection for ${networkId}:`, error);
    throw error;
  }
}
```

#### Current
Optimized blockchain interactions with gas management:
```typescript
// Gas fee optimization
async function optimizeGasFee(networkId = 'ethereum') {
  try {
    const network = blockchainNetworks[networkId];
    const provider = network.provider;
    
    // Get current gas prices and network conditions
    const feeData = await provider.getFeeData();
    const block = await provider.getBlock('latest');
    const networkCongestion = block.gasUsed.mul(100).div(block.gasLimit).toNumber();
    
    // Adjust based on network congestion
    let maxFeeMultiplier;
    if (networkCongestion > 80) {
      // High congestion, pay premium for faster inclusion
      maxFeeMultiplier = 150; // 50% premium
    } else if (networkCongestion > 50) {
      // Medium congestion
      maxFeeMultiplier = 120; // 20% premium
    } else {
      // Low congestion
      maxFeeMultiplier = 110; // 10% premium
    }
    
    // Calculate optimal fees
    const maxFeePerGas = feeData.maxFeePerGas.mul(maxFeeMultiplier).div(100);
    const maxPriorityFeePerGas = feeData.maxPriorityFeePerGas.mul(maxFeeMultiplier).div(100);
    
    return {
      maxFeePerGas,
      maxPriorityFeePerGas,
      estimatedBaseFee: feeData.lastBaseFeePerGas,
      networkCongestion
    };
  } catch (error) {
    console.error(`Failed to optimize gas fee for ${networkId}:`, error);
    
    // Return reasonable defaults in case of error
    return {
      maxFeePerGas: ethers.utils.parseUnits('50', 'gwei'),
      maxPriorityFeePerGas: ethers.utils.parseUnits('2', 'gwei'),
      networkCongestion: 50,
      isEstimate: true
    };
  }
}

// Transaction with retry and optimization
async function executeBlockchainTransaction(
  networkId,
  contractMethod,
  params,
  options = {}
) {
  const maxRetries = options.maxRetries || 3;
  let retries = 0;
  let lastError;
  
  while (retries < maxRetries) {
    try {
      // Get blockchain connection
      const { contract } = await initBlockchain(networkId);
      
      // Get optimized gas settings
      const gasSettings = await optimizeGasFee(networkId);
      
      // Execute transaction
      const tx = await contract[contractMethod](...params, {
        maxFeePerGas: gasSettings.maxFeePerGas,
        maxPriorityFeePerGas: gasSettings.maxPriorityFeePerGas,
        ...options.transactionOptions
      });
      
      // Wait for confirmation with appropriate block confirmations
      const receipt = await tx.wait(options.confirmations || 1);
      
      // Log transaction details
      logBlockchainTransaction(tx.hash, receipt, networkId, contractMethod);
      
      return {
        transactionHash: tx.hash,
        blockNumber: receipt.blockNumber,
        status: receipt.status === 1 ? 'success' : 'failed',
        gasUsed: receipt.gasUsed.toString(),
        effectiveGasPrice: receipt.effectiveGasPrice.toString(),
      };
    } catch (error) {
      console.error(`Blockchain transaction attempt ${retries + 1} failed:`, error);
      lastError = error;
      
      // Check for specific error types to determine if retry is sensible
      if (error.code === 'INSUFFICIENT_FUNDS') {
        // No point retrying for insufficient funds
        throw error;
      }
      
      if (error.code === 'REPLACEMENT_UNDERPRICED') {
        // Need to increase gas price in next retry
        options.transactionOptions = {
          ...options.transactionOptions,
          maxPriorityFeePerGas: options.transactionOptions?.maxPriorityFeePerGas?.mul(130).div(100) ||
            ethers.utils.parseUnits('3', 'gwei')
        };
      }
      
      // Exponential backoff for retries
      const backoffTime = Math.pow(2, retries) * 1000; // 1s, 2s, 4s
      await new Promise(resolve => setTimeout(resolve, backoffTime));
      
      retries++;
    }
  }
  
  // All retries failed
  throw lastError;
}
```

### 2. Rights Registration

#### 12march547
Basic NFT minting for tracks:
```typescript
async function mintTrackNFT(trackId, userId) {
  try {
    const { contract } = initBlockchain();
    
    // Get track data
    const track = await db.tracks.findFirst({
      where: { id: trackId }
    });
    
    if (!track) {
      throw new Error(`Track ${trackId} not found`);
    }
    
    // Create metadata
    const metadata = {
      name: track.title,
      description: `${track.title} by ${track.artist}`,
      external_url: `${process.env.BASE_URL}/tracks/${trackId}`,
      image: track.coverArtUrl,
      attributes: [
        { trait_type: 'Genre', value: track.genre },
        { trait_type: 'Release Date', value: track.releaseDate }
      ]
    };
    
    // Store metadata on IPFS (simplified)
    const metadataUri = await uploadToIPFS(JSON.stringify(metadata));
    
    // Mint NFT
    const tx = await contract.mintTrackNFT(
      userId,
      trackId.toString(),
      metadataUri
    );
    
    // Wait for confirmation
    const receipt = await tx.wait(1);
    
    // Get token ID from event
    const event = receipt.events.find(e => e.event === 'TrackNFTMinted');
    const tokenId = event.args.tokenId.toString();
    
    // Update track with token information
    await db.tracks.update({
      where: { id: trackId },
      data: {
        tokenId,
        tokenAddress: contract.address,
        tokenUri: metadataUri
      }
    });
    
    return { tokenId, transactionHash: tx.hash };
  } catch (error) {
    console.error('Failed to mint track NFT:', error);
    throw error;
  }
}
```

#### 190320250630
Implemented comprehensive rights registration with blockchain:
```typescript
async function registerRightsWithBlockchain({
  assetId,
  assetType,
  rightsType,
  ownerId,
  percentage,
  territory,
  startDate,
  endDate,
  networkId = 'ethereum'
}) {
  try {
    // Validate inputs
    if (!assetId || !assetType || !rightsType || !ownerId || !percentage) {
      throw new Error('Missing required parameters for rights registration');
    }
    
    // Get blockchain connection
    const { contract, network } = await initBlockchain(networkId);
    
    // Get user's blockchain address
    const user = await db.users.findFirst({
      where: { id: ownerId },
      select: { blockchainAddress: true }
    });
    
    if (!user || !user.blockchainAddress) {
      throw new Error(`User ${ownerId} does not have a blockchain address`);
    }
    
    // Prepare rights data
    const rightsData = {
      assetId: assetId.toString(),
      assetType,
      rightsType,
      ownerAddress: user.blockchainAddress,
      percentage: percentage.toString(),
      territory: territory || 'GLOBAL',
      startTimestamp: Math.floor(startDate.getTime() / 1000),
      endTimestamp: endDate ? Math.floor(endDate.getTime() / 1000) : 0,
    };
    
    // Create rights metadata
    const metadata = {
      name: `${rightsType} Rights for ${assetType} #${assetId}`,
      description: `${percentage}% of ${rightsType} rights for ${assetType} #${assetId} in ${territory || 'GLOBAL'}`,
      attributes: [
        { trait_type: 'Asset Type', value: assetType },
        { trait_type: 'Rights Type', value: rightsType },
        { trait_type: 'Percentage', value: percentage },
        { trait_type: 'Territory', value: territory || 'GLOBAL' },
        { trait_type: 'Start Date', value: startDate.toISOString() },
        { trait_type: 'End Date', value: endDate ? endDate.toISOString() : 'Forever' }
      ]
    };
    
    // Store metadata on IPFS
    const metadataUri = await uploadToIPFS(JSON.stringify(metadata));
    
    // Register rights on blockchain
    const tx = await contract.registerRights(
      rightsData.assetId,
      rightsData.assetType,
      rightsData.rightsType,
      rightsData.ownerAddress,
      rightsData.percentage,
      rightsData.territory,
      rightsData.startTimestamp,
      rightsData.endTimestamp,
      metadataUri
    );
    
    // Wait for confirmation
    const receipt = await tx.wait(network.confirmations || 1);
    
    // Get rights ID from event
    const event = receipt.events.find(e => e.event === 'RightsRegistered');
    const blockchainRightsId = event.args.rightsId.toString();
    
    return {
      blockchainRightsId,
      transactionHash: tx.hash,
      blockNumber: receipt.blockNumber,
      metadataUri
    };
  } catch (error) {
    console.error('Failed to register rights on blockchain:', error);
    throw error;
  }
}
```

#### Current
Enhanced rights registration with optimized blockchain interactions:
```typescript
async function registerRightsWithBlockchain({
  assetId,
  assetType,
  rightsType,
  ownerId,
  percentage,
  territory,
  startDate,
  endDate,
  networkId = 'ethereum'
}) {
  try {
    // Validate inputs
    validateRightsInput({assetId, assetType, rightsType, ownerId, percentage});
    
    // Get user's blockchain address
    const user = await db.users.findFirst({
      where: { id: ownerId },
      select: { blockchainAddress: true }
    });
    
    if (!user?.blockchainAddress) {
      throw new Error(`User ${ownerId} does not have a blockchain address`);
    }
    
    // Prepare rights data
    const rightsData = prepareRightsData({
      assetId, 
      assetType, 
      rightsType,
      ownerAddress: user.blockchainAddress,
      percentage,
      territory: territory || 'GLOBAL',
      startDate,
      endDate
    });
    
    // Create and store rights metadata
    const metadataUri = await createAndStoreRightsMetadata(rightsData);
    
    // Execute blockchain transaction with optimized parameters
    const result = await executeBlockchainTransaction(
      networkId,
      'registerRights',
      [
        rightsData.assetId,
        rightsData.assetType,
        rightsData.rightsType,
        rightsData.ownerAddress,
        rightsData.percentage,
        rightsData.territory,
        rightsData.startTimestamp,
        rightsData.endTimestamp,
        metadataUri
      ],
      {
        // Use higher confirmation count for important rights transactions
        confirmations: 2,
        maxRetries: 5,
        // Add additional transaction options
        transactionOptions: {
          // Set priority to ensure timely execution
          maxPriorityFeePerGas: ethers.utils.parseUnits('3', 'gwei')
        }
      }
    );
    
    // Enhance result with additional metadata
    return {
      ...result,
      metadataUri,
      rightsData
    };
  } catch (error) {
    // Enhanced error handling with specific error types
    if (error.code === 'INSUFFICIENT_FUNDS') {
      throw new RightsRegistrationError(
        'Insufficient funds for blockchain registration',
        'INSUFFICIENT_FUNDS'
      );
    } else if (error.code === 'CALL_EXCEPTION') {
      throw new RightsRegistrationError(
        'Smart contract rejected the registration',
        'CONTRACT_ERROR'
      );
    }
    
    console.error('Failed to register rights on blockchain:', error);
    throw new RightsRegistrationError(
      'Rights registration failed',
      'REGISTRATION_FAILED',
      error
    );
  }
}

// Helper class for better error handling
class RightsRegistrationError extends Error {
  constructor(message, code, originalError = null) {
    super(message);
    this.name = 'RightsRegistrationError';
    this.code = code;
    this.originalError = originalError;
  }
}
```

## AI Implementation Evolution

### 1. Content Analysis

#### 8march258
Basic metadata enhancement:
```typescript
function enhanceTrackMetadata(title, artist, genre) {
  // Simple pattern matching for genres
  const genreMappings = {
    'hip-hop': ['rap', 'trap', 'urban'],
    'rock': ['alternative', 'indie', 'metal'],
    'pop': ['dance pop', 'synth-pop', 'mainstream'],
    'electronic': ['edm', 'house', 'techno', 'dubstep'],
    'rb': ['r&b', 'rnb', 'soul', 'contemporary r&b']
  };
  
  // Find related genres
  const relatedGenres = genreMappings[genre.toLowerCase()] || [];
  
  // Simple mood detection based on genre
  const moodMappings = {
    'hip-hop': ['energetic', 'confident', 'urban'],
    'rock': ['intense', 'emotional', 'raw'],
    'pop': ['upbeat', 'catchy', 'positive'],
    'electronic': ['energetic', 'atmospheric', 'danceable'],
    'rb': ['smooth', 'emotional', 'soulful']
  };
  
  const suggestedMoods = moodMappings[genre.toLowerCase()] || [];
  
  return {
    enhancedGenres: [genre, ...relatedGenres],
    suggestedMoods,
    isExplicit: title.toLowerCase().includes('explicit') || 
                title.toLowerCase().includes('parental advisory')
  };
}
```

#### 17032025
Implemented OpenAI integration:
```typescript
async function generateContentTags(title, artist, genre) {
  try {
    // Initialize OpenAI client
    const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
    
    // Create prompt for AI
    const prompt = `
      Analyze this music track:
      Title: "${title}"
      Artist: "${artist}"
      Genre: "${genre}"
      
      Please provide:
      1. Main genre and subgenres
      2. Mood tags (e.g., energetic, melancholic, upbeat)
      3. Related artists
      4. Is this likely explicit content? (yes/no)
      5. Suggested playlists
    `;
    
    // Request analysis from OpenAI
    const response = await openai.completions.create({
      model: "text-davinci-003",
      prompt,
      temperature: 0.7,
      max_tokens: 200,
      top_p: 1,
      frequency_penalty: 0,
      presence_penalty: 0
    });
    
    // Parse response (basic version)
    const analysisText = response.choices[0].text;
    
    // Extract genres
    const genreMatch = analysisText.match(/Main genre and subgenres:(.*?)(?:\n\d\.|\n$)/s);
    const genres = genreMatch ? 
      genreMatch[1].split(',').map(g => g.trim()).filter(Boolean) : 
      [genre];
    
    // Extract moods
    const moodMatch = analysisText.match(/Mood tags:(.*?)(?:\n\d\.|\n$)/s);
    const moods = moodMatch ? 
      moodMatch[1].split(',').map(m => m.trim()).filter(Boolean) : 
      [];
    
    // Extract explicit check
    const explicitMatch = analysisText.match(/explicit content\? \(yes\/no\):(.*?)(?:\n\d\.|\n$)/si);
    const isExplicit = explicitMatch ? 
      explicitMatch[1].trim().toLowerCase().includes('yes') : 
      false;
    
    return {
      genres,
      moods,
      isExplicit,
      analysisText
    };
  } catch (error) {
    console.error('AI analysis failed:', error);
    // Return basic analysis in case of failure
    return {
      genres: [genre],
      moods: [],
      isExplicit: false,
      analysisText: null,
      error: error.message
    };
  }
}
```

#### 190320250630
Complete AI suite with structured responses:
```typescript
export async function generateContentTags(
  title: string,
  artistName: string,
  type: "audio" | "video"
): Promise<{ tags: ContentTags; analysis: AIAnalysis }> {
  // Initialize OpenAI client with API key
  const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
  
  try {
    // Request AI analysis from OpenAI with structured format
    const response = await openai.chat.completions.create({
      model: "gpt-4",
      messages: [
        // System prompt defines the AI's role and capabilities
        {
          role: "system",
          content: `You are an expert music and media content analyzer with deep knowledge of genres, 
           styles, moods, cultural contexts, and commercial potential. Analyze the given ${type} 
           content information and provide detailed tags and analysis. Your response should be 
           formatted as valid JSON with these fields:
           - genres: array of genre tags
           - moods: array of mood tags
           - themes: array of thematic tags
           - explicit: boolean indicating if content likely contains explicit material
           - languages: array of likely languages used
           - similarArtists: array of similar artists
           - commercialPotential: object with numeric score (0-100) and analysis text
           - qualityAssessment: object with numeric score (0-100) and analysis text
           - contentWarnings: array of potential content warnings
           - suggestedPlaylists: array of playlist concepts this would fit in
           - summary: text summarizing the content
           - suggestedImprovements: array of potential improvements`,
        },
        // User prompt contains the content information to analyze
        {
          role: "user",
          content: `Please analyze this ${type} content:
           Title: "${title}"
           Artist: "${artistName}"`,
        },
      ],
      // Request JSON response format for reliable parsing
      response_format: { type: "json_object" },
    });

    // Get and parse the response content
    const result = JSON.parse(response.choices[0].message.content || "{}");
    
    // Validate and structure the response
    return {
      tags: {
        genres: validateArray(result.genres),
        moods: validateArray(result.moods),
        themes: validateArray(result.themes),
        explicit: Boolean(result.explicit),
        languages: validateArray(result.languages),
      },
      analysis: {
        summary: result.summary || "",
        commercialPotential: {
          score: validateScore(result.commercialPotential?.score),
          analysis: result.commercialPotential?.analysis || "",
        },
        qualityAssessment: {
          score: validateScore(result.qualityAssessment?.score),
          analysis: result.qualityAssessment?.analysis || "",
        },
        contentWarnings: validateArray(result.contentWarnings),
        suggestedPlaylists: validateArray(result.suggestedPlaylists),
        similarArtists: validateArray(result.similarArtists),
        suggestedImprovements: validateArray(result.suggestedImprovements),
      },
    };
  } catch (error) {
    console.error("AI Analysis failed:", error);
    // Return default/empty analysis in case of failure
    return {
      tags: {
        genres: [],
        moods: [],
        themes: [],
        explicit: false,
        languages: ["en"],
      },
      analysis: {
        summary: "",
        commercialPotential: { score: 0, analysis: "" },
        qualityAssessment: { score: 0, analysis: "" },
        contentWarnings: [],
        suggestedPlaylists: [],
        similarArtists: [],
        suggestedImprovements: [],
      },
    };
  }
}

// Helper functions for validation
function validateArray(value: any): string[] {
  if (!Array.isArray(value)) return [];
  return value.map(item => String(item).trim()).filter(Boolean);
}

function validateScore(value: any): number {
  const score = Number(value);
  if (isNaN(score)) return 0;
  return Math.max(0, Math.min(100, score));
}
```

#### Current
Added fallbacks for AI service unavailability:
```typescript
export async function generateContentTags(
  title: string,
  artistName: string,
  type: "audio" | "video"
): Promise<{ tags: ContentTags; analysis: AIAnalysis }> {
  // Return default data if OpenAI API key is not configured
  if (!process.env.OPENAI_API_KEY) {
    console.log("OpenAI API key not configured, returning default analysis data");
    return getDefaultAnalysis(title, artistName, type);
  }

  try {
    // Initialize OpenAI client with API key from environment
    const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
    
    // Check AI service status from cache
    const serviceStatus = await getAIServiceStatus();
    if (!serviceStatus.available) {
      console.log("AI service unavailable, using cached or generated results");
      return getCachedOrFallbackAnalysis(title, artistName, type);
    }
    
    // Request AI analysis from OpenAI
    const response = await openai.chat.completions.create({
      model: "gpt-4o",  // Using GPT-4o for enhanced media understanding
      messages: [
        // System prompt defines the AI's role and capabilities
        {
          role: "system",
          content: `You are an expert music and video content analyzer. Analyze the given ${type} content information and provide detailed tags and analysis. Consider the title and artist name to infer genre, mood, themes, and other relevant attributes.`,
        },
        // User prompt contains the content information to analyze
        {
          role: "user",
          content: `Please analyze this ${type} content:\nTitle: ${title}\nArtist: ${artistName}`,
        },
      ],
      // Request JSON response format for reliable parsing
      response_format: { type: "json_object" },
    });

    // Extract and parse the response content
    const content = response.choices[0].message.content || "{}";
    const result = JSON.parse(content);
    
    // Store result in cache for future fallback
    await cacheAnalysisResult(title, artistName, type, result);
    
    // Update service status in cache
    await updateAIServiceStatus(true);
    
    // Return validated and structured result
    return {
      tags: {
        genres: validateAndNormalizeTags(result.genres || []),
        moods: validateAndNormalizeTags(result.moods || []),
        themes: validateAndNormalizeTags(result.themes || []),
        explicit: Boolean(result.explicit),
        languages: validateAndNormalizeTags(result.languages || []),
      },
      analysis: {
        summary: result.summary || "",
        commercialPotential: {
          score: validateQualityScore(result.commercialPotential?.score),
          analysis: result.commercialPotential?.analysis || "",
        },
        qualityAssessment: {
          score: validateQualityScore(result.qualityAssessment?.score),
          analysis: result.qualityAssessment?.analysis || "",
        },
        contentWarnings: validateAndNormalizeTags(result.contentWarnings || []),
        suggestedPlaylists: result.suggestedPlaylists || [],
        similarArtists: result.similarArtists || [],
        suggestedImprovements: result.suggestedImprovements || [],
        confidence: 0.95, // High confidence for direct AI analysis
      },
    };
  } catch (error) {
    // Handle service unavailability
    if (error.status === 429 || error.status === 500 || error.status === 503) {
      // Mark service as unavailable in cache
      await updateAIServiceStatus(false, error.message);
      console.log("AI service temporarily unavailable:", error.message);
    } else {
      console.error("AI Analysis failed:", error);
    }
    
    // Use cached or fallback analysis
    return getCachedOrFallbackAnalysis(title, artistName, type);
  }
}

// Enhanced validation helpers
function validateAndNormalizeTags(tags) {
  // Normalize and validate tags
  return tags.map(tag => tag.toLowerCase().trim())
    .filter(tag => tag.length > 0)
    .slice(0, 10); // Limit number of tags
}

function validateQualityScore(score) {
  // Ensure score is a number between 0-100
  const numScore = Number(score);
  if (isNaN(numScore)) return 0;
  return Math.max(0, Math.min(100, numScore));
}

// AI service status management
async function getAIServiceStatus() {
  try {
    const cachedStatus = await cache.get('ai_service_status');
    if (cachedStatus) {
      return JSON.parse(cachedStatus);
    }
    return { available: true, lastChecked: new Date().toISOString() };
  } catch (error) {
    console.error('Error getting AI service status:', error);
    return { available: true, lastChecked: new Date().toISOString() };
  }
}

async function updateAIServiceStatus(available, errorMessage = null) {
  try {
    const status = {
      available,
      lastChecked: new Date().toISOString(),
      error: errorMessage,
      // If service is unavailable, set automatic retry after 10 minutes
      retryAfter: available ? null : new Date(Date.now() + 10 * 60 * 1000).toISOString()
    };
    await cache.set('ai_service_status', JSON.stringify(status), 60 * 60); // 1 hour cache
    return status;
  } catch (error) {
    console.error('Error updating AI service status:', error);
  }
}

// Fallback and caching system
async function cacheAnalysisResult(title, artistName, type, result) {
  try {
    const cacheKey = `ai_analysis:${type}:${title}:${artistName}`.toLowerCase();
    await cache.set(cacheKey, JSON.stringify(result), 7 * 24 * 60 * 60); // 7 days cache
  } catch (error) {
    console.error('Error caching analysis result:', error);
  }
}

async function getCachedOrFallbackAnalysis(title, artistName, type) {
  try {
    // Try to get from cache first
    const cacheKey = `ai_analysis:${type}:${title}:${artistName}`.toLowerCase();
    const cachedResult = await cache.get(cacheKey);
    
    if (cachedResult) {
      const result = JSON.parse(cachedResult);
      return {
        // Similar structure as above but with cached data
        tags: { /* ... */ },
        analysis: { 
          /* ... */,
          confidence: 0.8, // Lower confidence for cached result
          source: 'cache'
        }
      };
    }
    
    // If no cached result, generate basic analysis
    return getDefaultAnalysis(title, artistName, type);
  } catch (error) {
    console.error('Error getting cached analysis:', error);
    return getDefaultAnalysis(title, artistName, type);
  }
}

function getDefaultAnalysis(title, artistName, type) {
  // Generate basic analysis from title and artist name
  // This performs simple pattern matching without synthetic data generation
  
  // Extract potential genres from title
  const genres = extractGenresFromTitle(title, artistName);
  
  // Basic mood inference
  const moods = inferMoodsFromTitle(title);
  
  return {
    tags: {
      genres: genres.length > 0 ? genres : ["pop"], // Basic inference
      moods: moods.length > 0 ? moods : ["neutral"],
      themes: [],
      explicit: title.toLowerCase().includes("explicit"),
      languages: ["en"], // Default to English
    },
    analysis: {
      summary: `"${title}" by ${artistName}`,
      commercialPotential: {
        score: 50, // Neutral score
        analysis: "Analysis unavailable. Please try again later."
      },
      qualityAssessment: {
        score: 50, // Neutral score
        analysis: "Assessment unavailable. Please try again later."
      },
      contentWarnings: title.toLowerCase().includes("explicit") ? ["explicit lyrics"] : [],
      suggestedPlaylists: [],
      similarArtists: [],
      suggestedImprovements: [],
      confidence: 0.5, // Low confidence for generated fallback
      source: 'fallback'
    }
  };
}
```

## Audio Processing Evolution

### 1. Audio Pipeline

#### PPv1
Basic audio metadata extraction:
```typescript
async function processAudioFile(filePath) {
  try {
    // Use ffprobe to extract audio metadata
    const { stdout } = await exec(`ffprobe -v quiet -print_format json -show_format -show_streams "${filePath}"`);
    const metadata = JSON.parse(stdout);
    
    // Extract basic information
    const audioStream = metadata.streams.find(stream => stream.codec_type === 'audio');
    
    if (!audioStream) {
      throw new Error('No audio stream found in file');
    }
    
    const format = metadata.format;
    
    return {
      duration: parseFloat(format.duration),
      format: format.format_name,
      bitrate: parseInt(format.bit_rate, 10),
      channels: audioStream.channels,
      sampleRate: parseInt(audioStream.sample_rate, 10),
      codec: audioStream.codec_name
    };
  } catch (error) {
    console.error('Failed to process audio file:', error);
    throw error;
  }
}
```

#### 12march547
Implemented audio fingerprinting:
```typescript
async function createAudioFingerprint(filePath) {
  try {
    // Create a temporary directory for processing
    const tempDir = path.join(os.tmpdir(), 'audio-fingerprinting');
    await fs.promises.mkdir(tempDir, { recursive: true });
    
    // Generate a unique name for this file
    const fileId = crypto.randomUUID();
    const tempWavPath = path.join(tempDir, `${fileId}.wav`);
    
    // Convert to standard format for consistent fingerprinting
    await exec(`ffmpeg -i "${filePath}" -ar 44100 -ac 1 -vn "${tempWavPath}"`);
    
    // Generate fingerprint using chromaprint (fpcalc)
    const { stdout } = await exec(`fpcalc -raw -length 120 "${tempWavPath}"`);
    
    // Parse the output
    const fingerprintMatch = stdout.match(/FINGERPRINT=(.+)$/m);
    const durationMatch = stdout.match(/DURATION=(.+)$/m);
    
    if (!fingerprintMatch) {
      throw new Error('Failed to generate fingerprint');
    }
    
    const fingerprint = fingerprintMatch[1];
    const duration = durationMatch ? parseInt(durationMatch[1], 10) : 0;
    
    // Clean up temporary file
    await fs.promises.unlink(tempWavPath);
    
    // Generate a hash for quick comparison
    const fingerprintHash = crypto
      .createHash('sha256')
      .update(fingerprint)
      .digest('hex');
    
    return {
      fingerprint,
      fingerprintHash,
      duration,
      algorithm: 'chromaprint',
      version: '1.0'
    };
  } catch (error) {
    console.error('Failed to create audio fingerprint:', error);
    throw error;
  }
}
```

#### 190320250630
Complete audio processing pipeline:
```typescript
async function processAudio(filePath, options = {}) {
  try {
    // Create a processing job
    const jobId = crypto.randomUUID();
    const job = {
      id: jobId,
      filePath,
      options,
      status: 'processing',
      startTime: Date.now(),
      results: {},
      errors: []
    };
    
    // Store job in database
    await db.processingJobs.create({
      data: {
        id: jobId,
        type: 'audio',
        status: 'processing',
        filePath,
        options: JSON.stringify(options),
        startTime: new Date()
      }
    });
    
    // Extract basic metadata
    try {
      job.results.metadata = await extractAudioMetadata(filePath);
      await updateJobProgress(jobId, 10, 'Metadata extracted');
    } catch (error) {
      job.errors.push({ step: 'metadata', error: error.message });
      await logProcessingError(jobId, 'metadata', error);
    }
    
    // Generate fingerprints using multiple algorithms
    try {
      job.results.fingerprints = await generateMultipleFingerprints(filePath);
      await updateJobProgress(jobId, 20, 'Fingerprints generated');
    } catch (error) {
      job.errors.push({ step: 'fingerprinting', error: error.message });
      await logProcessingError(jobId, 'fingerprinting', error);
    }
    
    // Check for duplicates
    try {
      job.results.duplicateCheck = await checkForDuplicates(job.results.fingerprints);
      await updateJobProgress(jobId, 30, 'Duplicate check completed');
    } catch (error) {
      job.errors.push({ step: 'duplicateCheck', error: error.message });
      await logProcessingError(jobId, 'duplicateCheck', error);
    }
    
    // Generate waveform data
    try {
      job.results.waveform = await generateWaveformData(filePath);
      await updateJobProgress(jobId, 40, 'Waveform generated');
    } catch (error) {
      job.errors.push({ step: 'waveform', error: error.message });
      await logProcessingError(jobId, 'waveform', error);
    }
    
    // Analyze audio quality
    try {
      job.results.qualityAnalysis = await analyzeAudioQuality(filePath);
      await updateJobProgress(jobId, 60, 'Quality analysis completed');
    } catch (error) {
      job.errors.push({ step: 'qualityAnalysis', error: error.message });
      await logProcessingError(jobId, 'qualityAnalysis', error);
    }
    
    // Generate optimized formats
    try {
      job.results.formats = await generateOptimizedFormats(filePath, options.formats);
      await updateJobProgress(jobId, 80, 'Optimized formats generated');
    } catch (error) {
      job.errors.push({ step: 'formatConversion', error: error.message });
      await logProcessingError(jobId, 'formatConversion', error);
    }
    
    // Complete the job
    job.status = job.errors.length === 0 ? 'completed' : 'completed_with_errors';
    job.endTime = Date.now();
    job.processingTime = job.endTime - job.startTime;
    
    // Update job in database
    await db.processingJobs.update({
      where: { id: jobId },
      data: {
        status: job.status,
        results: JSON.stringify(job.results),
        errors: JSON.stringify(job.errors),
        endTime: new Date(job.endTime),
        processingTime: job.processingTime
      }
    });
    
    return job;
  } catch (error) {
    console.error('Audio processing failed:', error);
    
    // Update job in database with failure status
    await db.processingJobs.update({
      where: { id: jobId },
      data: {
        status: 'failed',
        errors: JSON.stringify([{ step: 'overall', error: error.message }]),
        endTime: new Date()
      }
    });
    
    throw error;
  }
}

// Quality analysis function
async function analyzeAudioQuality(filePath) {
  // Create temporary directory
  const tempDir = path.join(os.tmpdir(), 'audio-quality');
  await fs.promises.mkdir(tempDir, { recursive: true });
  
  // Generate a unique name for this analysis
  const fileId = crypto.randomUUID();
  const tempJsonPath = path.join(tempDir, `${fileId}.json`);
  
  try {
    // Use ffmpeg with loudnorm filter to analyze loudness
    await exec(`ffmpeg -i "${filePath}" -af loudnorm=print_format=json -f null - 2>${tempJsonPath}`);
    
    // Read the loudness analysis json
    const loudnessData = JSON.parse(await fs.promises.readFile(tempJsonPath, 'utf8'));
    
    // Use ffprobe to get spectral information
    const { stdout: spectrumData } = await exec(
      `ffmpeg -i "${filePath}" -af astats=metadata=1:reset=1,ametadata=print:key=lavfi.astats.Overall.RMS_level -f null -`
    );
    
    // Extract RMS level
    const rmsMatch = spectrumData.match(/lavfi\.astats\.Overall\.RMS_level=(.+)/);
    const rmsLevel = rmsMatch ? parseFloat(rmsMatch[1]) : null;
    
    // Use additional analysis for quality metrics
    const { stdout: samplePeakData } = await exec(
      `ffmpeg -i "${filePath}" -af astats=metadata=1:reset=1,ametadata=print:key=lavfi.astats.Overall.Peak_level -f null -`
    );
    
    // Extract peak level
    const peakMatch = samplePeakData.match(/lavfi\.astats\.Overall\.Peak_level=(.+)/);
    const peakLevel = peakMatch ? parseFloat(peakMatch[1]) : null;
    
    // Calculate quality metrics
    const dynamicRange = peakLevel !== null && rmsLevel !== null ? Math.abs(peakLevel - rmsLevel) : null;
    
    // Calculate overall quality score (a simplified version)
    let qualityScore = 0;
    let qualityIssues = [];
    
    // Check integrated loudness (target is -14 LUFS for most platforms)
    const integratedLoudness = parseFloat(loudnessData.input_i);
    if (integratedLoudness > -9) {
      qualityIssues.push('Audio is too loud, exceeding recommended levels');
      qualityScore -= 20;
    } else if (integratedLoudness < -18) {
      qualityIssues.push('Audio level is too low, may be inaudible on some devices');
      qualityScore -= 15;
    } else {
      qualityScore += 20;
    }
    
    // Check dynamic range (higher is generally better, but not always)
    if (dynamicRange !== null) {
      if (dynamicRange < 6) {
        qualityIssues.push('Low dynamic range, audio may sound flat or over-compressed');
        qualityScore -= 15;
      } else if (dynamicRange > 20) {
        qualityIssues.push('Very high dynamic range, quiet parts may be inaudible in noisy environments');
        qualityScore -= 5;
      } else {
        qualityScore += 15;
      }
    }
    
    // Check true peak (should not exceed -1 dBFS to avoid clipping)
    const truePeak = parseFloat(loudnessData.input_tp);
    if (truePeak > -1) {
      qualityIssues.push('Audio contains clipping, may cause distortion');
      qualityScore -= 25;
    } else if (truePeak > -3) {
      qualityIssues.push('Audio peaks close to clipping threshold');
      qualityScore -= 10;
    } else {
      qualityScore += 15;
    }
    
    // Normalize the score to a 0-100 scale
    qualityScore = Math.max(0, Math.min(100, 50 + qualityScore));
    
    // Generate mastering recommendations
    const masteringRecommendations = [];
    
    if (integratedLoudness > -9) {
      masteringRecommendations.push('Reduce overall level to achieve integrated loudness of -14 LUFS');
    } else if (integratedLoudness < -18) {
      masteringRecommendations.push('Increase overall level to achieve integrated loudness of -14 LUFS');
    }
    
    if (truePeak > -1) {
      masteringRecommendations.push('Apply limiter to prevent clipping and keep true peaks below -1 dBFS');
    }
    
    if (dynamicRange !== null && dynamicRange < 6) {
      masteringRecommendations.push('Reduce compression to improve dynamic range');
    }
    
    return {
      metrics: {
        integratedLoudness,
        truePeak,
        loudnessRange: parseFloat(loudnessData.input_lra),
        rmsLevel,
        peakLevel,
        dynamicRange
      },
      qualityScore,
      qualityIssues,
      masteringRecommendations
    };
  } catch (error) {
    console.error('Audio quality analysis failed:', error);
    throw error;
  } finally {
    // Clean up temporary files
    try {
      await fs.promises.unlink(tempJsonPath);
    } catch (error) {
      // Ignore cleanup errors
    }
  }
}
```

#### Current
Added batch processing capabilities:
```typescript
async function processBatch(files, options = {}) {
  // Validate input
  if (!Array.isArray(files) || files.length === 0) {
    throw new Error('No files provided for batch processing');
  }
  
  // Create batch record
  const batchId = crypto.randomUUID();
  const batch = {
    id: batchId,
    totalFiles: files.length,
    processedFiles: 0,
    successfulFiles: 0,
    failedFiles: 0,
    status: 'processing',
    startTime: Date.now(),
    results: [],
    errors: []
  };
  
  // Store batch info in database
  await db.processingBatches.create({
    data: {
      id: batchId,
      type: 'audio',
      totalFiles: files.length,
      status: 'processing',
      options: JSON.stringify(options),
      startTime: new Date()
    }
  });
  
  // Determine concurrency based on server resources and options
  const concurrency = options.concurrency || Math.min(
    Math.max(1, Math.floor(os.cpus().length / 2)),
    10, // Maximum concurrency
    files.length
  );
  
  console.log(`Processing batch ${batchId} with concurrency ${concurrency}`);
  
  // Create processing queue with concurrency limit
  const queue = new PQueue({ concurrency });
  
  // Add all files to the queue
  const promises = files.map((file, index) => {
    return queue.add(async () => {
      try {
        // Update batch with current file
        await db.processingBatches.update({
          where: { id: batchId },
          data: {
            currentFileIndex: index,
            currentFile: file.path || file
          }
        });
        
        // Process the file
        const result = await processAudio(file.path || file, options);
        
        // Update batch counters
        batch.processedFiles++;
        batch.successfulFiles++;
        batch.results.push({
          file: file.path || file,
          jobId: result.id,
          success: true
        });
        
        // Update progress in database
        await updateBatchProgress(batchId, batch);
        
        return result;
      } catch (error) {
        console.error(`Error processing file ${file.path || file}:`, error);
        
        // Update batch counters
        batch.processedFiles++;
        batch.failedFiles++;
        batch.errors.push({
          file: file.path || file,
          error: error.message
        });
        
        // Update progress in database
        await updateBatchProgress(batchId, batch);
        
        // Rethrow if configured to stop on first error
        if (options.stopOnError) {
          throw error;
        }
        
        // Otherwise return error result
        return {
          file: file.path || file,
          success: false,
          error: error.message
        };
      }
    });
  });
  
  // Wait for all files to be processed or failed
  try {
    await Promise.all(promises);
    
    // Update batch status
    batch.status = batch.failedFiles > 0 ? 'completed_with_errors' : 'completed';
    batch.endTime = Date.now();
    batch.processingTime = batch.endTime - batch.startTime;
    
    // Update final status in database
    await db.processingBatches.update({
      where: { id: batchId },
      data: {
        status: batch.status,
        processedFiles: batch.processedFiles,
        successfulFiles: batch.successfulFiles,
        failedFiles: batch.failedFiles,
        results: JSON.stringify(batch.results),
        errors: JSON.stringify(batch.errors),
        endTime: new Date(batch.endTime),
        processingTime: batch.processingTime
      }
    });
    
    console.log(`Batch ${batchId} completed: ${batch.successfulFiles} successful, ${batch.failedFiles} failed`);
    return batch;
  } catch (error) {
    console.error(`Batch ${batchId} failed:`, error);
    
    // Update batch with failure status
    await db.processingBatches.update({
      where: { id: batchId },
      data: {
        status: 'failed',
        processedFiles: batch.processedFiles,
        successfulFiles: batch.successfulFiles,
        failedFiles: batch.failedFiles,
        results: JSON.stringify(batch.results),
        errors: JSON.stringify([...batch.errors, { step: 'overall', error: error.message }]),
        endTime: new Date()
      }
    });
    
    // Rethrow the error
    throw error;
  }
}

// Helper function to update batch progress
async function updateBatchProgress(batchId, batch) {
  const progress = Math.floor((batch.processedFiles / batch.totalFiles) * 100);
  
  await db.processingBatches.update({
    where: { id: batchId },
    data: {
      processedFiles: batch.processedFiles,
      successfulFiles: batch.successfulFiles,
      failedFiles: batch.failedFiles,
      progress,
      results: JSON.stringify(batch.results),
      errors: JSON.stringify(batch.errors)
    }
  });
  
  // Emit progress event for real-time monitoring
  eventEmitter.emit('batchProgress', {
    batchId,
    progress,
    processedFiles: batch.processedFiles,
    totalFiles: batch.totalFiles
  });
}
```

## Rights Management Evolution

### 1. Dispute Resolution

#### 17032025
Basic dispute handling:
```typescript
export const rightsDisputes = pgTable("rights_disputes", {
  id: serial("id").primaryKey(),
  assetId: integer("asset_id").notNull(),
  assetType: text("asset_type").notNull(), // "track", "release", etc.
  disputeType: conflictTypeEnum("dispute_type").notNull(),
  claimantId: integer("claimant_id").notNull(),
  respondentId: integer("respondent_id").notNull(),
  rightId: integer("right_id").references(() => rights.id),
  description: text("description").notNull(),
  evidence: json("evidence").default([]),
  status: text("status").notNull().default("open"),
  resolution: text("resolution"),
  resolutionDate: timestamp("resolution_date"),
  resolvedById: integer("resolved_by_id"),
  createdAt: timestamp("created_at").notNull().defaultNow(),
  updatedAt: timestamp("updated_at").notNull().defaultNow(),
});
```

#### Current
Formalized dispute process workflow:
```typescript
// Dispute creation
async function createDispute({
  assetId,
  assetType,
  rightId,
  claimantId,
  respondentId,
  reason,
  evidence,
}) {
  // Validate dispute data
  if (!assetId || !assetType || !rightId || !claimantId || !respondentId || !reason) {
    throw new Error('Missing required dispute information');
  }
  
  // Check if existing dispute
  const existingDispute = await db.rightsDisputes.findFirst({
    where: {
      assetId,
      assetType,
      rightId,
      claimantId,
      status: { in: ['open', 'under_review', 'escalated'] }
    }
  });
  
  if (existingDispute) {
    throw new Error(`An active dispute already exists for this right (ID: ${existingDispute.id})`);
  }
  
  // Create dispute workflow
  const workflow = {
    steps: [
      {
        name: 'dispute_opened',
        status: 'completed',
        completedAt: new Date().toISOString(),
        completedBy: claimantId,
      },
      {
        name: 'respondent_notification',
        status: 'pending',
      },
      {
        name: 'evidence_collection',
        status: 'in_progress',
        startedAt: new Date().toISOString(),
      },
      {
        name: 'admin_review',
        status: 'pending',
      },
      {
        name: 'resolution',
        status: 'pending',
      }
    ],
    currentStep: 'evidence_collection',
  };
  
  // Create dispute record
  const dispute = await db.rightsDisputes.create({
    data: {
      assetId,
      assetType,
      rightId,
      claimantId,
      respondentId,
      reason,
      evidence: evidence || [],
      status: 'open',
      workflow: JSON.stringify(workflow),
      createdAt: new Date(),
      updatedAt: new Date(),
    }
  });
  
  // Generate tracking ID
  const trackingId = generateDisputeTrackingId(dispute.id);
  
  // Update dispute with tracking ID
  await db.rightsDisputes.update({
    where: { id: dispute.id },
    data: {
      trackingId,
    }
  });
  
  // Notify respondent
  await notifyDisputeParty(respondentId, 'dispute_response_required', {
    disputeId: dispute.id,
    trackingId,
    assetType,
    assetId,
  });
  
  // Update workflow step
  await updateDisputeWorkflowStep(dispute.id, 'respondent_notification', 'completed');
  
  // Return dispute with tracking ID
  return {
    ...dispute,
    trackingId,
  };
}

// Dispute evidence submission
async function submitDisputeEvidence(disputeId, partyId, evidenceItems) {
  // Get dispute
  const dispute = await db.rightsDisputes.findUnique({
    where: { id: disputeId }
  });
  
  if (!dispute) {
    throw new Error(`Dispute ${disputeId} not found`);
  }
  
  // Check if party is involved in dispute
  if (dispute.claimantId !== partyId && dispute.respondentId !== partyId) {
    throw new Error('You are not authorized to submit evidence for this dispute');
  }
  
  // Check if dispute is in appropriate status
  if (!['open', 'under_review', 'evidence_collection'].includes(dispute.status)) {
    throw new Error(`Cannot submit evidence for dispute in status: ${dispute.status}`);
  }
  
  // Parse workflow
  const workflow = JSON.parse(dispute.workflow);
  if (workflow.currentStep !== 'evidence_collection') {
    throw new Error(`Dispute is not in evidence collection phase`);
  }
  
  // Validate evidence items
  if (!Array.isArray(evidenceItems) || evidenceItems.length === 0) {
    throw new Error('Invalid evidence items');
  }
  
  // Prepare new evidence entries
  const newEvidence = evidenceItems.map(item => ({
    id: crypto.randomUUID(),
    title: item.title,
    description: item.description,
    fileUrl: item.fileUrl,
    fileType: item.fileType,
    submittedBy: partyId,
    submittedAt: new Date().toISOString(),
    partyType: partyId === dispute.claimantId ? 'claimant' : 'respondent'
  }));
  
  // Update dispute with new evidence
  const currentEvidence = Array.isArray(dispute.evidence) ? dispute.evidence : [];
  const updatedEvidence = [...currentEvidence, ...newEvidence];
  
  await db.rightsDisputes.update({
    where: { id: disputeId },
    data: {
      evidence: updatedEvidence,
      updatedAt: new Date()
    }
  });
  
  // Check if both parties have submitted evidence
  const hasClaimantEvidence = updatedEvidence.some(e => e.partyType === 'claimant');
  const hasRespondentEvidence = updatedEvidence.some(e => e.partyType === 'respondent');
  
  // If both parties have submitted evidence, move to admin review
  if (hasClaimantEvidence && hasRespondentEvidence) {
    await updateDisputeWorkflowStep(disputeId, 'evidence_collection', 'completed');
    await updateDisputeWorkflowStep(disputeId, 'admin_review', 'in_progress');
    
    await db.rightsDisputes.update({
      where: { id: disputeId },
      data: {
        status: 'under_review',
        updatedAt: new Date()
      }
    });
    
    // Notify admin team
    await notifyAdminTeam('dispute_review_required', {
      disputeId,
      trackingId: dispute.trackingId,
      assetType: dispute.assetType,
      assetId: dispute.assetId,
    });
  }
  
  return {
    success: true,
    message: 'Evidence submitted successfully',
    evidenceCount: updatedEvidence.length,
    disputeStatus: hasClaimantEvidence && hasRespondentEvidence ? 'under_review' : dispute.status
  };
}

// Resolve dispute
async function resolveDispute(disputeId, resolverId, resolution, decision, notes) {
  // Get dispute
  const dispute = await db.rightsDisputes.findUnique({
    where: { id: disputeId }
  });
  
  if (!dispute) {
    throw new Error(`Dispute ${disputeId} not found`);
  }
  
  // Check if in appropriate status
  if (dispute.status !== 'under_review') {
    throw new Error(`Cannot resolve dispute in status: ${dispute.status}`);
  }
  
  // Validate resolution
  if (!['resolved_for_claimant', 'resolved_for_respondent', 'split_decision', 'no_action'].includes(resolution)) {
    throw new Error('Invalid resolution type');
  }
  
  // Update dispute
  await db.rightsDisputes.update({
    where: { id: disputeId },
    data: {
      status: 'resolved',
      resolution,
      resolutionNotes: notes,
      resolutionDate: new Date(),
      resolvedById: resolverId,
      updatedAt: new Date()
    }
  });
  
  // Update workflow
  await updateDisputeWorkflowStep(disputeId, 'admin_review', 'completed');
  await updateDisputeWorkflowStep(disputeId, 'resolution', 'completed');
  
  // Apply decision if needed
  if (resolution !== 'no_action') {
    await applyDisputeResolution(disputeId, resolution, decision);
  }
  
  // Notify parties
  await notifyDisputeParty(dispute.claimantId, 'dispute_resolved', {
    disputeId,
    trackingId: dispute.trackingId,
    resolution,
    resolutionNotes: notes
  });
  
  await notifyDisputeParty(dispute.respondentId, 'dispute_resolved', {
    disputeId,
    trackingId: dispute.trackingId,
    resolution,
    resolutionNotes: notes
  });
  
  return {
    success: true,
    message: 'Dispute resolved successfully',
    resolution,
    resolutionDate: new Date()
  };
}
```

## Best Implementation By Component

### Database Schema
**Best Implementation**: Current branch with specific tables from 190320250630
```typescript
// Current branch analytics with event tracking
export const analytics = pgTable("analytics", {
  id: serial("id").primaryKey(),
  trackId: integer("track_id").notNull(),
  releaseId: integer("release_id"),
  date: timestamp("date").notNull(),
  platform: text("platform").notNull(),
  streams: integer("streams").notNull().default(0),
  revenue: numeric("revenue").notNull().default("0"),
  country: text("country").default("unknown"),
  city: text("city").default("unknown"),
  playlistAdds: integer("playlist_adds").default(0),
  saves: integer("saves").default(0),
  shares: integer("shares").default(0),
  avgPlayTime: numeric("avg_play_time").default("0"),
  event: text("event"),
  eventDetails: json("event_details"),
  demographics: json("demographics").default({
    // Demographics structure
  }),
});

// 190320250630 royalty tables
export const royaltyCalculations = pgTable("royalty_calculations", {
  id: serial("id").primaryKey(),
  // Comprehensive financial fields...
});
```

### Authentication
**Best Implementation**: 190320250630 with Current's security enhancements
```typescript
// 190320250630 role-based system with specialized flows
// Current branch's enhanced password validation
function validatePassword(password: string): boolean {
  // Enhanced validation with multiple requirements
  if (password.length < 10) return false;
  if (!/[A-Z]/.test(password)) return false;
  if (!/[a-z]/.test(password)) return false;
  if (!/[0-9]/.test(password)) return false;
  if (!/[^A-Za-z0-9]/.test(password)) return false;
  return true;
}

// 190320250630 specialized auth flows
// Current branch's session monitoring
function detectSuspiciousActivity(req): boolean {
  // Enhanced security checks
}
```

### Blockchain Integration
**Best Implementation**: 17032025 multi-network with Current's optimizations
```typescript
// 17032025 multi-network configuration
const blockchainNetworks = {
  ethereum: { /* network config */ },
  polygon: { /* network config */ }
};

// Current branch gas optimization
async function optimizeGasFee(networkId) {
  // Dynamic fee calculation
}

// Current branch transaction handling with retry
async function executeBlockchainTransaction(networkId, contractMethod, params, options) {
  // Robust transaction execution
}
```

### AI Implementation
**Best Implementation**: 190320250630 features with Current's fallbacks
```typescript
// 190320250630 comprehensive AI suite
// Current branch fallback mechanisms
export async function generateContentTags(title, artistName, type) {
  // Check for API key and service availability
  if (!process.env.OPENAI_API_KEY) {
    return getDefaultAnalysis(title, artistName, type);
  }
  
  try {
    // AI processing with robust error handling
  } catch (error) {
    // Fallback to cached or generated results
    return getCachedOrFallbackAnalysis(title, artistName, type);
  }
}
```

### Audio Processing
**Best Implementation**: 190320250630 pipeline with Current's batch capabilities
```typescript
// 190320250630 comprehensive audio processing
async function processAudio(filePath, options) {
  // Complete audio pipeline with quality assessment
}

// Current branch batch processing
async function processBatch(files, options) {
  // Parallel processing with queue management
}
```

### Rights Management
**Best Implementation**: 190320250630 rights system with Current's dispute resolution
```typescript
// 190320250630 comprehensive rights
// Current branch dispute resolution
async function createDispute({assetId, assetType, rightId, claimantId, respondentId, reason, evidence}) {
  // Formalized dispute workflow
}

async function resolveDispute(disputeId, resolverId, resolution, decision, notes) {
  // Structured resolution process
}
```

## Conclusion

The TuneMantra codebase has evolved significantly over successive branches, with clear patterns of increasing sophistication and optimization. The precise code analysis reveals:

1. **PPv1** featured excellent documentation that was lost in 3march but reinstated in 190320250630

2. **3march to 8march258** added significant analytics capabilities with demographic data

3. **12march547** brought critical architectural changes, consolidating the SuperAdmin table into the user role system

4. **17032025** implemented multi-blockchain network capability, greatly enhancing platform flexibility

5. **190320250630** featured the most comprehensive implementations across most components, particularly for rights management and audio processing

6. **Current** branch focused on performance optimizations, naming standardization, fallback mechanisms, and enhanced error handling

The optimal implementation would combine Current branch's optimizations and fallback mechanisms with 190320250630's comprehensive feature set, 17032025's multi-network blockchain capabilities, and the documentation style of PPv1/190320250630.

---

## documentation/project/implementation-plan.md

# TuneMantra Implementation Plan

This document outlines the step-by-step process for implementing the recommended approach of combining the best features from multiple branches.

## Implementation Strategy

### Step 1: Start with Current Branch as Foundation

- Clone or copy the current branch as the base
- Preserve the optimized naming conventions (e.g., `splitPercentage`)
- Keep the enhanced error handling and performance optimizations
- Maintain event tracking analytics and default values

### Step 2: Schema Integration

#### From 190320250630

Import these tables from `shared/schema.ts`:

1. **Royalty Tables**:
   - `royaltyCalculations`
   - Associated schemas and relationships
   
2. **Rights Management Tables**:
   - Territorial rights support
   - Time-based expiration logic

```typescript
// Example integration of royalty tables from 190320250630
export const royaltyCalculations = pgTable("royalty_calculations", {
  id: serial("id").primaryKey(),
  // Foreign keys for related data
  distributionRecordId: integer("distribution_record_id").notNull(),
  releaseId: integer("release_id").notNull(),
  trackId: integer("track_id").notNull(),
  userId: integer("user_id").notNull(),
  
  // Calculation financial data
  amount: numeric("amount").notNull(), // calculated royalty amount
  streamCount: integer("stream_count").notNull().default(0),
  ratePerStream: numeric("rate_per_stream"),
  
  // Other fields from 190320250630...
});

// Ensure validation schema is also added
export const insertRoyaltyCalculationSchema = createInsertSchema(royaltyCalculations)
  .omit({
    id: true,
    createdAt: true,
    updatedAt: true,
    // Other generated fields...
  })
  .extend({
    amount: z.number().min(0, "Amount must be a positive number"),
    // Other validations...
  });

export type RoyaltyCalculation = typeof royaltyCalculations.$inferSelect;
export type InsertRoyaltyCalculation = z.infer<typeof insertRoyaltyCalculationSchema>;
```

#### Update Relations

Ensure all relations between tables are properly updated:

```typescript
// Example of updating relations for royalty tables
export const royaltyCalculationsRelations = relations(royaltyCalculations, ({ one }) => ({
  release: one(releases, {
    fields: [royaltyCalculations.releaseId],
    references: [releases.id],
  }),
  track: one(tracks, {
    fields: [royaltyCalculations.trackId],
    references: [tracks.id],
  }),
  user: one(users, {
    fields: [royaltyCalculations.userId],
    references: [users.id],
  }),
  // Other relations...
}));
```

### Step 3: Authentication System Integration

1. **Keep Current Branch Password Validation**:

```typescript
// Current branch enhanced password validation
function validatePassword(password: string): boolean {
  if (password.length < 10) return false;
  if (!/[A-Z]/.test(password)) return false;
  if (!/[a-z]/.test(password)) return false;
  if (!/[0-9]/.test(password)) return false;
  if (!/[^A-Za-z0-9]/.test(password)) return false;
  return true;
}
```

2. **Incorporate 190320250630 Role-Based Access Control**:

```typescript
// From 190320250630
function hasPermission(userRole: string, requiredPermission: string): boolean {
  const permissions = {
    admin: ['all'],
    label: [
      'manage_label', 
      'manage_artists', 
      'upload_content', 
      'view_analytics', 
      'manage_releases',
      'manage_distributions',
      'view_royalties'
    ],
    artist_manager: [
      'manage_artists', 
      'upload_content', 
      'view_analytics',
      'manage_releases',
      'view_artist_royalties'
    ],
    artist: [
      'upload_content', 
      'view_own_analytics',
      'manage_own_releases'
    ]
  };
  
  const userPermissions = permissions[userRole] || [];
  return userPermissions.includes('all') || userPermissions.includes(requiredPermission);
}

// Middleware to check permission
function requirePermission(permission: string) {
  return (req, res, next) => {
    if (!req.user) {
      return res.status(401).json({ error: 'Authentication required' });
    }
    
    if (!hasPermission(req.user.role, permission)) {
      return res.status(403).json({ error: 'Permission denied' });
    }
    
    next();
  };
}
```

3. **Add Current Branch Security Monitoring**:

```typescript
// Current branch security monitoring
function detectSuspiciousActivity(req): boolean {
  if (!req.session.userId) return false;
  
  // Check for IP changes
  if (req.session.ipAddress && req.session.ipAddress !== req.ip) {
    logSecurityEvent('ip_changed', {
      userId: req.session.userId,
      oldIp: req.session.ipAddress,
      newIp: req.ip
    });
    return true;
  }
  
  // Other security checks...
  
  return false;
}
```

### Step 4: Blockchain Integration

1. **Import Multi-Network Configuration from 17032025**:

```typescript
// From 17032025
const blockchainNetworks = {
  ethereum: {
    name: 'Ethereum Mainnet',
    chainId: 1,
    currency: 'ETH',
    provider: new ethers.providers.JsonRpcProvider(process.env.ETHEREUM_RPC_URL),
    contractAddress: process.env.ETHEREUM_CONTRACT_ADDRESS,
    contractABI: JSON.parse(fs.readFileSync('./contracts/RightsManager.json', 'utf8')).abi,
  },
  polygon: {
    name: 'Polygon Mainnet',
    chainId: 137,
    currency: 'MATIC',
    provider: new ethers.providers.JsonRpcProvider(process.env.POLYGON_RPC_URL),
    contractAddress: process.env.POLYGON_CONTRACT_ADDRESS,
    contractABI: JSON.parse(fs.readFileSync('./contracts/RightsManager.json', 'utf8')).abi,
  },
  // Add more networks as needed
};
```

2. **Add Gas Optimization from Current Branch**:

```typescript
// From Current branch
async function optimizeGasFee(networkId = 'ethereum') {
  try {
    const network = blockchainNetworks[networkId];
    const provider = network.provider;
    
    // Get current gas prices and network conditions
    const feeData = await provider.getFeeData();
    const block = await provider.getBlock('latest');
    const networkCongestion = block.gasUsed.mul(100).div(block.gasLimit).toNumber();
    
    // Adjust based on network congestion
    let maxFeeMultiplier;
    if (networkCongestion > 80) {
      // High congestion, pay premium for faster inclusion
      maxFeeMultiplier = 150; // 50% premium
    } else if (networkCongestion > 50) {
      // Medium congestion
      maxFeeMultiplier = 120; // 20% premium
    } else {
      // Low congestion
      maxFeeMultiplier = 110; // 10% premium
    }
    
    // Calculate optimal fees
    const maxFeePerGas = feeData.maxFeePerGas.mul(maxFeeMultiplier).div(100);
    const maxPriorityFeePerGas = feeData.maxPriorityFeePerGas.mul(maxFeeMultiplier).div(100);
    
    return {
      maxFeePerGas,
      maxPriorityFeePerGas,
      estimatedBaseFee: feeData.lastBaseFeePerGas,
      networkCongestion
    };
  } catch (error) {
    console.error(`Failed to optimize gas fee for ${networkId}:`, error);
    
    // Return reasonable defaults in case of error
    return {
      maxFeePerGas: ethers.utils.parseUnits('50', 'gwei'),
      maxPriorityFeePerGas: ethers.utils.parseUnits('2', 'gwei'),
      networkCongestion: 50,
      isEstimate: true
    };
  }
}
```

3. **Combine with Rights Registration from 190320250630**:

```typescript
// Combine 190320250630 rights registration with Current branch optimization
async function registerRightsWithBlockchain({
  assetId,
  assetType,
  rightsType,
  ownerId,
  percentage,
  territory,
  startDate,
  endDate,
  networkId = 'ethereum'
}) {
  try {
    // Validate inputs from Current branch
    validateRightsInput({assetId, assetType, rightsType, ownerId, percentage});
    
    // Get user's blockchain address
    const user = await db.users.findFirst({
      where: { id: ownerId },
      select: { blockchainAddress: true }
    });
    
    if (!user?.blockchainAddress) {
      throw new Error(`User ${ownerId} does not have a blockchain address`);
    }
    
    // Get gas optimization from Current branch
    const gasSettings = await optimizeGasFee(networkId);
    
    // Get blockchain connection from 17032025
    const { contract, network } = await initBlockchain(networkId);
    
    // Register rights (from 190320250630 with Current optimization)
    const tx = await contract.registerRights(
      assetId.toString(),
      assetType,
      rightsType,
      user.blockchainAddress,
      percentage.toString(),
      territory || 'GLOBAL',
      Math.floor(startDate.getTime() / 1000),
      endDate ? Math.floor(endDate.getTime() / 1000) : 0,
      { 
        maxFeePerGas: gasSettings.maxFeePerGas,
        maxPriorityFeePerGas: gasSettings.maxPriorityFeePerGas
      }
    );
    
    // Wait for confirmation from Current branch
    const receipt = await tx.wait(network.confirmations || 1);
    
    // Enhanced result with additional metadata from Current
    return {
      transactionHash: tx.hash,
      blockNumber: receipt.blockNumber,
      status: receipt.status === 1 ? 'success' : 'failed',
      gasUsed: receipt.gasUsed.toString(),
      effectiveGasPrice: receipt.effectiveGasPrice.toString(),
    };
  } catch (error) {
    // Enhanced error handling from Current
    handleBlockchainError(error, 'rights_registration');
    throw new Error(`Rights registration failed: ${error.message}`);
  }
}
```

### Step 5: AI Integration

1. **Combine 190320250630 Features with Current Fallbacks**:

```typescript
// Combine 190320250630 AI features with Current fallbacks
export async function generateContentTags(
  title: string,
  artistName: string,
  type: "audio" | "video"
): Promise<{ tags: ContentTags; analysis: AIAnalysis }> {
  // Current branch fallback mechanism
  if (!process.env.OPENAI_API_KEY) {
    console.log("OpenAI API key not configured, returning default analysis data");
    return getDefaultAnalysis(title, artistName, type);
  }

  try {
    // Check AI service status from cache (Current branch)
    const serviceStatus = await getAIServiceStatus();
    if (!serviceStatus.available) {
      console.log("AI service unavailable, using cached or generated results");
      return getCachedOrFallbackAnalysis(title, artistName, type);
    }
    
    // Initialize OpenAI client
    const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
    
    // 190320250630 comprehensive prompt structure with Current's model upgrade
    const response = await openai.chat.completions.create({
      model: "gpt-4o",  // Current branch model
      messages: [
        // System prompt from 190320250630
        {
          role: "system",
          content: `You are an expert music and media content analyzer with deep knowledge of genres, 
           styles, moods, cultural contexts, and commercial potential. Analyze the given ${type} 
           content information and provide detailed tags and analysis. Your response should be 
           formatted as valid JSON with these fields:
           - genres: array of genre tags
           - moods: array of mood tags
           - themes: array of thematic tags
           - explicit: boolean indicating if content likely contains explicit material
           - languages: array of likely languages used
           - similarArtists: array of similar artists
           - commercialPotential: object with numeric score (0-100) and analysis text
           - qualityAssessment: object with numeric score (0-100) and analysis text
           - contentWarnings: array of potential content warnings
           - suggestedPlaylists: array of playlist concepts this would fit in
           - summary: text summarizing the content
           - suggestedImprovements: array of potential improvements`,
        },
        // User prompt
        {
          role: "user",
          content: `Please analyze this ${type} content:\nTitle: ${title}\nArtist: ${artistName}`,
        },
      ],
      response_format: { type: "json_object" }, // 190320250630 structure
    });

    // Current branch enhanced parsing
    const content = response.choices[0].message.content || "{}";
    const result = JSON.parse(content);
    
    // Store result in cache for future fallback (Current branch)
    await cacheAnalysisResult(title, artistName, type, result);
    
    // Update service status in cache (Current branch)
    await updateAIServiceStatus(true);
    
    // Return validated and structured result from 190320250630
    return {
      tags: {
        genres: validateAndNormalizeTags(result.genres || []),
        moods: validateAndNormalizeTags(result.moods || []),
        themes: validateAndNormalizeTags(result.themes || []),
        explicit: Boolean(result.explicit),
        languages: validateAndNormalizeTags(result.languages || []),
      },
      analysis: {
        summary: result.summary || "",
        commercialPotential: {
          score: validateQualityScore(result.commercialPotential?.score),
          analysis: result.commercialPotential?.analysis || "",
        },
        qualityAssessment: {
          score: validateQualityScore(result.qualityAssessment?.score),
          analysis: result.qualityAssessment?.analysis || "",
        },
        contentWarnings: validateAndNormalizeTags(result.contentWarnings || []),
        suggestedPlaylists: result.suggestedPlaylists || [],
        similarArtists: result.similarArtists || [],
        suggestedImprovements: result.suggestedImprovements || [],
        confidence: 0.95, // Current branch addition
      },
    };
  } catch (error) {
    // Current branch enhanced error handling
    if (error.status === 429 || error.status === 500 || error.status === 503) {
      // Mark service as unavailable in cache
      await updateAIServiceStatus(false, error.message);
      console.log("AI service temporarily unavailable:", error.message);
    } else {
      console.error("AI Analysis failed:", error);
    }
    
    // Current branch fallback approach
    return getCachedOrFallbackAnalysis(title, artistName, type);
  }
}

// Current branch validation helpers
function validateAndNormalizeTags(tags) {
  return tags.map(tag => tag.toLowerCase().trim())
    .filter(tag => tag.length > 0)
    .slice(0, 10); // Limit number of tags
}

function validateQualityScore(score) {
  const numScore = Number(score);
  if (isNaN(numScore)) return 0;
  return Math.max(0, Math.min(100, numScore));
}
```

### Step 6: Audio Processing Integration

1. **Combine 190320250630 Pipeline with Current Batch Processing**:

```typescript
// Main entry point for batch processing (Current branch)
async function processBatch(files, options = {}) {
  // Validate input
  if (!Array.isArray(files) || files.length === 0) {
    throw new Error('No files provided for batch processing');
  }
  
  // Create batch record
  const batchId = crypto.randomUUID();
  const batch = {
    id: batchId,
    totalFiles: files.length,
    processedFiles: 0,
    successfulFiles: 0,
    failedFiles: 0,
    status: 'processing',
    startTime: Date.now(),
    results: [],
    errors: []
  };
  
  // Store batch info in database
  await db.processingBatches.create({
    data: {
      id: batchId,
      type: 'audio',
      totalFiles: files.length,
      status: 'processing',
      options: JSON.stringify(options),
      startTime: new Date()
    }
  });
  
  // Determine concurrency from Current branch
  const concurrency = options.concurrency || Math.min(
    Math.max(1, Math.floor(os.cpus().length / 2)),
    10, // Maximum concurrency
    files.length
  );
  
  // Create queue with concurrency limit
  const queue = new PQueue({ concurrency });
  
  // Process all files in parallel with queue
  const promises = files.map((file, index) => {
    return queue.add(async () => {
      try {
        // Update batch with current file
        await updateBatchProgress(batchId, index, file);
        
        // Process individual file using 190320250630 pipeline
        const result = await processAudio(file.path || file, options);
        
        // Update batch counters
        batch.processedFiles++;
        batch.successfulFiles++;
        batch.results.push(result);
        
        // Update progress
        await updateBatchProgress(batchId, batch);
        
        return result;
      } catch (error) {
        // Current branch error handling
        console.error(`Error processing file ${file.path || file}:`, error);
        
        // Update batch counters
        batch.processedFiles++;
        batch.failedFiles++;
        batch.errors.push({
          file: file.path || file,
          error: error.message
        });
        
        // Update progress
        await updateBatchProgress(batchId, batch);
        
        // Handle errors
        if (options.stopOnError) {
          throw error;
        }
        
        return {
          file: file.path || file,
          success: false,
          error: error.message
        };
      }
    });
  });
  
  // Wait for all files to be processed
  try {
    await Promise.all(promises);
    
    // Update final status
    batch.status = batch.failedFiles > 0 ? 'completed_with_errors' : 'completed';
    batch.endTime = Date.now();
    batch.processingTime = batch.endTime - batch.startTime;
    
    // Update in database
    await finalizeBatch(batchId, batch);
    
    return batch;
  } catch (error) {
    // Handle batch failure
    console.error(`Batch ${batchId} failed:`, error);
    
    // Update with failure
    await markBatchFailed(batchId, batch, error);
    
    throw error;
  }
}

// Audio processing pipeline from 190320250630
async function processAudio(filePath, options = {}) {
  // 190320250630 comprehensive audio processing...

  // Extract metadata
  const metadata = await extractAudioMetadata(filePath);
  
  // Generate fingerprints
  const fingerprints = await generateMultipleFingerprints(filePath);
  
  // Check for duplicates
  const duplicateCheck = await checkForDuplicates(fingerprints);
  
  // Generate waveform
  const waveform = await generateWaveformData(filePath);
  
  // Quality analysis from 190320250630
  const qualityAnalysis = await analyzeAudioQuality(filePath);
  
  // Format conversion
  const formats = await generateOptimizedFormats(filePath, options.formats);
  
  // Return complete result
  return {
    metadata,
    fingerprints,
    duplicateCheck,
    waveform,
    qualityAnalysis,
    formats,
    processingTime: Date.now() - startTime
  };
}
```

### Step 7: Rights Management Integration

1. **Combine 190320250630 Rights System with Current Dispute Resolution**:

```typescript
// 190320250630 rights registration with Current optimization
async function registerRights(rightData) {
  // Rights registration code from 190320250630
}

// Current branch dispute resolution
async function createDispute({
  assetId,
  assetType,
  rightId,
  claimantId,
  respondentId,
  reason,
  evidence,
}) {
  // Validate dispute data
  if (!assetId || !assetType || !rightId || !claimantId || !respondentId || !reason) {
    throw new Error('Missing required dispute information');
  }
  
  // Create dispute workflow
  const workflow = {
    steps: [
      {
        name: 'dispute_opened',
        status: 'completed',
        completedAt: new Date().toISOString(),
        completedBy: claimantId,
      },
      {
        name: 'respondent_notification',
        status: 'pending',
      },
      {
        name: 'evidence_collection',
        status: 'in_progress',
        startedAt: new Date().toISOString(),
      },
      {
        name: 'admin_review',
        status: 'pending',
      },
      {
        name: 'resolution',
        status: 'pending',
      }
    ],
    currentStep: 'evidence_collection',
  };
  
  // Create dispute record
  const dispute = await db.rightsDisputes.create({
    data: {
      assetId,
      assetType,
      rightId,
      claimantId,
      respondentId,
      reason,
      evidence: evidence || [],
      status: 'open',
      workflow: JSON.stringify(workflow),
      createdAt: new Date(),
      updatedAt: new Date(),
    }
  });
  
  // Notification and return logic...
  
  return dispute;
}
```

### Step 8: Documentation Integration

1. **Apply PPv1/190320250630 Documentation Style to All Components**:

```typescript
/**
 * Generate content tags and analysis using AI
 * 
 * This function takes basic information about a piece of content (title, artist, type)
 * and generates detailed metadata and analysis using OpenAI's API.
 * 
 * If the OpenAI API is unavailable or not configured, the function falls back to:
 * 1. Cached results if available
 * 2. Basic pattern-based analysis as a last resort
 * 
 * @param title - The title of the content
 * @param artistName - The name of the artist or creator
 * @param type - The type of content ("audio" or "video")
 * @returns An object containing structured tags and analysis information
 */
export async function generateContentTags(
  title: string,
  artistName: string,
  type: "audio" | "video"
): Promise<{ tags: ContentTags; analysis: AIAnalysis }> {
  // Function implementation...
}
```

## Testing Strategy

After implementing these changes, test each component thoroughly:

1. **Database Schema**:
   - Verify all tables are created correctly
   - Test relationships between tables
   - Ensure validation works as expected

2. **Authentication**:
   - Test password validation
   - Verify role-based access control
   - Test session security monitoring

3. **Blockchain Integration**:
   - Verify multi-network support
   - Test gas optimization
   - Test rights registration

4. **AI Integration**:
   - Test with valid API key
   - Test fallback when API key is missing
   - Test fallback when service is unavailable

5. **Audio Processing**:
   - Test individual file processing
   - Test batch processing
   - Verify quality analysis

6. **Rights Management**:
   - Test rights registration
   - Test dispute creation and resolution
   - Verify workflow progression

## Final Steps

1. Update all imports and dependencies
2. Resolve any conflicts between implementations
3. Run comprehensive tests
4. Document the changes and implementation decisions

---

## documentation/project-overview.md

# TuneMantra Project Overview

## Introduction

TuneMantra is a blockchain-powered music distribution platform revolutionizing artist empowerment through intelligent rights management and comprehensive content delivery systems. This document provides a high-level overview of the project.

## Core Technology Stack

TuneMantra is built on a modern technology stack:

- **Frontend**: React, TypeScript, TailwindCSS
- **Backend**: Node.js, Express, TypeScript
- **Database**: PostgreSQL with Drizzle ORM
- **Blockchain**: Smart contracts on Polygon and Ethereum networks
- **Security**: JWT authentication, role-based access control
- **Testing**: Comprehensive test coverage with Jest and React Testing Library

## Key Features

TuneMantra includes several key features:

1. **Blockchain Rights Management**: Immutable recording of music rights on the blockchain
2. **Content Distribution**: Multi-channel digital music distribution
3. **Rights Verification**: Cryptographic verification of rights ownership
4. **Royalty Management**: Automated royalty calculations and distributions
5. **Analytics Dashboard**: Comprehensive performance tracking
6. **Artist Portal**: User-friendly interface for artists
7. **Label Management**: Tools for label administrators
8. **Smart Contracts**: Automated contract execution for rights management

## Documentation Structure

This repository contains comprehensive documentation organized into logical sections:

- **[Admin](admin/)**: Documentation for platform administrators
- **[Developer](developer/)**: Documentation for developers working on the platform
- **[User](user/)**: Documentation for platform users (artists, labels)
- **[Technical](technical/)**: Detailed technical documentation
- **[Reference](reference/)**: API reference and other reference materials
- **[Diagrams](diagrams/)**: Visual representations of the system
- **[Guides](guides/)**: Step-by-step guides for common tasks
- **[Resources](resources/)**: Additional resources and templates

## Getting Started

- For platform users, start with the [User Guide](user/user-guide.md)
- For developers, refer to the [Developer Onboarding Guide](developer/onboarding-guide.md)
- For system administrators, see the [Admin Guide](admin/README.md)

## Blockchain Integration

TuneMantra leverages blockchain technology for transparent rights management and verification. Key blockchain components include:

- **Rights Registry Contract**: Records and verifies music rights
- **Music NFT Contract**: Creates and manages NFTs representing musical assets
- **Royalty Splitter Contract**: Handles automated royalty distribution

For detailed information about the blockchain integration, see the [Blockchain Documentation](technical/blockchain/README.md).

## Project Status

TuneMantra is in active development with regular feature additions and improvements. For the latest development roadmap, see the [Implementation Roadmap](technical/IMPLEMENTATION_ROADMAP.md).

---

## documentation/reference/README.md

# TuneMantra Reference Documentation

This section contains reference materials for the TuneMantra platform.

## API Reference

- [API Reference](api-reference.md) - Complete API reference documentation
- [API Endpoints](api-endpoints.md) - List of all API endpoints
- [API Examples](api-examples.md) - Example API requests and responses

## Data Models

- [Data Models](data-models.md) - Detailed data model documentation
- [Database Schema](database-schema.md) - Database schema reference
- [Entity Relationships](entity-relationships.md) - Entity relationship diagrams

## Technical Reference

- [Glossary](glossary.md) - Glossary of terms used in the platform
- [Technology Stack](technology-stack.md) - Overview of technologies used
- [System Requirements](system-requirements.md) - Hardware and software requirements

## Standards and Specifications

- [Coding Standards](coding-standards.md) - Coding style and standards
- [Documentation Standards](documentation-standards.md) - Documentation guidelines
- [Testing Standards](testing-standards.md) - Testing guidelines and standards

## Troubleshooting

- [Error Codes](error-codes.md) - List of error codes and their meanings
- [Troubleshooting Guide](troubleshooting-guide.md) - Common issues and solutions
- [Known Issues](known-issues.md) - Known issues and workarounds

---

## documentation/reference/api/api-reference.md

# TuneMantra API Reference

*Version: 1.0.0 (March 27, 2025)*

## Table of Contents

- [Introduction](#introduction)
- [Authentication](#authentication)
- [Error Handling](#error-handling)
- [Rate Limiting](#rate-limiting)
- [API Versioning](#api-versioning)
- [User API](#user-api)
- [Organization API](#organization-api)
- [Content API](#content-api)
- [Distribution API](#distribution-api)
- [Rights API](#rights-api)
- [Royalty API](#royalty-api)
- [Analytics API](#analytics-api)
- [WebHooks API](#webhooks-api)
- [Appendix](#appendix)

## Introduction

The TuneMantra API provides programmatic access to the platform's functionality. This reference documents all available endpoints, request/response formats, and authentication requirements.

### Base URL

All API requests should be made to:

```
https://api.tunemantra.com/v1
```

### Request Format

All requests should be made with the appropriate HTTP method (GET, POST, PUT, DELETE) and include the required headers:

```
Content-Type: application/json
Authorization: Bearer {your_api_token}
```

### Response Format

All responses are returned in JSON format. A typical response includes:

```json
{
  "status": "success",
  "data": { ... },
  "meta": {
    "page": 1,
    "limit": 50,
    "total": 245
  }
}
```

Error responses follow this format:

```json
{
  "status": "error",
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Invalid input data",
    "details": [...]
  }
}
```

## Authentication

### Obtaining API Credentials

To use the TuneMantra API, you must first obtain API credentials:

1. Log in to your TuneMantra account
2. Navigate to Settings > API Access
3. Click "Create API Key"
4. Configure the permissions for your API key
5. Store the API key securely

### Authentication Methods

The API supports two authentication methods:

#### Bearer Token Authentication

Include your API token in the Authorization header:

```
Authorization: Bearer {your_api_token}
```

#### OAuth 2.0 Authentication

For third-party applications, use OAuth 2.0:

1. Redirect users to `https://api.tunemantra.com/oauth/authorize`
2. User authorizes your application
3. User is redirected back with an authorization code
4. Exchange the code for an access token at `https://api.tunemantra.com/oauth/token`
5. Use the access token in API requests

## Error Handling

### Error Codes

The API uses standard HTTP status codes and provides detailed error messages:

| Status Code | Meaning |
|-------------|---------|
| 200 | OK - The request was successful |
| 201 | Created - Resource was successfully created |
| 400 | Bad Request - Invalid input data |
| 401 | Unauthorized - Authentication required |
| 403 | Forbidden - Insufficient permissions |
| 404 | Not Found - Resource not found |
| 409 | Conflict - Resource conflict |
| 429 | Too Many Requests - Rate limit exceeded |
| 500 | Internal Server Error - Server-side error |

### Error Response Format

```json
{
  "status": "error",
  "error": {
    "code": "ERROR_CODE",
    "message": "Human-readable error message",
    "details": [
      {
        "field": "field_name",
        "message": "Specific error for this field"
      }
    ]
  }
}
```

## Rate Limiting

To ensure system stability, the API implements rate limiting:

| Plan | Requests per Minute | Daily Limit |
|------|---------------------|-------------|
| Basic | 60 | 10,000 |
| Professional | 300 | 50,000 |
| Enterprise | 1,000 | 250,000 |

Rate limit headers are included in all responses:

```
X-RateLimit-Limit: 60
X-RateLimit-Remaining: 58
X-RateLimit-Reset: 1616136850
```

## API Versioning

### Version Format

The API version is included in the URL path:

```
https://api.tunemantra.com/v1/resource
```

### Version Support

- Major versions (v1, v2) may include breaking changes
- Minor versions are backward compatible
- Each major version is supported for 18 months after a new major version is released

## User API

### Get Current User

Retrieves information about the authenticated user.

**Request:**

```
GET /users/me
```

**Response:**

```json
{
  "status": "success",
  "data": {
    "id": "user_12345",
    "email": "user@example.com",
    "firstName": "John",
    "lastName": "Doe",
    "role": "admin",
    "organizationId": "org_12345",
    "createdAt": "2023-01-15T12:00:00Z",
    "lastLogin": "2023-03-27T09:15:22Z",
    "preferences": {
      "timezone": "America/New_York",
      "language": "en-US",
      "notifications": {
        "email": true,
        "push": false
      }
    }
  }
}
```

### List Users

Returns a list of users in the organization.

**Request:**

```
GET /users?limit=50&page=1
```

**Query Parameters:**

| Parameter | Type | Description |
|-----------|------|-------------|
| limit | number | Number of results per page (default: 50, max: 100) |
| page | number | Page number (default: 1) |
| role | string | Filter by role (optional) |
| query | string | Search by name or email (optional) |

**Response:**

```json
{
  "status": "success",
  "data": [
    {
      "id": "user_12345",
      "email": "user@example.com",
      "firstName": "John",
      "lastName": "Doe",
      "role": "admin",
      "organizationId": "org_12345",
      "createdAt": "2023-01-15T12:00:00Z",
      "lastLogin": "2023-03-27T09:15:22Z"
    },
    {
      "id": "user_12346",
      "email": "user2@example.com",
      "firstName": "Jane",
      "lastName": "Smith",
      "role": "content_manager",
      "organizationId": "org_12345",
      "createdAt": "2023-02-10T14:30:00Z",
      "lastLogin": "2023-03-26T16:45:10Z"
    }
  ],
  "meta": {
    "page": 1,
    "limit": 50,
    "total": 245
  }
}
```

### Create User

Creates a new user in the organization.

**Request:**

```
POST /users
```

**Request Body:**

```json
{
  "email": "newuser@example.com",
  "firstName": "Sarah",
  "lastName": "Johnson",
  "role": "content_manager",
  "password": "SecurePassword123!",
  "preferences": {
    "timezone": "Europe/London",
    "language": "en-GB"
  }
}
```

**Response:**

```json
{
  "status": "success",
  "data": {
    "id": "user_12347",
    "email": "newuser@example.com",
    "firstName": "Sarah",
    "lastName": "Johnson",
    "role": "content_manager",
    "organizationId": "org_12345",
    "createdAt": "2023-03-27T10:30:00Z",
    "preferences": {
      "timezone": "Europe/London",
      "language": "en-GB",
      "notifications": {
        "email": true,
        "push": true
      }
    }
  }
}
```

### Update User

Updates an existing user.

**Request:**

```
PUT /users/{user_id}
```

**Request Body:**

```json
{
  "firstName": "Sarah",
  "lastName": "Johnson-Smith",
  "role": "rights_manager",
  "preferences": {
    "timezone": "Europe/Paris"
  }
}
```

**Response:**

```json
{
  "status": "success",
  "data": {
    "id": "user_12347",
    "email": "newuser@example.com",
    "firstName": "Sarah",
    "lastName": "Johnson-Smith",
    "role": "rights_manager",
    "organizationId": "org_12345",
    "createdAt": "2023-03-27T10:30:00Z",
    "updatedAt": "2023-03-27T11:15:00Z",
    "preferences": {
      "timezone": "Europe/Paris",
      "language": "en-GB",
      "notifications": {
        "email": true,
        "push": true
      }
    }
  }
}
```

### Delete User

Deletes a user.

**Request:**

```
DELETE /users/{user_id}
```

**Response:**

```json
{
  "status": "success",
  "data": {
    "message": "User deleted successfully"
  }
}
```

## Organization API

### Get Organization

Retrieves information about the specified organization.

**Request:**

```
GET /organizations/{organization_id}
```

**Response:**

```json
{
  "status": "success",
  "data": {
    "id": "org_12345",
    "name": "Example Records",
    "type": "label",
    "tier": "professional",
    "createdAt": "2022-05-10T08:30:00Z",
    "contactEmail": "info@examplerecords.com",
    "phone": "+1-555-123-4567",
    "address": {
      "street": "123 Music Avenue",
      "city": "Los Angeles",
      "state": "CA",
      "postalCode": "90001",
      "country": "US"
    },
    "branding": {
      "logoUrl": "https://assets.tunemantra.com/logos/example-records.png",
      "primaryColor": "#3A86FF",
      "secondaryColor": "#FF006E"
    },
    "settings": {
      "defaultCurrency": "USD",
      "fiscalYearStart": "01-01",
      "defaultPaymentMethod": "direct_deposit"
    },
    "parent": null,
    "subsidiaries": [
      {
        "id": "org_12346",
        "name": "Example Urban",
        "type": "imprint"
      },
      {
        "id": "org_12347",
        "name": "Example Classical",
        "type": "imprint"
      }
    ]
  }
}
```

### List Organizations

Returns a list of organizations.

**Request:**

```
GET /organizations?limit=50&page=1
```

**Query Parameters:**

| Parameter | Type | Description |
|-----------|------|-------------|
| limit | number | Number of results per page (default: 50, max: 100) |
| page | number | Page number (default: 1) |
| type | string | Filter by organization type (optional) |
| parent | string | Filter by parent organization ID (optional) |
| query | string | Search by name (optional) |

**Response:**

```json
{
  "status": "success",
  "data": [
    {
      "id": "org_12345",
      "name": "Example Records",
      "type": "label",
      "tier": "professional",
      "createdAt": "2022-05-10T08:30:00Z"
    },
    {
      "id": "org_12346",
      "name": "Example Urban",
      "type": "imprint",
      "tier": "professional",
      "createdAt": "2022-06-15T10:45:00Z",
      "parent": {
        "id": "org_12345",
        "name": "Example Records"
      }
    }
  ],
  "meta": {
    "page": 1,
    "limit": 50,
    "total": 12
  }
}
```

### Create Organization

Creates a new organization.

**Request:**

```
POST /organizations
```

**Request Body:**

```json
{
  "name": "New Label Records",
  "type": "label",
  "tier": "professional",
  "contactEmail": "info@newlabelrecords.com",
  "phone": "+1-555-987-6543",
  "address": {
    "street": "456 Melody Lane",
    "city": "Nashville",
    "state": "TN",
    "postalCode": "37203",
    "country": "US"
  },
  "branding": {
    "primaryColor": "#4CAF50",
    "secondaryColor": "#FFC107"
  },
  "settings": {
    "defaultCurrency": "USD",
    "fiscalYearStart": "01-01",
    "defaultPaymentMethod": "paypal"
  },
  "parentId": null
}
```

**Response:**

```json
{
  "status": "success",
  "data": {
    "id": "org_12348",
    "name": "New Label Records",
    "type": "label",
    "tier": "professional",
    "createdAt": "2023-03-27T14:00:00Z",
    "contactEmail": "info@newlabelrecords.com",
    "phone": "+1-555-987-6543",
    "address": {
      "street": "456 Melody Lane",
      "city": "Nashville",
      "state": "TN",
      "postalCode": "37203",
      "country": "US"
    },
    "branding": {
      "logoUrl": null,
      "primaryColor": "#4CAF50",
      "secondaryColor": "#FFC107"
    },
    "settings": {
      "defaultCurrency": "USD",
      "fiscalYearStart": "01-01",
      "defaultPaymentMethod": "paypal"
    },
    "parent": null,
    "subsidiaries": []
  }
}
```

## Content API

### Get Release

Retrieves information about a specific release.

**Request:**

```
GET /content/releases/{release_id}
```

**Response:**

```json
{
  "status": "success",
  "data": {
    "id": "rel_12345",
    "title": "Summer Vibes",
    "artist": "DJ Sunshine",
    "type": "album",
    "upc": "123456789012",
    "releaseDate": "2023-06-15",
    "originalReleaseDate": "2023-06-15",
    "label": {
      "id": "org_12345",
      "name": "Example Records"
    },
    "genre": ["Electronic", "Dance"],
    "subGenre": "House",
    "language": "English",
    "explicit": false,
    "status": "released",
    "artwork": {
      "url": "https://assets.tunemantra.com/artwork/rel_12345.jpg",
      "width": 3000,
      "height": 3000
    },
    "tracks": [
      {
        "id": "track_23456",
        "title": "Summer Begins",
        "artist": "DJ Sunshine",
        "isrc": "ABCDE1234567",
        "trackNumber": 1,
        "discNumber": 1,
        "duration": 195,
        "explicit": false,
        "audioFile": {
          "url": "https://assets.tunemantra.com/audio/track_23456.wav",
          "format": "WAV",
          "bitrate": 1411,
          "sampleRate": 44100
        }
      },
      {
        "id": "track_23457",
        "title": "Beach Party",
        "artist": "DJ Sunshine ft. Sandy Shores",
        "isrc": "ABCDE1234568",
        "trackNumber": 2,
        "discNumber": 1,
        "duration": 210,
        "explicit": false,
        "audioFile": {
          "url": "https://assets.tunemantra.com/audio/track_23457.wav",
          "format": "WAV",
          "bitrate": 1411,
          "sampleRate": 44100
        }
      }
    ],
    "createdAt": "2023-03-01T09:30:00Z",
    "updatedAt": "2023-03-10T14:45:00Z",
    "metadata": {
      "copyright": "℗ 2023 Example Records",
      "publishingRights": "© 2023 Example Records",
      "territories": ["WORLDWIDE"],
      "parental_advisory": false,
      "compilation": false
    },
    "distribution": {
      "status": "complete",
      "platforms": [
        {
          "name": "Spotify",
          "status": "live",
          "link": "https://open.spotify.com/album/123456"
        },
        {
          "name": "Apple Music",
          "status": "live",
          "link": "https://music.apple.com/album/123456"
        }
      ]
    }
  }
}
```

### List Releases

Returns a list of releases.

**Request:**

```
GET /content/releases?limit=50&page=1
```

**Query Parameters:**

| Parameter | Type | Description |
|-----------|------|-------------|
| limit | number | Number of results per page (default: 50, max: 100) |
| page | number | Page number (default: 1) |
| artist | string | Filter by artist (optional) |
| status | string | Filter by status (optional) |
| type | string | Filter by release type (optional) |
| date_from | string | Filter by release date from (YYYY-MM-DD) (optional) |
| date_to | string | Filter by release date to (YYYY-MM-DD) (optional) |
| query | string | Search by title or UPC (optional) |

**Response:**

```json
{
  "status": "success",
  "data": [
    {
      "id": "rel_12345",
      "title": "Summer Vibes",
      "artist": "DJ Sunshine",
      "type": "album",
      "upc": "123456789012",
      "releaseDate": "2023-06-15",
      "label": {
        "id": "org_12345",
        "name": "Example Records"
      },
      "status": "released",
      "artwork": {
        "url": "https://assets.tunemantra.com/artwork/rel_12345_thumb.jpg"
      },
      "trackCount": 10
    },
    {
      "id": "rel_12346",
      "title": "Winter Dreams",
      "artist": "Frosty Tones",
      "type": "single",
      "upc": "123456789013",
      "releaseDate": "2023-12-01",
      "label": {
        "id": "org_12345",
        "name": "Example Records"
      },
      "status": "scheduled",
      "artwork": {
        "url": "https://assets.tunemantra.com/artwork/rel_12346_thumb.jpg"
      },
      "trackCount": 1
    }
  ],
  "meta": {
    "page": 1,
    "limit": 50,
    "total": 245
  }
}
```

### Create Release

Creates a new release.

**Request:**

```
POST /content/releases
```

**Request Body:**

```json
{
  "title": "Autumn Leaves",
  "artist": "Maple Tree",
  "type": "EP",
  "upc": "123456789014",
  "releaseDate": "2023-09-21",
  "originalReleaseDate": "2023-09-21",
  "labelId": "org_12345",
  "genre": ["Indie", "Folk"],
  "subGenre": "Acoustic",
  "language": "English",
  "explicit": false,
  "metadata": {
    "copyright": "℗ 2023 Example Records",
    "publishingRights": "© 2023 Example Records",
    "territories": ["WORLDWIDE"],
    "parental_advisory": false,
    "compilation": false
  }
}
```

**Response:**

```json
{
  "status": "success",
  "data": {
    "id": "rel_12347",
    "title": "Autumn Leaves",
    "artist": "Maple Tree",
    "type": "EP",
    "upc": "123456789014",
    "releaseDate": "2023-09-21",
    "originalReleaseDate": "2023-09-21",
    "label": {
      "id": "org_12345",
      "name": "Example Records"
    },
    "genre": ["Indie", "Folk"],
    "subGenre": "Acoustic",
    "language": "English",
    "explicit": false,
    "status": "draft",
    "artwork": null,
    "tracks": [],
    "createdAt": "2023-03-27T15:30:00Z",
    "updatedAt": "2023-03-27T15:30:00Z",
    "metadata": {
      "copyright": "℗ 2023 Example Records",
      "publishingRights": "© 2023 Example Records",
      "territories": ["WORLDWIDE"],
      "parental_advisory": false,
      "compilation": false
    },
    "distribution": {
      "status": "not_started",
      "platforms": []
    }
  }
}
```

## Distribution API

### Get Distribution Status

Retrieves the distribution status for a release.

**Request:**

```
GET /distribution/releases/{release_id}
```

**Response:**

```json
{
  "status": "success",
  "data": {
    "releaseId": "rel_12345",
    "releaseTitle": "Summer Vibes",
    "overallStatus": "complete",
    "distributionDate": "2023-05-15T08:00:00Z",
    "lastUpdated": "2023-05-20T14:30:00Z",
    "platforms": [
      {
        "id": "platform_1",
        "name": "Spotify",
        "status": "live",
        "deliveryDate": "2023-05-15T08:10:00Z",
        "liveDate": "2023-05-17T12:30:00Z",
        "link": "https://open.spotify.com/album/123456",
        "errors": null
      },
      {
        "id": "platform_2",
        "name": "Apple Music",
        "status": "live",
        "deliveryDate": "2023-05-15T08:15:00Z",
        "liveDate": "2023-05-18T09:45:00Z",
        "link": "https://music.apple.com/album/123456",
        "errors": null
      },
      {
        "id": "platform_3",
        "name": "Amazon Music",
        "status": "live",
        "deliveryDate": "2023-05-15T08:20:00Z",
        "liveDate": "2023-05-19T16:20:00Z",
        "link": "https://music.amazon.com/albums/123456",
        "errors": null
      },
      {
        "id": "platform_4",
        "name": "Tidal",
        "status": "processing",
        "deliveryDate": "2023-05-15T08:25:00Z",
        "liveDate": null,
        "link": null,
        "errors": null
      },
      {
        "id": "platform_5",
        "name": "YouTube Music",
        "status": "error",
        "deliveryDate": "2023-05-15T08:30:00Z",
        "liveDate": null,
        "link": null,
        "errors": [
          {
            "code": "ARTWORK_RESOLUTION",
            "message": "Artwork does not meet minimum resolution requirements",
            "details": "Minimum 3000x3000 pixels required"
          }
        ]
      }
    ],
    "territories": ["WORLDWIDE"],
    "exclusions": [],
    "takedowns": []
  }
}
```

### Create Distribution

Creates a distribution plan for a release.

**Request:**

```
POST /distribution/releases
```

**Request Body:**

```json
{
  "releaseId": "rel_12347",
  "scheduledDate": "2023-09-14T00:00:00Z",
  "platforms": [
    "platform_1",
    "platform_2",
    "platform_3",
    "platform_4",
    "platform_5"
  ],
  "territories": ["WORLDWIDE"],
  "exclusions": [
    {
      "platform": "platform_5",
      "territories": ["CN"]
    }
  ],
  "preOrder": {
    "enabled": true,
    "startDate": "2023-09-01T00:00:00Z"
  }
}
```

**Response:**

```json
{
  "status": "success",
  "data": {
    "id": "dist_34567",
    "releaseId": "rel_12347",
    "releaseTitle": "Autumn Leaves",
    "overallStatus": "scheduled",
    "scheduledDate": "2023-09-14T00:00:00Z",
    "createdAt": "2023-03-27T16:00:00Z",
    "platforms": [
      {
        "id": "platform_1",
        "name": "Spotify",
        "status": "scheduled",
        "scheduledDate": "2023-09-14T00:00:00Z"
      },
      {
        "id": "platform_2",
        "name": "Apple Music",
        "status": "scheduled",
        "scheduledDate": "2023-09-14T00:00:00Z"
      },
      {
        "id": "platform_3",
        "name": "Amazon Music",
        "status": "scheduled",
        "scheduledDate": "2023-09-14T00:00:00Z"
      },
      {
        "id": "platform_4",
        "name": "Tidal",
        "status": "scheduled",
        "scheduledDate": "2023-09-14T00:00:00Z"
      },
      {
        "id": "platform_5",
        "name": "YouTube Music",
        "status": "scheduled",
        "scheduledDate": "2023-09-14T00:00:00Z",
        "territories": ["WORLDWIDE", "!CN"]
      }
    ],
    "territories": ["WORLDWIDE"],
    "exclusions": [
      {
        "platform": "platform_5",
        "territories": ["CN"]
      }
    ],
    "preOrder": {
      "enabled": true,
      "startDate": "2023-09-01T00:00:00Z"
    }
  }
}
```

### Create Takedown

Creates a takedown request for a release.

**Request:**

```
POST /distribution/takedowns
```

**Request Body:**

```json
{
  "releaseId": "rel_12345",
  "reason": "COPYRIGHT_DISPUTE",
  "details": "Copyright claim from original rights holder",
  "platforms": ["platform_1", "platform_2"],
  "territories": ["WORLDWIDE"],
  "urgency": "high"
}
```

**Response:**

```json
{
  "status": "success",
  "data": {
    "id": "takedown_23456",
    "releaseId": "rel_12345",
    "releaseTitle": "Summer Vibes",
    "reason": "COPYRIGHT_DISPUTE",
    "details": "Copyright claim from original rights holder",
    "status": "processing",
    "createdAt": "2023-03-27T16:30:00Z",
    "completedAt": null,
    "platforms": [
      {
        "id": "platform_1",
        "name": "Spotify",
        "status": "processing",
        "requestDate": "2023-03-27T16:30:00Z",
        "completionDate": null
      },
      {
        "id": "platform_2",
        "name": "Apple Music",
        "status": "processing",
        "requestDate": "2023-03-27T16:30:00Z",
        "completionDate": null
      }
    ],
    "territories": ["WORLDWIDE"],
    "urgency": "high"
  }
}
```

## Rights API

### Get Rights

Retrieves rights information for a specific content item.

**Request:**

```
GET /rights/content/{content_id}
```

**Response:**

```json
{
  "status": "success",
  "data": {
    "contentId": "track_23456",
    "contentType": "track",
    "contentTitle": "Summer Begins",
    "artist": "DJ Sunshine",
    "masterRights": [
      {
        "id": "right_34567",
        "type": "master_recording",
        "territories": ["WORLDWIDE"],
        "startDate": "2023-01-01",
        "endDate": null,
        "owners": [
          {
            "entity": {
              "id": "org_12345",
              "name": "Example Records",
              "type": "organization"
            },
            "percentage": 80.00,
            "role": "record_label"
          },
          {
            "entity": {
              "id": "user_12345",
              "name": "John Producer",
              "type": "individual"
            },
            "percentage": 20.00,
            "role": "producer"
          }
        ],
        "documentUrl": "https://assets.tunemantra.com/documents/rights_34567.pdf",
        "status": "active",
        "createdAt": "2023-01-15T10:00:00Z",
        "updatedAt": "2023-01-15T10:00:00Z"
      }
    ],
    "publishingRights": [
      {
        "id": "right_34568",
        "type": "publishing",
        "territories": ["WORLDWIDE"],
        "startDate": "2023-01-01",
        "endDate": null,
        "owners": [
          {
            "entity": {
              "id": "org_12348",
              "name": "Example Publishing",
              "type": "organization"
            },
            "percentage": 50.00,
            "role": "publisher"
          },
          {
            "entity": {
              "id": "user_12345",
              "name": "John Writer",
              "type": "individual"
            },
            "percentage": 50.00,
            "role": "songwriter"
          }
        ],
        "documentUrl": "https://assets.tunemantra.com/documents/rights_34568.pdf",
        "status": "active",
        "createdAt": "2023-01-15T10:30:00Z",
        "updatedAt": "2023-01-15T10:30:00Z"
      }
    ],
    "performanceRights": [
      {
        "id": "right_34569",
        "type": "performance",
        "territories": ["WORLDWIDE"],
        "startDate": "2023-01-01",
        "endDate": null,
        "owners": [
          {
            "entity": {
              "id": "user_12345",
              "name": "DJ Sunshine",
              "type": "individual"
            },
            "percentage": 100.00,
            "role": "performer"
          }
        ],
        "documentUrl": "https://assets.tunemantra.com/documents/rights_34569.pdf",
        "status": "active",
        "createdAt": "2023-01-15T11:00:00Z",
        "updatedAt": "2023-01-15T11:00:00Z"
      }
    ],
    "conflicts": []
  }
}
```

### Create Rights

Creates a new rights record.

**Request:**

```
POST /rights
```

**Request Body:**

```json
{
  "contentId": "track_23457",
  "contentType": "track",
  "rightType": "master_recording",
  "territories": ["WORLDWIDE"],
  "startDate": "2023-01-01",
  "endDate": null,
  "owners": [
    {
      "entityId": "org_12345",
      "entityType": "organization",
      "percentage": 80.00,
      "role": "record_label"
    },
    {
      "entityId": "user_12345",
      "entityType": "individual",
      "percentage": 20.00,
      "role": "producer"
    }
  ],
  "documentUrl": "https://assets.tunemantra.com/documents/rights_34570.pdf"
}
```

**Response:**

```json
{
  "status": "success",
  "data": {
    "id": "right_34570",
    "contentId": "track_23457",
    "contentType": "track",
    "contentTitle": "Beach Party",
    "type": "master_recording",
    "territories": ["WORLDWIDE"],
    "startDate": "2023-01-01",
    "endDate": null,
    "owners": [
      {
        "entity": {
          "id": "org_12345",
          "name": "Example Records",
          "type": "organization"
        },
        "percentage": 80.00,
        "role": "record_label"
      },
      {
        "entity": {
          "id": "user_12345",
          "name": "John Producer",
          "type": "individual"
        },
        "percentage": 20.00,
        "role": "producer"
      }
    ],
    "documentUrl": "https://assets.tunemantra.com/documents/rights_34570.pdf",
    "status": "active",
    "createdAt": "2023-03-27T17:00:00Z",
    "updatedAt": "2023-03-27T17:00:00Z",
    "conflicts": []
  }
}
```

## Royalty API

### Get Royalty Statement

Retrieves a royalty statement.

**Request:**

```
GET /royalties/statements/{statement_id}
```

**Response:**

```json
{
  "status": "success",
  "data": {
    "id": "stmt_45678",
    "recipient": {
      "id": "user_12345",
      "name": "John Doe",
      "type": "individual"
    },
    "organization": {
      "id": "org_12345",
      "name": "Example Records"
    },
    "period": {
      "startDate": "2023-01-01",
      "endDate": "2023-03-31"
    },
    "generatedDate": "2023-04-15T10:00:00Z",
    "status": "paid",
    "currency": "USD",
    "summary": {
      "totalRevenue": 5250.75,
      "totalRoyalties": 1050.15,
      "advances": 0.00,
      "recoupables": 0.00,
      "adjustments": 0.00,
      "taxWithheld": 105.02,
      "netPayable": 945.13
    },
    "earnings": [
      {
        "releaseId": "rel_12345",
        "releaseTitle": "Summer Vibes",
        "trackId": "track_23456",
        "trackTitle": "Summer Begins",
        "platform": "Spotify",
        "territory": "US",
        "earningType": "streaming",
        "units": 250000,
        "revenue": 1000.00,
        "royaltyRate": 20.00,
        "royaltyAmount": 200.00
      },
      {
        "releaseId": "rel_12345",
        "releaseTitle": "Summer Vibes",
        "trackId": "track_23456",
        "trackTitle": "Summer Begins",
        "platform": "Apple Music",
        "territory": "US",
        "earningType": "streaming",
        "units": 150000,
        "revenue": 750.00,
        "royaltyRate": 20.00,
        "royaltyAmount": 150.00
      }
    ],
    "paymentDetails": {
      "paymentId": "pmt_56789",
      "paymentDate": "2023-04-20T14:30:00Z",
      "paymentMethod": "direct_deposit",
      "paymentReference": "REF123456"
    }
  }
}
```

### List Royalty Statements

Returns a list of royalty statements.

**Request:**

```
GET /royalties/statements?limit=50&page=1
```

**Query Parameters:**

| Parameter | Type | Description |
|-----------|------|-------------|
| limit | number | Number of results per page (default: 50, max: 100) |
| page | number | Page number (default: 1) |
| recipient_id | string | Filter by recipient ID (optional) |
| period_start | string | Filter by period start date (YYYY-MM-DD) (optional) |
| period_end | string | Filter by period end date (YYYY-MM-DD) (optional) |
| status | string | Filter by status (optional) |

**Response:**

```json
{
  "status": "success",
  "data": [
    {
      "id": "stmt_45678",
      "recipient": {
        "id": "user_12345",
        "name": "John Doe",
        "type": "individual"
      },
      "organization": {
        "id": "org_12345",
        "name": "Example Records"
      },
      "period": {
        "startDate": "2023-01-01",
        "endDate": "2023-03-31"
      },
      "generatedDate": "2023-04-15T10:00:00Z",
      "status": "paid",
      "currency": "USD",
      "summary": {
        "totalRoyalties": 1050.15,
        "netPayable": 945.13
      }
    },
    {
      "id": "stmt_45679",
      "recipient": {
        "id": "user_12345",
        "name": "John Doe",
        "type": "individual"
      },
      "organization": {
        "id": "org_12345",
        "name": "Example Records"
      },
      "period": {
        "startDate": "2022-10-01",
        "endDate": "2022-12-31"
      },
      "generatedDate": "2023-01-15T10:00:00Z",
      "status": "paid",
      "currency": "USD",
      "summary": {
        "totalRoyalties": 875.50,
        "netPayable": 787.95
      }
    }
  ],
  "meta": {
    "page": 1,
    "limit": 50,
    "total": 8
  }
}
```

### Generate Royalty Statement

Generates a new royalty statement.

**Request:**

```
POST /royalties/statements
```

**Request Body:**

```json
{
  "recipientId": "user_12345",
  "organizationId": "org_12345",
  "period": {
    "startDate": "2023-04-01",
    "endDate": "2023-06-30"
  },
  "currency": "USD"
}
```

**Response:**

```json
{
  "status": "success",
  "data": {
    "id": "stmt_45680",
    "recipient": {
      "id": "user_12345",
      "name": "John Doe",
      "type": "individual"
    },
    "organization": {
      "id": "org_12345",
      "name": "Example Records"
    },
    "period": {
      "startDate": "2023-04-01",
      "endDate": "2023-06-30"
    },
    "generatedDate": "2023-03-27T17:30:00Z",
    "status": "processing",
    "currency": "USD",
    "estimatedCompletionTime": "2023-03-27T18:00:00Z"
  }
}
```

## Analytics API

### Get Release Performance

Retrieves performance analytics for a specific release.

**Request:**

```
GET /analytics/releases/{release_id}?period=30d
```

**Query Parameters:**

| Parameter | Type | Description |
|-----------|------|-------------|
| period | string | Time period for analytics (7d, 30d, 90d, 1y, all) |
| platform | string | Filter by platform (optional) |
| territory | string | Filter by territory (optional) |

**Response:**

```json
{
  "status": "success",
  "data": {
    "releaseId": "rel_12345",
    "releaseTitle": "Summer Vibes",
    "period": "30d",
    "dateRange": {
      "from": "2023-02-25",
      "to": "2023-03-27"
    },
    "summary": {
      "totalStreams": 1250000,
      "totalRevenue": 5000.00,
      "percentChange": {
        "streams": 15.3,
        "revenue": 12.8
      }
    },
    "platforms": [
      {
        "name": "Spotify",
        "streams": 750000,
        "revenue": 3000.00,
        "percentChange": {
          "streams": 18.5,
          "revenue": 16.2
        }
      },
      {
        "name": "Apple Music",
        "streams": 300000,
        "revenue": 1500.00,
        "percentChange": {
          "streams": 10.2,
          "revenue": 9.5
        }
      },
      {
        "name": "Amazon Music",
        "streams": 150000,
        "revenue": 450.00,
        "percentChange": {
          "streams": 12.1,
          "revenue": 10.8
        }
      },
      {
        "name": "Other",
        "streams": 50000,
        "revenue": 50.00,
        "percentChange": {
          "streams": 5.3,
          "revenue": 4.1
        }
      }
    ],
    "territories": [
      {
        "code": "US",
        "name": "United States",
        "streams": 500000,
        "revenue": 2500.00,
        "percentChange": {
          "streams": 20.1,
          "revenue": 18.5
        }
      },
      {
        "code": "GB",
        "name": "United Kingdom",
        "streams": 250000,
        "revenue": 1000.00,
        "percentChange": {
          "streams": 15.3,
          "revenue": 13.2
        }
      },
      {
        "code": "DE",
        "name": "Germany",
        "streams": 150000,
        "revenue": 600.00,
        "percentChange": {
          "streams": 12.5,
          "revenue": 11.8
        }
      },
      {
        "code": "OTHER",
        "name": "Other Countries",
        "streams": 350000,
        "revenue": 900.00,
        "percentChange": {
          "streams": 8.7,
          "revenue": 7.9
        }
      }
    ],
    "timeSeries": {
      "intervals": [
        "2023-02-25",
        "2023-02-26",
        "2023-02-27",
        // More dates...
        "2023-03-27"
      ],
      "streams": [
        42000,
        41500,
        43200,
        // More values...
        45600
      ],
      "revenue": [
        168.00,
        166.00,
        172.80,
        // More values...
        182.40
      ]
    },
    "tracks": [
      {
        "id": "track_23456",
        "title": "Summer Begins",
        "streams": 750000,
        "revenue": 3000.00,
        "percentChange": {
          "streams": 25.3,
          "revenue": 22.8
        }
      },
      {
        "id": "track_23457",
        "title": "Beach Party",
        "streams": 500000,
        "revenue": 2000.00,
        "percentChange": {
          "streams": 5.3,
          "revenue": 4.8
        }
      }
    ]
  }
}
```

### Get Artist Performance

Retrieves performance analytics for a specific artist.

**Request:**

```
GET /analytics/artists/{artist_id}?period=90d
```

**Query Parameters:**

| Parameter | Type | Description |
|-----------|------|-------------|
| period | string | Time period for analytics (7d, 30d, 90d, 1y, all) |
| platform | string | Filter by platform (optional) |
| territory | string | Filter by territory (optional) |

**Response:**

```json
{
  "status": "success",
  "data": {
    "artistId": "artist_12345",
    "artistName": "DJ Sunshine",
    "period": "90d",
    "dateRange": {
      "from": "2022-12-27",
      "to": "2023-03-27"
    },
    "summary": {
      "totalStreams": 5250000,
      "totalRevenue": 21000.00,
      "percentChange": {
        "streams": 35.3,
        "revenue": 32.8
      }
    },
    "platforms": [
      {
        "name": "Spotify",
        "streams": 3150000,
        "revenue": 12600.00,
        "percentChange": {
          "streams": 38.5,
          "revenue": 36.2
        }
      },
      {
        "name": "Apple Music",
        "streams": 1260000,
        "revenue": 6300.00,
        "percentChange": {
          "streams": 30.2,
          "revenue": 29.5
        }
      },
      {
        "name": "Amazon Music",
        "streams": 630000,
        "revenue": 1890.00,
        "percentChange": {
          "streams": 32.1,
          "revenue": 30.8
        }
      },
      {
        "name": "Other",
        "streams": 210000,
        "revenue": 210.00,
        "percentChange": {
          "streams": 25.3,
          "revenue": 24.1
        }
      }
    ],
    "territories": [
      {
        "code": "US",
        "name": "United States",
        "streams": 2100000,
        "revenue": 10500.00,
        "percentChange": {
          "streams": 40.1,
          "revenue": 38.5
        }
      },
      {
        "code": "GB",
        "name": "United Kingdom",
        "streams": 1050000,
        "revenue": 4200.00,
        "percentChange": {
          "streams": 35.3,
          "revenue": 33.2
        }
      },
      {
        "code": "DE",
        "name": "Germany",
        "streams": 630000,
        "revenue": 2520.00,
        "percentChange": {
          "streams": 32.5,
          "revenue": 31.8
        }
      },
      {
        "code": "OTHER",
        "name": "Other Countries",
        "streams": 1470000,
        "revenue": 3780.00,
        "percentChange": {
          "streams": 28.7,
          "revenue": 27.9
        }
      }
    ],
    "timeSeries": {
      "intervals": [
        "2022-12-27",
        "2023-01-03",
        "2023-01-10",
        // More weeks...
        "2023-03-20"
      ],
      "streams": [
        176400,
        185220,
        194481,
        // More values...
        238920
      ],
      "revenue": [
        705.60,
        740.88,
        777.92,
        // More values...
        955.68
      ]
    },
    "topReleases": [
      {
        "id": "rel_12345",
        "title": "Summer Vibes",
        "streams": 3150000,
        "revenue": 12600.00,
        "percentChange": {
          "streams": 45.3,
          "revenue": 42.8
        }
      },
      {
        "id": "rel_12340",
        "title": "Winter Chill",
        "streams": 2100000,
        "revenue": 8400.00,
        "percentChange": {
          "streams": 25.3,
          "revenue": 22.8
        }
      }
    ],
    "topTracks": [
      {
        "id": "track_23456",
        "title": "Summer Begins",
        "release": "Summer Vibes",
        "streams": 1890000,
        "revenue": 7560.00,
        "percentChange": {
          "streams": 55.3,
          "revenue": 52.8
        }
      },
      {
        "id": "track_23457",
        "title": "Beach Party",
        "release": "Summer Vibes",
        "streams": 1260000,
        "revenue": 5040.00,
        "percentChange": {
          "streams": 35.3,
          "revenue": 32.8
        }
      },
      {
        "id": "track_23450",
        "title": "Snowfall",
        "release": "Winter Chill",
        "streams": 1050000,
        "revenue": 4200.00,
        "percentChange": {
          "streams": 30.3,
          "revenue": 28.8
        }
      }
    ]
  }
}
```

### Get Catalog Overview

Retrieves performance analytics for the entire catalog.

**Request:**

```
GET /analytics/catalog?period=1y
```

**Query Parameters:**

| Parameter | Type | Description |
|-----------|------|-------------|
| period | string | Time period for analytics (7d, 30d, 90d, 1y, all) |
| platform | string | Filter by platform (optional) |
| territory | string | Filter by territory (optional) |

**Response:**

```json
{
  "status": "success",
  "data": {
    "period": "1y",
    "dateRange": {
      "from": "2022-03-27",
      "to": "2023-03-27"
    },
    "summary": {
      "totalStreams": 52500000,
      "totalRevenue": 210000.00,
      "percentChange": {
        "streams": 85.3,
        "revenue": 82.8
      },
      "totalReleases": 45,
      "totalTracks": 350,
      "totalArtists": 25
    },
    "platforms": [
      {
        "name": "Spotify",
        "streams": 31500000,
        "revenue": 126000.00,
        "percentChange": {
          "streams": 88.5,
          "revenue": 86.2
        }
      },
      {
        "name": "Apple Music",
        "streams": 12600000,
        "revenue": 63000.00,
        "percentChange": {
          "streams": 80.2,
          "revenue": 79.5
        }
      },
      {
        "name": "Amazon Music",
        "streams": 6300000,
        "revenue": 18900.00,
        "percentChange": {
          "streams": 82.1,
          "revenue": 80.8
        }
      },
      {
        "name": "Other",
        "streams": 2100000,
        "revenue": 2100.00,
        "percentChange": {
          "streams": 75.3,
          "revenue": 74.1
        }
      }
    ],
    "territories": [
      {
        "code": "US",
        "name": "United States",
        "streams": 21000000,
        "revenue": 105000.00,
        "percentChange": {
          "streams": 90.1,
          "revenue": 88.5
        }
      },
      {
        "code": "GB",
        "name": "United Kingdom",
        "streams": 10500000,
        "revenue": 42000.00,
        "percentChange": {
          "streams": 85.3,
          "revenue": 83.2
        }
      },
      {
        "code": "DE",
        "name": "Germany",
        "streams": 6300000,
        "revenue": 25200.00,
        "percentChange": {
          "streams": 82.5,
          "revenue": 81.8
        }
      },
      {
        "code": "OTHER",
        "name": "Other Countries",
        "streams": 14700000,
        "revenue": 37800.00,
        "percentChange": {
          "streams": 78.7,
          "revenue": 77.9
        }
      }
    ],
    "timeSeries": {
      "intervals": [
        "2022-04",
        "2022-05",
        "2022-06",
        // More months...
        "2023-03"
      ],
      "streams": [
        3150000,
        3307500,
        3472875,
        // More values...
        5250000
      ],
      "revenue": [
        12600.00,
        13230.00,
        13891.50,
        // More values...
        21000.00
      ]
    },
    "topReleases": [
      {
        "id": "rel_12345",
        "title": "Summer Vibes",
        "artist": "DJ Sunshine",
        "streams": 10500000,
        "revenue": 42000.00,
        "percentChange": {
          "streams": 95.3,
          "revenue": 92.8
        }
      },
      {
        "id": "rel_12340",
        "title": "Winter Chill",
        "artist": "DJ Sunshine",
        "streams": 7350000,
        "revenue": 29400.00,
        "percentChange": {
          "streams": 85.3,
          "revenue": 82.8
        }
      },
      {
        "id": "rel_12350",
        "title": "Midnight Dreams",
        "artist": "Night Owl",
        "streams": 5250000,
        "revenue": 21000.00,
        "percentChange": {
          "streams": 75.3,
          "revenue": 72.8
        }
      }
    ],
    "topArtists": [
      {
        "id": "artist_12345",
        "name": "DJ Sunshine",
        "streams": 17850000,
        "revenue": 71400.00,
        "percentChange": {
          "streams": 95.3,
          "revenue": 92.8
        }
      },
      {
        "id": "artist_12346",
        "name": "Night Owl",
        "streams": 10500000,
        "revenue": 42000.00,
        "percentChange": {
          "streams": 85.3,
          "revenue": 82.8
        }
      },
      {
        "id": "artist_12347",
        "name": "Melody Maker",
        "streams": 7350000,
        "revenue": 29400.00,
        "percentChange": {
          "streams": 75.3,
          "revenue": 72.8
        }
      }
    ],
    "genres": [
      {
        "name": "Electronic",
        "streams": 18375000,
        "revenue": 73500.00,
        "percentChange": {
          "streams": 95.3,
          "revenue": 92.8
        }
      },
      {
        "name": "Pop",
        "streams": 10500000,
        "revenue": 42000.00,
        "percentChange": {
          "streams": 85.3,
          "revenue": 82.8
        }
      },
      {
        "name": "Indie",
        "streams": 7350000,
        "revenue": 29400.00,
        "percentChange": {
          "streams": 75.3,
          "revenue": 72.8
        }
      }
    ]
  }
}
```

## WebHooks API

### Get Webhooks

Retrieves the list of configured webhooks.

**Request:**

```
GET /webhooks
```

**Response:**

```json
{
  "status": "success",
  "data": [
    {
      "id": "webhook_12345",
      "url": "https://example.com/webhooks/tunemantra",
      "description": "Distribution status webhook",
      "events": [
        "distribution.status.changed",
        "distribution.delivery.complete",
        "distribution.takedown.complete"
      ],
      "status": "active",
      "createdAt": "2023-01-15T10:00:00Z",
      "updatedAt": "2023-01-15T10:00:00Z"
    },
    {
      "id": "webhook_12346",
      "url": "https://example.com/webhooks/royalties",
      "description": "Royalty statement webhook",
      "events": [
        "royalty.statement.generated",
        "royalty.payment.processed"
      ],
      "status": "active",
      "createdAt": "2023-02-20T14:30:00Z",
      "updatedAt": "2023-02-20T14:30:00Z"
    }
  ]
}
```

### Create Webhook

Creates a new webhook subscription.

**Request:**

```
POST /webhooks
```

**Request Body:**

```json
{
  "url": "https://example.com/webhooks/analytics",
  "description": "Analytics update webhook",
  "events": [
    "analytics.daily.update",
    "analytics.release.milestone"
  ],
  "secret": "your_webhook_secret"
}
```

**Response:**

```json
{
  "status": "success",
  "data": {
    "id": "webhook_12347",
    "url": "https://example.com/webhooks/analytics",
    "description": "Analytics update webhook",
    "events": [
      "analytics.daily.update",
      "analytics.release.milestone"
    ],
    "status": "active",
    "createdAt": "2023-03-27T18:00:00Z",
    "updatedAt": "2023-03-27T18:00:00Z"
  }
}
```

### Test Webhook

Sends a test event to a webhook endpoint.

**Request:**

```
POST /webhooks/{webhook_id}/test
```

**Request Body:**

```json
{
  "event": "analytics.daily.update"
}
```

**Response:**

```json
{
  "status": "success",
  "data": {
    "id": "webhook_test_12345",
    "webhook_id": "webhook_12347",
    "event": "analytics.daily.update",
    "sentAt": "2023-03-27T18:15:00Z",
    "status": "sent",
    "responseCode": 200,
    "responseBody": "Received"
  }
}
```

## Appendix

### Event Types

The following event types are available for webhook subscriptions:

#### User Events
- `user.created` - A new user is created
- `user.updated` - User information is updated
- `user.deleted` - A user is deleted
- `user.login` - A user logs in

#### Organization Events
- `organization.created` - A new organization is created
- `organization.updated` - Organization information is updated
- `organization.deleted` - An organization is deleted

#### Content Events
- `content.release.created` - A new release is created
- `content.release.updated` - A release is updated
- `content.release.deleted` - A release is deleted
- `content.track.uploaded` - A track is uploaded
- `content.artwork.uploaded` - Artwork is uploaded
- `content.metadata.updated` - Metadata is updated

#### Distribution Events
- `distribution.scheduled` - Distribution is scheduled
- `distribution.started` - Distribution process started
- `distribution.status.changed` - Distribution status changed
- `distribution.delivery.complete` - Delivery to platform completed
- `distribution.takedown.requested` - Takedown requested
- `distribution.takedown.complete` - Takedown completed

#### Rights Events
- `rights.created` - A new rights record is created
- `rights.updated` - A rights record is updated
- `rights.deleted` - A rights record is deleted
- `rights.conflict.detected` - A rights conflict is detected
- `rights.conflict.resolved` - A rights conflict is resolved

#### Royalty Events
- `royalty.statement.generated` - A royalty statement is generated
- `royalty.statement.approved` - A royalty statement is approved
- `royalty.payment.scheduled` - A royalty payment is scheduled
- `royalty.payment.processed` - A royalty payment is processed

#### Analytics Events
- `analytics.daily.update` - Daily analytics update is available
- `analytics.release.milestone` - A release reaches a milestone
- `analytics.artist.milestone` - An artist reaches a milestone

### Status Codes

Common status values used throughout the API:

#### Content Status
- `draft` - Initial creation, incomplete
- `pending` - Complete but awaiting approval
- `approved` - Approved and ready for distribution
- `scheduled` - Scheduled for distribution
- `processing` - Being processed for distribution
- `released` - Live on platforms
- `takedown` - Removed from platforms
- `rejected` - Rejected during approval process
- `error` - Error during processing

#### Distribution Status
- `not_started` - Distribution not yet started
- `scheduled` - Scheduled for future distribution
- `processing` - Distribution in progress
- `complete` - Distribution completed successfully
- `error` - Error during distribution
- `takedown` - Content takedown in progress
- `removed` - Content removed from platforms

#### Rights Status
- `pending` - Rights claim pending verification
- `active` - Rights claim active
- `expired` - Rights claim expired
- `disputed` - Rights claim under dispute
- `revoked` - Rights claim revoked

#### Royalty Status
- `processing` - Statement being generated
- `generated` - Statement generated
- `approved` - Statement approved for payment
- `scheduled` - Payment scheduled
- `paid` - Payment processed
- `disputed` - Statement under dispute

---

© 2023-2025 TuneMantra. All rights reserved.

---

## documentation/reference/glossary.md

# TuneMantra Industry Glossary

*Version: 1.0.0 (March 27, 2025)*

## Introduction

This glossary provides definitions for music industry terms, digital distribution concepts, rights management terminology, and technical vocabulary used throughout the TuneMantra platform documentation. It serves as a reference to help users understand specialized terminology encountered in the music rights and royalty management ecosystem.

## Terms

### A

**Aggregator**  
A service that collects and distributes digital music to multiple platforms, handling the technical aspects of delivery, metadata formatting, and royalty collection.

**AIFF (Audio Interchange File Format)**  
A high-quality, uncompressed audio file format developed by Apple, often used for master recordings.

**Artist**  
The performer or creator of a musical recording, who may or may not be the songwriter.

**ArtistID**  
A unique identifier assigned to an artist within the TuneMantra platform to ensure consistent attribution across releases.

**ASCAP (American Society of Composers, Authors and Publishers)**  
A U.S. performing rights organization that collects royalties for the public performance of its members' works.

**Audio Fingerprinting**  
Technology that creates a unique digital signature of an audio recording, used for content identification and rights management.

**Audit Trail**  
A chronological record of system activities that provides evidence of operations, procedures, and changes to records.

### B

**Backend**  
The server-side components of the TuneMantra platform responsible for processing, database operations, and business logic.

**Blanket License**  
A license that allows the user to access an entire catalog of music for a flat fee, typically issued by performing rights organizations.

**BMI (Broadcast Music, Inc.)**  
A U.S. performing rights organization that represents songwriters, composers, and music publishers.

**Bundle**  
A collection of tracks sold together (album, EP, etc.) or a combination of music products offered as a single purchase.

### C

**Catalog**  
The complete collection of recordings or compositions owned or controlled by a label, publisher, or artist.

**Content ID**  
A system (especially on platforms like YouTube) that identifies and manages copyrighted content, enabling rights holders to monetize, track, or control their intellectual property.

**Cover Art**  
The image displayed to represent a release, typically required to be a square image with specific dimensions.

**Cue Sheet**  
A document listing all music used in film, television, or other media, including timing, usage type, and rights information.

**Content Delivery Network (CDN)**  
A distributed network of servers that delivers media files and other content to users with high performance and reliability.

### D

**DDEX (Digital Data Exchange)**  
A consortium that creates standards for the exchange of data between companies in the digital music supply chain.

**Digital Distribution**  
The delivery of music content to online platforms and services for streaming and download.

**Digital Service Provider (DSP)**  
An online platform that offers music streaming or download services, such as Spotify, Apple Music, or Amazon Music.

**DRM (Digital Rights Management)**  
Technology used to control and restrict the use of digital content after sale.

**Dubset**  
A platform that identifies samples and remixes, ensuring rights holders are compensated for the use of their content.

### E

**ERN (Electronic Release Notification)**  
A DDEX standard format for communicating release information between labels and digital service providers.

**Enrollment**  
The process of registering and configuring an organization within the TuneMantra platform.

**Exclusive Rights**  
Legal rights granted solely to one party, preventing others from using the protected material without permission.

**Extended Play (EP)**  
A musical recording that contains more tracks than a single but fewer than an album, typically 3-6 tracks.

### F

**FLAC (Free Lossless Audio Codec)**  
A compressed audio format that preserves the full quality of the original audio.

**Frontend**  
The user interface and client-side components of the TuneMantra platform that users interact with directly.

**Fingerprint**  
A unique digital identifier generated from the content of an audio file, used for identification and rights management.

**Fulfillment**  
The process of delivering content to digital service providers according to their technical specifications.

### G

**GEMA (Gesellschaft für musikalische Aufführungs- und mechanische Vervielfältigungsrechte)**  
The German performing rights organization.

**Gracenote**  
A database that provides music metadata, used for identification and information enrichment.

**Granular Rights**  
Detailed control over specific aspects of content usage, such as territory, time period, or usage type.

**GUI (Graphical User Interface)**  
The visual components of software that allow users to interact with the system.

### H

**Harry Fox Agency (HFA)**  
An organization that provides licensing and royalty collection services for mechanical rights in the United States.

**Hierarchical Structure**  
An organizational arrangement where entities are organized in levels, such as parent labels and sub-labels.

**HLS (HTTP Live Streaming)**  
A streaming protocol developed by Apple for delivering audio and video content.

### I

**Ingestion**  
The process of receiving, validating, and processing content and metadata for distribution.

**Intellectual Property (IP)**  
Legal rights that result from creative effort, including copyrights and trademarks.

**ISRC (International Standard Recording Code)**  
A unique identifier for sound recordings and music video recordings, consisting of 12 alphanumeric characters.

**ISWC (International Standard Musical Work Code)**  
A unique identifier for musical compositions, regardless of their manifestations.

**iTunes Store**  
Apple's online media store for purchasing and downloading music, videos, and other digital content.

### J

**JSON (JavaScript Object Notation)**  
A lightweight data interchange format used for API communication in the TuneMantra platform.

**JioSaavn**  
An Indian music streaming service with significant market presence in South Asia.

### K

**Kafka**  
A distributed event streaming platform used for high-performance data pipelines and streaming analytics.

**Key**  
The musical key of a composition, often included in metadata for DJ-oriented platforms.

**Kubernetes**  
An open-source platform for managing containerized workloads and services, used for TuneMantra's infrastructure.

### L

**Label**  
A company that manufactures, distributes, and promotes recorded music.

**License**  
Legal permission to use copyrighted material under specific conditions.

**LUFS (Loudness Units Full Scale)**  
A measurement standard for audio loudness used in mastering and platform compliance.

**Lossless**  
Audio compression that preserves all the original data, allowing exact reconstruction of the source.

### M

**Master Recording**  
The original recording from which copies are made for distribution.

**Mechanical Rights**  
The rights to reproduce and distribute copyrighted musical compositions in recorded form.

**Metadata**  
Descriptive information about music content, including titles, artists, composers, release dates, and identifiers.

**Multi-factor Authentication (MFA)**  
A security mechanism that requires multiple methods to verify a user's identity for login and other sensitive operations.

**Multi-tenant Architecture**  
A software architecture where a single instance serves multiple organizations while keeping their data isolated.

### N

**Neighboring Rights**  
Rights related to the public performance of sound recordings, separate from the copyrights of the musical composition.

**Normalization**  
The process of adjusting the volume of audio to a standard level.

**Non-interactive Streaming**  
Streaming services where users cannot select specific tracks, like internet radio.

### O

**OAuth 2.0**  
An authorization framework that enables third-party applications to obtain limited access to a service, used for API security.

**On-demand Streaming**  
Services that allow users to select and play specific tracks at will.

**Opus**  
A lossy audio coding format designed for interactive real-time applications over the Internet.

**Organization Hierarchy**  
The structure of relationships between parent labels, sub-labels, imprints, and other organizational entities.

### P

**Parental Advisory**  
A warning label indicating explicit content that may be inappropriate for younger audiences.

**Performing Rights**  
Rights related to the public performance or broadcast of musical compositions.

**Pixel**  
The smallest controllable element of a picture, relevant for cover art specifications.

**PRO (Performing Rights Organization)**  
An agency that collects royalties for the public performance of music on behalf of songwriters and publishers.

**PostgreSQL**  
An open-source relational database management system used as the primary data store for TuneMantra.

**Pre-save**  
A promotional mechanism allowing fans to save upcoming releases to their streaming library before the official release date.

**Publishing**  
Business activities related to the exploitation and administration of musical compositions.

### Q

**QA (Quality Assurance)**  
The process of verifying that content meets required technical and qualitative standards before distribution.

**QQ Music**  
A popular music streaming service in China operated by Tencent.

**Queue**  
A system for organizing content processing tasks in sequence.

**Quota**  
Limitations on usage or submissions within the platform, often tied to service tier.

### R

**Reconciliation**  
The process of matching sales or streaming reports with expected values to identify discrepancies.

**Redis**  
An in-memory data structure store used for caching and session management in the TuneMantra platform.

**Release**  
A music product made available to the public, which may be a single track, EP, or album.

**Remastering**  
The process of improving the sound quality of a previously created recording.

**RESTful API**  
An architectural style for designing networked applications, used for TuneMantra's external integrations.

**Retention Policy**  
Rules governing how long different types of data are kept before deletion or archiving.

**Rights Holder**  
A person or entity that owns or controls rights to musical content.

**Royalty**  
Payment made to rights holders for the use of their intellectual property.

### S

**Sample Rate**  
The number of samples of audio taken per second, measured in Hz or kHz.

**SDK (Software Development Kit)**  
A collection of software development tools for creating applications that interact with the TuneMantra platform.

**SESAC (Society of European Stage Authors and Composers)**  
A performing rights organization in the United States.

**Settlement**  
The process of calculating and distributing royalty payments to rights holders.

**Soundexchange**  
A non-profit performance rights organization that collects and distributes digital performance royalties for sound recordings.

**Split**  
The division of royalties among multiple rights holders based on ownership percentages.

**Spotify**  
A digital music streaming service offering access to millions of songs.

**Streaming**  
The method of transmitting or receiving data (especially audio and video) over a computer network as a steady, continuous flow.

**Subscription**  
A business model where users pay a recurring fee for access to a service or content.

**Sync License**  
Permission to use a composition or recording in timed relation with visual media.

### T

**Takedown**  
The removal of content from distribution platforms, often due to rights disputes or legal issues.

**Territory**  
Geographic regions where rights are granted or restricted.

**TIDAL**  
A subscription-based music streaming service known for high-quality audio.

**TikTok**  
A social media platform focused on short-form videos, with significant music usage.

**Two-dimensional Barcode (2D Barcode)**  
A graphical representation of data, such as a QR code, that can store product information.

### U

**UPC (Universal Product Code)**  
A barcode symbology used for tracking trade items, particularly on physical products.

**UGC (User-Generated Content)**  
Content created and shared by users on platforms like YouTube or TikTok.

**Usage Rights**  
Legal permissions for how, where, and when content can be used.

**UUID (Universally Unique Identifier)**  
A 128-bit label used for identifying resources in the system.

### V

**VAT (Value Added Tax)**  
A consumption tax placed on products, affecting royalty calculations in some territories.

**Verification**  
The process of confirming the identity or authenticity of users, content, or rights claims.

**Version**  
A variation of a recording, such as radio edit, extended mix, or acoustic version.

**Video Stream**  
Delivery of video content, which may include music, such as music videos on YouTube.

### W

**WAV (Waveform Audio File Format)**  
An uncompressed audio file format that preserves the original quality of recordings.

**Webhook**  
A mechanism for services to provide real-time notifications about events to other applications.

**White Label**  
A product or service produced by one company that other companies rebrand to make it appear as their own.

**Windowing**  
The practice of releasing content to different platforms at different times.

### X

**XML (Extensible Markup Language)**  
A markup language that defines rules for encoding documents in a format that is both human-readable and machine-readable.

**XSS (Cross-Site Scripting)**  
A security vulnerability that allows attackers to inject client-side scripts into web pages, addressed by TuneMantra's security measures.

### Y

**YouTube Content ID**  
A digital fingerprinting system developed by Google to identify and manage copyrighted content on YouTube.

**Year of Publication**  
The year in which a work was first published or released, important for copyright and metadata.

**Yellow Flag**  
In the TuneMantra system, an indicator of potential issues that require attention but don't block distribution.

### Z

**Zero-rated**  
Content or services that are exempt from data usage charges by mobile carriers.

**ZIP**  
A file format used for data compression and archiving, often used for bundling assets for delivery.

---

© 2023-2025 TuneMantra. All rights reserved.

---

## documentation/resources/README.md

# TuneMantra Resources

This section contains additional resources for the TuneMantra platform.

## Templates

- [Content Submission Templates](templates/content-submission.md) - Templates for content submission
- [Metadata Templates](templates/metadata.md) - Templates for metadata
- [Agreement Templates](templates/agreements.md) - Templates for agreements
- [Report Templates](templates/reports.md) - Templates for reports

## Sample Files

- [Sample Metadata Files](samples/metadata.md) - Sample metadata files
- [Sample API Requests](samples/api-requests.md) - Sample API requests
- [Sample Reports](samples/reports.md) - Sample reports

## External Resources

- [Industry Standards](external/industry-standards.md) - Relevant industry standards
- [Useful Links](external/useful-links.md) - Useful external resources
- [Partner Documentation](external/partner-docs.md) - Documentation from partner services

## FAQs

- [User FAQs](faqs/user-faqs.md) - Frequently asked questions for users
- [Developer FAQs](faqs/developer-faqs.md) - Frequently asked questions for developers
- [Admin FAQs](faqs/admin-faqs.md) - Frequently asked questions for administrators

## Training Materials

- [User Training](training/user-training.md) - Training materials for users
- [Developer Training](training/developer-training.md) - Training materials for developers
- [Admin Training](training/admin-training.md) - Training materials for administrators

---

## documentation/technical/IMPLEMENTATION_ROADMAP.md

# TuneMantra Implementation Roadmap

This document outlines the implementation roadmap for the TuneMantra platform with a focus on blockchain functionality.


---

## documentation/technical/analytics/analytics-system.md

# Analytics System

*Version: 1.0.0 (March 27, 2025)*

## Table of Contents

- [Introduction](#introduction)
- [System Architecture](#system-architecture)
- [Data Collection Framework](#data-collection-framework)
- [Data Processing Pipeline](#data-processing-pipeline)
- [Data Storage Infrastructure](#data-storage-infrastructure)
- [Analytics Models](#analytics-models)
- [Reporting Framework](#reporting-framework)
- [Visualization System](#visualization-system)
- [Insight Generation](#insight-generation)
- [AI Recommendation Engine](#ai-recommendation-engine)
- [Integration Points](#integration-points)
- [Security and Privacy](#security-and-privacy)
- [Performance Optimization](#performance-optimization)
- [Administration](#administration)
- [Future Roadmap](#future-roadmap)
- [Appendix](#appendix)

## Introduction

The TuneMantra Analytics System is a comprehensive platform for collecting, processing, analyzing, and visualizing data related to music distribution, consumption, and performance. This document provides detailed information about the system's architecture, components, capabilities, and operational characteristics.

### Purpose and Scope

This document covers:

- The complete analytics architecture and technology stack
- Data collection mechanisms from multiple sources
- Processing pipelines and transformation logic
- Storage infrastructure and data management
- Analytics models and insight generation
- Reporting and visualization capabilities
- AI-driven recommendation engine
- Integration points with other systems
- Security, privacy, and performance considerations

### Background

Understanding music performance across multiple platforms is critical for rights holders to make informed decisions about their content strategy, marketing investments, and catalog development. The TuneMantra Analytics System was developed to address the complex challenges of multi-platform data aggregation, normalization, and analysis.

Key challenges addressed include:

- Heterogeneous data formats from diverse platforms
- Varying granularity and reporting periods
- Reconciliation of conflicting information
- Real-time processing requirements
- Massive data volumes requiring efficient storage
- Complex relationship modeling for attribution
- Privacy compliance across global regulations

### Business Objectives

The Analytics System supports the following business objectives:

1. **Performance Tracking**: Monitor content performance across all platforms
2. **Trend Identification**: Detect emerging patterns and opportunities
3. **Decision Support**: Provide actionable insights for strategic decisions
4. **Revenue Correlation**: Connect performance metrics to financial outcomes
5. **Audience Understanding**: Develop insights into listener demographics and behavior
6. **Catalog Optimization**: Identify strengths and gaps in content offerings
7. **Marketing Effectiveness**: Measure the impact of promotional activities

## System Architecture

The Analytics System is designed as a scalable, distributed architecture capable of handling large data volumes with real-time processing capabilities.

### High-Level Architecture

The system follows a modular architecture with these primary layers:

1. **Collection Layer**: Interfaces with data sources and ingestion mechanisms
2. **Processing Layer**: Data transformation, enrichment, and normalization
3. **Storage Layer**: Multi-tier persistence for different data types and access patterns
4. **Analytics Layer**: Computation, modeling, and insight generation
5. **Presentation Layer**: Reporting, visualization, and interaction
6. **Integration Layer**: Connections with other platform components

### System Context

The Analytics System interacts with:

1. **External Platforms**: Sources of performance and consumption data
2. **Distribution System**: Source of delivery and availability information
3. **Rights Management System**: Source of ownership and attribution data
4. **Royalty System**: Consumer of performance data for financial calculations
5. **User Management System**: Source of organizational context and permissions
6. **Client Applications**: Consumption of analytics through user interfaces

### Technology Stack

The system is built using:

1. **Programming Languages**: Python for data processing, TypeScript/Node.js for services
2. **Data Processing**: Apache Spark for large-scale processing, Kafka Streams for real-time
3. **Storage Technologies**: PostgreSQL for relational, MongoDB for document, ClickHouse for timeseries
4. **Analytics Tools**: TensorFlow for ML, Pandas for data manipulation, NumPy for numerical
5. **Visualization**: D3.js, Chart.js, and React visualization components
6. **Infrastructure**: Kubernetes for orchestration, Airflow for workflow management

### Deployment Model

The system is deployed across:

1. **Processing Cluster**: Distributed compute for batch and stream processing
2. **Storage Cluster**: Tiered storage with performance optimization
3. **Serving Layer**: API services for data access and integration
4. **Caching Layer**: High-speed access for frequently accessed data
5. **Reporting Servers**: Dedicated resources for complex report generation
6. **Development Environment**: Isolated resources for model development

## Data Collection Framework

The Analytics System employs an extensive data collection framework to gather information from diverse sources.

### External Data Sources

The system collects data from:

1. **Streaming Platforms**: Spotify, Apple Music, Amazon Music, etc.
2. **Video Platforms**: YouTube, TikTok, Instagram, etc.
3. **Download Stores**: iTunes, Amazon MP3, Beatport, etc.
4. **Social Media**: Facebook, Twitter, Instagram, etc.
5. **Radio Monitoring**: Airplay tracking services
6. **Chart Services**: Billboard, Official Charts, etc.
7. **Survey Data**: Consumer research and audience studies

### Collection Methods

Data is collected through various methods:

1. **Direct API Integration**: Real-time or scheduled API calls
2. **Report Processing**: Automated parsing of platform-generated reports
3. **File Imports**: Processing of standard format data files
4. **Web Scraping**: Structured extraction of public information
5. **Manual Entry**: User-provided data for special cases
6. **Webhook Receivers**: Event-based data reception
7. **Database Integration**: Direct connections to authorized data sources

### Ingestion Mechanisms

Data ingestion is managed through:

1. **Scheduled Collection**: Periodic retrieval based on availability
2. **Real-time Streaming**: Continuous data flow for time-sensitive sources
3. **Batch Processing**: Efficient handling of large data volumes
4. **Change Data Capture**: Incremental collection of modified data
5. **Push Mechanisms**: Platform-initiated data delivery
6. **Pull Mechanisms**: System-initiated data retrieval
7. **Hybrid Approaches**: Combined techniques for optimal efficiency

### Collection Monitoring

The collection process is monitored through:

1. **Completeness Checking**: Verification of expected data arrival
2. **Freshness Monitoring**: Tracking of data recency and timeliness
3. **Volume Analysis**: Monitoring of data quantity and patterns
4. **Error Detection**: Identification of collection failures
5. **Source Reliability**: Tracking of data source performance
6. **Schema Validation**: Verification of data structure and format

### Data Cataloging

Collected data is cataloged with:

1. **Source Metadata**: Origin, timing, and collection details
2. **Schema Information**: Structure, format, and field descriptions
3. **Quality Metrics**: Completeness, accuracy, and reliability indicators
4. **Relationship Mapping**: Connections to other data sets
5. **Versioning**: Tracking of data evolution and updates
6. **Lineage Tracking**: Record of data transformations and processing

## Data Processing Pipeline

The Analytics System utilizes a sophisticated data processing pipeline to transform raw data into analytics-ready information.

### Data Validation

Incoming data undergoes validation:

1. **Schema Verification**: Confirmation of expected structure
2. **Type Checking**: Validation of data types and formats
3. **Range Validation**: Verification of values within expected bounds
4. **Consistency Checking**: Cross-field validation and logical constraints
5. **Referential Integrity**: Verification of relationship validity
6. **Duplicate Detection**: Identification of redundant information

### Data Cleaning

Raw data is cleaned through:

1. **Missing Value Handling**: Imputation, flagging, or filtering
2. **Outlier Management**: Detection and appropriate handling
3. **Noise Reduction**: Filtering of irrelevant variations
4. **Error Correction**: Fixing of identifiable data issues
5. **Format Standardization**: Normalization of inconsistent formats
6. **Deduplication**: Removal of redundant information
7. **Character Encoding**: Standardization of text representation

### Data Transformation

Transformation processes include:

1. **Field Mapping**: Conversion to standard schema
2. **Normalization**: Scaling to consistent ranges or distributions
3. **Aggregation**: Summarization at appropriate levels
4. **Enrichment**: Addition of derived or supplementary information
5. **Temporal Alignment**: Adjustment to standard time periods
6. **Unit Conversion**: Standardization of measurements
7. **Derivation**: Calculation of new fields from existing data

### Entity Resolution

The system performs entity matching:

1. **Artist Identification**: Matching across variant names and spellings
2. **Release Matching**: Correlation across platforms and identifiers
3. **Track Linking**: Association of equivalent content items
4. **Organization Mapping**: Connection of related business entities
5. **Identifier Reconciliation**: Matching of various ID systems (ISRC, UPC, etc.)
6. **Fuzzy Matching**: Similarity-based association for imperfect matches
7. **Hierarchical Mapping**: Connection of parent-child relationships

### Data Integration

Integration processes include:

1. **Cross-source Merging**: Combining data from multiple origins
2. **Timeline Integration**: Aligning data across different time periods
3. **Hierarchy Building**: Constructing multi-level relationships
4. **Context Addition**: Incorporating explanatory information
5. **Metadata Association**: Connecting descriptive information
6. **Relationship Mapping**: Establishing entity connections
7. **Provenance Tracking**: Maintaining source attribution

### Processing Modes

The system operates in multiple processing modes:

1. **Batch Processing**: Scheduled handling of accumulated data
2. **Streaming Processing**: Real-time handling of continuous data
3. **Micro-batch Processing**: Frequent processing of small data sets
4. **Interactive Processing**: On-demand data transformation
5. **Incremental Processing**: Processing of changes only
6. **Reprocessing**: Complete data refresh when needed
7. **Hybrid Processing**: Combined approaches for different data types

## Data Storage Infrastructure

The Analytics System uses a multi-tier storage infrastructure optimized for different data types and access patterns.

### Storage Tiers

The system employs multiple storage tiers:

1. **Raw Data Zone**: Unmodified source data preservation
2. **Processed Data Zone**: Cleaned and transformed data
3. **Analytics Data Zone**: Optimized storage for analysis
4. **Serving Data Zone**: High-performance access for reporting
5. **Archive Zone**: Long-term retention of historical data
6. **Temporary Zone**: Transient storage for processing

### Storage Technologies

Different technologies are used for specific purposes:

1. **Relational Databases**: PostgreSQL for structured, relationship-rich data
2. **Document Stores**: MongoDB for flexible, schema-variable information
3. **Time Series Databases**: ClickHouse for sequential performance metrics
4. **Key-Value Stores**: Redis for high-speed cached data
5. **Column Stores**: Amazon Redshift for analytical queries
6. **Object Storage**: S3-compatible storage for large objects and files
7. **Graph Databases**: Neo4j for complex relationship modeling

### Data Modeling

Data is modeled through:

1. **Dimensional Modeling**: Star and snowflake schemas for analytics
2. **Normalized Modeling**: Relational structures for transactional data
3. **Document Modeling**: Flexible schema for varied content
4. **Time Series Modeling**: Optimized structures for sequential data
5. **Graph Modeling**: Entity-relationship representation
6. **Hybrid Modeling**: Combined approaches for complex domains

### Data Organization

Information is organized using:

1. **Hierarchical Structures**: Parent-child relationships
2. **Taxonomies**: Controlled classification systems
3. **Tagging Systems**: Flexible categorization
4. **Ontologies**: Semantic relationship networks
5. **Faceted Classification**: Multi-dimensional categorization
6. **Temporal Partitioning**: Time-based data segmentation
7. **Spatial Organization**: Geographic structuring

### Data Lifecycle Management

The system manages data through its lifecycle:

1. **Ingestion Policies**: Rules for data acceptance and validation
2. **Retention Policies**: Timeframes for data preservation
3. **Archival Strategies**: Methods for long-term storage
4. **Purging Procedures**: Controlled data removal
5. **Versioning Approach**: Management of data evolution
6. **Recovery Mechanisms**: Protection against data loss
7. **Lineage Tracking**: Documentation of data transformations

### Storage Optimization

Performance is optimized through:

1. **Indexing Strategies**: Strategic index creation for query patterns
2. **Partitioning Schemes**: Data segmentation for parallel access
3. **Compression Techniques**: Size reduction while preserving information
4. **Caching Mechanisms**: High-speed access for frequent data
5. **Materialized Views**: Pre-computed results for common queries
6. **Query Optimization**: Efficient data retrieval patterns
7. **Storage Tiering**: Placement based on access frequency

## Analytics Models

The Analytics System employs various analytical models to derive insights from processed data.

### Descriptive Analytics

Historical analysis includes:

1. **Performance Metrics**: Streams, downloads, views, engagement
2. **Trend Analysis**: Patterns over time and seasonality
3. **Comparative Analysis**: Performance against benchmarks
4. **Distribution Analysis**: Geographic and demographic spread
5. **Correlation Analysis**: Relationships between variables
6. **Anomaly Detection**: Identification of unusual patterns
7. **Attribution Analysis**: Source and influence tracking

### Predictive Analytics

Forward-looking models include:

1. **Forecasting Models**: Future performance projection
2. **Trend Prediction**: Pattern continuation estimation
3. **Audience Growth Modeling**: Listener base expansion prediction
4. **Churn Prediction**: Engagement drop identification
5. **Content Performance Estimation**: New release success modeling
6. **Market Response Modeling**: Impact prediction for actions
7. **Scenario Analysis**: Outcome estimation for different conditions

### Prescriptive Analytics

Recommendation models include:

1. **Release Optimization**: Timing and strategy recommendations
2. **Catalog Development**: Content gap identification
3. **Marketing Allocation**: Resource distribution suggestions
4. **Platform Prioritization**: Focus recommendation based on performance
5. **Audience Targeting**: Segment selection for promotion
6. **Pricing Optimization**: Revenue maximization suggestions
7. **Collaboration Recommendations**: Partnership opportunity identification

### Segmentation Models

Audience classification includes:

1. **Demographic Segmentation**: Age, location, language groups
2. **Behavioral Segmentation**: Listening patterns and preferences
3. **Engagement Segmentation**: Interaction level and frequency
4. **Value Segmentation**: Revenue generation classification
5. **Platform Segmentation**: Service usage patterns
6. **Genre Affinity**: Style preference grouping
7. **Discovery Patterns**: Content exploration classification

### Attribution Models

Influence tracking includes:

1. **First-touch Attribution**: Initial discovery credit
2. **Last-touch Attribution**: Final conversion credit
3. **Multi-touch Attribution**: Distributed influence credit
4. **Time-decay Attribution**: Temporally weighted credit
5. **Position-based Attribution**: Role-specific credit allocation
6. **Algorithm-based Attribution**: Machine learning credit determination
7. **Custom Attribution**: Tailored models for specific scenarios

### Statistical Models

Analysis techniques include:

1. **Regression Analysis**: Relationship quantification
2. **Time Series Analysis**: Sequential pattern identification
3. **Cluster Analysis**: Natural grouping discovery
4. **Factor Analysis**: Underlying dimension identification
5. **ANOVA**: Variance source determination
6. **Hypothesis Testing**: Statistical validation
7. **Bayesian Analysis**: Probabilistic inference

## Reporting Framework

The Analytics System provides a comprehensive reporting framework for insight delivery.

### Report Types

The system supports various report formats:

1. **Dashboards**: Interactive visual summaries
2. **Scheduled Reports**: Automated periodic delivery
3. **Ad-hoc Reports**: User-defined custom analysis
4. **Drill-down Reports**: Hierarchical exploration
5. **Comparative Reports**: Benchmarking and trending
6. **Alert Reports**: Exception-based notifications
7. **Executive Summaries**: High-level overviews

### Standard Reports

Pre-configured reports include:

1. **Performance Overview**: High-level metrics summary
2. **Catalog Analysis**: Content performance breakdown
3. **Audience Insights**: Listener demographic and behavior
4. **Platform Comparison**: Cross-service performance
5. **Geographic Distribution**: Territorial performance
6. **Trend Analysis**: Time-based pattern identification
7. **Release Performance**: New content tracking

### Reporting Dimensions

Reports can be analyzed across:

1. **Time Dimensions**: Day, week, month, quarter, year
2. **Content Dimensions**: Track, release, artist, label
3. **Geographic Dimensions**: Country, region, city
4. **Platform Dimensions**: Service, tier, access method
5. **Demographic Dimensions**: Age, gender, language
6. **Genre Dimensions**: Style, mood, era
7. **Business Dimensions**: Organization, division, label

### Report Delivery

Reports are delivered through:

1. **Web Interface**: Interactive online access
2. **Email Distribution**: Scheduled delivery to recipients
3. **Mobile Application**: On-device access
4. **API Access**: Programmatic retrieval
5. **Export Formats**: PDF, Excel, CSV generation
6. **Notification System**: Alert-based delivery
7. **Embedded Analytics**: Integration in other interfaces

### Reporting Controls

Report customization includes:

1. **Filtering**: Criteria-based data selection
2. **Sorting**: Order control for results
3. **Grouping**: Hierarchical organization
4. **Aggregation**: Summarization level control
5. **Time Period Selection**: Timeframe adjustment
6. **Comparative Selection**: Benchmark choice
7. **Visualization Options**: Display format selection

### Scheduling and Distribution

Automated reporting includes:

1. **Periodic Scheduling**: Time-based generation
2. **Event-triggered Reports**: Action-based creation
3. **Recipient Management**: Controlled distribution
4. **Format Selection**: Output type configuration
5. **Delivery Channel**: Distribution method choice
6. **Archive Access**: Historical report retention
7. **Failure Handling**: Error recovery for delivery

## Visualization System

The Analytics System provides sophisticated visualization capabilities for intuitive data understanding.

### Chart Types

Supported visualizations include:

1. **Line Charts**: Trend and time series visualization
2. **Bar Charts**: Comparative value display
3. **Pie/Donut Charts**: Proportion representation
4. **Area Charts**: Cumulative value visualization
5. **Scatter Plots**: Correlation and distribution display
6. **Heat Maps**: Intensity visualization
7. **Bubble Charts**: Multi-dimensional comparison
8. **Radar Charts**: Multi-variable comparison
9. **Sankey Diagrams**: Flow representation
10. **Tree Maps**: Hierarchical proportion display

### Interactive Features

Visualization interactivity includes:

1. **Filtering**: Dynamic data focus
2. **Drill-down**: Hierarchical exploration
3. **Tooltips**: Contextual information display
4. **Zooming**: Detail level adjustment
5. **Panning**: View position control
6. **Selection**: Data point highlighting
7. **Animation**: Temporal changes visualization
8. **Linked Views**: Cross-chart interaction

### Advanced Visualizations

Specialized visuals include:

1. **Geographic Maps**: Spatial performance visualization
2. **Network Graphs**: Relationship visualization
3. **Stream Graphs**: Temporal proportion changes
4. **Chord Diagrams**: Inter-relationship flows
5. **Parallel Coordinates**: Multi-dimensional comparison
6. **Word Clouds**: Text frequency visualization
7. **Sunburst Charts**: Hierarchical proportion display
8. **Force-directed Graphs**: Dynamic relationship networks

### Custom Visualizations

Domain-specific visuals include:

1. **Catalog Navigator**: Interactive content exploration
2. **Release Timeline**: Chronological release visualization
3. **Artist Network**: Collaboration relationship display
4. **Platform Comparison Matrix**: Cross-service performance
5. **Audience Segmentation Map**: Listener group visualization
6. **Genre Distribution**: Music style breakdown
7. **Royalty Flow Diagram**: Revenue attribution visualization

### Visualization Accessibility

Inclusive design features:

1. **Color Blindness Support**: Accessible color schemes
2. **Text Alternatives**: Non-visual data representation
3. **Keyboard Navigation**: Non-mouse interaction
4. **Screen Reader Support**: Audio description
5. **Resizable Components**: Display size adaptation
6. **High Contrast Options**: Visibility enhancement
7. **Simplified Views**: Cognitive load reduction

### Mobile Visualization

Small screen optimization includes:

1. **Responsive Design**: Layout adaptation
2. **Touch Interaction**: Finger-friendly controls
3. **Progressive Disclosure**: Information layering
4. **Simplified Views**: Essential information focus
5. **Performance Optimization**: Resource-efficient rendering
6. **Offline Capability**: Disconnected operation
7. **Portrait/Landscape Adaptation**: Orientation handling

## Insight Generation

The Analytics System employs advanced techniques to automatically generate actionable insights.

### Insight Types

The system identifies various insights:

1. **Trend Identification**: Pattern recognition and projection
2. **Anomaly Detection**: Unusual pattern identification
3. **Correlation Discovery**: Relationship identification
4. **Opportunity Spotting**: Potential advantage detection
5. **Risk Highlighting**: Potential issue identification
6. **Comparative Analysis**: Benchmark deviation recognition
7. **Causal Inference**: Influence factor identification

### Insight Generation Methods

Insights are derived through:

1. **Statistical Analysis**: Mathematical pattern detection
2. **Machine Learning**: Algorithm-based inference
3. **Rule-based Systems**: Predefined condition evaluation
4. **Time Series Analysis**: Sequential pattern recognition
5. **Comparative Frameworks**: Benchmark-based evaluation
6. **Threshold Monitoring**: Limit-based detection
7. **Expert Systems**: Domain knowledge application

### Prioritization Framework

Insights are prioritized based on:

1. **Business Impact**: Potential value influence
2. **Confidence Level**: Statistical reliability
3. **Actionability**: Feasibility of response
4. **Urgency**: Time sensitivity
5. **Audience Relevance**: Recipient applicability
6. **Novelty**: New information value
7. **Trend Strength**: Pattern significance

### Natural Language Generation

Insights are expressed through:

1. **Narrative Summaries**: Contextual explanation
2. **Key Finding Highlights**: Important discovery emphasis
3. **Recommendation Generation**: Action suggestion
4. **Comparative Statements**: Relative performance description
5. **Trend Description**: Pattern explanation
6. **Causal Analysis**: Reason identification
7. **Future Projection**: Expected outcome description

### Insight Delivery

Insights are provided through:

1. **Dashboard Integration**: Visual interface embedding
2. **Notification System**: Alert-based delivery
3. **Email Digests**: Periodic summaries
4. **Mobile Alerts**: On-device notifications
5. **Report Annotations**: Context within analysis
6. **API Access**: Programmatic retrieval
7. **Virtual Assistant Integration**: Conversational delivery

### Feedback Loop

Insight quality is improved through:

1. **User Rating**: Recipient evaluation
2. **Acted Upon Tracking**: Implementation monitoring
3. **Accuracy Validation**: Outcome comparison
4. **Relevance Feedback**: Usefulness assessment
5. **Improvement Suggestions**: User enhancement ideas
6. **A/B Testing**: Alternative approach comparison
7. **Learning System**: Adaptation based on feedback

## AI Recommendation Engine

The Analytics System includes an AI-powered recommendation engine for personalized insights and suggestions.

### Recommendation Types

The system generates various recommendations:

1. **Content Recommendations**: Release and track suggestions
2. **Marketing Recommendations**: Promotion and targeting advice
3. **Strategy Recommendations**: Business direction guidance
4. **Platform Recommendations**: Distribution channel suggestions
5. **Timing Recommendations**: Release schedule optimization
6. **Pricing Recommendations**: Monetization strategy advice
7. **Collaboration Recommendations**: Partnership suggestions

### Recommendation Models

Suggestions are generated using:

1. **Collaborative Filtering**: Similar user behavior patterns
2. **Content-based Filtering**: Item attribute matching
3. **Knowledge-based Recommendations**: Rule and constraint application
4. **Hybrid Approaches**: Combined technique implementation
5. **Deep Learning Models**: Neural network pattern recognition
6. **Reinforcement Learning**: Feedback-optimized suggestions
7. **Contextual Bandits**: Exploration-exploitation balance

### Personalization Framework

Recommendations are personalized based on:

1. **User Role**: Position-specific relevance
2. **Organization Context**: Business situation applicability
3. **Historical Interaction**: Past engagement patterns
4. **Stated Preferences**: Explicit user choices
5. **Similar Profiles**: Peer group behaviors
6. **Current Goals**: Declared objectives
7. **Seasonal Context**: Time-appropriate suggestions

### Exploration Features

Discovery is supported through:

1. **Serendipity Mechanisms**: Unexpected but valuable suggestions
2. **Diversity Promotion**: Varied recommendation sets
3. **Novelty Balancing**: New versus familiar optimization
4. **Explanation Provision**: Recommendation reasoning
5. **Confidence Indication**: Certainty level communication
6. **Alternative Suggestions**: Multiple option presentation
7. **Interactive Refinement**: User-guided adjustment

### Training and Improvement

The system learns through:

1. **Supervised Learning**: Labeled example training
2. **Unsupervised Learning**: Pattern discovery without labels
3. **Reinforcement Learning**: Feedback-based optimization
4. **Online Learning**: Continuous model updating
5. **Transfer Learning**: Cross-domain knowledge application
6. **Federated Learning**: Distributed model improvement
7. **A/B Testing**: Experimental approach comparison

### Ethical Implementation

Responsible AI practices include:

1. **Bias Detection**: Unfair pattern identification
2. **Fairness Measures**: Equitable treatment enforcement
3. **Transparency Mechanisms**: Understanding enablement
4. **Privacy Protection**: Personal data safeguarding
5. **Diversity Promotion**: Varied representation
6. **Human Oversight**: Expert supervision
7. **Continuous Evaluation**: Ongoing assessment

## Integration Points

The Analytics System integrates with various internal and external systems for comprehensive functionality.

### Internal System Integration

Connections with platform components include:

1. **Content Management System**: Catalog and metadata context
2. **Rights Management System**: Ownership and attribution information
3. **Distribution System**: Availability and delivery status
4. **Royalty System**: Financial performance correlation
5. **User Management System**: Identity and permissions
6. **Notification System**: Alert delivery
7. **API Gateway**: External access control

### External System Integration

Connections with external systems include:

1. **Streaming Platforms**: Performance data sources
2. **Social Media Platforms**: Engagement and audience data
3. **Marketing Systems**: Campaign and promotion context
4. **Industry Databases**: Reference information
5. **Market Research Services**: Audience and trend information
6. **Business Intelligence Tools**: Advanced analysis integration
7. **Third-party Visualization**: Specialized display integration

### Integration Methods

Connection approaches include:

1. **API-based Integration**: Service interface connection
2. **File-based Exchange**: Structured data transfer
3. **Database Integration**: Direct data access
4. **Event-driven Integration**: Message-based communication
5. **Webhook Implementation**: Notification-based interaction
6. **ETL Processes**: Extract-Transform-Load workflows
7. **Custom Connectors**: Specialized integration components

### Data Exchange Formats

Information is exchanged using:

1. **JSON**: Lightweight, flexible structure
2. **XML**: Standard hierarchical format
3. **CSV/TSV**: Tabular data representation
4. **Parquet**: Columnar storage format
5. **Avro**: Compact binary format
6. **Protocol Buffers**: Efficient serialization
7. **Custom Formats**: Specialized data structures

### Integration Security

Secure connection measures include:

1. **Authentication**: Identity verification
2. **Authorization**: Access control
3. **Encryption**: Data protection
4. **Rate Limiting**: Usage control
5. **Audit Logging**: Activity tracking
6. **Data Validation**: Structure verification
7. **Secure Channels**: Protected transmission

### Integration Governance

Connection management includes:

1. **Documentation**: Interface specification
2. **Version Control**: Change management
3. **Dependency Tracking**: Relationship documentation
4. **Monitoring**: Health and performance tracking
5. **Error Handling**: Issue management
6. **SLA Management**: Service level enforcement
7. **Change Communication**: Update notification

## Security and Privacy

The Analytics System incorporates comprehensive security and privacy measures to protect sensitive information.

### Data Protection

Information is secured through:

1. **Encryption at Rest**: Stored data protection
2. **Encryption in Transit**: Transmission protection
3. **Access Controls**: Permission-based restrictions
4. **Anonymization**: Identity removal
5. **Pseudonymization**: Identity substitution
6. **Tokenization**: Sensitive data replacement
7. **Data Masking**: Value obfuscation

### Authentication and Authorization

Access is controlled through:

1. **Multi-factor Authentication**: Enhanced identity verification
2. **Role-based Access Control**: Position-appropriate permissions
3. **Attribute-based Access Control**: Context-sensitive permissions
4. **Fine-grained Permissions**: Detailed access control
5. **Time-limited Access**: Temporary authorization
6. **Emergency Access**: Break-glass procedures
7. **Delegation Controls**: Permission transfer management

### Audit and Compliance

Governance is ensured through:

1. **Comprehensive Logging**: Activity recording
2. **Access Auditing**: Usage review
3. **Change Tracking**: Modification history
4. **Compliance Monitoring**: Regulation adherence
5. **Privacy Impact Assessment**: Risk evaluation
6. **Regular Audits**: Scheduled examination
7. **Remediation Tracking**: Issue resolution management

### Privacy Framework

User data is protected through:

1. **Consent Management**: Permission tracking
2. **Purpose Limitation**: Usage restriction
3. **Data Minimization**: Collection restriction
4. **Storage Limitation**: Retention control
5. **Rights Management**: User control enablement
6. **Privacy by Design**: Built-in protection
7. **Cross-border Controls**: Geographic restrictions

### Threat Protection

Security threats are addressed through:

1. **Vulnerability Management**: Weakness identification and resolution
2. **Intrusion Detection**: Unauthorized access identification
3. **Anomaly Detection**: Unusual pattern identification
4. **DDoS Protection**: Availability attack mitigation
5. **API Security**: Interface protection
6. **Web Application Protection**: Frontend safeguards
7. **Security Monitoring**: Continuous surveillance

### Incident Response

Security events are managed through:

1. **Incident Detection**: Issue identification
2. **Classification**: Severity determination
3. **Containment**: Impact limitation
4. **Eradication**: Problem elimination
5. **Recovery**: Normal operation restoration
6. **Post-incident Analysis**: Cause identification
7. **Improvement Implementation**: Vulnerability remediation

## Performance Optimization

The Analytics System incorporates various optimizations to ensure efficient operation at scale.

### Query Optimization

Data retrieval is optimized through:

1. **Query Planning**: Execution strategy optimization
2. **Index Utilization**: Efficient data access
3. **Join Optimization**: Relationship traversal efficiency
4. **Materialized Views**: Pre-computed result storage
5. **Query Caching**: Result reuse
6. **Execution Plan Analysis**: Performance bottleneck identification
7. **Query Rewriting**: Equivalent but faster formulation

### Processing Optimization

Data transformation is optimized through:

1. **Parallel Processing**: Simultaneous execution
2. **Distributed Computing**: Workload division
3. **In-memory Processing**: RAM-based operation
4. **Incremental Processing**: Change-only handling
5. **Pipeline Optimization**: Operation sequencing
6. **Resource Allocation**: Appropriate provisioning
7. **Batch Size Tuning**: Optimal grouping

### Storage Optimization

Data storage is optimized through:

1. **Data Partitioning**: Logical segmentation
2. **Compression**: Size reduction
3. **Columnar Storage**: Access pattern optimization
4. **Hot/Cold Tiering**: Usage-based placement
5. **Indexing Strategies**: Lookup acceleration
6. **Caching Hierarchies**: Multi-level fast access
7. **Data Pruning**: Unnecessary information removal

### Visualization Optimization

Display performance is enhanced through:

1. **Data Aggregation**: Summary-level display
2. **Progressive Loading**: Incremental rendering
3. **Lazy Rendering**: On-demand display
4. **Client-side Caching**: Local data storage
5. **Optimized Rendering**: Efficient drawing
6. **Viewport Culling**: Off-screen element skipping
7. **Reduced Precision**: Appropriate detail level

### Scalability Measures

Growth accommodation includes:

1. **Horizontal Scaling**: Server addition
2. **Vertical Scaling**: Resource expansion
3. **Auto-scaling**: Demand-based adjustment
4. **Load Balancing**: Traffic distribution
5. **Sharding**: Data distribution
6. **Microservice Architecture**: Component isolation
7. **Stateless Design**: Session independence

### Resource Management

System resources are managed through:

1. **Workload Scheduling**: Execution timing
2. **Priority Queuing**: Importance-based ordering
3. **Resource Quotas**: Usage limitations
4. **Throttling**: Rate control
5. **Connection Pooling**: Reuse optimization
6. **Graceful Degradation**: Controlled performance reduction
7. **Resource Monitoring**: Usage tracking

## Administration

The Analytics System provides comprehensive administration capabilities for system management.

### Configuration Management

System settings are managed through:

1. **Environment Configuration**: Deployment-specific settings
2. **Feature Flags**: Functionality enablement
3. **Integration Settings**: Connection parameters
4. **Processing Rules**: Transformation configuration
5. **Security Parameters**: Protection settings
6. **Performance Tuning**: Optimization controls
7. **UI Customization**: Interface adjustment

### Monitoring and Alerting

System oversight includes:

1. **Health Monitoring**: Component status tracking
2. **Performance Metrics**: Efficiency measurement
3. **Error Tracking**: Issue identification
4. **Usage Statistics**: Utilization monitoring
5. **Capacity Planning**: Resource forecasting
6. **SLA Monitoring**: Service level tracking
7. **Alert Configuration**: Notification management

### Job Management

Processing tasks are managed through:

1. **Schedule Configuration**: Timing control
2. **Job Prioritization**: Execution order
3. **Dependency Management**: Task sequence control
4. **Failure Handling**: Error recovery
5. **Resource Allocation**: Capacity assignment
6. **Manual Triggering**: On-demand execution
7. **History Tracking**: Execution recording

### User Management

System access is managed through:

1. **User Provisioning**: Account creation
2. **Role Assignment**: Permission grouping
3. **Access Control**: Resource permission
4. **Permission Auditing**: Access review
5. **Session Management**: Login control
6. **Activity Tracking**: Action recording
7. **Profile Management**: User information

### Data Management

Information is managed through:

1. **Data Lifecycle**: Stage progression control
2. **Retention Policy**: Storage duration
3. **Archival Process**: Long-term preservation
4. **Purge Procedures**: Removal workflow
5. **Recovery Options**: Restoration capability
6. **Quality Monitoring**: Integrity verification
7. **Lineage Tracking**: Transformation history

### System Maintenance

Operational tasks include:

1. **Backup Management**: Copy creation and verification
2. **Update Procedures**: Version management
3. **Patch Application**: Fix implementation
4. **Performance Tuning**: Optimization adjustment
5. **Database Maintenance**: Health preservation
6. **Storage Management**: Capacity planning
7. **Security Updates**: Protection enhancement

## Future Roadmap

The Analytics System continues to evolve with planned enhancements and expansions.

### Near-term Roadmap

Upcoming enhancements include:

1. **Enhanced AI Capabilities**: Advanced machine learning models
2. **Predictive Analytics Expansion**: More forecasting capabilities
3. **Natural Language Interface**: Conversational analytics
4. **Real-time Dashboard Expansion**: More live monitoring
5. **Mobile Analytics Enhancement**: Improved on-device experience
6. **Integration Expansion**: Additional platform connections
7. **Performance Optimization**: Faster processing and querying

### Strategic Directions

Long-term vision includes:

1. **Autonomous Analytics**: Self-optimizing analysis
2. **Prescriptive Intelligence**: Action recommendation automation
3. **Embedded Analytics**: Integration throughout platform
4. **Extended Reality Visualization**: AR/VR data exploration
5. **Voice-driven Analysis**: Spoken interaction
6. **Federated Analytics**: Distributed computation model
7. **Blockchain Integration**: Verifiable analytics

### Research Initiatives

Exploration areas include:

1. **Advanced Causality Models**: Improved attribution
2. **Deep Learning for Music**: Content-based prediction
3. **Quantum Computing Application**: Complex calculation acceleration
4. **Privacy-preserving Analytics**: Enhanced protection techniques
5. **Edge Analytics**: Distributed processing approach
6. **Explainable AI**: Transparent reasoning
7. **Multimodal Analysis**: Combined data type processing

## Appendix

### Glossary

- **KPI (Key Performance Indicator)**: Critical metric for success measurement
- **ETL (Extract, Transform, Load)**: Data processing workflow
- **OLAP (Online Analytical Processing)**: Multi-dimensional analysis
- **Data Warehouse**: Structured repository for analysis
- **Data Lake**: Flexible storage for diverse data
- **Machine Learning**: Algorithms for pattern recognition
- **Data Mining**: Pattern discovery in large datasets
- **Business Intelligence**: Information analysis for decision support
- **Dimension**: Perspective for data analysis
- **Measure**: Quantifiable value for analysis
- **Aggregation**: Summarization of detailed data
- **Data Mart**: Subject-specific analytical subset
- **Dashboard**: Visual display of key metrics
- **Data Visualization**: Graphical representation of information
- **Report**: Formatted presentation of data
- **Insight**: Meaningful understanding derived from data
- **Segmentation**: Division into meaningful groups
- **Attribution**: Assignment of credit for outcomes
- **Forecast**: Prediction of future values
- **Anomaly**: Unusual pattern or outlier

### Reference Documents

- Original Analytics System Design (September 2023)
- Data Collection Framework v2.0 (January 2024)
- Processing Pipeline Specification v1.5 (March 2024)
- AI Recommendation Engine Design v1.0 (August 2024)
- Reporting Framework v2.5 (October 2024)
- Current System Implementation (March 2025)

---

© 2023-2025 TuneMantra. All rights reserved.

---

## documentation/technical/api/api-docs.md

# API Documentation

## Overview

TuneMantra's API is built as a RESTful service using Node.js and Express. The API provides endpoints for managing users, tracks, releases, distribution, royalties, and analytics. This documentation outlines the available endpoints, request/response formats, and authentication requirements.

## Base URL

All API endpoints are relative to the base URL of your TuneMantra instance:

- Development: `http://localhost:5000/api`
- Production: `https://your-tunemantra-instance.replit.app/api`

## Authentication

Most API endpoints require authentication. TuneMantra uses session-based authentication for the web interface and API key authentication for programmatic access.

### Session Authentication

For browser-based interactions, authentication is managed through cookies and sessions:

1. **Login**: `POST /api/auth/login`
2. **Check Status**: `GET /api/auth/status`
3. **Logout**: `POST /api/auth/logout`

### API Key Authentication

For programmatic access, authentication is managed through API keys:

1. API keys are passed in the `Authorization` header as `Bearer {api_key}`
2. Each API key has specific scopes that limit what operations can be performed
3. API keys can be created, managed, and revoked through the API access endpoints

## Common Response Format

All API endpoints follow a consistent response format:

```json
{
  "data": {}, // The response data (object or array)
  "meta": {   // Meta information (pagination, etc.)
    "page": 1,
    "limit": 20,
    "total": 100
  },
  "error": null // Error information (null if no error)
}
```

Error responses:

```json
{
  "data": null,
  "meta": {},
  "error": {
    "message": "Error message",
    "code": "ERROR_CODE",
    "details": {} // Additional error details (optional)
  }
}
```

## API Endpoints

### Authentication Endpoints

#### Login

```
POST /api/auth/login
```

Authenticates a user and creates a session.

**Request Body:**
```json
{
  "username": "string",
  "password": "string"
}
```

**Response:**
```json
{
  "data": {
    "id": 1,
    "username": "string",
    "email": "string",
    "fullName": "string",
    "role": "string",
    "status": "string"
  },
  "meta": {},
  "error": null
}
```

#### Register

```
POST /api/auth/register
```

Registers a new user.

**Request Body:**
```json
{
  "username": "string",
  "password": "string",
  "email": "string",
  "fullName": "string",
  "phoneNumber": "string",
  "entityName": "string",
  "role": "string"
}
```

**Response:**
```json
{
  "data": {
    "id": 1,
    "username": "string",
    "email": "string"
  },
  "meta": {},
  "error": null
}
```

#### Check Authentication Status

```
GET /api/auth/status
```

Checks if the user is authenticated and returns user information.

**Response:**
```json
{
  "data": {
    "id": 1,
    "username": "string",
    "email": "string",
    "fullName": "string",
    "role": "string",
    "status": "string"
  },
  "meta": {},
  "error": null
}
```

#### Logout

```
POST /api/auth/logout
```

Logs out the user and destroys the session.

**Response:**
```json
{
  "data": {
    "message": "Logged out successfully"
  },
  "meta": {},
  "error": null
}
```

### User Management Endpoints

#### List Users

```
GET /api/users
```

Lists users with optional filtering and pagination.

**Query Parameters:**
- `status`: Filter by status (active, pending, etc.)
- `search`: Search term for username, email, etc.
- `page`: Page number (default: 1)
- `limit`: Items per page (default: 20)

**Response:**
```json
{
  "data": [
    {
      "id": 1,
      "username": "string",
      "email": "string",
      "fullName": "string",
      "role": "string",
      "status": "string",
      "createdAt": "string"
    }
  ],
  "meta": {
    "page": 1,
    "limit": 20,
    "total": 100
  },
  "error": null
}
```

#### Get User by ID

```
GET /api/users/:id
```

Retrieves a specific user by ID.

**Response:**
```json
{
  "data": {
    "id": 1,
    "username": "string",
    "email": "string",
    "fullName": "string",
    "phoneNumber": "string",
    "entityName": "string",
    "avatarUrl": "string",
    "role": "string",
    "status": "string",
    "createdAt": "string",
    "updatedAt": "string"
  },
  "meta": {},
  "error": null
}
```

#### Update User

```
PATCH /api/users/:id
```

Updates a user's information.

**Request Body:**
```json
{
  "fullName": "string",
  "phoneNumber": "string",
  "entityName": "string",
  "status": "string"
}
```

**Response:**
```json
{
  "data": {
    "id": 1,
    "username": "string",
    "email": "string",
    "fullName": "string",
    "status": "string",
    "updatedAt": "string"
  },
  "meta": {},
  "error": null
}
```

### API Key Management

#### List API Keys

```
GET /api/api-keys
```

Lists API keys for the authenticated user.

**Response:**
```json
{
  "data": [
    {
      "id": 1,
      "name": "string",
      "key": "string",
      "scopes": ["string"],
      "createdAt": "string",
      "lastUsed": "string",
      "expiresAt": "string",
      "isActive": true
    }
  ],
  "meta": {},
  "error": null
}
```

#### Create API Key

```
POST /api/api-keys
```

Creates a new API key for the authenticated user.

**Request Body:**
```json
{
  "name": "string",
  "scopes": ["string"],
  "expiresAt": "string"
}
```

**Response:**
```json
{
  "data": {
    "id": 1,
    "name": "string",
    "key": "string",
    "scopes": ["string"],
    "createdAt": "string",
    "expiresAt": "string",
    "isActive": true
  },
  "meta": {},
  "error": null
}
```

#### Delete API Key

```
DELETE /api/api-keys/:id
```

Deletes an API key.

**Response:**
```json
{
  "data": {
    "message": "API key deleted successfully"
  },
  "meta": {},
  "error": null
}
```

### Track Management

#### List Tracks by User

```
GET /api/users/:userId/tracks
```

Lists tracks for a specific user.

**Response:**
```json
{
  "data": [
    {
      "id": 1,
      "title": "string",
      "artist": "string",
      "artistName": "string",
      "genre": "string",
      "releaseDate": "string",
      "status": "string",
      "isrc": "string",
      "duration": 180,
      "createdAt": "string",
      "updatedAt": "string"
    }
  ],
  "meta": {},
  "error": null
}
```

#### Get Track by ID

```
GET /api/tracks/:id
```

Retrieves a specific track by ID.

**Response:**
```json
{
  "data": {
    "id": 1,
    "title": "string",
    "artist": "string",
    "artistName": "string",
    "genre": "string",
    "releaseDate": "string",
    "status": "string",
    "isrc": "string",
    "duration": 180,
    "metadata": {},
    "createdAt": "string",
    "updatedAt": "string"
  },
  "meta": {},
  "error": null
}
```

#### Create Track

```
POST /api/tracks
```

Creates a new track.

**Request Body:**
```json
{
  "releaseId": 1,
  "title": "string",
  "artist": "string",
  "artistName": "string",
  "genre": "string",
  "releaseDate": "string",
  "isrc": "string",
  "duration": 180,
  "metadata": {}
}
```

**Response:**
```json
{
  "data": {
    "id": 1,
    "title": "string",
    "artist": "string",
    "artistName": "string",
    "genre": "string",
    "releaseDate": "string",
    "status": "string",
    "isrc": "string",
    "duration": 180,
    "createdAt": "string",
    "updatedAt": "string"
  },
  "meta": {},
  "error": null
}
```

#### Update Track

```
PATCH /api/tracks/:id
```

Updates a track.

**Request Body:**
```json
{
  "title": "string",
  "artist": "string",
  "artistName": "string",
  "genre": "string",
  "releaseDate": "string",
  "isrc": "string",
  "duration": 180,
  "metadata": {}
}
```

**Response:**
```json
{
  "data": {
    "id": 1,
    "title": "string",
    "artist": "string",
    "artistName": "string",
    "genre": "string",
    "releaseDate": "string",
    "status": "string",
    "isrc": "string",
    "duration": 180,
    "updatedAt": "string"
  },
  "meta": {},
  "error": null
}
```

### Release Management

#### List Releases by User

```
GET /api/users/:userId/releases
```

Lists releases for a specific user.

**Response:**
```json
{
  "data": [
    {
      "id": 1,
      "title": "string",
      "artistName": "string",
      "labelName": "string",
      "upc": "string",
      "genre": "string",
      "language": "string",
      "status": "string",
      "type": "string",
      "releaseDate": "string",
      "createdAt": "string",
      "updatedAt": "string"
    }
  ],
  "meta": {},
  "error": null
}
```

#### Get Release by ID

```
GET /api/releases/:id
```

Retrieves a specific release by ID.

**Response:**
```json
{
  "data": {
    "id": 1,
    "title": "string",
    "artistName": "string",
    "labelName": "string",
    "upc": "string",
    "genre": "string",
    "language": "string",
    "description": "string",
    "status": "string",
    "type": "string",
    "releaseDate": "string",
    "contentTags": {},
    "aiAnalysis": {},
    "createdAt": "string",
    "updatedAt": "string"
  },
  "meta": {},
  "error": null
}
```

#### Create Release

```
POST /api/releases
```

Creates a new release.

**Request Body:**
```json
{
  "title": "string",
  "artistName": "string",
  "labelName": "string",
  "upc": "string",
  "genre": "string",
  "language": "string",
  "description": "string",
  "type": "string",
  "releaseDate": "string"
}
```

**Response:**
```json
{
  "data": {
    "id": 1,
    "title": "string",
    "artistName": "string",
    "labelName": "string",
    "upc": "string",
    "genre": "string",
    "language": "string",
    "description": "string",
    "status": "string",
    "type": "string",
    "releaseDate": "string",
    "createdAt": "string",
    "updatedAt": "string"
  },
  "meta": {},
  "error": null
}
```

#### Update Release

```
PATCH /api/releases/:id
```

Updates a release.

**Request Body:**
```json
{
  "title": "string",
  "artistName": "string",
  "labelName": "string",
  "genre": "string",
  "language": "string",
  "description": "string",
  "status": "string",
  "releaseDate": "string"
}
```

**Response:**
```json
{
  "data": {
    "id": 1,
    "title": "string",
    "artistName": "string",
    "labelName": "string",
    "upc": "string",
    "genre": "string",
    "language": "string",
    "description": "string",
    "status": "string",
    "type": "string",
    "releaseDate": "string",
    "updatedAt": "string"
  },
  "meta": {},
  "error": null
}
```

### Distribution Management

#### List Distribution Platforms

```
GET /api/distribution/platforms
```

Lists available distribution platforms.

**Response:**
```json
{
  "data": [
    {
      "id": 1,
      "name": "string",
      "status": "string",
      "deliveryMethod": "string",
      "settings": {}
    }
  ],
  "meta": {},
  "error": null
}
```

#### Distribute Release

```
POST /api/distribution/release/:releaseId
```

Distributes a release to one or more platforms.

**Request Body:**
```json
{
  "platformIds": [1, 2, 3]
}
```

**Response:**
```json
{
  "data": {
    "message": "Distribution initiated",
    "distributionIds": [1, 2, 3]
  },
  "meta": {},
  "error": null
}
```

#### Get Distribution Status

```
GET /api/distribution/status/:releaseId
```

Gets the distribution status for a release.

**Response:**
```json
{
  "data": [
    {
      "id": 1,
      "releaseId": 1,
      "platformId": 1,
      "platformName": "string",
      "status": "string",
      "platformReleaseId": "string",
      "platformUrl": "string",
      "errorDetails": "string",
      "distributedAt": "string"
    }
  ],
  "meta": {},
  "error": null
}
```

### Analytics Management

#### Get Track Analytics

```
GET /api/analytics/tracks/:trackId
```

Gets analytics data for a track.

**Query Parameters:**
- `startDate`: Start date for filtering (YYYY-MM-DD)
- `endDate`: End date for filtering (YYYY-MM-DD)
- `platform`: Filter by platform

**Response:**
```json
{
  "data": {
    "summary": {
      "totalStreams": 10000,
      "totalRevenue": 100.5,
      "topPlatforms": ["string"],
      "topCountries": ["string"]
    },
    "timeSeries": [
      {
        "date": "string",
        "streams": 500,
        "revenue": 5.25
      }
    ],
    "platforms": [
      {
        "name": "string",
        "streams": 4000,
        "revenue": 45.2,
        "percentage": 40
      }
    ],
    "countries": [
      {
        "name": "string",
        "streams": 2500,
        "revenue": 28.75,
        "percentage": 25
      }
    ]
  },
  "meta": {},
  "error": null
}
```

#### Get Release Analytics

```
GET /api/analytics/releases/:releaseId
```

Gets analytics data for a release.

**Query Parameters:**
- `startDate`: Start date for filtering (YYYY-MM-DD)
- `endDate`: End date for filtering (YYYY-MM-DD)
- `platform`: Filter by platform

**Response:**
```json
{
  "data": {
    "summary": {
      "totalStreams": 25000,
      "totalRevenue": 250.75,
      "topTracks": ["string"],
      "topPlatforms": ["string"],
      "topCountries": ["string"]
    },
    "timeSeries": [
      {
        "date": "string",
        "streams": 1200,
        "revenue": 12.6
      }
    ],
    "tracks": [
      {
        "id": 1,
        "title": "string",
        "streams": 8000,
        "revenue": 84,
        "percentage": 32
      }
    ],
    "platforms": [
      {
        "name": "string",
        "streams": 10000,
        "revenue": 105,
        "percentage": 40
      }
    ],
    "countries": [
      {
        "name": "string",
        "streams": 6250,
        "revenue": 65.62,
        "percentage": 25
      }
    ]
  },
  "meta": {},
  "error": null
}
```

#### Get Dashboard Analytics

```
GET /api/analytics/dashboard
```

Gets dashboard analytics for the authenticated user.

**Response:**
```json
{
  "data": {
    "summary": {
      "totalStreams": 100000,
      "totalRevenue": 1050,
      "revenueChange": 5.2,
      "streamChange": 8.5
    },
    "topReleases": [
      {
        "id": 1,
        "title": "string",
        "streams": 25000,
        "revenue": 262.5
      }
    ],
    "topTracks": [
      {
        "id": 1,
        "title": "string",
        "streams": 12000,
        "revenue": 126
      }
    ],
    "revenueTimeSeries": [
      {
        "date": "string",
        "revenue": 52.5
      }
    ],
    "streamTimeSeries": [
      {
        "date": "string",
        "streams": 5000
      }
    ],
    "platformBreakdown": [
      {
        "platform": "string",
        "streams": 40000,
        "revenue": 420,
        "percentage": 40
      }
    ],
    "countryBreakdown": [
      {
        "country": "string",
        "streams": 25000,
        "revenue": 262.5,
        "percentage": 25
      }
    ]
  },
  "meta": {},
  "error": null
}
```

### Royalty Management

#### List Royalty Calculations

```
GET /api/royalties/calculations
```

Lists royalty calculations for the authenticated user.

**Query Parameters:**
- `startDate`: Start date for filtering (YYYY-MM-DD)
- `endDate`: End date for filtering (YYYY-MM-DD)
- `status`: Filter by status

**Response:**
```json
{
  "data": [
    {
      "id": 1,
      "trackId": 1,
      "releaseId": 1,
      "period": "string",
      "startDate": "string",
      "endDate": "string",
      "totalStreams": 5000,
      "totalRevenue": 52.5,
      "status": "string",
      "createdAt": "string",
      "updatedAt": "string"
    }
  ],
  "meta": {},
  "error": null
}
```

#### Process Royalty Calculation

```
POST /api/royalties/process
```

Triggers royalty calculation processing.

**Request Body:**
```json
{
  "trackIds": [1, 2, 3],
  "releaseId": 1,
  "startDate": "string",
  "endDate": "string",
  "forceRecalculation": false
}
```

**Response:**
```json
{
  "data": {
    "message": "Royalty calculation initiated",
    "jobId": 1
  },
  "meta": {},
  "error": null
}
```

#### Get Royalty Splits for Release

```
GET /api/royalties/splits/:releaseId
```

Gets royalty splits for a release.

**Response:**
```json
{
  "data": [
    {
      "id": 1,
      "releaseId": 1,
      "trackId": 1,
      "userId": 1,
      "username": "string",
      "role": "string",
      "sharePercent": 50
    }
  ],
  "meta": {},
  "error": null
}
```

#### Update Royalty Splits

```
PUT /api/royalties/splits/:releaseId
```

Updates royalty splits for a release.

**Request Body:**
```json
{
  "splits": [
    {
      "userId": 1,
      "role": "string",
      "sharePercent": 50
    },
    {
      "userId": 2,
      "role": "string",
      "sharePercent": 50
    }
  ]
}
```

**Response:**
```json
{
  "data": {
    "message": "Royalty splits updated successfully"
  },
  "meta": {},
  "error": null
}
```

### Payment Management

#### List Payment Methods

```
GET /api/payments/methods
```

Lists payment methods for the authenticated user.

**Response:**
```json
{
  "data": [
    {
      "id": 1,
      "type": "string",
      "name": "string",
      "details": {},
      "isDefault": true,
      "isVerified": true,
      "createdAt": "string",
      "updatedAt": "string"
    }
  ],
  "meta": {},
  "error": null
}
```

#### Create Payment Method

```
POST /api/payments/methods
```

Creates a new payment method for the authenticated user.

**Request Body:**
```json
{
  "type": "string",
  "name": "string",
  "details": {},
  "isDefault": true
}
```

**Response:**
```json
{
  "data": {
    "id": 1,
    "type": "string",
    "name": "string",
    "details": {},
    "isDefault": true,
    "isVerified": false,
    "createdAt": "string",
    "updatedAt": "string"
  },
  "meta": {},
  "error": null
}
```

#### List Withdrawals

```
GET /api/payments/withdrawals
```

Lists withdrawal requests for the authenticated user.

**Response:**
```json
{
  "data": [
    {
      "id": 1,
      "amount": 100,
      "currency": "string",
      "status": "string",
      "processedAt": "string",
      "notes": "string",
      "createdAt": "string",
      "updatedAt": "string"
    }
  ],
  "meta": {},
  "error": null
}
```

#### Create Withdrawal Request

```
POST /api/payments/withdrawals
```

Creates a new withdrawal request.

**Request Body:**
```json
{
  "paymentMethodId": 1,
  "amount": 100,
  "currency": "string",
  "notes": "string"
}
```

**Response:**
```json
{
  "data": {
    "id": 1,
    "amount": 100,
    "currency": "string",
    "status": "string",
    "notes": "string",
    "createdAt": "string",
    "updatedAt": "string"
  },
  "meta": {},
  "error": null
}
```

## Error Codes

The API uses standardized error codes to indicate different types of errors:

| Code | Description |
|------|-------------|
| `AUTH_REQUIRED` | Authentication is required for this endpoint |
| `INVALID_CREDENTIALS` | Invalid username or password |
| `PERMISSION_DENIED` | User does not have permission for this operation |
| `RESOURCE_NOT_FOUND` | The requested resource was not found |
| `VALIDATION_ERROR` | The request data failed validation |
| `DUPLICATE_ENTRY` | A resource with the same unique identifier already exists |
| `RATE_LIMIT_EXCEEDED` | Too many requests have been made in a short time |
| `INTERNAL_ERROR` | An unexpected error occurred on the server |

## Pagination

Endpoints that return lists of items support pagination through query parameters:

- `page`: The page number to retrieve (default: 1)
- `limit`: The number of items per page (default: 20)

The response includes pagination metadata:

```json
{
  "meta": {
    "page": 1,
    "limit": 20,
    "total": 100,
    "totalPages": 5
  }
}
```

## Filtering and Sorting

Many list endpoints support filtering and sorting through query parameters:

- `sort`: Field to sort by (e.g., `createdAt`)
- `order`: Sort order (`asc` or `desc`)
- `status`: Filter by status
- `search`: Search term for text fields
- `startDate`: Filter by date range start
- `endDate`: Filter by date range end

## Rate Limiting

The API implements rate limiting to prevent abuse:

- Rate limits are applied per user/API key
- Limits are higher for authenticated users than anonymous requests
- When rate limited, the API returns a 429 Too Many Requests status with a Retry-After header

## Webhook Notifications

TuneMantra supports webhooks for real-time notifications of events:

- Distribution status changes
- Royalty calculation completions
- New analytics data available
- Payment status updates

Webhooks can be configured in the user settings or via the API.

---

## documentation/technical/api/api-reference.md

# TuneMantra API Reference

<div align="center">
  <img src="../diagrams/api-overview-diagram.svg" alt="TuneMantra API Overview" width="700" />
</div>

## Overview

The TuneMantra API provides a comprehensive set of endpoints for interacting with all aspects of the platform. This reference document covers authentication, request formats, response handling, error codes, and detailed specifications for each API endpoint.

## API Status

**Completion: 95.00% (Core Backend Services)**

| API Group | Status | Completion % |
|-----------|--------|--------------|
| Authentication | Complete | 100.00% |
| User Management | Complete | 100.00% |
| Content Management | Complete | 100.00% |
| Distribution | Complete | 100.00% |
| Rights Management | Near completion | 97.50% |
| Royalty Management | Complete | 100.00% |
| Analytics | Advanced development | 87.50% |
| Payment | Complete | 100.00% |
| Search | Complete | 100.00% |
| Webhooks | Near completion | 95.00% |

## Authentication

All API requests must be authenticated using JWT (JSON Web Tokens) or API keys.

### Authentication Methods

#### JWT Authentication

For user-based interactions, use JWT authentication:

```
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

JWT tokens are obtained by calling the `/api/auth/login` endpoint and are valid for 24 hours.

#### API Key Authentication

For service-to-service communication, use API key authentication:

```
X-API-Key: tm_a1b2c3d4e5f6g7h8i9j0...
```

API keys can be generated in the Admin Dashboard and have configurable permissions and expiration.

### Obtaining a JWT Token

```http
POST /api/auth/login
Content-Type: application/json

{
  "email": "user@example.com",
  "password": "password123"
}
```

Response:

```json
{
  "success": true,
  "data": {
    "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "expiresAt": "2025-03-24T23:59:59Z",
    "user": {
      "id": 123,
      "email": "user@example.com",
      "name": "John Doe",
      "role": "artist"
    }
  }
}
```

## API Request Format

### Base URL

```
https://api.tunemantra.com/v1
```

### Request Headers

All requests should include:

```
Content-Type: application/json
Accept: application/json
Authorization: Bearer <token> (or X-API-Key for API key auth)
```

Optional headers:

```
X-Request-ID: <unique request identifier>
X-Idempotency-Key: <idempotency key for POST/PUT/DELETE>
```

### Request Parameters

- **Path Parameters**: Part of the URL path (e.g., `/users/{userId}`)
- **Query Parameters**: Appended to the URL (e.g., `?page=1&limit=10`)
- **Request Body**: JSON payload for POST, PUT, and PATCH requests

## API Response Format

All API responses follow a consistent format:

```json
{
  "success": true,
  "data": {
    // Response data specific to the endpoint
  },
  "meta": {
    "requestId": "req_1234567890",
    "timestamp": "2025-03-23T15:23:45Z",
    "pagination": {
      "page": 1,
      "limit": 10,
      "total": 100,
      "pages": 10
    }
  }
}
```

For error responses:

```json
{
  "success": false,
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "The request data is invalid",
    "details": [
      {
        "field": "email",
        "message": "Must be a valid email address"
      }
    ]
  },
  "meta": {
    "requestId": "req_1234567890",
    "timestamp": "2025-03-23T15:23:45Z"
  }
}
```

## Error Codes

| HTTP Status | Error Code | Description |
|-------------|------------|-------------|
| 400 | BAD_REQUEST | The request is malformed |
| 400 | VALIDATION_ERROR | The request data fails validation |
| 401 | UNAUTHORIZED | Authentication is required |
| 403 | FORBIDDEN | Insufficient permissions |
| 404 | NOT_FOUND | The requested resource does not exist |
| 409 | CONFLICT | The request conflicts with the current state |
| 422 | UNPROCESSABLE_ENTITY | The request is valid but cannot be processed |
| 429 | RATE_LIMITED | Too many requests |
| 500 | SERVER_ERROR | An unexpected server error occurred |
| 503 | SERVICE_UNAVAILABLE | The service is temporarily unavailable |

## Core API Endpoints

### User Management API

#### Get Current User

```http
GET /api/users/me
```

Response:

```json
{
  "success": true,
  "data": {
    "id": 123,
    "email": "user@example.com",
    "name": "John Doe",
    "role": "artist",
    "organizationId": 456,
    "createdAt": "2024-01-15T10:30:00Z",
    "updatedAt": "2025-03-10T14:25:00Z",
    "settings": {
      "notifications": {
        "email": true,
        "push": true
      },
      "theme": "dark"
    }
  }
}
```

#### List Users

```http
GET /api/organizations/{organizationId}/users?page=1&limit=10&role=artist
```

Response:

```json
{
  "success": true,
  "data": [
    {
      "id": 123,
      "email": "user@example.com",
      "name": "John Doe",
      "role": "artist",
      "createdAt": "2024-01-15T10:30:00Z"
    },
    // Additional users...
  ],
  "meta": {
    "pagination": {
      "page": 1,
      "limit": 10,
      "total": 45,
      "pages": 5
    }
  }
}
```

#### Create User

```http
POST /api/organizations/{organizationId}/users
Content-Type: application/json

{
  "email": "newuser@example.com",
  "name": "Jane Smith",
  "role": "manager",
  "password": "securePassword123",
  "settings": {
    "notifications": {
      "email": true,
      "push": false
    }
  }
}
```

Response:

```json
{
  "success": true,
  "data": {
    "id": 124,
    "email": "newuser@example.com",
    "name": "Jane Smith",
    "role": "manager",
    "organizationId": 456,
    "createdAt": "2025-03-23T15:30:00Z",
    "updatedAt": "2025-03-23T15:30:00Z"
  }
}
```

### Content Management API

#### Get Release

```http
GET /api/releases/{releaseId}
```

Response:

```json
{
  "success": true,
  "data": {
    "id": "rel_123456",
    "title": "Summer Vibes",
    "artistName": "DJ Sunshine",
    "releaseDate": "2025-05-15",
    "upc": "123456789012",
    "status": "approved",
    "coverArtUrl": "https://assets.tunemantra.com/covers/rel_123456.jpg",
    "genre": "Electronic",
    "subGenre": "House",
    "language": "English",
    "tracks": [
      {
        "id": "trk_789012",
        "title": "Beach Party",
        "duration": 195,
        "isrc": "ABCDE1234567",
        "trackNumber": 1,
        "explicit": false
      },
      // Additional tracks...
    ],
    "rightsHolders": [
      {
        "id": "rh_456789",
        "name": "John Doe",
        "role": "Primary Artist",
        "share": 50
      },
      {
        "id": "rh_567890",
        "name": "Jane Smith",
        "role": "Producer",
        "share": 50
      }
    ],
    "distributionStatus": {
      "spotify": "live",
      "appleMusic": "pending",
      "amazonMusic": "processing"
    }
  }
}
```

#### Create Release

```http
POST /api/organizations/{organizationId}/releases
Content-Type: application/json

{
  "title": "Summer Vibes",
  "artistName": "DJ Sunshine",
  "releaseDate": "2025-05-15",
  "genre": "Electronic",
  "subGenre": "House",
  "language": "English",
  "tracks": [
    {
      "title": "Beach Party",
      "duration": 195,
      "isrc": "ABCDE1234567",
      "trackNumber": 1,
      "explicit": false,
      "audioFileId": "audio_123456"
    }
  ],
  "rightsHolders": [
    {
      "userId": 123,
      "role": "Primary Artist",
      "share": 50
    },
    {
      "userId": 124,
      "role": "Producer",
      "share": 50
    }
  ],
  "coverArtId": "image_789012"
}
```

Response:

```json
{
  "success": true,
  "data": {
    "id": "rel_123456",
    "title": "Summer Vibes",
    "status": "draft",
    "createdAt": "2025-03-23T16:00:00Z",
    "updatedAt": "2025-03-23T16:00:00Z"
    // Additional release data...
  }
}
```

### Distribution API

#### Get Distribution Status

```http
GET /api/releases/{releaseId}/distribution
```

Response:

```json
{
  "success": true,
  "data": {
    "releaseId": "rel_123456",
    "status": "partially_distributed",
    "platformStatuses": [
      {
        "platform": "spotify",
        "status": "live",
        "url": "https://open.spotify.com/album/123456",
        "distributedAt": "2025-03-20T10:15:00Z",
        "liveAt": "2025-03-22T00:00:00Z"
      },
      {
        "platform": "appleMusic",
        "status": "pending",
        "scheduledFor": "2025-03-24T00:00:00Z"
      },
      {
        "platform": "amazonMusic",
        "status": "processing",
        "submittedAt": "2025-03-23T09:30:00Z"
      }
    ],
    "issues": []
  }
}
```

#### Create Distribution

```http
POST /api/releases/{releaseId}/distribute
Content-Type: application/json

{
  "platforms": ["spotify", "appleMusic", "amazonMusic", "deezer"],
  "scheduledReleaseDate": "2025-05-15",
  "priority": "standard"
}
```

Response:

```json
{
  "success": true,
  "data": {
    "distributionId": "dist_123456",
    "status": "scheduled",
    "platforms": ["spotify", "appleMusic", "amazonMusic", "deezer"],
    "scheduledReleaseDate": "2025-05-15",
    "estimatedCompletionDate": "2025-05-14T00:00:00Z"
  }
}
```

### Rights Management API

#### Get Rights Information

```http
GET /api/releases/{releaseId}/rights
```

Response:

```json
{
  "success": true,
  "data": {
    "releaseId": "rel_123456",
    "rightsHolders": [
      {
        "id": "rh_456789",
        "userId": 123,
        "name": "John Doe",
        "role": "Primary Artist",
        "share": 50,
        "verified": true,
        "blockchainVerificationId": "0x1234567890abcdef",
        "agreedToTerms": true,
        "agreedAt": "2025-03-15T12:30:00Z"
      },
      {
        "id": "rh_567890",
        "userId": 124,
        "name": "Jane Smith",
        "role": "Producer",
        "share": 50,
        "verified": true,
        "blockchainVerificationId": "0xabcdef1234567890",
        "agreedToTerms": true,
        "agreedAt": "2025-03-15T14:45:00Z"
      }
    ],
    "license": {
      "type": "exclusive",
      "territory": "worldwide",
      "startDate": "2025-05-15",
      "endDate": null
    },
    "copyrightOwner": "TuneMantra Records",
    "publishingRights": "TuneMantra Publishing"
  }
}
```

#### Update Rights Holder

```http
PUT /api/releases/{releaseId}/rights/holders/{rightsHolderId}
Content-Type: application/json

{
  "role": "Primary Artist",
  "share": 40
}
```

Response:

```json
{
  "success": true,
  "data": {
    "id": "rh_456789",
    "userId": 123,
    "name": "John Doe",
    "role": "Primary Artist",
    "share": 40,
    "verified": true,
    "updatedAt": "2025-03-23T16:30:00Z"
  }
}
```

### Royalty Management API

#### Get Royalty Overview

```http
GET /api/organizations/{organizationId}/royalties/overview?period=2025-02
```

Response:

```json
{
  "success": true,
  "data": {
    "period": "2025-02",
    "totalEarnings": 12345.67,
    "currency": "USD",
    "platforms": [
      {
        "name": "Spotify",
        "earnings": 5678.90,
        "streams": 1234567,
        "avgPerStream": 0.0046
      },
      {
        "name": "Apple Music",
        "earnings": 3456.78,
        "streams": 456789,
        "avgPerStream": 0.0076
      },
      {
        "name": "Amazon Music",
        "earnings": 2345.67,
        "streams": 345678,
        "avgPerStream": 0.0068
      },
      {
        "name": "Others",
        "earnings": 864.32,
        "streams": 123456,
        "avgPerStream": 0.0070
      }
    ],
    "topReleases": [
      {
        "releaseId": "rel_123456",
        "title": "Summer Vibes",
        "artistName": "DJ Sunshine",
        "earnings": 4567.89,
        "streams": 789012
      },
      // Additional releases...
    ],
    "paymentStatus": "processing",
    "estimatedPaymentDate": "2025-04-15"
  }
}
```

#### Get Detailed Royalty Statement

```http
GET /api/organizations/{organizationId}/royalties/statements/{statementId}
```

Response:

```json
{
  "success": true,
  "data": {
    "statementId": "stmt_123456",
    "period": "2025-02",
    "organizationId": 456,
    "generateDate": "2025-03-15T00:00:00Z",
    "totalEarnings": 12345.67,
    "currency": "USD",
    "status": "paid",
    "paymentDate": "2025-03-20T00:00:00Z",
    "paymentMethod": "Bank Transfer",
    "transactionId": "txn_abcdef123456",
    "releases": [
      {
        "releaseId": "rel_123456",
        "title": "Summer Vibes",
        "artistName": "DJ Sunshine",
        "earnings": 4567.89,
        "platforms": [
          {
            "name": "Spotify",
            "earnings": 2345.67,
            "streams": 456789,
            "countries": [
              {
                "code": "US",
                "earnings": 1234.56,
                "streams": 234567
              },
              // Additional countries...
            ]
          },
          // Additional platforms...
        ],
        "tracks": [
          {
            "trackId": "trk_789012",
            "title": "Beach Party",
            "earnings": 3456.78,
            "streams": 567890
          },
          // Additional tracks...
        ]
      },
      // Additional releases...
    ],
    "deductions": [
      {
        "type": "platform_fee",
        "description": "Platform Service Fee",
        "amount": 1234.57
      },
      {
        "type": "tax_withholding",
        "description": "Tax Withholding (US)",
        "amount": 246.91
      }
    ],
    "payees": [
      {
        "userId": 123,
        "name": "John Doe",
        "role": "Primary Artist",
        "amount": 5432.10,
        "percentage": 50
      },
      {
        "userId": 124,
        "name": "Jane Smith",
        "role": "Producer",
        "amount": 5432.09,
        "percentage": 50
      }
    ]
  }
}
```

### Analytics API

#### Get Performance Overview

```http
GET /api/organizations/{organizationId}/analytics/overview?period=last90days
```

Response:

```json
{
  "success": true,
  "data": {
    "period": "last90days",
    "streams": {
      "total": 12345678,
      "previousPeriod": 9876543,
      "change": 25.0,
      "timeline": [
        {
          "date": "2025-01-01",
          "value": 123456
        },
        // Additional date points...
      ]
    },
    "earnings": {
      "total": 45678.90,
      "previousPeriod": 34567.89,
      "change": 32.1,
      "timeline": [
        {
          "date": "2025-01-01",
          "value": 456.78
        },
        // Additional date points...
      ]
    },
    "platforms": [
      {
        "name": "Spotify",
        "streams": 5678901,
        "earnings": 23456.78,
        "change": 15.4
      },
      // Additional platforms...
    ],
    "topReleases": [
      {
        "releaseId": "rel_123456",
        "title": "Summer Vibes",
        "artistName": "DJ Sunshine",
        "streams": 1234567,
        "earnings": 5678.90
      },
      // Additional releases...
    ],
    "topCountries": [
      {
        "code": "US",
        "name": "United States",
        "streams": 3456789,
        "earnings": 15678.90
      },
      // Additional countries...
    ]
  }
}
```

#### Get Release Analytics

```http
GET /api/releases/{releaseId}/analytics?period=last30days&metrics=streams,earnings,listeners
```

Response:

```json
{
  "success": true,
  "data": {
    "releaseId": "rel_123456",
    "title": "Summer Vibes",
    "period": "last30days",
    "metrics": {
      "streams": {
        "total": 456789,
        "previousPeriod": 345678,
        "change": 32.1,
        "timeline": [
          {
            "date": "2025-02-23",
            "value": 15678
          },
          // Additional date points...
        ]
      },
      "earnings": {
        "total": 2345.67,
        "previousPeriod": 1234.56,
        "change": 90.0,
        "timeline": [
          {
            "date": "2025-02-23",
            "value": 78.90
          },
          // Additional date points...
        ]
      },
      "listeners": {
        "total": 123456,
        "previousPeriod": 98765,
        "change": 25.0,
        "timeline": [
          {
            "date": "2025-02-23",
            "value": 4567
          },
          // Additional date points...
        ]
      }
    },
    "platforms": [
      {
        "name": "Spotify",
        "streams": 234567,
        "earnings": 1234.56,
        "listeners": 78901
      },
      // Additional platforms...
    ],
    "countries": [
      {
        "code": "US",
        "name": "United States",
        "streams": 123456,
        "earnings": 678.90,
        "listeners": 34567
      },
      // Additional countries...
    ],
    "tracks": [
      {
        "trackId": "trk_789012",
        "title": "Beach Party",
        "streams": 345678,
        "earnings": 1789.01,
        "listeners": 98765
      },
      // Additional tracks...
    ]
  }
}
```

### Payment API

#### Get Payment Methods

```http
GET /api/organizations/{organizationId}/payment-methods
```

Response:

```json
{
  "success": true,
  "data": [
    {
      "id": "pm_123456",
      "type": "bank_account",
      "name": "Primary Bank Account",
      "details": {
        "accountHolderName": "TuneMantra Records LLC",
        "bankName": "Global Bank",
        "accountNumberLast4": "1234",
        "routingNumber": "******123",
        "currency": "USD"
      },
      "isDefault": true,
      "createdAt": "2024-05-15T10:30:00Z"
    },
    {
      "id": "pm_234567",
      "type": "paypal",
      "name": "PayPal Account",
      "details": {
        "email": "finance@tunemantrarecords.com"
      },
      "isDefault": false,
      "createdAt": "2024-06-20T14:45:00Z"
    }
  ]
}
```

#### Create Payment Method

```http
POST /api/organizations/{organizationId}/payment-methods
Content-Type: application/json

{
  "type": "bank_account",
  "name": "Secondary Bank Account",
  "details": {
    "accountHolderName": "TuneMantra International LLC",
    "bankName": "World Bank",
    "accountNumber": "9876543210",
    "routingNumber": "987654321",
    "currency": "EUR"
  },
  "isDefault": false
}
```

Response:

```json
{
  "success": true,
  "data": {
    "id": "pm_345678",
    "type": "bank_account",
    "name": "Secondary Bank Account",
    "details": {
      "accountHolderName": "TuneMantra International LLC",
      "bankName": "World Bank",
      "accountNumberLast4": "3210",
      "routingNumber": "******321",
      "currency": "EUR"
    },
    "isDefault": false,
    "createdAt": "2025-03-23T17:15:00Z"
  }
}
```

#### Get Withdrawal History

```http
GET /api/organizations/{organizationId}/withdrawals?page=1&limit=10
```

Response:

```json
{
  "success": true,
  "data": [
    {
      "id": "with_123456",
      "amount": 12345.67,
      "currency": "USD",
      "status": "completed",
      "paymentMethodId": "pm_123456",
      "paymentMethodType": "bank_account",
      "paymentMethodDetails": {
        "accountHolderName": "TuneMantra Records LLC",
        "bankName": "Global Bank",
        "accountNumberLast4": "1234"
      },
      "requestedAt": "2025-03-01T10:30:00Z",
      "processedAt": "2025-03-03T15:45:00Z",
      "estimatedArrivalDate": "2025-03-05T00:00:00Z",
      "transactionId": "txn_abcdef123456"
    },
    // Additional withdrawals...
  ],
  "meta": {
    "pagination": {
      "page": 1,
      "limit": 10,
      "total": 45,
      "pages": 5
    }
  }
}
```

#### Request Withdrawal

```http
POST /api/organizations/{organizationId}/withdrawals
Content-Type: application/json

{
  "amount": 5000.00,
  "currency": "USD",
  "paymentMethodId": "pm_123456",
  "description": "March 2025 earnings withdrawal"
}
```

Response:

```json
{
  "success": true,
  "data": {
    "id": "with_234567",
    "amount": 5000.00,
    "currency": "USD",
    "status": "pending",
    "paymentMethodId": "pm_123456",
    "paymentMethodType": "bank_account",
    "paymentMethodDetails": {
      "accountHolderName": "TuneMantra Records LLC",
      "bankName": "Global Bank",
      "accountNumberLast4": "1234"
    },
    "requestedAt": "2025-03-23T17:30:00Z",
    "estimatedProcessingDate": "2025-03-25T00:00:00Z",
    "estimatedArrivalDate": "2025-03-27T00:00:00Z",
    "description": "March 2025 earnings withdrawal"
  }
}
```

## Webhook API

TuneMantra provides webhooks for real-time updates on various events.

### Webhook Events

| Event Type | Description |
|------------|-------------|
| `release.created` | A new release has been created |
| `release.updated` | A release has been updated |
| `release.approved` | A release has been approved for distribution |
| `release.rejected` | A release has been rejected |
| `distribution.started` | Distribution process has started |
| `distribution.completed` | Distribution to all platforms is complete |
| `distribution.failed` | Distribution to one or more platforms failed |
| `platform.status_changed` | Status on a specific platform has changed |
| `royalty.statement_generated` | A new royalty statement has been generated |
| `royalty.payment_initiated` | A royalty payment has been initiated |
| `royalty.payment_completed` | A royalty payment has been completed |
| `user.created` | A new user has been created |
| `user.deleted` | A user has been deleted |
| `payment_method.created` | A new payment method has been added |
| `withdrawal.status_changed` | Status of a withdrawal has changed |

### Webhook Payload Format

```json
{
  "id": "evt_123456789",
  "eventType": "release.approved",
  "timestamp": "2025-03-23T17:45:00Z",
  "data": {
    // Event-specific data
  }
}
```

### Register Webhook Endpoint

```http
POST /api/organizations/{organizationId}/webhooks
Content-Type: application/json

{
  "url": "https://example.com/webhooks/tunemantra",
  "events": ["release.approved", "distribution.completed", "royalty.payment_completed"],
  "description": "Production event handler",
  "secret": "whsec_abcdefghijklmnopqrstuvwxyz"
}
```

Response:

```json
{
  "success": true,
  "data": {
    "id": "wh_123456",
    "url": "https://example.com/webhooks/tunemantra",
    "events": ["release.approved", "distribution.completed", "royalty.payment_completed"],
    "description": "Production event handler",
    "status": "active",
    "createdAt": "2025-03-23T17:45:00Z"
  }
}
```

## API Rate Limits

TuneMantra API implements rate limiting to ensure fair usage and system stability:

| API Group | Basic Plan | Pro Plan | Enterprise Plan |
|-----------|------------|----------|----------------|
| Authentication | 10/min | 20/min | 50/min |
| User Management | 60/min | 300/min | 1000/min |
| Content Management | 120/min | 600/min | 2000/min |
| Distribution | 60/min | 300/min | 1000/min |
| Rights Management | 60/min | 300/min | 1000/min |
| Royalty Management | 60/min | 300/min | 1000/min |
| Analytics | 120/min | 600/min | 2000/min |
| Payment | 60/min | 300/min | 1000/min |
| Search | 300/min | 1000/min | 3000/min |

Exceeded rate limits return a 429 Too Many Requests response with a Retry-After header.

## API Versioning

The TuneMantra API uses semantic versioning:

- Major version changes (e.g., v1 to v2) may include breaking changes
- Minor version updates are backward compatible
- Current API version: v1

Version is specified in the URL path: `/v1/resources`

## Best Practices

1. **Use Idempotency Keys**: For non-GET requests to prevent duplicate operations
2. **Implement Retry Logic**: With exponential backoff for 5xx errors
3. **Validate Webhook Signatures**: To ensure webhook authenticity
4. **Cache Authentication Tokens**: Until close to expiration to reduce authentication requests
5. **Use Compression**: Set `Accept-Encoding: gzip` for improved performance
6. **Include Request IDs**: In all API calls for easier troubleshooting
7. **Pagination**: Use limit and page parameters for large collections
8. **Filtering**: Use query parameters to filter results

## Development Resources

- **API Playground**: [https://api-playground.tunemantra.com](https://api-playground.tunemantra.com)
- **SDK Libraries**: [https://github.com/tunemantra/api-sdks](https://github.com/tunemantra/api-sdks)
- **API Status**: [https://status.tunemantra.com](https://status.tunemantra.com)

---

*For detailed implementation examples and code snippets, please refer to the [API Implementation Guide](../developer/api-implementation-guide.md).*

---

## documentation/technical/architecture/comprehensive-system-architecture.md

# TuneMantra System Architecture\n\nThis document outlines the comprehensive system architecture of the TuneMantra platform.
# TuneMantra Comprehensive System Architecture

**Version:** 2.1.0
**Last Updated:** March 28, 2025
**Document Status:** Active

## Introduction

This document provides a comprehensive overview of the TuneMantra platform architecture. It describes the system's components, their interactions, data flows, and technical implementation details. This consolidated architecture document serves as the authoritative reference for all architectural aspects of the TuneMantra platform.

## Table of Contents

1. [System Overview](#system-overview)
2. [Architectural Principles](#architectural-principles)
3. [High-Level Architecture](#high-level-architecture)
4. [Core Components](#core-components)
   - [User Management System](#user-management-system)
   - [Content Management System](#content-management-system)
   - [Distribution System](#distribution-system)
   - [Rights Management System](#rights-management-system)
   - [Royalty System](#royalty-system)
   - [Analytics Platform](#analytics-platform)
   - [Integration Framework](#integration-framework)
5. [Technology Stack](#technology-stack)
6. [Data Architecture](#data-architecture)
7. [Security Architecture](#security-architecture)
8. [Integration Architecture](#integration-architecture)
9. [Deployment Architecture](#deployment-architecture)
10. [Performance Considerations](#performance-considerations)
11. [Scalability Strategy](#scalability-strategy)
12. [Disaster Recovery](#disaster-recovery)
13. [Advanced Technology Integrations](#advanced-technology-integrations)
    - [Blockchain Integration](#blockchain-integration)
    - [AI and Machine Learning Components](#ai-and-machine-learning-components)
    - [Quantum-Resistant Security](#quantum-resistant-security)
    - [Neuro-Symbolic AI Knowledge Graph](#neuro-symbolic-ai-knowledge-graph)
14. [Future Architecture Roadmap](#future-architecture-roadmap)

## System Overview

TuneMantra is a comprehensive multi-tenant platform for music distribution, rights management, and royalty processing. The system enables music labels, distributors, and independent artists to manage their catalog, distribute content to digital service providers (DSPs), track performance, and process royalty payments.

The platform is designed as a cloud-native application with a microservices architecture, enabling flexibility, scalability, and continuous delivery. It employs modern development practices including infrastructure-as-code, automated testing, and CI/CD pipelines.

## Architectural Principles

The TuneMantra architecture is guided by the following principles:

1. **Multi-tenancy** - All components support multiple organizations with strict data isolation
2. **API-First** - All functionality is exposed through well-defined APIs
3. **Cloud-Native** - Designed to leverage cloud services and patterns
4. **Microservices-Based** - Functionality is divided into independent, loosely-coupled services
5. **Scalability** - Components can scale independently based on demand
6. **Security-by-Design** - Security is integrated into all aspects of the architecture
7. **Observability** - Comprehensive monitoring, logging, and tracing
8. **Automation** - Infrastructure management and deployment are fully automated
9. **Data Integrity** - Strict data validation and consistency mechanisms
10. **Interoperability** - Extensive support for industry standards and integration patterns

## High-Level Architecture

The TuneMantra platform follows a layered architecture:

1. **Presentation Layer** - Web applications, mobile apps, and API endpoints
2. **API Gateway Layer** - API management, routing, and security
3. **Business Logic Layer** - Microservices implementing core domain functionality
4. **Data Access Layer** - Data repositories and data access objects
5. **Data Storage Layer** - Databases, object storage, and caching systems
6. **Integration Layer** - Connections to external systems and third-party services
7. **Infrastructure Layer** - Cloud resources, networking, and infrastructure management

The system employs both synchronous (REST, GraphQL) and asynchronous (event-driven) communication patterns between services, with a central event bus facilitating loose coupling.

## Core Components

### User Management System

The User Management System handles authentication, authorization, and user profile management. It supports:

- Multi-factor authentication
- Role-based access control (RBAC)
- Fine-grained permissions
- Organization hierarchy
- User provisioning and deprovisioning
- Session management
- Audit logging of user activities

**Implementation Details:**
- Leverages OAuth 2.0 and OpenID Connect for identity management
- JWT-based authentication
- RBAC implementation using custom claims
- User profile database with encryption for sensitive data
- Integration with directory services (LDAP/Active Directory)
- Support for SSO (Single Sign-On) via SAML

### Content Management System

The Content Management System manages the catalog of music and related assets. It supports:

- Metadata management for releases, tracks, and artists
- Digital asset management for audio files, artwork, and promotional materials
- Versioning of content and metadata
- Batch operations for content management
- Automated quality control
- Content enrichment via third-party services

**Implementation Details:**
- Microservice architecture with dedicated services for metadata and asset management
- Object storage for digital assets with CDN integration
- Metadata stored in PostgreSQL with JSON support for flexible schema extensions
- Elasticsearch for text search capabilities
- Automated validation pipelines for incoming content
- Audio processing pipeline for format conversion and quality analysis

### Distribution System

The Distribution System handles the delivery of content to DSPs and management of the distribution workflow. It supports:

- Configuration of distribution targets
- Packaging content for specific DSP requirements
- Delivery scheduling and prioritization
- Delivery status tracking
- Error handling and retry logic
- Takedown management

**Implementation Details:**
- Microservice architecture with dedicated services for different distribution processes
- Integration adapters for each DSP with version management
- Workflow engine for distribution process orchestration
- Priority queue system for delivery scheduling
- State machine for tracking distribution status
- Idempotent operations to handle retries safely

### Rights Management System

The Rights Management System manages ownership information, rights data, and licensing. It supports:

- Rights holder management
- Territory-specific rights configuration
- Time-bounded rights management
- Rights transfer and acquisition workflow
- Conflict detection and resolution
- Historical rights tracking

**Implementation Details:**
- Graph database for complex rights relationships
- Temporal data modeling for time-bound rights
- Blockchain integration for immutable rights records
- Rules engine for rights validation and conflict detection
- Integration with industry rights databases
- Digital contract management with secure storage

### Royalty System

The Royalty System calculates and processes royalty payments. It supports:

- Revenue data import from multiple sources
- Complex royalty rule configuration
- Split payment calculations
- Advance and minimum guarantee handling
- Statement generation
- Payment processing

**Implementation Details:**
- Data pipeline for revenue data normalization
- Rules engine for royalty calculations
- In-memory processing for complex calculations
- Versioned royalty rules with effective dates
- Integrated payment gateway connections
- Comprehensive audit trail for all calculations

### Analytics Platform

The Analytics Platform processes and visualizes data for business intelligence. It supports:

- Real-time and historical performance tracking
- Customizable dashboards
- Trend analysis
- Market intelligence
- Predictive analytics
- Export and sharing capabilities

**Implementation Details:**
- Data warehouse for aggregated analytics data
- Stream processing for real-time analytics
- OLAP cubes for dimensional analysis
- ML models for predictive analytics
- BI visualization layer with customizable dashboards
- ETL pipelines for data integration from multiple sources

### Integration Framework

The Integration Framework enables connectivity with external systems. It supports:

- Public API for third-party integration
- Webhook system for event notifications
- Bulk data import/export
- EDI (Electronic Data Interchange) support
- Partner portal integration
- Custom integration development

**Implementation Details:**
- API Gateway for API management and security
- OpenAPI documentation
- Webhook delivery system with retry logic
- Message queue integration for asynchronous processing
- Data transformation services
- Integration monitoring and alerting

## Technology Stack

The TuneMantra platform is built using the following technologies:

**Frontend:**
- React.js for web applications
- React Native for mobile applications
- TypeScript for type safety
- Redux for state management
- Material-UI and custom design system
- Jest and React Testing Library for testing

**Backend:**
- Node.js with TypeScript for microservices
- Express.js for API framework
- gRPC for internal service communication
- GraphQL for client-facing APIs
- Jest for testing

**Data Storage:**
- PostgreSQL for relational data
- MongoDB for document storage
- Redis for caching and session management
- Neo4j for graph data (rights management)
- Elasticsearch for search functionality
- MinIO for object storage

**Infrastructure:**
- Kubernetes for container orchestration
- Docker for containerization
- Terraform for infrastructure-as-code
- AWS/Azure/GCP for cloud infrastructure
- Kong API Gateway
- RabbitMQ for message queuing
- ELK Stack for logging and monitoring
- Prometheus and Grafana for metrics and visualization

**DevOps:**
- GitHub for source control
- GitHub Actions for CI/CD
- Jest and Supertest for automated testing
- SonarQube for code quality analysis
- Artifactory for artifact management
- Vault for secrets management

## Data Architecture

The data architecture employs a polyglot persistence approach, using different database technologies for different data needs:

1. **Transactional Data** - PostgreSQL for ACID-compliant operations
2. **Content Metadata** - PostgreSQL with JSONB for flexibility
3. **Digital Assets** - Object storage with metadata in PostgreSQL
4. **Rights Data** - Neo4j graph database for relationship modeling
5. **Analytics Data** - Data warehouse with star schema
6. **Search Indexes** - Elasticsearch
7. **Caching Layer** - Redis
8. **Message Queues** - RabbitMQ
9. **Event Store** - Event sourcing database for auditing

Data consistency is maintained through a combination of:
- Transactional boundaries within services
- Eventual consistency across services
- Event-driven architecture for state propagation
- Distributed transactions where necessary
- Idempotent operations and retry mechanisms

## Security Architecture

The security architecture implements defense-in-depth with multiple security layers:

1. **Network Security:**
   - VPC isolation
   - Network segmentation
   - WAF (Web Application Firewall)
   - DDoS protection
   - IP whitelisting for admin functions

2. **Identity and Access:**
   - Multi-factor authentication
   - Role-based access control
   - Principle of least privilege
   - Regular access reviews
   - Token-based authentication
   - IP-based access restrictions

3. **Data Security:**
   - Encryption at rest (AES-256)
   - Encryption in transit (TLS 1.3)
   - Field-level encryption for sensitive data
   - Data masking for non-privileged access
   - Key rotation
   - Secure key management

4. **Application Security:**
   - Input validation
   - Output encoding
   - CSRF protection
   - XSS prevention
   - SQL injection prevention
   - Regular vulnerability scanning
   - Third-party dependency scanning

5. **Operational Security:**
   - Security logging and monitoring
   - Intrusion detection
   - Regular penetration testing
   - Security incident response
   - Compliance monitoring

6. **Advanced Security:**
   - Quantum-resistant cryptography
   - Blockchain-based audit trail
   - Secure multi-party computation
   - Homomorphic encryption for sensitive analytics

## Integration Architecture

The integration architecture supports multiple integration patterns:

1. **REST APIs:**
   - OpenAPI 3.0 specification
   - Versioned endpoints
   - Rate limiting
   - OAuth 2.0 authentication
   - HATEOAS for discoverability

2. **GraphQL API:**
   - Self-documenting schema
   - Efficient data fetching
   - Real-time subscriptions
   - Batched operations

3. **Webhooks:**
   - Event-based notifications
   - Configurable delivery
   - Signature verification
   - Delivery confirmation
   - Retry mechanisms

4. **Bulk Data Exchange:**
   - SFTP support
   - S3-compatible interfaces
   - Scheduled data exports
   - Delta synchronization
   - Data validation

5. **Streaming Data:**
   - Kafka streams
   - WebSocket APIs
   - Server-sent events

6. **Partner Integrations:**
   - DSP-specific adapters
   - Industry standard formats (DDEX)
   - Custom B2B integrations

## Deployment Architecture

The deployment architecture is based on Kubernetes, with the following components:

1. **Kubernetes Clusters:**
   - Production, staging, and development environments
   - Multi-region deployment for high availability
   - Node auto-scaling based on load
   - Pod disruption budgets for availability

2. **Service Mesh:**
   - Istio for service-to-service communication
   - Traffic management
   - Security policy enforcement
   - Observability data collection

3. **CI/CD Pipeline:**
   - Infrastructure-as-code with Terraform
   - GitOps workflow with ArgoCD
   - Automated testing
   - Blue/green deployments
   - Canary releases

4. **Monitoring and Observability:**
   - Distributed tracing with Jaeger
   - Metrics collection with Prometheus
   - Logging with ELK stack
   - Alerting with AlertManager
   - Dashboards with Grafana

5. **Backup and Disaster Recovery:**
   - Regular database backups
   - Cross-region replication
   - Recovery point objectives (RPO) of 15 minutes
   - Recovery time objectives (RTO) of 1 hour

## Performance Considerations

The architecture addresses performance through several strategies:

1. **Caching:**
   - Multi-level caching (application, database, CDN)
   - Cache invalidation strategies
   - Distributed caching with Redis

2. **Database Optimization:**
   - Query optimization
   - Appropriate indexing
   - Read replicas for heavy read operations
   - Connection pooling
   - Query result caching

3. **Application Performance:**
   - Code profiling and optimization
   - Asynchronous processing for non-critical operations
   - Resource pooling
   - Efficient algorithms for computationally intensive tasks
   - Lazy loading of resources

4. **Network Optimization:**
   - CDN for static assets
   - Response compression
   - HTTP/2 and HTTP/3 support
   - Connection keep-alive
   - Minimized payload sizes

5. **Load Testing:**
   - Regular performance benchmarking
   - Stress testing
   - Load modeling based on usage patterns
   - Performance degradation analysis

## Scalability Strategy

The architecture is designed for horizontal and vertical scalability:

1. **Horizontal Scaling:**
   - Stateless microservices
   - Container orchestration with Kubernetes
   - Auto-scaling based on metrics
   - Load balancing
   - Service discovery

2. **Database Scaling:**
   - Sharding for high-volume data
   - Read replicas for read-heavy workloads
   - Connection pooling
   - Query optimization
   - NoSQL databases for specific use cases

3. **Content Delivery Scaling:**
   - Distributed CDN
   - Edge caching
   - Optimized delivery paths
   - Tiered storage strategy

4. **Processing Scaling:**
   - Parallel processing for batch operations
   - Distributed computation for analytics
   - Queue-based workload distribution
   - Resource isolation for critical services

## Disaster Recovery

The disaster recovery strategy includes:

1. **Data Backup:**
   - Regular automated backups
   - Point-in-time recovery
   - Cross-region backup storage
   - Regular backup testing

2. **High Availability:**
   - Multi-zone deployment
   - Redundant infrastructure
   - Automatic failover
   - Load balancing across regions

3. **Recovery Procedures:**
   - Documented recovery processes
   - Regular disaster recovery drills
   - Automated recovery scripts
   - Priority-based service restoration

4. **Business Continuity:**
   - Hot standby environment
   - Geographical redundancy
   - Alternative communication channels
   - Critical functionality identification

## Advanced Technology Integrations

### Blockchain Integration

The platform integrates blockchain technology for several use cases:

1. **Immutable Rights Records:**
   - Smart contracts for rights management
   - Transparent ownership tracking
   - Verifiable rights history
   - Blockchain-based rights transfer

2. **Royalty Distribution:**
   - Smart contracts for automatic royalty distribution
   - Transparent payment tracking
   - Reduced payment friction
   - Micro-payment support

3. **Content Authentication:**
   - Blockchain-based content fingerprinting
   - Proof of creation timestamps
   - Usage tracking
   - Anti-piracy measures

**Implementation Details:**
- Ethereum-based smart contracts
- Layer 2 scaling solutions for efficiency
- IPFS integration for content links
- Multi-signature wallets for security
- Hybrid on-chain/off-chain architecture for performance
- Cross-chain interoperability support

### AI and Machine Learning Components

The platform leverages AI and machine learning for:

1. **Content Recommendations:**
   - User behavior analysis
   - Collaborative filtering
   - Content-based recommendation
   - Contextual recommendations
   - A/B testing framework

2. **Metadata Enhancement:**
   - Automatic genre classification
   - Mood analysis
   - Similar content identification
   - Music characteristic extraction
   - Automated tagging

3. **Predictive Analytics:**
   - Trend prediction
   - Revenue forecasting
   - Audience growth modeling
   - Content performance prediction
   - Anomaly detection

4. **Content Analysis:**
   - Audio fingerprinting
   - Similarity detection
   - Quality assessment
   - Speech recognition
   - Lyric analysis

**Implementation Details:**
- TensorFlow and PyTorch for deep learning models
- H2O.ai for automated machine learning
   - Containerized ML model serving
   - Feature store for consistent feature engineering
   - Model versioning and A/B testing framework
   - Real-time inference API
   - Batch prediction pipelines

### Quantum-Resistant Security

The platform implements quantum-resistant security measures:

1. **Post-Quantum Cryptography:**
   - Lattice-based cryptography
   - Hash-based signature schemes
   - Code-based cryptography
   - Multivariate polynomial cryptography

2. **Hybrid Cryptographic Approach:**
   - Dual algorithm implementation
   - Graceful security transition
   - Algorithm agility
   - Crypto-agility framework

**Implementation Details:**
- NIST post-quantum cryptography standards implementation
- Hybrid certificates combining traditional and PQC algorithms
- Key encapsulation mechanisms (KEMs) for secure key exchange
- Post-quantum secure random number generation
- Crypto-agility framework for algorithm updates

### Neuro-Symbolic AI Knowledge Graph

The platform implements a neuro-symbolic AI approach for complex reasoning:

1. **Knowledge Graph:**
   - Music domain ontology
   - Entity relationship modeling
   - Semantic reasoning capabilities
   - Knowledge extraction from unstructured data
   - Temporal information representation

2. **Neuro-Symbolic Integration:**
   - Neural networks for pattern recognition
   - Symbolic reasoning for logic and rules
   - Explainable AI implementation
   - Human-in-the-loop learning
   - Uncertainty handling

**Implementation Details:**
- RDF/OWL-based knowledge representation
- SPARQL query capability
- Vector embeddings for semantic similarity
- Graph neural networks for representation learning
- Rule-based systems integrated with neural models
- Attention mechanisms for knowledge graph navigation

## Future Architecture Roadmap

The architecture roadmap includes the following initiatives:

1. **Near-term (6-12 months):**
   - Complete migration to Kubernetes
   - Enhance observability with distributed tracing
   - Implement chaos engineering practices
   - Expand GraphQL API coverage
   - Deploy advanced caching strategies

2. **Mid-term (12-24 months):**
   - Implement service mesh across all environments
   - Enhance event-driven architecture
   - Expand edge computing capabilities
   - Implement artificial intelligence operations (AIOps)
   - Deploy quantum-resistant cryptography

3. **Long-term (24-36 months):**
   - Implementation of Federated Learning for privacy-preserving AI
   - Advanced neuro-symbolic AI integration
   - Full post-quantum cryptography transition
   - Blockchain-based rights and royalty management
   - Decentralized content distribution mechanisms

---

## References

- [System Architecture Diagrams](../diagrams/)
- [API Documentation](../developer/api-reference.md)
- [Security Policies](../user/security-guide.md)
- [Data Model Documentation](../technical/data-model.md)
- [Workflow Diagrams](../diagrams/ascii_workflows_consolidated.txt)

---

© 2023-2025 TuneMantra. All rights reserved.# TuneMantra System Architecture

*Version: 1.0.0 (March 27, 2025)*

## Table of Contents

- [Introduction](#introduction)
- [Architectural Overview](#architectural-overview)
- [System Components](#system-components)
- [Data Architecture](#data-architecture)
- [Integration Architecture](#integration-architecture)
- [Security Architecture](#security-architecture)
- [Deployment Architecture](#deployment-architecture)
- [Performance Architecture](#performance-architecture)
- [Scalability and Resilience](#scalability-and-resilience)
- [Development Environment](#development-environment)
- [Future Architecture](#future-architecture)
- [Architecture Decision Records](#architecture-decision-records)

## Introduction

The TuneMantra platform is designed as a comprehensive multi-tenant music distribution system, enabling content providers to manage, distribute, and monetize their music across global digital platforms. This document provides a detailed overview of the system's architecture, including its components, interactions, and design principles.

### Purpose

This architecture document serves as a reference for understanding the system's structure and behavior. It provides:

1. High-level and detailed views of the system's components
2. Descriptions of data flows and integration points
3. Explanations of architectural decisions and their rationales
4. Guidelines for system extensions and modifications
5. A foundation for system evaluation and improvement

### Design Principles

The architecture is guided by these core principles:

1. **Security by Design**: Security considerations are incorporated from the beginning of the design process, not added later.
2. **Scalability**: The system can scale horizontally to handle increasing load and data volume.
3. **Modularity**: Components are designed with clear responsibilities and interfaces, enabling independent evolution.
4. **Multi-tenancy**: The platform supports multiple organizations with strict data isolation.
5. **Global Availability**: The system is designed for global distribution and accessibility.
6. **Extensibility**: The architecture facilitates the addition of new features and integrations.
7. **Observability**: System behavior and performance can be monitored and analyzed.

### Architectural Requirements

The architecture addresses these key requirements:

1. **Functional Requirements**:
   - Support for complete music asset management
   - Distribution to 150+ digital service providers
   - Rights and ownership management
   - Royalty calculation and payment processing
   - Comprehensive analytics and reporting

2. **Non-Functional Requirements**:
   - Performance: Response time under 500ms for 95% of requests
   - Scalability: Support for millions of tracks and thousands of users
   - Availability: 99.9% uptime (less than 9 hours of downtime annually)
   - Security: Protection of sensitive financial and content data
   - Compliance: Adherence to industry standards and regulations

## Architectural Overview

### System Context

The TuneMantra platform operates within an ecosystem of users, content providers, distribution partners, and financial services.

#### External Entities

- **Content Providers**: Artists, labels, and distributors who supply music content
- **Digital Service Providers (DSPs)**: Streaming platforms, download stores, and other distribution targets
- **Financial Services**: Payment processors, banking systems, and tax authorities
- **End Users**: Administrators, label managers, artists, and financial personnel who interact with the system

#### Context Diagram

The context diagram illustrates the system's boundaries and its interactions with external entities:

```
┌───────────────────────────────────────────────────────────────────┐
│                                                                   │
│  ┌────────────┐        ┌─────────────┐       ┌───────────────┐   │
│  │            │        │             │       │               │   │
│  │  Content   │◄──────►│  TuneMantra │◄─────►│  Digital      │   │
│  │  Providers │        │  Platform   │       │  Service      │   │
│  │            │        │             │       │  Providers    │   │
│  └────────────┘        └─────┬───────┘       └───────────────┘   │
│                              │                                    │
│                              │                                    │
│                              ▼                                    │
│                       ┌─────────────┐                             │
│                       │             │                             │
│                       │  Financial  │                             │
│                       │  Services   │                             │
│                       │             │                             │
│                       └─────────────┘                             │
│                                                                   │
└───────────────────────────────────────────────────────────────────┘
```

### High-Level Architecture

TuneMantra is built as a layered, microservices-based architecture with the following major layers:

1. **Presentation Layer**: Web interfaces, mobile applications, and API clients
2. **API Gateway Layer**: The entry point for all client requests, handling authentication, routing, and rate limiting
3. **Service Layer**: Core business services implemented as microservices
4. **Data Layer**: Databases, caches, and storage systems

#### Architecture Diagram

The high-level architecture diagram shows the major system components:

```
┌───────────────────────────────────────────────────────────────────────┐
│                      PRESENTATION LAYER                                │
│                                                                       │
│  ┌─────────────┐  ┌─────────────┐  ┌────────────┐  ┌──────────────┐   │
│  │  Web App    │  │  Mobile App │  │  Partner   │  │  Admin       │   │
│  │             │  │             │  │  API       │  │  Portal      │   │
│  └──────┬──────┘  └──────┬──────┘  └─────┬──────┘  └──────┬───────┘   │
│         │                │                │                │           │
└─────────┼────────────────┼────────────────┼────────────────┼───────────┘
          │                │                │                │            
┌─────────┼────────────────┼────────────────┼────────────────┼───────────┐
│         ▼                ▼                ▼                ▼           │
│                                                                       │
│  ┌─────────────────────────────────────────────────────────────────┐  │
│  │                         API GATEWAY                             │  │
│  │                                                                 │  │
│  │  ┌─────────────┐  ┌─────────────┐  ┌────────────┐  ┌─────────┐  │  │
│  │  │ Auth &      │  │ Request     │  │ Rate       │  │ Routing │  │  │
│  │  │ Authorization│  │ Validation  │  │ Limiting   │  │         │  │  │
│  │  └─────────────┘  └─────────────┘  └────────────┘  └─────────┘  │  │
│  └──────────────────────────────┬──────────────────────────────────┘  │
│                                 │                                     │
└─────────────────────────────────┼─────────────────────────────────────┘
                                  │                                      
┌─────────────────────────────────┼─────────────────────────────────────┐
│                                 ▼                                     │
│                          SERVICE LAYER                                │
│                                                                       │
│  ┌────────────┐  ┌──────────┐  ┌─────────────┐  ┌────────────────┐   │
│  │  User &    │  │ Catalog  │  │ Distribution│  │ Rights &       │   │
│  │  Org Mgmt  │  │ Services │  │ Services    │  │ Royalty Mgmt   │   │
│  └────────────┘  └──────────┘  └─────────────┘  └────────────────┘   │
│                                                                       │
│  ┌────────────┐  ┌──────────┐  ┌─────────────┐  ┌────────────────┐   │
│  │  Payment   │  │ Analytics│  │ Notification│  │ Background     │   │
│  │  Services  │  │ Services │  │ Services    │  │ Processing     │   │
│  └────────────┘  └──────────┘  └─────────────┘  └────────────────┘   │
│                                                                       │
└──────────────────────────────────┬────────────────────────────────────┘
                                   │                                     
┌──────────────────────────────────┼────────────────────────────────────┐
│                                  ▼                                    │
│                           DATA LAYER                                  │
│                                                                       │
│  ┌────────────┐  ┌────────────┐  ┌────────────┐  ┌────────────────┐  │
│  │  Postgres  │  │ Redis      │  │ S3         │  │ Elasticsearch   │  │
│  │  Database  │  │ Cache      │  │ Storage    │  │                 │  │
│  └────────────┘  └────────────┘  └────────────┘  └────────────────┘  │
│                                                                       │
└───────────────────────────────────────────────────────────────────────┘
```

### Architectural Patterns

TuneMantra utilizes several architectural patterns:

1. **Microservices Architecture**: The system is composed of independent, loosely coupled services, each responsible for specific business functionality.

2. **API Gateway Pattern**: All client requests flow through a central gateway that handles cross-cutting concerns like authentication, routing, and rate limiting.

3. **Event-Driven Architecture**: Services communicate through events for asynchronous operations, improving decoupling and scalability.

4. **CQRS (Command Query Responsibility Segregation)**: For certain services, the system separates read and write operations to optimize performance.

5. **Repository Pattern**: Data access is abstracted behind repositories, providing a consistent interface to different data stores.

6. **Circuit Breaker Pattern**: The system includes mechanisms to handle failures in distributed service calls gracefully.

7. **Bulkhead Pattern**: Resources are isolated to prevent cascading failures across the system.

## System Components

### Presentation Layer

The presentation layer provides the user interfaces for different types of users.

#### Web Application

The primary user interface is a single-page application (SPA) built with React.

**Key Features**:
- Responsive design for desktop and tablet
- Role-based user interfaces
- Real-time data updates
- Offline capabilities for certain functions

**Technologies**:
- React
- TypeScript
- React Query for data fetching
- TailwindCSS with shadcn/ui for styling
- Vite for building and bundling

#### Mobile Application

A companion mobile application for iOS and Android.

**Key Features**:
- Limited subset of web functionality focused on monitoring and approvals
- Push notifications for important events
- Offline access to recent data

**Technologies**:
- React Native
- TypeScript
- Realm for offline storage
- Firebase for push notifications

#### Partner API Clients

SDKs and libraries for integration with partner systems.

**Key Features**:
- Authentication handling
- Request and response mapping
- Error handling
- Rate limiting awareness

**Technologies**:
- TypeScript (JavaScript SDK)
- Python
- PHP
- Java
- C#

#### Admin Portal

A specialized interface for system administrators.

**Key Features**:
- System configuration
- User and organization management
- Monitoring and analytics
- Support tools

**Technologies**:
- Same stack as the main web application
- Additional administrative components

### API Gateway Layer

The API gateway serves as the entry point for all client requests.

#### Authentication Service

Handles user authentication and token issuance.

**Key Features**:
- Username/password authentication
- OAuth 2.0 support
- Multi-factor authentication
- Token issuance and validation
- Session management

**Technologies**:
- Node.js
- Express
- JSON Web Tokens (JWT)
- Redis for token storage
- bcrypt for password hashing

#### Request Validation

Validates incoming requests before they reach the services.

**Key Features**:
- Schema validation
- Parameter sanitization
- Content type validation
- Request size limiting

**Technologies**:
- Zod for schema validation
- Express middleware
- Custom validation rules

#### Rate Limiting

Controls the number of requests clients can make.

**Key Features**:
- IP-based rate limiting
- Token-based rate limiting
- Quota management
- Throttling configuration

**Technologies**:
- Redis for rate counter storage
- Token bucket algorithm implementation
- Custom rate limiting middleware

#### Routing and Load Balancing

Directs requests to appropriate services.

**Key Features**:
- Service discovery
- Request routing
- Load balancing
- Circuit breaking

**Technologies**:
- Express routing
- Service discovery integration
- Load balancer integration

### Service Layer

The service layer contains the core business logic of the system.

#### User and Organization Management

Manages user accounts, organizations, and access control.

**Key Features**:
- User registration and profile management
- Organization creation and management
- Role-based access control
- Organization hierarchy management

**Technologies**:
- Node.js with Express
- Drizzle ORM
- PostgreSQL for data storage
- Redis for caching

#### Catalog Services

Manages music content and metadata.

**Key Features**:
- Content ingestion and validation
- Metadata management
- Asset storage and retrieval
- Content versioning

**Technologies**:
- Node.js with Express
- Drizzle ORM
- PostgreSQL for metadata
- S3 for asset storage
- Elasticsearch for search

#### Distribution Services

Handles content delivery to digital service providers.

**Key Features**:
- Platform-specific formatting
- Delivery scheduling
- Status tracking
- Takedown management

**Technologies**:
- Node.js with Express
- Drizzle ORM
- PostgreSQL for data storage
- Queue systems for delivery management
- Platform-specific adapters

#### Rights and Royalty Management

Manages content ownership, revenue allocation, and royalty calculations.

**Key Features**:
- Rights ownership management
- Revenue ingestion and processing
- Royalty calculation
- Split management
- Statement generation

**Technologies**:
- Node.js with Express
- Drizzle ORM
- PostgreSQL for data storage
- Redis for calculation caching
- Background processing for calculations

#### Payment Services

Handles payment processing and financial transactions.

**Key Features**:
- Payment method management
- Payment batch processing
- Transaction recording
- Currency conversion
- Tax handling

**Technologies**:
- Node.js with Express
- Drizzle ORM
- PostgreSQL for data storage
- Payment gateway integrations
- Encryption for sensitive data

#### Analytics Services

Provides data analysis and reporting capabilities.

**Key Features**:
- Data collection and processing
- Report generation
- Dashboard data
- Custom metrics
- Data export

**Technologies**:
- Node.js with Express
- Drizzle ORM
- PostgreSQL for relational data
- Elasticsearch for analytics storage
- Redis for caching

#### Notification Services

Manages notifications and communication.

**Key Features**:
- Email notifications
- Push notifications
- In-app notifications
- Notification preferences
- Delivery tracking

**Technologies**:
- Node.js with Express
- Email service integration
- Push notification services
- WebSockets for real-time notifications
- Template rendering

#### Background Processing

Handles long-running and scheduled tasks.

**Key Features**:
- Task scheduling
- Long-running calculations
- Batch processing
- Asynchronous operations
- Retry logic

**Technologies**:
- Node.js
- Bull for job queues
- Redis for queue storage
- Worker processes
- Monitoring and logging

### Data Layer

The data layer stores and provides access to the system's data.

#### PostgreSQL Database

The primary relational database for transactional data.

**Key Features**:
- Transactional data storage
- Complex relationships
- ACID compliance
- Data integrity enforcement

**Design Principles**:
- Normalized schema design
- Optimized indexing
- Partitioning for large tables
- Read replicas for scaling

#### Redis Cache

In-memory data structure store used for caching and temporary data.

**Key Features**:
- Session storage
- Cache for frequent queries
- Rate limiting counters
- Job queue storage
- Pub/sub for real-time features

**Usage Patterns**:
- Time-limited caching
- Invalidation strategies
- Memory optimization
- Cluster configuration

#### Object Storage (S3)

Storage for binary assets and large objects.

**Key Features**:
- Audio file storage
- Image storage
- Document storage
- Backup storage
- Large dataset storage

**Organization**:
- Bucket strategy
- Access control policies
- Lifecycle management
- Encryption configuration

#### Elasticsearch

Search and analytics engine.

**Key Features**:
- Full-text search
- Analytics data storage
- Aggregation and reporting
- Real-time search updates

**Index Design**:
- Optimized mappings
- Indexing strategies
- Analyzer configuration
- Shard management

## Data Architecture

### Data Model

The TuneMantra data model is organized around these core entities:

1. **Users and Organizations**: User accounts, organization records, and their relationships
2. **Content**: Music releases, tracks, and associated metadata
3. **Rights**: Ownership and rights information
4. **Distribution**: Platform delivery records and status
5. **Revenue**: Income records from various sources
6. **Royalties**: Calculated payments based on revenue and rights
7. **Payments**: Financial transaction records

#### Entity Relationship Diagram

The following diagram shows the high-level relationships between key entities:

```
┌────────────┐       ┌────────────┐       ┌────────────┐
│            │       │            │       │            │
│   Users    │◄──────┤  OrgUsers  ├───────►Organizations│
│            │       │            │       │            │
└────────────┘       └────────────┘       └─────┬──────┘
                                                │
                                                │
                                          ┌─────▼──────┐
                                          │            │
                                          │  Releases  │
                                          │            │
                                          └─────┬──────┘
                                                │
                     ┌────────────┐             │
                     │            │             │
                     │   Rights   │◄────────────┤
                     │            │             │
                     └──────┬─────┘             │
                            │                   │
                            │             ┌─────▼──────┐
                            │             │            │
                            │             │   Tracks   │
                            │             │            │
                            │             └─────┬──────┘
                     ┌──────▼─────┐             │
                     │            │             │
                     │  Splits    │             │
                     │            │             │
                     └──────┬─────┘             │
                            │                   │
              ┌─────────────┼───────────────────┘
              │             │                   
     ┌────────▼──────┐     ┌▼────────────┐      ┌────────────┐
     │               │     │              │      │            │
     │  Royalties    │◄────┤   Revenue    │◄─────┤Distribution │
     │               │     │              │      │            │
     └───────┬───────┘     └──────────────┘      └────────────┘
             │                                           
             │                                           
     ┌───────▼───────┐                                   
     │               │                                   
     │   Payments    │                                   
     │               │                                   
     └───────────────┘                                   
```

### Data Flow

Data flows through the system in several key patterns:

1. **Content Ingestion Flow**:
   - Content is uploaded through the web application
   - Metadata is validated and stored in PostgreSQL
   - Media files are processed and stored in S3
   - Search indexes are updated in Elasticsearch

2. **Distribution Flow**:
   - Approved content is scheduled for distribution
   - Platform-specific formatting is applied
   - Content is delivered to DSPs via APIs or file transfers
   - Status updates are recorded and tracked

3. **Revenue Processing Flow**:
   - Revenue data is imported from platforms
   - Data is validated and normalized
   - Revenue is allocated based on rights data
   - Royalties are calculated and stored

4. **Payment Processing Flow**:
   - Royalty payments are aggregated and batched
   - Payment transactions are created
   - Funds are transferred via payment providers
   - Transaction records are updated

### Data Storage Strategy

The system employs a multi-tiered storage strategy:

1. **Transactional Data**: PostgreSQL
   - User and organization data
   - Content metadata
   - Rights and ownership
   - Financial records

2. **Binary Assets**: S3-compatible object storage
   - Audio files
   - Image files
   - Document files
   - Backup data

3. **Cache and Temporary Data**: Redis
   - Session data
   - Frequent query results
   - Computational intermediates
   - Rate limiting counters

4. **Search and Analytics Data**: Elasticsearch
   - Searchable content metadata
   - Analytics aggregations
   - Reporting data
   - Historical trends

### Data Access Patterns

The system supports these primary data access patterns:

1. **API-Based Access**: All client interactions use the REST API or GraphQL
2. **Service-to-Service Communication**: Internal services communicate via API calls and message queues
3. **Batch Processing**: Background jobs process data in batches for efficiency
4. **Real-Time Updates**: WebSockets provide immediate updates for critical data changes
5. **Reporting and Analytics**: Specialized queries access denormalized data for analysis

## Integration Architecture

### External System Integration

TuneMantra integrates with various external systems:

1. **Digital Service Providers (150+)**:
   - Music streaming platforms
   - Download stores
   - Video platforms
   - Social media platforms

2. **Financial Services**:
   - Payment processors
   - Banking systems
   - Tax services
   - Currency exchange services

3. **Identity Providers**:
   - OAuth providers
   - SAML providers
   - Social login services

4. **Notification Services**:
   - Email service providers
   - Push notification services
   - SMS gateways

### Integration Patterns

The system employs these integration patterns:

1. **REST API Integration**:
   - Synchronous communication with external services
   - Standardized request/response formats
   - Error handling and retry logic

2. **Webhook Integration**:
   - Event-based notifications from the platform
   - Subscription-based delivery
   - Verification and security measures

3. **SFTP and File Transfer**:
   - Batch file delivery for certain DSPs
   - Scheduled file transfers
   - Format conversions

4. **Message Queue Integration**:
   - Asynchronous processing of integration events
   - Decoupling from external systems
   - Retry and failure handling

### API Management

The API strategy includes:

1. **API Versioning**:
   - Semantic versioning (major.minor.patch)
   - URL-based versioning (e.g., /v1/resources)
   - Backward compatibility requirements

2. **API Documentation**:
   - OpenAPI/Swagger specifications
   - Interactive documentation
   - Code samples and examples
   - SDK generation

3. **API Security**:
   - OAuth 2.0 authentication
   - Scoped permissions
   - Rate limiting
   - Request validation

4. **API Monitoring**:
   - Usage metrics
   - Error tracking
   - Performance monitoring
   - SLA compliance

### Event-Driven Architecture

The system utilizes events for loosely coupled integrations:

1. **Event Types**:
   - Content events (created, updated, delivered)
   - User events (registered, updated, deleted)
   - Financial events (revenue recorded, payment processed)
   - System events (configuration changed, error occurred)

2. **Event Distribution**:
   - Internal event bus for system components
   - Webhook delivery for external subscribers
   - Event persistence for auditability
   - Event replay capabilities

3. **Event Schema Management**:
   - Versioned event schemas
   - Compatibility requirements
   - Documentation and discovery
   - Validation enforcement

## Security Architecture

The security architecture is described in detail in the [Security Model](./security-model.md) document. Key aspects include:

### Authentication and Authorization

1. **User Authentication**:
   - Password-based authentication
   - Multi-factor authentication
   - Social authentication
   - Single sign-on (SSO)

2. **API Authentication**:
   - OAuth 2.0 with JWT
   - Client credentials flow
   - Authorization code flow
   - Token refresh mechanisms

3. **Authorization Model**:
   - Role-based access control (RBAC)
   - Attribute-based access control (ABAC)
   - Organization-level permissions
   - Resource-level permissions

### Data Protection

1. **Data Encryption**:
   - Transport encryption (TLS 1.3)
   - Storage encryption (AES-256)
   - Field-level encryption for sensitive data
   - Key management systems

2. **Privacy Controls**:
   - Personal data minimization
   - Consent management
   - Data retention policies
   - Anonymization capabilities

### Network Security

1. **Network Architecture**:
   - Defense in depth approach
   - Network segmentation
   - Security groups and ACLs
   - DDoS protection

2. **API Security**:
   - Rate limiting
   - Input validation
   - Output encoding
   - Security headers

### Monitoring and Compliance

1. **Security Monitoring**:
   - Intrusion detection
   - Anomaly detection
   - Log analysis
   - Vulnerability scanning

2. **Compliance Framework**:
   - SOC 2 compliance
   - GDPR compliance
   - CCPA compliance
   - Industry-specific regulations

## Deployment Architecture

### Environment Strategy

TuneMantra is deployed across multiple environments:

1. **Development**: For active development work
   - Isolated developer environments
   - Shared development services
   - Mocked external integrations

2. **Testing**: For automated testing
   - Integration test environment
   - Performance test environment
   - Security test environment

3. **Staging**: Production-like environment for verification
   - Mirrors production configuration
   - Limited production data
   - Final testing before production

4. **Production**: Live environment serving users
   - Multi-region deployment
   - High availability configuration
   - Full monitoring and alerting

### Infrastructure Architecture

The production infrastructure is designed for high availability and scalability:

1. **Cloud Provider**: AWS primary, with multi-cloud capability
   - EC2 for compute
   - RDS for PostgreSQL
   - ElastiCache for Redis
   - S3 for storage
   - Elasticsearch Service
   - CloudFront for CDN

2. **Regional Strategy**:
   - Primary region: US East
   - Secondary regions: EU West, Asia Pacific
   - Data replication between regions
   - Regional failover capability

3. **Network Architecture**:
   - VPC with public and private subnets
   - NAT gateways for private subnet egress
   - Load balancers for traffic distribution
   - VPN for administrative access

4. **Containerization**:
   - Docker for application packaging
   - ECS for container orchestration
   - ECR for container registry
   - Standardized container configuration

### Deployment Pipeline

The CI/CD pipeline automates deployment:

1. **Continuous Integration**:
   - Automated builds
   - Unit and integration testing
   - Code quality checks
   - Security scanning

2. **Continuous Delivery**:
   - Automated deployment to development
   - Manual approval for staging and production
   - Blue/green deployment strategy
   - Automated smoke testing

3. **Infrastructure as Code**:
   - Terraform for infrastructure provisioning
   - CloudFormation for AWS-specific resources
   - Version-controlled infrastructure
   - Environment templating

### Monitoring and Operations

Operational capabilities include:

1. **Monitoring Stack**:
   - Datadog for metrics and dashboards
   - ELK stack for log management
   - Sentry for error tracking
   - Custom health checks

2. **Alerting**:
   - PagerDuty for incident management
   - Slack integrations for notifications
   - Escalation policies
   - On-call rotations

3. **Backup and Recovery**:
   - Automated database backups
   - Point-in-time recovery capability
   - Cross-region backup replication
   - Regular recovery testing

## Performance Architecture

### Performance Requirements

The system is designed to meet these performance targets:

1. **Response Time**:
   - API requests: 95th percentile under 300ms
   - Web application: Page load under 2 seconds
   - Background jobs: Appropriate to the task

2. **Throughput**:
   - API: 1000+ requests per second
   - File processing: 100+ tracks per minute
   - Royalty calculations: Millions of calculations per hour

3. **Data Volume**:
   - Catalog: Millions of tracks
   - Rights: Millions of ownership records
   - Royalties: Billions of calculation records
   - Users: Thousands of concurrent users

### Performance Design Patterns

The architecture employs these performance patterns:

1. **Caching Strategy**:
   - Multi-level caching (application, API, database)
   - Cache invalidation policies
   - Cache warming for predictable data
   - Distributed caching with Redis

2. **Database Optimization**:
   - Query optimization and indexing
   - Read replicas for scaling reads
   - Connection pooling
   - Statement timeouts for runaway queries
   - Query plan analysis

3. **Asynchronous Processing**:
   - Background job processing
   - Task prioritization
   - Batch processing for efficiency
   - Work queues for load distribution

4. **Content Delivery**:
   - CDN for static assets
   - Asset optimization (compression, minification)
   - Browser caching directives
   - Image and media optimization

### Performance Testing

The performance testing strategy includes:

1. **Load Testing**:
   - Simulated user behavior
   - Gradual ramp-up patterns
   - Peak load simulation
   - Extended duration tests

2. **Stress Testing**:
   - Beyond-capacity testing
   - Resource exhaustion scenarios
   - Recovery testing
   - Failover testing

3. **Endurance Testing**:
   - Long-duration testing
   - Memory leak detection
   - Resource utilization monitoring
   - Performance degradation analysis

4. **Performance Monitoring**:
   - Real-time metrics collection
   - Performance baselines
   - Anomaly detection
   - Trend analysis

## Scalability and Resilience

### Scalability Approach

The system scales through these mechanisms:

1. **Horizontal Scaling**:
   - Stateless services for easy replication
   - Load-balanced service instances
   - Auto-scaling based on metrics
   - Geographic distribution

2. **Database Scaling**:
   - Read replicas for query scaling
   - Connection pooling
   - Sharding for extreme scale
   - Caching to reduce database load

3. **Storage Scaling**:
   - Object storage for unlimited asset growth
   - CDN for content distribution
   - Tiered storage for cost optimization
   - Archiving for cold data

4. **Processing Scaling**:
   - Distributed task processing
   - Work queue partitioning
   - Parallel processing for large tasks
   - Resource allocation control

### Resilience Design

The system is designed for resilience through:

1. **Fault Tolerance**:
   - No single points of failure
   - Service redundancy
   - Data replication
   - Geographic distribution

2. **Graceful Degradation**:
   - Feature prioritization
   - Fallback mechanisms
   - Partial functionality modes
   - User communication during issues

3. **Error Handling**:
   - Comprehensive error detection
   - Retry mechanisms with backoff
   - Circuit breakers for failing services
   - Fallback strategies for critical functions

4. **Disaster Recovery**:
   - Multi-region capability
   - Regular backup testing
   - Documented recovery procedures
   - Recovery time objectives (RTOs)
   - Recovery point objectives (RPOs)

### Resilience Testing

The resilience testing program includes:

1. **Chaos Engineering**:
   - Controlled failure injection
   - Service termination tests
   - Network disruption simulations
   - Resource constraint tests

2. **Failover Testing**:
   - Database failover drills
   - Region evacuation exercises
   - Service recovery validation
   - Data consistency verification

3. **Load Shedding Testing**:
   - Graceful degradation verification
   - Priority function preservation
   - Recovery from overload conditions
   - User experience during constraints

## Development Environment

### Local Development

Developers work with:

1. **Development Tooling**:
   - Visual Studio Code with standardized extensions
   - Docker for local service containers
   - Node.js and npm for build tools
   - Git for version control

2. **Local Environment**:
   - Docker Compose for service dependencies
   - Local environment variables
   - Mocked external services
   - Hot reloading for rapid iteration

3. **Testing Tools**:
   - Jest for unit testing
   - Cypress for end-to-end testing
   - ESLint and Prettier for code quality
   - TypeScript for type checking

### Continuous Integration

The CI system provides:

1. **Build Automation**:
   - Automated builds on commit
   - Dependency security scanning
   - Code quality checks
   - Test execution

2. **Pull Request Validation**:
   - Pre-merge checks
   - Code review assistance
   - Test coverage reporting
   - Performance impact estimation

3. **Release Management**:
   - Version tagging
   - Release notes generation
   - Artifact publishing
   - Deployment triggering

### Development Practices

The team follows these practices:

1. **Version Control**:
   - Feature branching
   - Pull request workflow
   - Conventional commits
   - Semantic versioning

2. **Testing Strategy**:
   - Test-driven development (TDD)
   - Automated testing
   - Integration testing
   - End-to-end testing

3. **Code Quality**:
   - Code reviews
   - Static analysis
   - Pair programming
   - Documentation standards

## Future Architecture

The architectural roadmap includes:

### Near-Term Evolution (6-12 months)

1. **GraphQL API Expansion**:
   - Complete GraphQL coverage for all resources
   - Subscription support for real-time updates
   - Improved client-side performance
   - Reduced over-fetching and under-fetching

2. **Enhanced Analytics**:
   - Real-time analytics processing
   - Machine learning integration
   - Predictive analytics capabilities
   - Improved visualization options

3. **Multi-Region Expansion**:
   - Full multi-region deployment
   - Geographic routing optimization
   - Data sovereignty compliance
   - Region-specific optimizations

### Medium-Term Evolution (1-2 years)

1. **Serverless Adoption**:
   - Serverless functions for appropriate workloads
   - Event-driven processing expansion
   - Improved cost efficiency
   - Automatic scaling

2. **AI Integration**:
   - Content analysis capabilities
   - Recommendation engines
   - Fraud detection
   - Automated metadata enhancement

3. **Enhanced Mobile Capabilities**:
   - Offline-first mobile experience
   - Native app performance improvements
   - Mobile-specific features
   - Cross-device synchronization

### Long-Term Vision (2+ years)

1. **Blockchain Integration**:
   - Rights verification on blockchain
   - Smart contracts for royalty agreements
   - Transparent payment tracking
   - Immutable audit trails

2. **Global Edge Computing**:
   - Edge processing for low-latency operations
   - Global content delivery optimization
   - Region-specific compliance handling
   - Network optimization

3. **Quantum-Safe Security**:
   - Post-quantum cryptography adoption
   - Quantum-resistant algorithms
   - Long-term security planning
   - Secure transition strategy

## Architecture Decision Records

Key architectural decisions and their rationales are documented below.

### ADR-001: Adoption of Microservices Architecture

**Context**: The initial architecture needed to balance rapid development with future scalability.

**Decision**: Adopt a modular microservices architecture, organizing services around business capabilities.

**Rationale**:
- Enables independent scaling of components
- Supports independent development and deployment
- Allows technology diversity where appropriate
- Facilitates team ownership of specific domains

**Consequences**:
- Increased operational complexity
- Need for service discovery and orchestration
- Inter-service communication overhead
- Distributed transaction challenges

### ADR-002: PostgreSQL as Primary Data Store

**Context**: Selection of a primary database technology for transactional data.

**Decision**: Use PostgreSQL as the primary relational database.

**Rationale**:
- Strong ACID compliance
- Robust JSON support for semi-structured data
- Rich feature set including advanced indexing
- Strong community and commercial support
- Excellent migration and scaling options

**Consequences**:
- Need for careful schema design
- Connection management complexity
- Potential scaling challenges for extreme write loads
- Need for additional technologies for certain use cases

### ADR-003: React for Frontend Development

**Context**: Selection of a frontend technology for the web application.

**Decision**: Use React with TypeScript for frontend development.

**Rationale**:
- Component-based architecture for reusability
- Strong typing with TypeScript for safety
- Rich ecosystem and community support
- Virtual DOM for performance optimization
- Support for server-side rendering

**Consequences**:
- Learning curve for developers
- Build system complexity
- Need for careful state management
- Browser compatibility considerations

### ADR-004: Event-Driven Architecture for Key Workflows

**Context**: Design of inter-service communication patterns.

**Decision**: Implement event-driven architecture for asynchronous operations.

**Rationale**:
- Decoupling of services
- Improved scalability for processing-intensive operations
- Natural fit for real-time features
- Support for replay and audit capabilities

**Consequences**:
- Event schema management complexity
- Eventual consistency challenges
- Debugging and monitoring complexity
- Need for robust error handling

### ADR-005: Multi-Region Deployment Strategy

**Context**: Geographic distribution strategy for global users.

**Decision**: Implement multi-region deployment with data replication.

**Rationale**:
- Improved global performance
- Disaster recovery capabilities
- Data sovereignty compliance
- High availability

**Consequences**:
- Increased operational complexity
- Data synchronization challenges
- Cost implications
- Complexity in deployment pipelines

---

© 2023-2025 TuneMantra. All rights reserved.

---

## documentation/technical/audio/audio-fingerprinting.md

# Audio Fingerprinting Technical Documentation

## Overview

The audio fingerprinting system in TuneMantra uses acoustic fingerprinting technology to analyze and identify audio content. This system helps protect intellectual property rights, detect copyright infringement, and ensure content originality during the upload process.

## Architecture

The audio fingerprinting feature consists of several components:

1. **Client-Side Components**:
   - `AudioFingerprintValidator`: React component for upload validation
   - Audio processing and submission utilities

2. **Server-Side Components**:
   - ACR Cloud service integration
   - Fingerprinting API endpoints
   - Result processing and analysis

3. **External Services**:
   - ACR Cloud API (primary fingerprinting service)

## Technical Implementation

### Server-Side Implementation

#### ACR Cloud Service Integration

The platform integrates with ACR Cloud through the `acr-cloud-service.ts` module, which provides:

```typescript
// Core identification function
async function identifyAudio(audioBuffer: Buffer): Promise<IdentificationResult> {
  // Generate signature from audio
  const signature = acrCloud.createSignature({
    method: 'POST',
    uri: '/v1/identify',
    accessKey: process.env.ACR_CLOUD_ACCESS_KEY,
    secretKey: process.env.ACR_CLOUD_SECRET_KEY,
    dataType: 'audio',
    signatureVersion: '1'
  });

  // Send audio data to ACR Cloud for identification
  const response = await fetch('https://identify-eu-west-1.acrcloud.com/v1/identify', {
    method: 'POST',
    headers: {
      'Content-Type': 'multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW',
      'Accept': 'application/json',
      'Authorization': signature
    },
    body: createIdentifyFormData(audioBuffer)
  });

  // Process and return results
  const result = await response.json();
  return processIdentificationResult(result);
}

// Process and categorize results
function processIdentificationResult(result: any): IdentificationResult {
  const processed: IdentificationResult = {
    status: { code: result.status.code, message: result.status.msg },
    matches: [],
    metadata: {
      timestamp: new Date().toISOString(),
      processingTimeMs: result.cost_time || 0
    }
  };

  // Extract and process matched tracks
  if (result.metadata && result.metadata.music) {
    processed.matches = result.metadata.music.map(match => ({
      id: match.acrid,
      title: match.title,
      artist: match.artists.map(a => a.name).join(', '),
      album: match.album?.name || '',
      releaseDate: match.release_date || '',
      score: match.score,
      confidenceScore: calculateConfidenceScore(match),
      durationMs: match.duration_ms || 0,
      matchTimeMs: match.play_offset_ms,
      externalIds: extractExternalIds(match)
    }));
  }

  return processed;
}
```

#### API Endpoints

The platform exposes the following endpoints for fingerprinting operations:

1. **Identification Endpoint**:
   
```typescript
// POST /api/fingerprint/identify
router.post('/identify', upload.single('audio'), async (req, res) => {
  try {
    // Validate request
    if (!req.file) {
      return res.status(400).json({ 
        error: 'Missing audio file' 
      });
    }
    
    // Process audio file
    const result = await acrCloudService.identifyAudio(req.file.buffer);
    
    // Return identification results
    return res.json(result);
  } catch (error) {
    logger.error('Error in audio identification:', error);
    return res.status(500).json({ 
      error: 'Failed to process audio identification request' 
    });
  }
});
```

2. **Copyright Check Endpoint**:

```typescript
// POST /api/fingerprint/copyright-check
router.post('/copyright-check', upload.single('audio'), async (req, res) => {
  try {
    // Validate request
    if (!req.file) {
      return res.status(400).json({ 
        error: 'Missing audio file' 
      });
    }
    
    // Get metadata from request body
    const { title, artist } = req.body;
    
    // Process audio for copyright check
    const result = await acrCloudService.checkCopyright(
      req.file.buffer,
      { title, artist }
    );
    
    // Return copyright check results
    return res.json(result);
  } catch (error) {
    logger.error('Error in copyright check:', error);
    return res.status(500).json({ 
      error: 'Failed to process copyright check request' 
    });
  }
});
```

3. **Metadata Validation Endpoint**:

```typescript
// POST /api/fingerprint/validate-metadata
router.post('/validate-metadata', upload.single('audio'), async (req, res) => {
  try {
    // Validate request
    if (!req.file) {
      return res.status(400).json({ 
        error: 'Missing audio file' 
      });
    }
    
    // Get provided metadata
    const metadata = req.body;
    
    // Validate metadata against audio content
    const result = await acrCloudService.validateMetadata(
      req.file.buffer,
      metadata
    );
    
    // Return validation results
    return res.json(result);
  } catch (error) {
    logger.error('Error in metadata validation:', error);
    return res.status(500).json({ 
      error: 'Failed to process metadata validation request' 
    });
  }
});
```

### Client-Side Implementation

#### Audio Fingerprint Validator Component

The `AudioFingerprintValidator` component integrates with the upload form to validate audio files for copyright issues:

```tsx
// Client-side fingerprinting component
const AudioFingerprintValidator: React.FC<AudioFingerprintValidatorProps> = ({
  audioFile,
  metadata,
  onValidationComplete
}) => {
  const [isValidating, setIsValidating] = useState(false);
  const [results, setResults] = useState<ValidationResults | null>(null);
  const [error, setError] = useState<string | null>(null);

  // Function to start validation process
  const startValidation = async () => {
    if (!audioFile) {
      setError('No audio file provided');
      return;
    }

    setIsValidating(true);
    setError(null);

    try {
      // Create form data with audio file and metadata
      const formData = new FormData();
      formData.append('audio', audioFile);
      
      if (metadata.title) formData.append('title', metadata.title);
      if (metadata.artist) formData.append('artist', metadata.artist);

      // Send to server for processing
      const response = await fetch('/api/fingerprint/copyright-check', {
        method: 'POST',
        body: formData
      });

      if (!response.ok) {
        throw new Error(`Server returned ${response.status}`);
      }

      // Process results
      const validationResults = await response.json();
      setResults(validationResults);
      
      // Notify parent component
      if (onValidationComplete) {
        onValidationComplete(validationResults);
      }
    } catch (err) {
      setError(err.message || 'Failed to validate audio');
    } finally {
      setIsValidating(false);
    }
  };

  // Render component UI
  return (
    <div className="audio-fingerprint-validator">
      <h3>Copyright Validation</h3>
      
      {!isValidating && !results && (
        <Button onClick={startValidation} disabled={!audioFile}>
          Start Fingerprinting Validation
        </Button>
      )}
      
      {isValidating && (
        <div className="validation-in-progress">
          <Spinner />
          <p>Analyzing audio fingerprint...</p>
        </div>
      )}
      
      {results && (
        <ValidationResultsDisplay results={results} />
      )}
      
      {error && (
        <div className="validation-error">
          <AlertTriangle className="icon" />
          <p>Error: {error}</p>
        </div>
      )}
    </div>
  );
};
```

#### Integration with Upload Flow

The audio fingerprinting component is integrated into the upload flow in the metadata tab:

```tsx
// Integration in upload form
function UploadForm() {
  // Form state
  const [activeTab, setActiveTab] = useState('files');
  const [uploadedFiles, setUploadedFiles] = useState<File[]>([]);
  const [metadata, setMetadata] = useState<TrackMetadata>({
    title: '',
    artist: '',
    // Other metadata fields
  });
  const [fingerprintResults, setFingerprintResults] = useState(null);

  // Handle fingerprinting validation completion
  const handleValidationComplete = (results) => {
    setFingerprintResults(results);
    
    // Automatically update metadata if high confidence matches found
    if (results.matches && results.matches.length > 0) {
      const bestMatch = results.matches[0];
      if (bestMatch.confidenceScore > 90) {
        // Alert user about high-confidence match
        showConfirmationDialog({
          title: 'Potential Copyright Match',
          message: `We've detected a high-confidence match with "${bestMatch.title}" by ${bestMatch.artist}. Please ensure you have the rights to use this content.`,
          confirmLabel: 'Acknowledge',
          onConfirm: () => {}
        });
      }
    }
  };

  // Render form
  return (
    <div className="upload-form">
      <Tabs value={activeTab} onValueChange={setActiveTab}>
        <TabsList>
          <TabsTrigger value="files">Files</TabsTrigger>
          <TabsTrigger value="metadata">Metadata</TabsTrigger>
          <TabsTrigger value="rights">Rights</TabsTrigger>
          <TabsTrigger value="distribution">Distribution</TabsTrigger>
        </TabsList>
        
        <TabsContent value="files">
          {/* File upload UI */}
        </TabsContent>
        
        <TabsContent value="metadata">
          {/* Metadata form */}
          <div className="metadata-form">
            {/* Metadata fields */}
          </div>
          
          {/* Fingerprinting component */}
          {uploadedFiles.length > 0 && (
            <Card>
              <CardHeader>
                <CardTitle>Content Validation</CardTitle>
                <CardDescription>
                  Verify your content for copyright and quality issues
                </CardDescription>
              </CardHeader>
              <CardContent>
                <AudioFingerprintValidator 
                  audioFile={uploadedFiles[0]}
                  metadata={metadata}
                  onValidationComplete={handleValidationComplete}
                />
              </CardContent>
            </Card>
          )}
        </TabsContent>
        
        {/* Other tabs */}
      </Tabs>
    </div>
  );
}
```

## API Response Format

### Identification Response

```json
{
  "status": {
    "code": 0,
    "message": "Success"
  },
  "matches": [
    {
      "id": "acr_id_123456789",
      "title": "Song Title",
      "artist": "Artist Name",
      "album": "Album Name",
      "releaseDate": "2023-01-01",
      "score": 95,
      "confidenceScore": 92,
      "durationMs": 240000,
      "matchTimeMs": 15000,
      "externalIds": {
        "isrc": "ABC123456789",
        "upc": "123456789012"
      }
    }
  ],
  "metadata": {
    "timestamp": "2023-04-15T12:34:56Z",
    "processingTimeMs": 1250
  }
}
```

### Copyright Check Response

```json
{
  "status": {
    "code": 0,
    "message": "Success"
  },
  "copyrightIssues": {
    "hasIssues": true,
    "confidence": 95,
    "matches": [
      {
        "title": "Original Song",
        "artist": "Original Artist",
        "confidenceScore": 92,
        "matchType": "full_match",
        "potentialIssue": "This appears to be a copy of an existing track"
      }
    ]
  },
  "metadataIssues": {
    "hasIssues": true,
    "issues": [
      {
        "field": "title",
        "provided": "My Song",
        "detected": "Original Song",
        "confidence": 90,
        "issue": "Title does not match detected content"
      }
    ]
  },
  "sampleDetection": {
    "hasSamples": true,
    "samples": [
      {
        "title": "Sampled Track",
        "artist": "Sampled Artist",
        "confidence": 85,
        "startTimeMs": 45000,
        "durationMs": 3000
      }
    ]
  }
}
```

## Performance Considerations

1. **Optimization**:
   - Audio files are analyzed in chunks to improve processing speed
   - Background processing for large audio files
   - Results caching for previously analyzed content

2. **Rate Limiting**:
   - Service access is rate-limited to prevent overuse
   - Rate limits: 60 requests per minute, 1000 requests per day

3. **Error Handling**:
   - Robust error handling for network issues
   - Graceful degradation when service is unavailable
   - Clear error messages for troubleshooting

## Security Considerations

1. **Data Privacy**:
   - Audio data is only stored temporarily during processing
   - No permanent storage of uploaded audio for fingerprinting
   - Results are stored with appropriate access controls

2. **API Security**:
   - ACR Cloud API keys are stored securely in environment variables
   - All API requests use HTTPS encryption
   - Server-side signature generation for secure API access

## Environment Configuration

The following environment variables must be configured:

```
ACR_CLOUD_ACCESS_KEY=your_access_key
ACR_CLOUD_SECRET_KEY=your_secret_key
ACR_CLOUD_HOST=identify-eu-west-1.acrcloud.com
ACR_CLOUD_ENDPOINT=/v1/identify
```

## Troubleshooting

Common issues and solutions:

1. **Connection Issues**:
   - Verify network connectivity
   - Check ACR Cloud service status
   - Ensure correct API endpoint configuration

2. **Authentication Errors**:
   - Verify ACR Cloud keys are correctly configured
   - Ensure API keys have appropriate permissions

3. **Processing Errors**:
   - Validate audio file format (supported formats: MP3, WAV, AAC)
   - Check file size (maximum: 50MB)
   - Ensure minimum audio duration (10 seconds)

---

## documentation/technical/backend.md

# Backend Architecture Documentation

## Overview

TuneMantra's backend is built on a Node.js/Express foundation, providing a robust API layer for the React frontend and other clients. The architecture follows modern best practices with a focus on type safety, modular design, and scalability.

## Architecture Principles

The backend follows these core principles:

1. **Type Safety**: TypeScript throughout the codebase with strict typing
2. **Separation of Concerns**: Clear boundaries between layers
3. **Dependency Injection**: Loose coupling between components
4. **Schema-First Design**: Database and API schemas as the source of truth
5. **Comprehensive Testing**: Testable architecture with high coverage
6. **Secure by Default**: Security built into the architecture

## System Components

### Server Core

The server core (`server/index.ts`) sets up the Express application with:

- CORS configuration
- Security middleware (Helmet)
- JSON request parsing
- Cookie parsing
- Static file serving
- Session management
- Error handling

### API Routes

API routes (`server/routes.ts`) define the RESTful endpoints:

- Authentication endpoints
- User management
- Content management (tracks, releases)
- Distribution management
- Analytics endpoints
- Royalty management

Routes follow a consistent pattern:
- Clear path structure
- Proper HTTP method usage
- Input validation
- Authentication/authorization checks
- Consistent response format

### Authentication System

The authentication system (`server/auth.ts`) provides:

- Session-based authentication
- Password security (hashing with scrypt)
- Login/logout functionality
- User registration
- Authorization middleware
- API key authentication

### Storage Layer

The storage layer (`server/storage.ts`) abstracts database operations:

- Implementation of the `IStorage` interface
- CRUD operations for all entity types
- Transaction management
- Query optimization
- Connection pooling

### Services

Specialized service modules implement complex business logic:

- **Distribution Service**: Handles music distribution to platforms
- **Analytics Service**: Processes and aggregates analytics data
- **Royalty Calculation Service**: Implements royalty calculation logic
- **AI Tagging Service**: Provides AI-powered content analysis
- **Integration Service**: Manages integrations with external systems

### Database Connection

Database connectivity (`server/db.ts`) manages PostgreSQL connections:

- Connection pool configuration
- WebSocket support for Neon Serverless
- Environment-based configuration
- Drizzle ORM initialization

### Utilities

Shared utility modules provide reusable functionality:

- **Validation**: Request validation and sanitization
- **Error Handling**: Standardized error handling
- **ID Generation**: Secure ID generation and validation
- **Permissions**: Permission checking and role management
- **File Handling**: File upload and processing utilities

## Data Flow

### Request Lifecycle

1. **Request Arrival**: Client sends HTTP request to API endpoint
2. **Middleware Processing**:
   - Security headers applied
   - Session validation
   - CORS checks
   - Rate limiting
3. **Route Handling**:
   - Endpoint matched
   - Authentication/authorization checks
   - Input validation
4. **Business Logic**:
   - Service layer processes request
   - Storage layer executes database operations
5. **Response Generation**:
   - Standardized response format
   - Error handling if needed
   - Response sent to client

### Data Access Pattern

1. **API Layer**: Routes receive and validate requests
2. **Service Layer**: Implements business logic
3. **Storage Layer**: Executes database operations
4. **Database**: Stores and retrieves persistent data

## Code Organization

The backend code is organized into the following structure:

```
server/
├── config/          # Configuration files
├── lib/             # Shared libraries
├── middleware/      # Express middleware
├── routes/          # API routes
├── services/        # Business logic services
├── utils/           # Utility functions
├── auth.ts          # Authentication system
├── db.ts            # Database connection
├── index.ts         # Server entry point
├── routes.ts        # Route registration
├── storage.ts       # Data storage interface
├── types.ts         # TypeScript type definitions
└── vite.ts          # Development server configuration
```

## Key Interfaces

### IStorage Interface

The `IStorage` interface (`server/types.ts`) defines the contract for all data storage operations:

```typescript
export interface IStorage {
  sessionStore: session.Store;

  // User management methods
  getAllUsers(options?: {...}): Promise<User[]>;
  getUser(id: number): Promise<User | undefined>;
  // ... more user methods

  // Track management methods
  getTracksByUserId(userId: number): Promise<Track[]>;
  getTrackById(id: number): Promise<Track | undefined>;
  // ... more track methods

  // Release management methods
  getReleasesByUserId(userId: number): Promise<Release[]>;
  createRelease(userId: number, release: InsertRelease): Promise<Release>;
  // ... more release methods

  // Distribution methods
  getDistributionPlatforms(): Promise<DistributionPlatform[]>;
  createDistributionRecord(record: InsertDistributionRecord): Promise<DistributionRecord>;
  // ... more distribution methods

  // Analytics methods
  getTrackAnalytics(trackId: number): Promise<Analytics[]>;
  createAnalytics(analyticsData: InsertAnalytics): Promise<Analytics>;
  // ... more analytics methods

  // Royalty management methods
  getRoyaltyCalculations(userId: number): Promise<RoyaltyCalculation[]>;
  createRoyaltyCalculation(calculation: InsertRoyaltyCalculation): Promise<RoyaltyCalculation>;
  // ... more royalty methods
}
```

### Service Interfaces

Each service module implements a specific interface focused on its domain:

```typescript
// Example: Distribution Service Interface
interface IDistributionService {
  distributeRelease(releaseId: number, platformIds: number[]): Promise<DistributionRecord[]>;
  distributeToPlatform(releaseId: number, platformId: number): Promise<DistributionRecord>;
  processDistribution(distributionId: number): Promise<boolean>;
  getDistributionStatus(releaseId: number): Promise<DistributionStatus[]>;
  cancelDistribution(distributionId: number): Promise<boolean>;
  scheduleDistribution(releaseId: number, platformIds: number[], scheduleDate: Date): Promise<ScheduledDistribution>;
}
```

## Authentication Flow

### Session-Based Authentication

1. User submits login credentials
2. Server validates credentials
3. On success, creates session with user ID
4. Session ID stored in cookie
5. Subsequent requests include cookie for authentication

```typescript
// Login endpoint implementation
app.post('/api/auth/login', (req, res, next) => {
  passport.authenticate('local', (err, user, info) => {
    if (err) return next(err);
    if (!user) {
      return res.status(401).json({
        error: {
          message: info.message || 'Invalid credentials',
          code: 'INVALID_CREDENTIALS'
        }
      });
    }
    req.login(user, (err) => {
      if (err) return next(err);
      return res.json({ data: sanitizeUser(user), meta: {} });
    });
  })(req, res, next);
});
```

### API Key Authentication

1. Client includes API key in Authorization header
2. Server validates API key against database
3. Server checks key permissions against requested operation
4. On validation, request proceeds with associated user context

```typescript
// API key authentication middleware
const apiKeyAuth = async (req, res, next) => {
  const authHeader = req.headers.authorization;
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return res.status(401).json({
      error: {
        message: 'API key required',
        code: 'AUTH_REQUIRED'
      }
    });
  }

  const apiKey = authHeader.split(' ')[1];
  try {
    const keyData = await storage.getApiKeyByValue(apiKey);
    if (!keyData || !keyData.isActive) {
      return res.status(401).json({
        error: {
          message: 'Invalid API key',
          code: 'INVALID_API_KEY'
        }
      });
    }

    // Check if key has required scope
    if (req.requiredScope && !keyData.scopes.includes(req.requiredScope)) {
      return res.status(403).json({
        error: {
          message: 'Insufficient permissions',
          code: 'INSUFFICIENT_SCOPE'
        }
      });
    }

    // Set user context
    req.userId = keyData.userId;
    req.apiKey = keyData;
    next();
  } catch (error) {
    next(error);
  }
};
```

## Error Handling

The backend implements a standardized error handling approach:

1. **Custom Error Types**: Defined for different error scenarios
2. **Global Error Handler**: Catches and formats all errors
3. **Consistent Response Format**: All errors follow the same structure
4. **Error Logging**: Comprehensive error logging for troubleshooting

```typescript
// Global error handler
app.use((err: any, _req: Request, res: Response, _next: NextFunction) => {
  // Log error
  console.error(`[ERROR] ${new Date().toISOString()}:`, {
    message: err.message,
    stack: process.env.NODE_ENV !== 'production' ? err.stack : undefined,
    code: err.code
  });

  // Send standardized response
  res.status(err.status || 500).json({
    data: null,
    meta: {},
    error: {
      message: err.message || 'An unexpected error occurred',
      code: err.code || 'INTERNAL_ERROR',
      details: err.details || undefined
    }
  });
});
```

## Database Access

### Drizzle ORM Integration

The backend uses Drizzle ORM for type-safe database access:

1. **Schema Definition**: Schemas defined in `shared/schema.ts`
2. **Type Generation**: TypeScript types generated from schema
3. **Query Building**: Type-safe query construction
4. **Migrations**: Schema migration through Drizzle Kit

```typescript
// Example Drizzle ORM usage
export async function getUserByUsername(username: string): Promise<User | undefined> {
  const result = await db.select().from(schema.users).where(eq(schema.users.username, username)).limit(1);
  return result[0];
}

export async function createUser(insertUser: InsertUser): Promise<User> {
  if (insertUser.password) {
    insertUser.password = await hashPassword(insertUser.password);
  }
  
  const [result] = await db.insert(schema.users).values({
    ...insertUser,
    createdAt: new Date(),
    updatedAt: new Date()
  }).returning();
  
  return result;
}
```

### Connection Pooling

The backend uses connection pooling for efficient database access:

```typescript
// Connection pool configuration
export const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  max: 20,                 // Maximum connections in pool
  idleTimeoutMillis: 30000, // Close idle connections after 30s
  connectionTimeoutMillis: 2000, // Connection timeout
  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false
});

// Initialize Drizzle with the connection pool
export const db = drizzle({ client: pool, schema });
```

## Middleware Components

The backend uses various middleware components:

### Authentication Middleware

```typescript
export const requireAuth = (req: Request, res: Response, next: NextFunction) => {
  if (!req.isAuthenticated() || !req.user) {
    return res.status(401).json({
      error: {
        message: 'Authentication required',
        code: 'AUTH_REQUIRED'
      }
    });
  }
  
  req.userId = req.user.id;
  next();
};
```

### Validation Middleware

```typescript
export function validateRequest(schema: z.ZodType<any>, source: 'body' | 'query' | 'params' = 'body') {
  return (req: Request, res: Response, next: NextFunction) => {
    try {
      const data = schema.parse(req[source]);
      req[source] = data; // Replace with validated data
      next();
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({
          error: {
            message: 'Validation error',
            code: 'VALIDATION_ERROR',
            details: error.errors
          }
        });
      }
      next(error);
    }
  };
}
```

### Rate Limiting Middleware

```typescript
const apiLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // limit each IP to 100 requests per windowMs
  standardHeaders: true,
  message: {
    error: {
      message: 'Too many requests, please try again later',
      code: 'RATE_LIMIT_EXCEEDED'
    }
  }
});

app.use('/api/', apiLimiter);
```

## Service Implementation Patterns

### Singleton Services

Most services are implemented as static classes:

```typescript
export class AnalyticsService {
  static async getTrackAnalytics(trackId: number, startDate?: Date, endDate?: Date) {
    // Implementation
  }
  
  static async getReleaseAnalytics(releaseId: number, startDate?: Date, endDate?: Date) {
    // Implementation
  }
  
  // More methods...
}
```

### Dependency Injection

Some services use dependency injection for testing:

```typescript
export class RoyaltyService {
  private storage: IStorage;
  private analyticsService: IAnalyticsService;
  
  constructor(storage: IStorage, analyticsService: IAnalyticsService) {
    this.storage = storage;
    this.analyticsService = analyticsService;
  }
  
  async calculateRoyalties(trackId: number, period: string) {
    const analytics = await this.analyticsService.getTrackAnalytics(trackId);
    // Implementation using this.storage and analytics
  }
  
  // More methods...
}
```

## Performance Considerations

The backend implements several performance optimizations:

### Query Optimization

- Use of appropriate indexes
- Pagination for large result sets
- Selection of only needed fields
- Query parameterization

```typescript
// Example of optimized query with pagination
async function getAllUsers({ 
  status, 
  search,
  page = 1,
  limit = 20
}: { 
  status?: string; 
  search?: string;
  page?: number;
  limit?: number;
}): Promise<User[]> {
  let query = db.select().from(schema.users);
  
  if (status) {
    query = query.where(eq(schema.users.status, status));
  }
  
  if (search) {
    query = query.where(
      or(
        like(schema.users.username, `%${search}%`),
        like(schema.users.email, `%${search}%`),
        like(schema.users.fullName, `%${search}%`)
      )
    );
  }
  
  // Apply pagination
  const offset = (page - 1) * limit;
  query = query.limit(limit).offset(offset);
  
  return await query;
}
```

### Caching Strategies

- In-memory caching for frequently accessed data
- Cache invalidation on update operations
- TTL-based cache expiration

```typescript
// Example of caching implementation
const cache = new Map<string, { data: any, expiry: number }>();

async function getCachedData(key: string, ttlMs: number, fetchFn: () => Promise<any>) {
  const now = Date.now();
  const cached = cache.get(key);
  
  if (cached && cached.expiry > now) {
    return cached.data;
  }
  
  const data = await fetchFn();
  cache.set(key, { data, expiry: now + ttlMs });
  return data;
}

// Usage
async function getDistributionPlatforms() {
  return getCachedData(
    'distribution_platforms',
    1000 * 60 * 60, // 1 hour TTL
    () => db.select().from(schema.distributionPlatforms)
  );
}
```

### Batch Processing

- Batch operations for multiple database updates
- Background job processing for long-running tasks
- Chunked processing for large datasets

```typescript
// Example of batch processing
async function processBulkDistributionJob(jobId: number) {
  const job = await storage.getBulkDistributionJobById(jobId);
  const platforms = await storage.getDistributionPlatforms();
  
  // Update job status
  await storage.updateBulkDistributionJob(jobId, { status: 'processing' });
  
  try {
    // Process in chunks to avoid memory issues
    const releases = await storage.getReleasesByIds(job.releaseIds);
    const chunkSize = 10;
    
    for (let i = 0; i < releases.length; i += chunkSize) {
      const chunk = releases.slice(i, i + chunkSize);
      
      // Process chunk in parallel
      await Promise.all(chunk.map(async (release) => {
        for (const platformId of job.platformIds) {
          const platform = platforms.find(p => p.id === platformId);
          if (!platform) continue;
          
          try {
            await storage.createDistributionRecord({
              releaseId: release.id,
              platformId,
              status: 'pending',
              createdAt: new Date(),
              updatedAt: new Date()
            });
            
            // Update platform status
            await storage.updateBulkDistributionJobPlatformStatus(
              jobId, 
              platformId, 
              'processing', 
              { releaseId: release.id }
            );
            
            // Actual distribution process
            await distributionService.processDistribution(release.id, platformId);
            
            // Update success status
            await storage.updateBulkDistributionJobPlatformStatus(
              jobId, 
              platformId, 
              'completed', 
              { releaseId: release.id }
            );
          } catch (error) {
            // Log error and update status
            console.error(`Distribution error for release ${release.id} to platform ${platformId}:`, error);
            await storage.updateBulkDistributionJobPlatformStatus(
              jobId, 
              platformId, 
              'failed', 
              { 
                releaseId: release.id, 
                error: error.message 
              }
            );
          }
        }
      }));
    }
    
    // Update job completion
    await storage.updateBulkDistributionJob(jobId, { 
      status: 'completed',
      completedAt: new Date()
    });
  } catch (error) {
    // Handle overall job failure
    console.error(`Bulk distribution job ${jobId} failed:`, error);
    await storage.updateBulkDistributionJob(jobId, { 
      status: 'failed',
      error: error.message
    });
  }
}
```

## Security Implementation

The backend implements multiple security measures:

### Input Validation

All user input is validated using Zod schemas:

```typescript
export const insertUserSchema = createInsertSchema(users)
  .extend({
    password: z.string().min(8).max(100),
    confirmPassword: z.string().min(8).max(100)
  })
  .refine(data => data.password === data.confirmPassword, {
    message: "Passwords don't match",
    path: ["confirmPassword"]
  });
```

### Authentication Security

Secure password hashing and verification:

```typescript
export async function hashPassword(password: string): Promise<string> {
  const salt = randomBytes(16).toString('hex');
  const hash = await scryptAsync(password, salt, 64);
  return `${hash.toString('hex')}.${salt}`;
}

async function comparePasswords(supplied: string, stored: string): Promise<boolean> {
  const [hash, salt] = stored.split('.');
  const suppliedHash = await scryptAsync(supplied, salt, 64);
  return timingSafeEqual(
    Buffer.from(hash, 'hex'),
    suppliedHash
  );
}
```

### API Security

- HTTPS enforcement
- CORS configuration
- Rate limiting
- Content Security Policy

```typescript
// Security middleware configuration
app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      connectSrc: ["'self'", "https://api.example.com"],
      scriptSrc: ["'self'", "'unsafe-inline'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      imgSrc: ["'self'", "data:", "https://assets.example.com"],
      fontSrc: ["'self'", "https://fonts.googleapis.com"],
    }
  },
  hsts: {
    maxAge: 31536000,
    includeSubDomains: true,
    preload: true
  }
}));
```

## Testing Approach

The backend is designed for comprehensive testing:

### Unit Testing

- Testing individual functions and methods
- Mocking dependencies
- Testing edge cases and error handling

```typescript
// Example unit test
describe('hashPassword', () => {
  it('should hash a password', async () => {
    const password = 'securePassword123';
    const hashedPassword = await hashPassword(password);
    
    expect(hashedPassword).not.toBe(password);
    expect(hashedPassword).toContain('.');
    
    const parts = hashedPassword.split('.');
    expect(parts).toHaveLength(2);
  });
});
```

### Integration Testing

- Testing API endpoints
- Testing database interactions
- Testing service integrations

```typescript
// Example integration test
describe('User API', () => {
  beforeAll(async () => {
    await setupTestDatabase();
  });
  
  afterAll(async () => {
    await teardownTestDatabase();
  });
  
  it('should create a new user', async () => {
    const response = await request(app)
      .post('/api/auth/register')
      .send({
        username: 'testuser',
        password: 'password123',
        confirmPassword: 'password123',
        email: 'test@example.com',
        fullName: 'Test User'
      });
    
    expect(response.status).toBe(200);
    expect(response.body.data).toHaveProperty('id');
    expect(response.body.data.username).toBe('testuser');
  });
});
```

## External Integrations

The backend integrates with various external systems:

### Music Streaming Platforms

- API-based integrations with major streaming services
- Platform-specific authentication
- Content delivery protocols
- Response handling and error management

### Payment Processors

- Integration with payment gateways
- Secure handling of payment information
- Transaction processing and verification
- Refund and chargeback handling

### Analytics Services

- Data exchange with analytics providers
- ETL processes for data consolidation
- Reporting API integration
- Custom metrics tracking

## Deployment Considerations

The backend is designed for flexible deployment:

### Environment Configuration

- Environment-specific settings through `.env` files
- Validation of required environment variables
- Default values for optional settings
- Secrets management

### Scaling Strategy

- Stateless design for horizontal scaling
- Connection pooling for database efficiency
- Caching for reduced database load
- Background job processing for long-running tasks

### Monitoring

- Structured logging for observability
- Performance metrics collection
- Error tracking and alerting
- Health check endpoints

## Conclusion

TuneMantra's backend architecture provides a solid foundation for the platform with its focus on type safety, modular design, and scalability. The clear separation of concerns, comprehensive testing approach, and attention to security make it robust and maintainable.

The architecture balances flexibility and structure, allowing for future growth while maintaining consistency throughout the codebase. The use of TypeScript and Drizzle ORM provides strong guarantees about data types and database interactions, reducing the risk of runtime errors.

By following this architecture documentation, developers can understand the system's design, extend its functionality, and maintain its performance and security characteristics.

---

## documentation/technical/blockchain/README.md

# TuneMantra Blockchain Documentation

## Introduction

This directory contains comprehensive documentation about TuneMantra's blockchain integration. TuneMantra leverages blockchain technology to enhance rights management, enable NFT creation, and ensure transparent royalty distribution in the music industry.

## Documentation Structure

This blockchain documentation is organized as follows:

- [Overview & Architecture](overview-architecture.md): High-level architectural overview of blockchain components
- [Smart Contracts](smart-contracts.md): Detailed documentation of the smart contracts used in the platform
- [Implementation Guide](implementation-guide.md): Guide for implementing blockchain functionality
- [Integration Guide](integration-guide.md): Guide for integrating with blockchain services
- [Testing Guide](testing-guide.md): Comprehensive guide for testing blockchain functionality

## Key Blockchain Features

TuneMantra's blockchain implementation provides several key features:

1. **Rights Registration and Verification**: Immutable recording of music rights on the blockchain
2. **NFT Creation**: Tokenization of musical assets as NFTs
3. **Royalty Distribution**: Transparent and automated royalty splitting
4. **Multi-Network Support**: Support for multiple blockchain networks
5. **Cryptographic Verification**: Secure verification of rights ownership
6. **Smart Contract Automation**: Automated contract execution for rights management

## Supported Blockchain Networks

TuneMantra currently supports the following blockchain networks:

| Network | Type | Purpose |
|---------|------|---------|
| Polygon Mumbai | Testnet | Development and testing |
| Polygon Mainnet | Mainnet | Production environment |
| Ethereum Mainnet | Mainnet | High-value assets |

Additional networks including Ethereum L2 solutions (Optimism, Arbitrum) are in development.

## Implementation Architecture

The blockchain implementation follows a multi-layered architecture:

```
┌───────────────────────────────────┐
│         TuneMantra Platform       │
└───────────────┬───────────────────┘
                │
┌───────────────▼───────────────────┐
│       Blockchain Connector        │
└───────────────┬───────────────────┘
                │
┌───────────────▼───────────────────┐
│      Multi-Network Adapter        │
└───────────────┬───────────────────┘
                │
┌───────────────▼───────────────────┐
│          Smart Contracts          │
└───────────────────────────────────┘
```

The blockchain connector provides a unified interface for interacting with blockchain functionality, while the multi-network adapter handles network-specific details for different blockchain networks.

## Getting Started

If you're new to the TuneMantra blockchain implementation, we recommend starting with the following documents:

1. [Overview & Architecture](overview-architecture.md) for a high-level understanding of the blockchain components
2. [Smart Contracts](smart-contracts.md) for details on the smart contract implementation
3. [Implementation Guide](implementation-guide.md) for guidance on implementing blockchain functionality

## Testing

Blockchain functionality can be tested using the simulation mode, which allows testing without actual blockchain transactions. For detailed testing information, refer to the [Testing Guide](testing-guide.md).

## Development Status

The blockchain implementation is currently in active development with:

- **Complete**: Core rights registration, NFT minting, multi-network adapter
- **In Progress**: Enhanced royalty distribution, cross-chain verification
- **Planned**: DAO governance, Layer 2 scaling solutions, zero-knowledge proofs

For more information about the development roadmap, refer to the [Implementation Roadmap](../IMPLEMENTATION_ROADMAP.md).

---

*This documentation is maintained based on the blockchain functionality found primarily in the 17032025 branch.*

---

## documentation/technical/comprehensive-system-architecture.md

# TuneMantra System Architecture\n\nThis document outlines the comprehensive system architecture of the TuneMantra platform.
# TuneMantra Comprehensive System Architecture

**Version:** 2.1.0
**Last Updated:** March 28, 2025
**Document Status:** Active

## Introduction

This document provides a comprehensive overview of the TuneMantra platform architecture. It describes the system's components, their interactions, data flows, and technical implementation details. This consolidated architecture document serves as the authoritative reference for all architectural aspects of the TuneMantra platform.

## Table of Contents

1. [System Overview](#system-overview)
2. [Architectural Principles](#architectural-principles)
3. [High-Level Architecture](#high-level-architecture)
4. [Core Components](#core-components)
   - [User Management System](#user-management-system)
   - [Content Management System](#content-management-system)
   - [Distribution System](#distribution-system)
   - [Rights Management System](#rights-management-system)
   - [Royalty System](#royalty-system)
   - [Analytics Platform](#analytics-platform)
   - [Integration Framework](#integration-framework)
5. [Technology Stack](#technology-stack)
6. [Data Architecture](#data-architecture)
7. [Security Architecture](#security-architecture)
8. [Integration Architecture](#integration-architecture)
9. [Deployment Architecture](#deployment-architecture)
10. [Performance Considerations](#performance-considerations)
11. [Scalability Strategy](#scalability-strategy)
12. [Disaster Recovery](#disaster-recovery)
13. [Advanced Technology Integrations](#advanced-technology-integrations)
    - [Blockchain Integration](#blockchain-integration)
    - [AI and Machine Learning Components](#ai-and-machine-learning-components)
    - [Quantum-Resistant Security](#quantum-resistant-security)
    - [Neuro-Symbolic AI Knowledge Graph](#neuro-symbolic-ai-knowledge-graph)
14. [Future Architecture Roadmap](#future-architecture-roadmap)

## System Overview

TuneMantra is a comprehensive multi-tenant platform for music distribution, rights management, and royalty processing. The system enables music labels, distributors, and independent artists to manage their catalog, distribute content to digital service providers (DSPs), track performance, and process royalty payments.

The platform is designed as a cloud-native application with a microservices architecture, enabling flexibility, scalability, and continuous delivery. It employs modern development practices including infrastructure-as-code, automated testing, and CI/CD pipelines.

## Architectural Principles

The TuneMantra architecture is guided by the following principles:

1. **Multi-tenancy** - All components support multiple organizations with strict data isolation
2. **API-First** - All functionality is exposed through well-defined APIs
3. **Cloud-Native** - Designed to leverage cloud services and patterns
4. **Microservices-Based** - Functionality is divided into independent, loosely-coupled services
5. **Scalability** - Components can scale independently based on demand
6. **Security-by-Design** - Security is integrated into all aspects of the architecture
7. **Observability** - Comprehensive monitoring, logging, and tracing
8. **Automation** - Infrastructure management and deployment are fully automated
9. **Data Integrity** - Strict data validation and consistency mechanisms
10. **Interoperability** - Extensive support for industry standards and integration patterns

## High-Level Architecture

The TuneMantra platform follows a layered architecture:

1. **Presentation Layer** - Web applications, mobile apps, and API endpoints
2. **API Gateway Layer** - API management, routing, and security
3. **Business Logic Layer** - Microservices implementing core domain functionality
4. **Data Access Layer** - Data repositories and data access objects
5. **Data Storage Layer** - Databases, object storage, and caching systems
6. **Integration Layer** - Connections to external systems and third-party services
7. **Infrastructure Layer** - Cloud resources, networking, and infrastructure management

The system employs both synchronous (REST, GraphQL) and asynchronous (event-driven) communication patterns between services, with a central event bus facilitating loose coupling.

## Core Components

### User Management System

The User Management System handles authentication, authorization, and user profile management. It supports:

- Multi-factor authentication
- Role-based access control (RBAC)
- Fine-grained permissions
- Organization hierarchy
- User provisioning and deprovisioning
- Session management
- Audit logging of user activities

**Implementation Details:**
- Leverages OAuth 2.0 and OpenID Connect for identity management
- JWT-based authentication
- RBAC implementation using custom claims
- User profile database with encryption for sensitive data
- Integration with directory services (LDAP/Active Directory)
- Support for SSO (Single Sign-On) via SAML

### Content Management System

The Content Management System manages the catalog of music and related assets. It supports:

- Metadata management for releases, tracks, and artists
- Digital asset management for audio files, artwork, and promotional materials
- Versioning of content and metadata
- Batch operations for content management
- Automated quality control
- Content enrichment via third-party services

**Implementation Details:**
- Microservice architecture with dedicated services for metadata and asset management
- Object storage for digital assets with CDN integration
- Metadata stored in PostgreSQL with JSON support for flexible schema extensions
- Elasticsearch for text search capabilities
- Automated validation pipelines for incoming content
- Audio processing pipeline for format conversion and quality analysis

### Distribution System

The Distribution System handles the delivery of content to DSPs and management of the distribution workflow. It supports:

- Configuration of distribution targets
- Packaging content for specific DSP requirements
- Delivery scheduling and prioritization
- Delivery status tracking
- Error handling and retry logic
- Takedown management

**Implementation Details:**
- Microservice architecture with dedicated services for different distribution processes
- Integration adapters for each DSP with version management
- Workflow engine for distribution process orchestration
- Priority queue system for delivery scheduling
- State machine for tracking distribution status
- Idempotent operations to handle retries safely

### Rights Management System

The Rights Management System manages ownership information, rights data, and licensing. It supports:

- Rights holder management
- Territory-specific rights configuration
- Time-bounded rights management
- Rights transfer and acquisition workflow
- Conflict detection and resolution
- Historical rights tracking

**Implementation Details:**
- Graph database for complex rights relationships
- Temporal data modeling for time-bound rights
- Blockchain integration for immutable rights records
- Rules engine for rights validation and conflict detection
- Integration with industry rights databases
- Digital contract management with secure storage

### Royalty System

The Royalty System calculates and processes royalty payments. It supports:

- Revenue data import from multiple sources
- Complex royalty rule configuration
- Split payment calculations
- Advance and minimum guarantee handling
- Statement generation
- Payment processing

**Implementation Details:**
- Data pipeline for revenue data normalization
- Rules engine for royalty calculations
- In-memory processing for complex calculations
- Versioned royalty rules with effective dates
- Integrated payment gateway connections
- Comprehensive audit trail for all calculations

### Analytics Platform

The Analytics Platform processes and visualizes data for business intelligence. It supports:

- Real-time and historical performance tracking
- Customizable dashboards
- Trend analysis
- Market intelligence
- Predictive analytics
- Export and sharing capabilities

**Implementation Details:**
- Data warehouse for aggregated analytics data
- Stream processing for real-time analytics
- OLAP cubes for dimensional analysis
- ML models for predictive analytics
- BI visualization layer with customizable dashboards
- ETL pipelines for data integration from multiple sources

### Integration Framework

The Integration Framework enables connectivity with external systems. It supports:

- Public API for third-party integration
- Webhook system for event notifications
- Bulk data import/export
- EDI (Electronic Data Interchange) support
- Partner portal integration
- Custom integration development

**Implementation Details:**
- API Gateway for API management and security
- OpenAPI documentation
- Webhook delivery system with retry logic
- Message queue integration for asynchronous processing
- Data transformation services
- Integration monitoring and alerting

## Technology Stack

The TuneMantra platform is built using the following technologies:

**Frontend:**
- React.js for web applications
- React Native for mobile applications
- TypeScript for type safety
- Redux for state management
- Material-UI and custom design system
- Jest and React Testing Library for testing

**Backend:**
- Node.js with TypeScript for microservices
- Express.js for API framework
- gRPC for internal service communication
- GraphQL for client-facing APIs
- Jest for testing

**Data Storage:**
- PostgreSQL for relational data
- MongoDB for document storage
- Redis for caching and session management
- Neo4j for graph data (rights management)
- Elasticsearch for search functionality
- MinIO for object storage

**Infrastructure:**
- Kubernetes for container orchestration
- Docker for containerization
- Terraform for infrastructure-as-code
- AWS/Azure/GCP for cloud infrastructure
- Kong API Gateway
- RabbitMQ for message queuing
- ELK Stack for logging and monitoring
- Prometheus and Grafana for metrics and visualization

**DevOps:**
- GitHub for source control
- GitHub Actions for CI/CD
- Jest and Supertest for automated testing
- SonarQube for code quality analysis
- Artifactory for artifact management
- Vault for secrets management

## Data Architecture

The data architecture employs a polyglot persistence approach, using different database technologies for different data needs:

1. **Transactional Data** - PostgreSQL for ACID-compliant operations
2. **Content Metadata** - PostgreSQL with JSONB for flexibility
3. **Digital Assets** - Object storage with metadata in PostgreSQL
4. **Rights Data** - Neo4j graph database for relationship modeling
5. **Analytics Data** - Data warehouse with star schema
6. **Search Indexes** - Elasticsearch
7. **Caching Layer** - Redis
8. **Message Queues** - RabbitMQ
9. **Event Store** - Event sourcing database for auditing

Data consistency is maintained through a combination of:
- Transactional boundaries within services
- Eventual consistency across services
- Event-driven architecture for state propagation
- Distributed transactions where necessary
- Idempotent operations and retry mechanisms

## Security Architecture

The security architecture implements defense-in-depth with multiple security layers:

1. **Network Security:**
   - VPC isolation
   - Network segmentation
   - WAF (Web Application Firewall)
   - DDoS protection
   - IP whitelisting for admin functions

2. **Identity and Access:**
   - Multi-factor authentication
   - Role-based access control
   - Principle of least privilege
   - Regular access reviews
   - Token-based authentication
   - IP-based access restrictions

3. **Data Security:**
   - Encryption at rest (AES-256)
   - Encryption in transit (TLS 1.3)
   - Field-level encryption for sensitive data
   - Data masking for non-privileged access
   - Key rotation
   - Secure key management

4. **Application Security:**
   - Input validation
   - Output encoding
   - CSRF protection
   - XSS prevention
   - SQL injection prevention
   - Regular vulnerability scanning
   - Third-party dependency scanning

5. **Operational Security:**
   - Security logging and monitoring
   - Intrusion detection
   - Regular penetration testing
   - Security incident response
   - Compliance monitoring

6. **Advanced Security:**
   - Quantum-resistant cryptography
   - Blockchain-based audit trail
   - Secure multi-party computation
   - Homomorphic encryption for sensitive analytics

## Integration Architecture

The integration architecture supports multiple integration patterns:

1. **REST APIs:**
   - OpenAPI 3.0 specification
   - Versioned endpoints
   - Rate limiting
   - OAuth 2.0 authentication
   - HATEOAS for discoverability

2. **GraphQL API:**
   - Self-documenting schema
   - Efficient data fetching
   - Real-time subscriptions
   - Batched operations

3. **Webhooks:**
   - Event-based notifications
   - Configurable delivery
   - Signature verification
   - Delivery confirmation
   - Retry mechanisms

4. **Bulk Data Exchange:**
   - SFTP support
   - S3-compatible interfaces
   - Scheduled data exports
   - Delta synchronization
   - Data validation

5. **Streaming Data:**
   - Kafka streams
   - WebSocket APIs
   - Server-sent events

6. **Partner Integrations:**
   - DSP-specific adapters
   - Industry standard formats (DDEX)
   - Custom B2B integrations

## Deployment Architecture

The deployment architecture is based on Kubernetes, with the following components:

1. **Kubernetes Clusters:**
   - Production, staging, and development environments
   - Multi-region deployment for high availability
   - Node auto-scaling based on load
   - Pod disruption budgets for availability

2. **Service Mesh:**
   - Istio for service-to-service communication
   - Traffic management
   - Security policy enforcement
   - Observability data collection

3. **CI/CD Pipeline:**
   - Infrastructure-as-code with Terraform
   - GitOps workflow with ArgoCD
   - Automated testing
   - Blue/green deployments
   - Canary releases

4. **Monitoring and Observability:**
   - Distributed tracing with Jaeger
   - Metrics collection with Prometheus
   - Logging with ELK stack
   - Alerting with AlertManager
   - Dashboards with Grafana

5. **Backup and Disaster Recovery:**
   - Regular database backups
   - Cross-region replication
   - Recovery point objectives (RPO) of 15 minutes
   - Recovery time objectives (RTO) of 1 hour

## Performance Considerations

The architecture addresses performance through several strategies:

1. **Caching:**
   - Multi-level caching (application, database, CDN)
   - Cache invalidation strategies
   - Distributed caching with Redis

2. **Database Optimization:**
   - Query optimization
   - Appropriate indexing
   - Read replicas for heavy read operations
   - Connection pooling
   - Query result caching

3. **Application Performance:**
   - Code profiling and optimization
   - Asynchronous processing for non-critical operations
   - Resource pooling
   - Efficient algorithms for computationally intensive tasks
   - Lazy loading of resources

4. **Network Optimization:**
   - CDN for static assets
   - Response compression
   - HTTP/2 and HTTP/3 support
   - Connection keep-alive
   - Minimized payload sizes

5. **Load Testing:**
   - Regular performance benchmarking
   - Stress testing
   - Load modeling based on usage patterns
   - Performance degradation analysis

## Scalability Strategy

The architecture is designed for horizontal and vertical scalability:

1. **Horizontal Scaling:**
   - Stateless microservices
   - Container orchestration with Kubernetes
   - Auto-scaling based on metrics
   - Load balancing
   - Service discovery

2. **Database Scaling:**
   - Sharding for high-volume data
   - Read replicas for read-heavy workloads
   - Connection pooling
   - Query optimization
   - NoSQL databases for specific use cases

3. **Content Delivery Scaling:**
   - Distributed CDN
   - Edge caching
   - Optimized delivery paths
   - Tiered storage strategy

4. **Processing Scaling:**
   - Parallel processing for batch operations
   - Distributed computation for analytics
   - Queue-based workload distribution
   - Resource isolation for critical services

## Disaster Recovery

The disaster recovery strategy includes:

1. **Data Backup:**
   - Regular automated backups
   - Point-in-time recovery
   - Cross-region backup storage
   - Regular backup testing

2. **High Availability:**
   - Multi-zone deployment
   - Redundant infrastructure
   - Automatic failover
   - Load balancing across regions

3. **Recovery Procedures:**
   - Documented recovery processes
   - Regular disaster recovery drills
   - Automated recovery scripts
   - Priority-based service restoration

4. **Business Continuity:**
   - Hot standby environment
   - Geographical redundancy
   - Alternative communication channels
   - Critical functionality identification

## Advanced Technology Integrations

### Blockchain Integration

The platform integrates blockchain technology for several use cases:

1. **Immutable Rights Records:**
   - Smart contracts for rights management
   - Transparent ownership tracking
   - Verifiable rights history
   - Blockchain-based rights transfer

2. **Royalty Distribution:**
   - Smart contracts for automatic royalty distribution
   - Transparent payment tracking
   - Reduced payment friction
   - Micro-payment support

3. **Content Authentication:**
   - Blockchain-based content fingerprinting
   - Proof of creation timestamps
   - Usage tracking
   - Anti-piracy measures

**Implementation Details:**
- Ethereum-based smart contracts
- Layer 2 scaling solutions for efficiency
- IPFS integration for content links
- Multi-signature wallets for security
- Hybrid on-chain/off-chain architecture for performance
- Cross-chain interoperability support

### AI and Machine Learning Components

The platform leverages AI and machine learning for:

1. **Content Recommendations:**
   - User behavior analysis
   - Collaborative filtering
   - Content-based recommendation
   - Contextual recommendations
   - A/B testing framework

2. **Metadata Enhancement:**
   - Automatic genre classification
   - Mood analysis
   - Similar content identification
   - Music characteristic extraction
   - Automated tagging

3. **Predictive Analytics:**
   - Trend prediction
   - Revenue forecasting
   - Audience growth modeling
   - Content performance prediction
   - Anomaly detection

4. **Content Analysis:**
   - Audio fingerprinting
   - Similarity detection
   - Quality assessment
   - Speech recognition
   - Lyric analysis

**Implementation Details:**
- TensorFlow and PyTorch for deep learning models
- H2O.ai for automated machine learning
   - Containerized ML model serving
   - Feature store for consistent feature engineering
   - Model versioning and A/B testing framework
   - Real-time inference API
   - Batch prediction pipelines

### Quantum-Resistant Security

The platform implements quantum-resistant security measures:

1. **Post-Quantum Cryptography:**
   - Lattice-based cryptography
   - Hash-based signature schemes
   - Code-based cryptography
   - Multivariate polynomial cryptography

2. **Hybrid Cryptographic Approach:**
   - Dual algorithm implementation
   - Graceful security transition
   - Algorithm agility
   - Crypto-agility framework

**Implementation Details:**
- NIST post-quantum cryptography standards implementation
- Hybrid certificates combining traditional and PQC algorithms
- Key encapsulation mechanisms (KEMs) for secure key exchange
- Post-quantum secure random number generation
- Crypto-agility framework for algorithm updates

### Neuro-Symbolic AI Knowledge Graph

The platform implements a neuro-symbolic AI approach for complex reasoning:

1. **Knowledge Graph:**
   - Music domain ontology
   - Entity relationship modeling
   - Semantic reasoning capabilities
   - Knowledge extraction from unstructured data
   - Temporal information representation

2. **Neuro-Symbolic Integration:**
   - Neural networks for pattern recognition
   - Symbolic reasoning for logic and rules
   - Explainable AI implementation
   - Human-in-the-loop learning
   - Uncertainty handling

**Implementation Details:**
- RDF/OWL-based knowledge representation
- SPARQL query capability
- Vector embeddings for semantic similarity
- Graph neural networks for representation learning
- Rule-based systems integrated with neural models
- Attention mechanisms for knowledge graph navigation

## Future Architecture Roadmap

The architecture roadmap includes the following initiatives:

1. **Near-term (6-12 months):**
   - Complete migration to Kubernetes
   - Enhance observability with distributed tracing
   - Implement chaos engineering practices
   - Expand GraphQL API coverage
   - Deploy advanced caching strategies

2. **Mid-term (12-24 months):**
   - Implement service mesh across all environments
   - Enhance event-driven architecture
   - Expand edge computing capabilities
   - Implement artificial intelligence operations (AIOps)
   - Deploy quantum-resistant cryptography

3. **Long-term (24-36 months):**
   - Implementation of Federated Learning for privacy-preserving AI
   - Advanced neuro-symbolic AI integration
   - Full post-quantum cryptography transition
   - Blockchain-based rights and royalty management
   - Decentralized content distribution mechanisms

---

## References

- [System Architecture Diagrams](../diagrams/)
- [API Documentation](../developer/api-reference.md)
- [Security Policies](../user/security-guide.md)
- [Data Model Documentation](../technical/data-model.md)
- [Workflow Diagrams](../diagrams/ascii_workflows_consolidated.txt)

---

© 2023-2025 TuneMantra. All rights reserved.# TuneMantra System Architecture

*Version: 1.0.0 (March 27, 2025)*

## Table of Contents

- [Introduction](#introduction)
- [Architectural Overview](#architectural-overview)
- [System Components](#system-components)
- [Data Architecture](#data-architecture)
- [Integration Architecture](#integration-architecture)
- [Security Architecture](#security-architecture)
- [Deployment Architecture](#deployment-architecture)
- [Performance Architecture](#performance-architecture)
- [Scalability and Resilience](#scalability-and-resilience)
- [Development Environment](#development-environment)
- [Future Architecture](#future-architecture)
- [Architecture Decision Records](#architecture-decision-records)

## Introduction

The TuneMantra platform is designed as a comprehensive multi-tenant music distribution system, enabling content providers to manage, distribute, and monetize their music across global digital platforms. This document provides a detailed overview of the system's architecture, including its components, interactions, and design principles.

### Purpose

This architecture document serves as a reference for understanding the system's structure and behavior. It provides:

1. High-level and detailed views of the system's components
2. Descriptions of data flows and integration points
3. Explanations of architectural decisions and their rationales
4. Guidelines for system extensions and modifications
5. A foundation for system evaluation and improvement

### Design Principles

The architecture is guided by these core principles:

1. **Security by Design**: Security considerations are incorporated from the beginning of the design process, not added later.
2. **Scalability**: The system can scale horizontally to handle increasing load and data volume.
3. **Modularity**: Components are designed with clear responsibilities and interfaces, enabling independent evolution.
4. **Multi-tenancy**: The platform supports multiple organizations with strict data isolation.
5. **Global Availability**: The system is designed for global distribution and accessibility.
6. **Extensibility**: The architecture facilitates the addition of new features and integrations.
7. **Observability**: System behavior and performance can be monitored and analyzed.

### Architectural Requirements

The architecture addresses these key requirements:

1. **Functional Requirements**:
   - Support for complete music asset management
   - Distribution to 150+ digital service providers
   - Rights and ownership management
   - Royalty calculation and payment processing
   - Comprehensive analytics and reporting

2. **Non-Functional Requirements**:
   - Performance: Response time under 500ms for 95% of requests
   - Scalability: Support for millions of tracks and thousands of users
   - Availability: 99.9% uptime (less than 9 hours of downtime annually)
   - Security: Protection of sensitive financial and content data
   - Compliance: Adherence to industry standards and regulations

## Architectural Overview

### System Context

The TuneMantra platform operates within an ecosystem of users, content providers, distribution partners, and financial services.

#### External Entities

- **Content Providers**: Artists, labels, and distributors who supply music content
- **Digital Service Providers (DSPs)**: Streaming platforms, download stores, and other distribution targets
- **Financial Services**: Payment processors, banking systems, and tax authorities
- **End Users**: Administrators, label managers, artists, and financial personnel who interact with the system

#### Context Diagram

The context diagram illustrates the system's boundaries and its interactions with external entities:

```
┌───────────────────────────────────────────────────────────────────┐
│                                                                   │
│  ┌────────────┐        ┌─────────────┐       ┌───────────────┐   │
│  │            │        │             │       │               │   │
│  │  Content   │◄──────►│  TuneMantra │◄─────►│  Digital      │   │
│  │  Providers │        │  Platform   │       │  Service      │   │
│  │            │        │             │       │  Providers    │   │
│  └────────────┘        └─────┬───────┘       └───────────────┘   │
│                              │                                    │
│                              │                                    │
│                              ▼                                    │
│                       ┌─────────────┐                             │
│                       │             │                             │
│                       │  Financial  │                             │
│                       │  Services   │                             │
│                       │             │                             │
│                       └─────────────┘                             │
│                                                                   │
└───────────────────────────────────────────────────────────────────┘
```

### High-Level Architecture

TuneMantra is built as a layered, microservices-based architecture with the following major layers:

1. **Presentation Layer**: Web interfaces, mobile applications, and API clients
2. **API Gateway Layer**: The entry point for all client requests, handling authentication, routing, and rate limiting
3. **Service Layer**: Core business services implemented as microservices
4. **Data Layer**: Databases, caches, and storage systems

#### Architecture Diagram

The high-level architecture diagram shows the major system components:

```
┌───────────────────────────────────────────────────────────────────────┐
│                      PRESENTATION LAYER                                │
│                                                                       │
│  ┌─────────────┐  ┌─────────────┐  ┌────────────┐  ┌──────────────┐   │
│  │  Web App    │  │  Mobile App │  │  Partner   │  │  Admin       │   │
│  │             │  │             │  │  API       │  │  Portal      │   │
│  └──────┬──────┘  └──────┬──────┘  └─────┬──────┘  └──────┬───────┘   │
│         │                │                │                │           │
└─────────┼────────────────┼────────────────┼────────────────┼───────────┘
          │                │                │                │            
┌─────────┼────────────────┼────────────────┼────────────────┼───────────┐
│         ▼                ▼                ▼                ▼           │
│                                                                       │
│  ┌─────────────────────────────────────────────────────────────────┐  │
│  │                         API GATEWAY                             │  │
│  │                                                                 │  │
│  │  ┌─────────────┐  ┌─────────────┐  ┌────────────┐  ┌─────────┐  │  │
│  │  │ Auth &      │  │ Request     │  │ Rate       │  │ Routing │  │  │
│  │  │ Authorization│  │ Validation  │  │ Limiting   │  │         │  │  │
│  │  └─────────────┘  └─────────────┘  └────────────┘  └─────────┘  │  │
│  └──────────────────────────────┬──────────────────────────────────┘  │
│                                 │                                     │
└─────────────────────────────────┼─────────────────────────────────────┘
                                  │                                      
┌─────────────────────────────────┼─────────────────────────────────────┐
│                                 ▼                                     │
│                          SERVICE LAYER                                │
│                                                                       │
│  ┌────────────┐  ┌──────────┐  ┌─────────────┐  ┌────────────────┐   │
│  │  User &    │  │ Catalog  │  │ Distribution│  │ Rights &       │   │
│  │  Org Mgmt  │  │ Services │  │ Services    │  │ Royalty Mgmt   │   │
│  └────────────┘  └──────────┘  └─────────────┘  └────────────────┘   │
│                                                                       │
│  ┌────────────┐  ┌──────────┐  ┌─────────────┐  ┌────────────────┐   │
│  │  Payment   │  │ Analytics│  │ Notification│  │ Background     │   │
│  │  Services  │  │ Services │  │ Services    │  │ Processing     │   │
│  └────────────┘  └──────────┘  └─────────────┘  └────────────────┘   │
│                                                                       │
└──────────────────────────────────┬────────────────────────────────────┘
                                   │                                     
┌──────────────────────────────────┼────────────────────────────────────┐
│                                  ▼                                    │
│                           DATA LAYER                                  │
│                                                                       │
│  ┌────────────┐  ┌────────────┐  ┌────────────┐  ┌────────────────┐  │
│  │  Postgres  │  │ Redis      │  │ S3         │  │ Elasticsearch   │  │
│  │  Database  │  │ Cache      │  │ Storage    │  │                 │  │
│  └────────────┘  └────────────┘  └────────────┘  └────────────────┘  │
│                                                                       │
└───────────────────────────────────────────────────────────────────────┘
```

### Architectural Patterns

TuneMantra utilizes several architectural patterns:

1. **Microservices Architecture**: The system is composed of independent, loosely coupled services, each responsible for specific business functionality.

2. **API Gateway Pattern**: All client requests flow through a central gateway that handles cross-cutting concerns like authentication, routing, and rate limiting.

3. **Event-Driven Architecture**: Services communicate through events for asynchronous operations, improving decoupling and scalability.

4. **CQRS (Command Query Responsibility Segregation)**: For certain services, the system separates read and write operations to optimize performance.

5. **Repository Pattern**: Data access is abstracted behind repositories, providing a consistent interface to different data stores.

6. **Circuit Breaker Pattern**: The system includes mechanisms to handle failures in distributed service calls gracefully.

7. **Bulkhead Pattern**: Resources are isolated to prevent cascading failures across the system.

## System Components

### Presentation Layer

The presentation layer provides the user interfaces for different types of users.

#### Web Application

The primary user interface is a single-page application (SPA) built with React.

**Key Features**:
- Responsive design for desktop and tablet
- Role-based user interfaces
- Real-time data updates
- Offline capabilities for certain functions

**Technologies**:
- React
- TypeScript
- React Query for data fetching
- TailwindCSS with shadcn/ui for styling
- Vite for building and bundling

#### Mobile Application

A companion mobile application for iOS and Android.

**Key Features**:
- Limited subset of web functionality focused on monitoring and approvals
- Push notifications for important events
- Offline access to recent data

**Technologies**:
- React Native
- TypeScript
- Realm for offline storage
- Firebase for push notifications

#### Partner API Clients

SDKs and libraries for integration with partner systems.

**Key Features**:
- Authentication handling
- Request and response mapping
- Error handling
- Rate limiting awareness

**Technologies**:
- TypeScript (JavaScript SDK)
- Python
- PHP
- Java
- C#

#### Admin Portal

A specialized interface for system administrators.

**Key Features**:
- System configuration
- User and organization management
- Monitoring and analytics
- Support tools

**Technologies**:
- Same stack as the main web application
- Additional administrative components

### API Gateway Layer

The API gateway serves as the entry point for all client requests.

#### Authentication Service

Handles user authentication and token issuance.

**Key Features**:
- Username/password authentication
- OAuth 2.0 support
- Multi-factor authentication
- Token issuance and validation
- Session management

**Technologies**:
- Node.js
- Express
- JSON Web Tokens (JWT)
- Redis for token storage
- bcrypt for password hashing

#### Request Validation

Validates incoming requests before they reach the services.

**Key Features**:
- Schema validation
- Parameter sanitization
- Content type validation
- Request size limiting

**Technologies**:
- Zod for schema validation
- Express middleware
- Custom validation rules

#### Rate Limiting

Controls the number of requests clients can make.

**Key Features**:
- IP-based rate limiting
- Token-based rate limiting
- Quota management
- Throttling configuration

**Technologies**:
- Redis for rate counter storage
- Token bucket algorithm implementation
- Custom rate limiting middleware

#### Routing and Load Balancing

Directs requests to appropriate services.

**Key Features**:
- Service discovery
- Request routing
- Load balancing
- Circuit breaking

**Technologies**:
- Express routing
- Service discovery integration
- Load balancer integration

### Service Layer

The service layer contains the core business logic of the system.

#### User and Organization Management

Manages user accounts, organizations, and access control.

**Key Features**:
- User registration and profile management
- Organization creation and management
- Role-based access control
- Organization hierarchy management

**Technologies**:
- Node.js with Express
- Drizzle ORM
- PostgreSQL for data storage
- Redis for caching

#### Catalog Services

Manages music content and metadata.

**Key Features**:
- Content ingestion and validation
- Metadata management
- Asset storage and retrieval
- Content versioning

**Technologies**:
- Node.js with Express
- Drizzle ORM
- PostgreSQL for metadata
- S3 for asset storage
- Elasticsearch for search

#### Distribution Services

Handles content delivery to digital service providers.

**Key Features**:
- Platform-specific formatting
- Delivery scheduling
- Status tracking
- Takedown management

**Technologies**:
- Node.js with Express
- Drizzle ORM
- PostgreSQL for data storage
- Queue systems for delivery management
- Platform-specific adapters

#### Rights and Royalty Management

Manages content ownership, revenue allocation, and royalty calculations.

**Key Features**:
- Rights ownership management
- Revenue ingestion and processing
- Royalty calculation
- Split management
- Statement generation

**Technologies**:
- Node.js with Express
- Drizzle ORM
- PostgreSQL for data storage
- Redis for calculation caching
- Background processing for calculations

#### Payment Services

Handles payment processing and financial transactions.

**Key Features**:
- Payment method management
- Payment batch processing
- Transaction recording
- Currency conversion
- Tax handling

**Technologies**:
- Node.js with Express
- Drizzle ORM
- PostgreSQL for data storage
- Payment gateway integrations
- Encryption for sensitive data

#### Analytics Services

Provides data analysis and reporting capabilities.

**Key Features**:
- Data collection and processing
- Report generation
- Dashboard data
- Custom metrics
- Data export

**Technologies**:
- Node.js with Express
- Drizzle ORM
- PostgreSQL for relational data
- Elasticsearch for analytics storage
- Redis for caching

#### Notification Services

Manages notifications and communication.

**Key Features**:
- Email notifications
- Push notifications
- In-app notifications
- Notification preferences
- Delivery tracking

**Technologies**:
- Node.js with Express
- Email service integration
- Push notification services
- WebSockets for real-time notifications
- Template rendering

#### Background Processing

Handles long-running and scheduled tasks.

**Key Features**:
- Task scheduling
- Long-running calculations
- Batch processing
- Asynchronous operations
- Retry logic

**Technologies**:
- Node.js
- Bull for job queues
- Redis for queue storage
- Worker processes
- Monitoring and logging

### Data Layer

The data layer stores and provides access to the system's data.

#### PostgreSQL Database

The primary relational database for transactional data.

**Key Features**:
- Transactional data storage
- Complex relationships
- ACID compliance
- Data integrity enforcement

**Design Principles**:
- Normalized schema design
- Optimized indexing
- Partitioning for large tables
- Read replicas for scaling

#### Redis Cache

In-memory data structure store used for caching and temporary data.

**Key Features**:
- Session storage
- Cache for frequent queries
- Rate limiting counters
- Job queue storage
- Pub/sub for real-time features

**Usage Patterns**:
- Time-limited caching
- Invalidation strategies
- Memory optimization
- Cluster configuration

#### Object Storage (S3)

Storage for binary assets and large objects.

**Key Features**:
- Audio file storage
- Image storage
- Document storage
- Backup storage
- Large dataset storage

**Organization**:
- Bucket strategy
- Access control policies
- Lifecycle management
- Encryption configuration

#### Elasticsearch

Search and analytics engine.

**Key Features**:
- Full-text search
- Analytics data storage
- Aggregation and reporting
- Real-time search updates

**Index Design**:
- Optimized mappings
- Indexing strategies
- Analyzer configuration
- Shard management

## Data Architecture

### Data Model

The TuneMantra data model is organized around these core entities:

1. **Users and Organizations**: User accounts, organization records, and their relationships
2. **Content**: Music releases, tracks, and associated metadata
3. **Rights**: Ownership and rights information
4. **Distribution**: Platform delivery records and status
5. **Revenue**: Income records from various sources
6. **Royalties**: Calculated payments based on revenue and rights
7. **Payments**: Financial transaction records

#### Entity Relationship Diagram

The following diagram shows the high-level relationships between key entities:

```
┌────────────┐       ┌────────────┐       ┌────────────┐
│            │       │            │       │            │
│   Users    │◄──────┤  OrgUsers  ├───────►Organizations│
│            │       │            │       │            │
└────────────┘       └────────────┘       └─────┬──────┘
                                                │
                                                │
                                          ┌─────▼──────┐
                                          │            │
                                          │  Releases  │
                                          │            │
                                          └─────┬──────┘
                                                │
                     ┌────────────┐             │
                     │            │             │
                     │   Rights   │◄────────────┤
                     │            │             │
                     └──────┬─────┘             │
                            │                   │
                            │             ┌─────▼──────┐
                            │             │            │
                            │             │   Tracks   │
                            │             │            │
                            │             └─────┬──────┘
                     ┌──────▼─────┐             │
                     │            │             │
                     │  Splits    │             │
                     │            │             │
                     └──────┬─────┘             │
                            │                   │
              ┌─────────────┼───────────────────┘
              │             │                   
     ┌────────▼──────┐     ┌▼────────────┐      ┌────────────┐
     │               │     │              │      │            │
     │  Royalties    │◄────┤   Revenue    │◄─────┤Distribution │
     │               │     │              │      │            │
     └───────┬───────┘     └──────────────┘      └────────────┘
             │                                           
             │                                           
     ┌───────▼───────┐                                   
     │               │                                   
     │   Payments    │                                   
     │               │                                   
     └───────────────┘                                   
```

### Data Flow

Data flows through the system in several key patterns:

1. **Content Ingestion Flow**:
   - Content is uploaded through the web application
   - Metadata is validated and stored in PostgreSQL
   - Media files are processed and stored in S3
   - Search indexes are updated in Elasticsearch

2. **Distribution Flow**:
   - Approved content is scheduled for distribution
   - Platform-specific formatting is applied
   - Content is delivered to DSPs via APIs or file transfers
   - Status updates are recorded and tracked

3. **Revenue Processing Flow**:
   - Revenue data is imported from platforms
   - Data is validated and normalized
   - Revenue is allocated based on rights data
   - Royalties are calculated and stored

4. **Payment Processing Flow**:
   - Royalty payments are aggregated and batched
   - Payment transactions are created
   - Funds are transferred via payment providers
   - Transaction records are updated

### Data Storage Strategy

The system employs a multi-tiered storage strategy:

1. **Transactional Data**: PostgreSQL
   - User and organization data
   - Content metadata
   - Rights and ownership
   - Financial records

2. **Binary Assets**: S3-compatible object storage
   - Audio files
   - Image files
   - Document files
   - Backup data

3. **Cache and Temporary Data**: Redis
   - Session data
   - Frequent query results
   - Computational intermediates
   - Rate limiting counters

4. **Search and Analytics Data**: Elasticsearch
   - Searchable content metadata
   - Analytics aggregations
   - Reporting data
   - Historical trends

### Data Access Patterns

The system supports these primary data access patterns:

1. **API-Based Access**: All client interactions use the REST API or GraphQL
2. **Service-to-Service Communication**: Internal services communicate via API calls and message queues
3. **Batch Processing**: Background jobs process data in batches for efficiency
4. **Real-Time Updates**: WebSockets provide immediate updates for critical data changes
5. **Reporting and Analytics**: Specialized queries access denormalized data for analysis

## Integration Architecture

### External System Integration

TuneMantra integrates with various external systems:

1. **Digital Service Providers (150+)**:
   - Music streaming platforms
   - Download stores
   - Video platforms
   - Social media platforms

2. **Financial Services**:
   - Payment processors
   - Banking systems
   - Tax services
   - Currency exchange services

3. **Identity Providers**:
   - OAuth providers
   - SAML providers
   - Social login services

4. **Notification Services**:
   - Email service providers
   - Push notification services
   - SMS gateways

### Integration Patterns

The system employs these integration patterns:

1. **REST API Integration**:
   - Synchronous communication with external services
   - Standardized request/response formats
   - Error handling and retry logic

2. **Webhook Integration**:
   - Event-based notifications from the platform
   - Subscription-based delivery
   - Verification and security measures

3. **SFTP and File Transfer**:
   - Batch file delivery for certain DSPs
   - Scheduled file transfers
   - Format conversions

4. **Message Queue Integration**:
   - Asynchronous processing of integration events
   - Decoupling from external systems
   - Retry and failure handling

### API Management

The API strategy includes:

1. **API Versioning**:
   - Semantic versioning (major.minor.patch)
   - URL-based versioning (e.g., /v1/resources)
   - Backward compatibility requirements

2. **API Documentation**:
   - OpenAPI/Swagger specifications
   - Interactive documentation
   - Code samples and examples
   - SDK generation

3. **API Security**:
   - OAuth 2.0 authentication
   - Scoped permissions
   - Rate limiting
   - Request validation

4. **API Monitoring**:
   - Usage metrics
   - Error tracking
   - Performance monitoring
   - SLA compliance

### Event-Driven Architecture

The system utilizes events for loosely coupled integrations:

1. **Event Types**:
   - Content events (created, updated, delivered)
   - User events (registered, updated, deleted)
   - Financial events (revenue recorded, payment processed)
   - System events (configuration changed, error occurred)

2. **Event Distribution**:
   - Internal event bus for system components
   - Webhook delivery for external subscribers
   - Event persistence for auditability
   - Event replay capabilities

3. **Event Schema Management**:
   - Versioned event schemas
   - Compatibility requirements
   - Documentation and discovery
   - Validation enforcement

## Security Architecture

The security architecture is described in detail in the [Security Model](./security-model.md) document. Key aspects include:

### Authentication and Authorization

1. **User Authentication**:
   - Password-based authentication
   - Multi-factor authentication
   - Social authentication
   - Single sign-on (SSO)

2. **API Authentication**:
   - OAuth 2.0 with JWT
   - Client credentials flow
   - Authorization code flow
   - Token refresh mechanisms

3. **Authorization Model**:
   - Role-based access control (RBAC)
   - Attribute-based access control (ABAC)
   - Organization-level permissions
   - Resource-level permissions

### Data Protection

1. **Data Encryption**:
   - Transport encryption (TLS 1.3)
   - Storage encryption (AES-256)
   - Field-level encryption for sensitive data
   - Key management systems

2. **Privacy Controls**:
   - Personal data minimization
   - Consent management
   - Data retention policies
   - Anonymization capabilities

### Network Security

1. **Network Architecture**:
   - Defense in depth approach
   - Network segmentation
   - Security groups and ACLs
   - DDoS protection

2. **API Security**:
   - Rate limiting
   - Input validation
   - Output encoding
   - Security headers

### Monitoring and Compliance

1. **Security Monitoring**:
   - Intrusion detection
   - Anomaly detection
   - Log analysis
   - Vulnerability scanning

2. **Compliance Framework**:
   - SOC 2 compliance
   - GDPR compliance
   - CCPA compliance
   - Industry-specific regulations

## Deployment Architecture

### Environment Strategy

TuneMantra is deployed across multiple environments:

1. **Development**: For active development work
   - Isolated developer environments
   - Shared development services
   - Mocked external integrations

2. **Testing**: For automated testing
   - Integration test environment
   - Performance test environment
   - Security test environment

3. **Staging**: Production-like environment for verification
   - Mirrors production configuration
   - Limited production data
   - Final testing before production

4. **Production**: Live environment serving users
   - Multi-region deployment
   - High availability configuration
   - Full monitoring and alerting

### Infrastructure Architecture

The production infrastructure is designed for high availability and scalability:

1. **Cloud Provider**: AWS primary, with multi-cloud capability
   - EC2 for compute
   - RDS for PostgreSQL
   - ElastiCache for Redis
   - S3 for storage
   - Elasticsearch Service
   - CloudFront for CDN

2. **Regional Strategy**:
   - Primary region: US East
   - Secondary regions: EU West, Asia Pacific
   - Data replication between regions
   - Regional failover capability

3. **Network Architecture**:
   - VPC with public and private subnets
   - NAT gateways for private subnet egress
   - Load balancers for traffic distribution
   - VPN for administrative access

4. **Containerization**:
   - Docker for application packaging
   - ECS for container orchestration
   - ECR for container registry
   - Standardized container configuration

### Deployment Pipeline

The CI/CD pipeline automates deployment:

1. **Continuous Integration**:
   - Automated builds
   - Unit and integration testing
   - Code quality checks
   - Security scanning

2. **Continuous Delivery**:
   - Automated deployment to development
   - Manual approval for staging and production
   - Blue/green deployment strategy
   - Automated smoke testing

3. **Infrastructure as Code**:
   - Terraform for infrastructure provisioning
   - CloudFormation for AWS-specific resources
   - Version-controlled infrastructure
   - Environment templating

### Monitoring and Operations

Operational capabilities include:

1. **Monitoring Stack**:
   - Datadog for metrics and dashboards
   - ELK stack for log management
   - Sentry for error tracking
   - Custom health checks

2. **Alerting**:
   - PagerDuty for incident management
   - Slack integrations for notifications
   - Escalation policies
   - On-call rotations

3. **Backup and Recovery**:
   - Automated database backups
   - Point-in-time recovery capability
   - Cross-region backup replication
   - Regular recovery testing

## Performance Architecture

### Performance Requirements

The system is designed to meet these performance targets:

1. **Response Time**:
   - API requests: 95th percentile under 300ms
   - Web application: Page load under 2 seconds
   - Background jobs: Appropriate to the task

2. **Throughput**:
   - API: 1000+ requests per second
   - File processing: 100+ tracks per minute
   - Royalty calculations: Millions of calculations per hour

3. **Data Volume**:
   - Catalog: Millions of tracks
   - Rights: Millions of ownership records
   - Royalties: Billions of calculation records
   - Users: Thousands of concurrent users

### Performance Design Patterns

The architecture employs these performance patterns:

1. **Caching Strategy**:
   - Multi-level caching (application, API, database)
   - Cache invalidation policies
   - Cache warming for predictable data
   - Distributed caching with Redis

2. **Database Optimization**:
   - Query optimization and indexing
   - Read replicas for scaling reads
   - Connection pooling
   - Statement timeouts for runaway queries
   - Query plan analysis

3. **Asynchronous Processing**:
   - Background job processing
   - Task prioritization
   - Batch processing for efficiency
   - Work queues for load distribution

4. **Content Delivery**:
   - CDN for static assets
   - Asset optimization (compression, minification)
   - Browser caching directives
   - Image and media optimization

### Performance Testing

The performance testing strategy includes:

1. **Load Testing**:
   - Simulated user behavior
   - Gradual ramp-up patterns
   - Peak load simulation
   - Extended duration tests

2. **Stress Testing**:
   - Beyond-capacity testing
   - Resource exhaustion scenarios
   - Recovery testing
   - Failover testing

3. **Endurance Testing**:
   - Long-duration testing
   - Memory leak detection
   - Resource utilization monitoring
   - Performance degradation analysis

4. **Performance Monitoring**:
   - Real-time metrics collection
   - Performance baselines
   - Anomaly detection
   - Trend analysis

## Scalability and Resilience

### Scalability Approach

The system scales through these mechanisms:

1. **Horizontal Scaling**:
   - Stateless services for easy replication
   - Load-balanced service instances
   - Auto-scaling based on metrics
   - Geographic distribution

2. **Database Scaling**:
   - Read replicas for query scaling
   - Connection pooling
   - Sharding for extreme scale
   - Caching to reduce database load

3. **Storage Scaling**:
   - Object storage for unlimited asset growth
   - CDN for content distribution
   - Tiered storage for cost optimization
   - Archiving for cold data

4. **Processing Scaling**:
   - Distributed task processing
   - Work queue partitioning
   - Parallel processing for large tasks
   - Resource allocation control

### Resilience Design

The system is designed for resilience through:

1. **Fault Tolerance**:
   - No single points of failure
   - Service redundancy
   - Data replication
   - Geographic distribution

2. **Graceful Degradation**:
   - Feature prioritization
   - Fallback mechanisms
   - Partial functionality modes
   - User communication during issues

3. **Error Handling**:
   - Comprehensive error detection
   - Retry mechanisms with backoff
   - Circuit breakers for failing services
   - Fallback strategies for critical functions

4. **Disaster Recovery**:
   - Multi-region capability
   - Regular backup testing
   - Documented recovery procedures
   - Recovery time objectives (RTOs)
   - Recovery point objectives (RPOs)

### Resilience Testing

The resilience testing program includes:

1. **Chaos Engineering**:
   - Controlled failure injection
   - Service termination tests
   - Network disruption simulations
   - Resource constraint tests

2. **Failover Testing**:
   - Database failover drills
   - Region evacuation exercises
   - Service recovery validation
   - Data consistency verification

3. **Load Shedding Testing**:
   - Graceful degradation verification
   - Priority function preservation
   - Recovery from overload conditions
   - User experience during constraints

## Development Environment

### Local Development

Developers work with:

1. **Development Tooling**:
   - Visual Studio Code with standardized extensions
   - Docker for local service containers
   - Node.js and npm for build tools
   - Git for version control

2. **Local Environment**:
   - Docker Compose for service dependencies
   - Local environment variables
   - Mocked external services
   - Hot reloading for rapid iteration

3. **Testing Tools**:
   - Jest for unit testing
   - Cypress for end-to-end testing
   - ESLint and Prettier for code quality
   - TypeScript for type checking

### Continuous Integration

The CI system provides:

1. **Build Automation**:
   - Automated builds on commit
   - Dependency security scanning
   - Code quality checks
   - Test execution

2. **Pull Request Validation**:
   - Pre-merge checks
   - Code review assistance
   - Test coverage reporting
   - Performance impact estimation

3. **Release Management**:
   - Version tagging
   - Release notes generation
   - Artifact publishing
   - Deployment triggering

### Development Practices

The team follows these practices:

1. **Version Control**:
   - Feature branching
   - Pull request workflow
   - Conventional commits
   - Semantic versioning

2. **Testing Strategy**:
   - Test-driven development (TDD)
   - Automated testing
   - Integration testing
   - End-to-end testing

3. **Code Quality**:
   - Code reviews
   - Static analysis
   - Pair programming
   - Documentation standards

## Future Architecture

The architectural roadmap includes:

### Near-Term Evolution (6-12 months)

1. **GraphQL API Expansion**:
   - Complete GraphQL coverage for all resources
   - Subscription support for real-time updates
   - Improved client-side performance
   - Reduced over-fetching and under-fetching

2. **Enhanced Analytics**:
   - Real-time analytics processing
   - Machine learning integration
   - Predictive analytics capabilities
   - Improved visualization options

3. **Multi-Region Expansion**:
   - Full multi-region deployment
   - Geographic routing optimization
   - Data sovereignty compliance
   - Region-specific optimizations

### Medium-Term Evolution (1-2 years)

1. **Serverless Adoption**:
   - Serverless functions for appropriate workloads
   - Event-driven processing expansion
   - Improved cost efficiency
   - Automatic scaling

2. **AI Integration**:
   - Content analysis capabilities
   - Recommendation engines
   - Fraud detection
   - Automated metadata enhancement

3. **Enhanced Mobile Capabilities**:
   - Offline-first mobile experience
   - Native app performance improvements
   - Mobile-specific features
   - Cross-device synchronization

### Long-Term Vision (2+ years)

1. **Blockchain Integration**:
   - Rights verification on blockchain
   - Smart contracts for royalty agreements
   - Transparent payment tracking
   - Immutable audit trails

2. **Global Edge Computing**:
   - Edge processing for low-latency operations
   - Global content delivery optimization
   - Region-specific compliance handling
   - Network optimization

3. **Quantum-Safe Security**:
   - Post-quantum cryptography adoption
   - Quantum-resistant algorithms
   - Long-term security planning
   - Secure transition strategy

## Architecture Decision Records

Key architectural decisions and their rationales are documented below.

### ADR-001: Adoption of Microservices Architecture

**Context**: The initial architecture needed to balance rapid development with future scalability.

**Decision**: Adopt a modular microservices architecture, organizing services around business capabilities.

**Rationale**:
- Enables independent scaling of components
- Supports independent development and deployment
- Allows technology diversity where appropriate
- Facilitates team ownership of specific domains

**Consequences**:
- Increased operational complexity
- Need for service discovery and orchestration
- Inter-service communication overhead
- Distributed transaction challenges

### ADR-002: PostgreSQL as Primary Data Store

**Context**: Selection of a primary database technology for transactional data.

**Decision**: Use PostgreSQL as the primary relational database.

**Rationale**:
- Strong ACID compliance
- Robust JSON support for semi-structured data
- Rich feature set including advanced indexing
- Strong community and commercial support
- Excellent migration and scaling options

**Consequences**:
- Need for careful schema design
- Connection management complexity
- Potential scaling challenges for extreme write loads
- Need for additional technologies for certain use cases

### ADR-003: React for Frontend Development

**Context**: Selection of a frontend technology for the web application.

**Decision**: Use React with TypeScript for frontend development.

**Rationale**:
- Component-based architecture for reusability
- Strong typing with TypeScript for safety
- Rich ecosystem and community support
- Virtual DOM for performance optimization
- Support for server-side rendering

**Consequences**:
- Learning curve for developers
- Build system complexity
- Need for careful state management
- Browser compatibility considerations

### ADR-004: Event-Driven Architecture for Key Workflows

**Context**: Design of inter-service communication patterns.

**Decision**: Implement event-driven architecture for asynchronous operations.

**Rationale**:
- Decoupling of services
- Improved scalability for processing-intensive operations
- Natural fit for real-time features
- Support for replay and audit capabilities

**Consequences**:
- Event schema management complexity
- Eventual consistency challenges
- Debugging and monitoring complexity
- Need for robust error handling

### ADR-005: Multi-Region Deployment Strategy

**Context**: Geographic distribution strategy for global users.

**Decision**: Implement multi-region deployment with data replication.

**Rationale**:
- Improved global performance
- Disaster recovery capabilities
- Data sovereignty compliance
- High availability

**Consequences**:
- Increased operational complexity
- Data synchronization challenges
- Cost implications
- Complexity in deployment pipelines

---

© 2023-2025 TuneMantra. All rights reserved.

---

## documentation/technical/core/backend.md

# Backend Architecture Documentation

## Overview

TuneMantra's backend is built on a Node.js/Express foundation, providing a robust API layer for the React frontend and other clients. The architecture follows modern best practices with a focus on type safety, modular design, and scalability.

## Architecture Principles

The backend follows these core principles:

1. **Type Safety**: TypeScript throughout the codebase with strict typing
2. **Separation of Concerns**: Clear boundaries between layers
3. **Dependency Injection**: Loose coupling between components
4. **Schema-First Design**: Database and API schemas as the source of truth
5. **Comprehensive Testing**: Testable architecture with high coverage
6. **Secure by Default**: Security built into the architecture

## System Components

### Server Core

The server core (`server/index.ts`) sets up the Express application with:

- CORS configuration
- Security middleware (Helmet)
- JSON request parsing
- Cookie parsing
- Static file serving
- Session management
- Error handling

### API Routes

API routes (`server/routes.ts`) define the RESTful endpoints:

- Authentication endpoints
- User management
- Content management (tracks, releases)
- Distribution management
- Analytics endpoints
- Royalty management

Routes follow a consistent pattern:
- Clear path structure
- Proper HTTP method usage
- Input validation
- Authentication/authorization checks
- Consistent response format

### Authentication System

The authentication system (`server/auth.ts`) provides:

- Session-based authentication
- Password security (hashing with scrypt)
- Login/logout functionality
- User registration
- Authorization middleware
- API key authentication

### Storage Layer

The storage layer (`server/storage.ts`) abstracts database operations:

- Implementation of the `IStorage` interface
- CRUD operations for all entity types
- Transaction management
- Query optimization
- Connection pooling

### Services

Specialized service modules implement complex business logic:

- **Distribution Service**: Handles music distribution to platforms
- **Analytics Service**: Processes and aggregates analytics data
- **Royalty Calculation Service**: Implements royalty calculation logic
- **AI Tagging Service**: Provides AI-powered content analysis
- **Integration Service**: Manages integrations with external systems

### Database Connection

Database connectivity (`server/db.ts`) manages PostgreSQL connections:

- Connection pool configuration
- WebSocket support for Neon Serverless
- Environment-based configuration
- Drizzle ORM initialization

### Utilities

Shared utility modules provide reusable functionality:

- **Validation**: Request validation and sanitization
- **Error Handling**: Standardized error handling
- **ID Generation**: Secure ID generation and validation
- **Permissions**: Permission checking and role management
- **File Handling**: File upload and processing utilities

## Data Flow

### Request Lifecycle

1. **Request Arrival**: Client sends HTTP request to API endpoint
2. **Middleware Processing**:
   - Security headers applied
   - Session validation
   - CORS checks
   - Rate limiting
3. **Route Handling**:
   - Endpoint matched
   - Authentication/authorization checks
   - Input validation
4. **Business Logic**:
   - Service layer processes request
   - Storage layer executes database operations
5. **Response Generation**:
   - Standardized response format
   - Error handling if needed
   - Response sent to client

### Data Access Pattern

1. **API Layer**: Routes receive and validate requests
2. **Service Layer**: Implements business logic
3. **Storage Layer**: Executes database operations
4. **Database**: Stores and retrieves persistent data

## Code Organization

The backend code is organized into the following structure:

```
server/
├── config/          # Configuration files
├── lib/             # Shared libraries
├── middleware/      # Express middleware
├── routes/          # API routes
├── services/        # Business logic services
├── utils/           # Utility functions
├── auth.ts          # Authentication system
├── db.ts            # Database connection
├── index.ts         # Server entry point
├── routes.ts        # Route registration
├── storage.ts       # Data storage interface
├── types.ts         # TypeScript type definitions
└── vite.ts          # Development server configuration
```

## Key Interfaces

### IStorage Interface

The `IStorage` interface (`server/types.ts`) defines the contract for all data storage operations:

```typescript
export interface IStorage {
  sessionStore: session.Store;

  // User management methods
  getAllUsers(options?: {...}): Promise<User[]>;
  getUser(id: number): Promise<User | undefined>;
  // ... more user methods

  // Track management methods
  getTracksByUserId(userId: number): Promise<Track[]>;
  getTrackById(id: number): Promise<Track | undefined>;
  // ... more track methods

  // Release management methods
  getReleasesByUserId(userId: number): Promise<Release[]>;
  createRelease(userId: number, release: InsertRelease): Promise<Release>;
  // ... more release methods

  // Distribution methods
  getDistributionPlatforms(): Promise<DistributionPlatform[]>;
  createDistributionRecord(record: InsertDistributionRecord): Promise<DistributionRecord>;
  // ... more distribution methods

  // Analytics methods
  getTrackAnalytics(trackId: number): Promise<Analytics[]>;
  createAnalytics(analyticsData: InsertAnalytics): Promise<Analytics>;
  // ... more analytics methods

  // Royalty management methods
  getRoyaltyCalculations(userId: number): Promise<RoyaltyCalculation[]>;
  createRoyaltyCalculation(calculation: InsertRoyaltyCalculation): Promise<RoyaltyCalculation>;
  // ... more royalty methods
}
```

### Service Interfaces

Each service module implements a specific interface focused on its domain:

```typescript
// Example: Distribution Service Interface
interface IDistributionService {
  distributeRelease(releaseId: number, platformIds: number[]): Promise<DistributionRecord[]>;
  distributeToPlatform(releaseId: number, platformId: number): Promise<DistributionRecord>;
  processDistribution(distributionId: number): Promise<boolean>;
  getDistributionStatus(releaseId: number): Promise<DistributionStatus[]>;
  cancelDistribution(distributionId: number): Promise<boolean>;
  scheduleDistribution(releaseId: number, platformIds: number[], scheduleDate: Date): Promise<ScheduledDistribution>;
}
```

## Authentication Flow

### Session-Based Authentication

1. User submits login credentials
2. Server validates credentials
3. On success, creates session with user ID
4. Session ID stored in cookie
5. Subsequent requests include cookie for authentication

```typescript
// Login endpoint implementation
app.post('/api/auth/login', (req, res, next) => {
  passport.authenticate('local', (err, user, info) => {
    if (err) return next(err);
    if (!user) {
      return res.status(401).json({
        error: {
          message: info.message || 'Invalid credentials',
          code: 'INVALID_CREDENTIALS'
        }
      });
    }
    req.login(user, (err) => {
      if (err) return next(err);
      return res.json({ data: sanitizeUser(user), meta: {} });
    });
  })(req, res, next);
});
```

### API Key Authentication

1. Client includes API key in Authorization header
2. Server validates API key against database
3. Server checks key permissions against requested operation
4. On validation, request proceeds with associated user context

```typescript
// API key authentication middleware
const apiKeyAuth = async (req, res, next) => {
  const authHeader = req.headers.authorization;
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return res.status(401).json({
      error: {
        message: 'API key required',
        code: 'AUTH_REQUIRED'
      }
    });
  }

  const apiKey = authHeader.split(' ')[1];
  try {
    const keyData = await storage.getApiKeyByValue(apiKey);
    if (!keyData || !keyData.isActive) {
      return res.status(401).json({
        error: {
          message: 'Invalid API key',
          code: 'INVALID_API_KEY'
        }
      });
    }

    // Check if key has required scope
    if (req.requiredScope && !keyData.scopes.includes(req.requiredScope)) {
      return res.status(403).json({
        error: {
          message: 'Insufficient permissions',
          code: 'INSUFFICIENT_SCOPE'
        }
      });
    }

    // Set user context
    req.userId = keyData.userId;
    req.apiKey = keyData;
    next();
  } catch (error) {
    next(error);
  }
};
```

## Error Handling

The backend implements a standardized error handling approach:

1. **Custom Error Types**: Defined for different error scenarios
2. **Global Error Handler**: Catches and formats all errors
3. **Consistent Response Format**: All errors follow the same structure
4. **Error Logging**: Comprehensive error logging for troubleshooting

```typescript
// Global error handler
app.use((err: any, _req: Request, res: Response, _next: NextFunction) => {
  // Log error
  console.error(`[ERROR] ${new Date().toISOString()}:`, {
    message: err.message,
    stack: process.env.NODE_ENV !== 'production' ? err.stack : undefined,
    code: err.code
  });

  // Send standardized response
  res.status(err.status || 500).json({
    data: null,
    meta: {},
    error: {
      message: err.message || 'An unexpected error occurred',
      code: err.code || 'INTERNAL_ERROR',
      details: err.details || undefined
    }
  });
});
```

## Database Access

### Drizzle ORM Integration

The backend uses Drizzle ORM for type-safe database access:

1. **Schema Definition**: Schemas defined in `shared/schema.ts`
2. **Type Generation**: TypeScript types generated from schema
3. **Query Building**: Type-safe query construction
4. **Migrations**: Schema migration through Drizzle Kit

```typescript
// Example Drizzle ORM usage
export async function getUserByUsername(username: string): Promise<User | undefined> {
  const result = await db.select().from(schema.users).where(eq(schema.users.username, username)).limit(1);
  return result[0];
}

export async function createUser(insertUser: InsertUser): Promise<User> {
  if (insertUser.password) {
    insertUser.password = await hashPassword(insertUser.password);
  }
  
  const [result] = await db.insert(schema.users).values({
    ...insertUser,
    createdAt: new Date(),
    updatedAt: new Date()
  }).returning();
  
  return result;
}
```

### Connection Pooling

The backend uses connection pooling for efficient database access:

```typescript
// Connection pool configuration
export const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  max: 20,                 // Maximum connections in pool
  idleTimeoutMillis: 30000, // Close idle connections after 30s
  connectionTimeoutMillis: 2000, // Connection timeout
  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false
});

// Initialize Drizzle with the connection pool
export const db = drizzle({ client: pool, schema });
```

## Middleware Components

The backend uses various middleware components:

### Authentication Middleware

```typescript
export const requireAuth = (req: Request, res: Response, next: NextFunction) => {
  if (!req.isAuthenticated() || !req.user) {
    return res.status(401).json({
      error: {
        message: 'Authentication required',
        code: 'AUTH_REQUIRED'
      }
    });
  }
  
  req.userId = req.user.id;
  next();
};
```

### Validation Middleware

```typescript
export function validateRequest(schema: z.ZodType<any>, source: 'body' | 'query' | 'params' = 'body') {
  return (req: Request, res: Response, next: NextFunction) => {
    try {
      const data = schema.parse(req[source]);
      req[source] = data; // Replace with validated data
      next();
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({
          error: {
            message: 'Validation error',
            code: 'VALIDATION_ERROR',
            details: error.errors
          }
        });
      }
      next(error);
    }
  };
}
```

### Rate Limiting Middleware

```typescript
const apiLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // limit each IP to 100 requests per windowMs
  standardHeaders: true,
  message: {
    error: {
      message: 'Too many requests, please try again later',
      code: 'RATE_LIMIT_EXCEEDED'
    }
  }
});

app.use('/api/', apiLimiter);
```

## Service Implementation Patterns

### Singleton Services

Most services are implemented as static classes:

```typescript
export class AnalyticsService {
  static async getTrackAnalytics(trackId: number, startDate?: Date, endDate?: Date) {
    // Implementation
  }
  
  static async getReleaseAnalytics(releaseId: number, startDate?: Date, endDate?: Date) {
    // Implementation
  }
  
  // More methods...
}
```

### Dependency Injection

Some services use dependency injection for testing:

```typescript
export class RoyaltyService {
  private storage: IStorage;
  private analyticsService: IAnalyticsService;
  
  constructor(storage: IStorage, analyticsService: IAnalyticsService) {
    this.storage = storage;
    this.analyticsService = analyticsService;
  }
  
  async calculateRoyalties(trackId: number, period: string) {
    const analytics = await this.analyticsService.getTrackAnalytics(trackId);
    // Implementation using this.storage and analytics
  }
  
  // More methods...
}
```

## Performance Considerations

The backend implements several performance optimizations:

### Query Optimization

- Use of appropriate indexes
- Pagination for large result sets
- Selection of only needed fields
- Query parameterization

```typescript
// Example of optimized query with pagination
async function getAllUsers({ 
  status, 
  search,
  page = 1,
  limit = 20
}: { 
  status?: string; 
  search?: string;
  page?: number;
  limit?: number;
}): Promise<User[]> {
  let query = db.select().from(schema.users);
  
  if (status) {
    query = query.where(eq(schema.users.status, status));
  }
  
  if (search) {
    query = query.where(
      or(
        like(schema.users.username, `%${search}%`),
        like(schema.users.email, `%${search}%`),
        like(schema.users.fullName, `%${search}%`)
      )
    );
  }
  
  // Apply pagination
  const offset = (page - 1) * limit;
  query = query.limit(limit).offset(offset);
  
  return await query;
}
```

### Caching Strategies

- In-memory caching for frequently accessed data
- Cache invalidation on update operations
- TTL-based cache expiration

```typescript
// Example of caching implementation
const cache = new Map<string, { data: any, expiry: number }>();

async function getCachedData(key: string, ttlMs: number, fetchFn: () => Promise<any>) {
  const now = Date.now();
  const cached = cache.get(key);
  
  if (cached && cached.expiry > now) {
    return cached.data;
  }
  
  const data = await fetchFn();
  cache.set(key, { data, expiry: now + ttlMs });
  return data;
}

// Usage
async function getDistributionPlatforms() {
  return getCachedData(
    'distribution_platforms',
    1000 * 60 * 60, // 1 hour TTL
    () => db.select().from(schema.distributionPlatforms)
  );
}
```

### Batch Processing

- Batch operations for multiple database updates
- Background job processing for long-running tasks
- Chunked processing for large datasets

```typescript
// Example of batch processing
async function processBulkDistributionJob(jobId: number) {
  const job = await storage.getBulkDistributionJobById(jobId);
  const platforms = await storage.getDistributionPlatforms();
  
  // Update job status
  await storage.updateBulkDistributionJob(jobId, { status: 'processing' });
  
  try {
    // Process in chunks to avoid memory issues
    const releases = await storage.getReleasesByIds(job.releaseIds);
    const chunkSize = 10;
    
    for (let i = 0; i < releases.length; i += chunkSize) {
      const chunk = releases.slice(i, i + chunkSize);
      
      // Process chunk in parallel
      await Promise.all(chunk.map(async (release) => {
        for (const platformId of job.platformIds) {
          const platform = platforms.find(p => p.id === platformId);
          if (!platform) continue;
          
          try {
            await storage.createDistributionRecord({
              releaseId: release.id,
              platformId,
              status: 'pending',
              createdAt: new Date(),
              updatedAt: new Date()
            });
            
            // Update platform status
            await storage.updateBulkDistributionJobPlatformStatus(
              jobId, 
              platformId, 
              'processing', 
              { releaseId: release.id }
            );
            
            // Actual distribution process
            await distributionService.processDistribution(release.id, platformId);
            
            // Update success status
            await storage.updateBulkDistributionJobPlatformStatus(
              jobId, 
              platformId, 
              'completed', 
              { releaseId: release.id }
            );
          } catch (error) {
            // Log error and update status
            console.error(`Distribution error for release ${release.id} to platform ${platformId}:`, error);
            await storage.updateBulkDistributionJobPlatformStatus(
              jobId, 
              platformId, 
              'failed', 
              { 
                releaseId: release.id, 
                error: error.message 
              }
            );
          }
        }
      }));
    }
    
    // Update job completion
    await storage.updateBulkDistributionJob(jobId, { 
      status: 'completed',
      completedAt: new Date()
    });
  } catch (error) {
    // Handle overall job failure
    console.error(`Bulk distribution job ${jobId} failed:`, error);
    await storage.updateBulkDistributionJob(jobId, { 
      status: 'failed',
      error: error.message
    });
  }
}
```

## Security Implementation

The backend implements multiple security measures:

### Input Validation

All user input is validated using Zod schemas:

```typescript
export const insertUserSchema = createInsertSchema(users)
  .extend({
    password: z.string().min(8).max(100),
    confirmPassword: z.string().min(8).max(100)
  })
  .refine(data => data.password === data.confirmPassword, {
    message: "Passwords don't match",
    path: ["confirmPassword"]
  });
```

### Authentication Security

Secure password hashing and verification:

```typescript
export async function hashPassword(password: string): Promise<string> {
  const salt = randomBytes(16).toString('hex');
  const hash = await scryptAsync(password, salt, 64);
  return `${hash.toString('hex')}.${salt}`;
}

async function comparePasswords(supplied: string, stored: string): Promise<boolean> {
  const [hash, salt] = stored.split('.');
  const suppliedHash = await scryptAsync(supplied, salt, 64);
  return timingSafeEqual(
    Buffer.from(hash, 'hex'),
    suppliedHash
  );
}
```

### API Security

- HTTPS enforcement
- CORS configuration
- Rate limiting
- Content Security Policy

```typescript
// Security middleware configuration
app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      connectSrc: ["'self'", "https://api.example.com"],
      scriptSrc: ["'self'", "'unsafe-inline'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      imgSrc: ["'self'", "data:", "https://assets.example.com"],
      fontSrc: ["'self'", "https://fonts.googleapis.com"],
    }
  },
  hsts: {
    maxAge: 31536000,
    includeSubDomains: true,
    preload: true
  }
}));
```

## Testing Approach

The backend is designed for comprehensive testing:

### Unit Testing

- Testing individual functions and methods
- Mocking dependencies
- Testing edge cases and error handling

```typescript
// Example unit test
describe('hashPassword', () => {
  it('should hash a password', async () => {
    const password = 'securePassword123';
    const hashedPassword = await hashPassword(password);
    
    expect(hashedPassword).not.toBe(password);
    expect(hashedPassword).toContain('.');
    
    const parts = hashedPassword.split('.');
    expect(parts).toHaveLength(2);
  });
});
```

### Integration Testing

- Testing API endpoints
- Testing database interactions
- Testing service integrations

```typescript
// Example integration test
describe('User API', () => {
  beforeAll(async () => {
    await setupTestDatabase();
  });
  
  afterAll(async () => {
    await teardownTestDatabase();
  });
  
  it('should create a new user', async () => {
    const response = await request(app)
      .post('/api/auth/register')
      .send({
        username: 'testuser',
        password: 'password123',
        confirmPassword: 'password123',
        email: 'test@example.com',
        fullName: 'Test User'
      });
    
    expect(response.status).toBe(200);
    expect(response.body.data).toHaveProperty('id');
    expect(response.body.data.username).toBe('testuser');
  });
});
```

## External Integrations

The backend integrates with various external systems:

### Music Streaming Platforms

- API-based integrations with major streaming services
- Platform-specific authentication
- Content delivery protocols
- Response handling and error management

### Payment Processors

- Integration with payment gateways
- Secure handling of payment information
- Transaction processing and verification
- Refund and chargeback handling

### Analytics Services

- Data exchange with analytics providers
- ETL processes for data consolidation
- Reporting API integration
- Custom metrics tracking

## Deployment Considerations

The backend is designed for flexible deployment:

### Environment Configuration

- Environment-specific settings through `.env` files
- Validation of required environment variables
- Default values for optional settings
- Secrets management

### Scaling Strategy

- Stateless design for horizontal scaling
- Connection pooling for database efficiency
- Caching for reduced database load
- Background job processing for long-running tasks

### Monitoring

- Structured logging for observability
- Performance metrics collection
- Error tracking and alerting
- Health check endpoints

## Conclusion

TuneMantra's backend architecture provides a solid foundation for the platform with its focus on type safety, modular design, and scalability. The clear separation of concerns, comprehensive testing approach, and attention to security make it robust and maintainable.

The architecture balances flexibility and structure, allowing for future growth while maintaining consistency throughout the codebase. The use of TypeScript and Drizzle ORM provides strong guarantees about data types and database interactions, reducing the risk of runtime errors.

By following this architecture documentation, developers can understand the system's design, extend its functionality, and maintain its performance and security characteristics.

---

## documentation/technical/core/frontend.md

# Frontend Architecture Documentation

## Overview

TuneMantra's frontend is built using React with TypeScript, providing a responsive and intuitive user interface for artists, labels, and administrators. The architecture follows modern best practices with a focus on component reusability, state management, and user experience.

## Technology Stack

### Core Technologies

- **React**: Library for building user interfaces
- **TypeScript**: Typed superset of JavaScript for better developer experience
- **Vite**: Build tool for faster development and optimized production builds
- **TanStack Query**: Data fetching, caching, and state management
- **React Router DOM**: Routing and navigation
- **Wouter**: Lightweight routing alternative

### UI Framework

- **Tailwind CSS**: Utility-first CSS framework
- **Shadcn/UI**: Component library built on Radix UI primitives
- **Radix UI**: Unstyled, accessible UI components
- **Lucide React**: Icon library
- **Framer Motion**: Animation library

### Form Management

- **React Hook Form**: Form state management and validation
- **Zod**: Schema validation library
- **@hookform/resolvers**: Integration between React Hook Form and Zod

### Data Visualization

- **Recharts**: Composable charting library
- **React ChartJS**: ChartJS wrapper for React
- **D3.js**: Low-level data visualization library (for complex visualizations)

## Architecture Principles

The frontend follows these core principles:

1. **Component-Based Architecture**: Encapsulated, reusable components
2. **Typed Interfaces**: TypeScript for type safety across the application
3. **Separation of Concerns**: Clear boundaries between presentation, state, and logic
4. **Responsive Design**: Mobile-first approach to support all device sizes
5. **Accessibility**: WCAG compliance throughout the interface
6. **Performance Optimization**: Efficient rendering and loading strategies

## Application Structure

The frontend code is organized into the following structure:

```
client/
├── public/          # Static assets
├── src/
│   ├── components/  # React components
│   │   ├── ui/      # Base UI components
│   │   ├── layouts/ # Layout components
│   │   ├── forms/   # Form components
│   │   ├── charts/  # Data visualization components
│   │   └── feature/ # Feature-specific components
│   ├── hooks/       # Custom React hooks
│   ├── lib/         # Utility functions and constants
│   ├── pages/       # Page components
│   ├── schemas/     # Validation schemas
│   ├── services/    # API service functions
│   ├── styles/      # Global styles and Tailwind configuration
│   ├── types/       # TypeScript types and interfaces
│   ├── App.tsx      # Main application component
│   └── main.tsx     # Application entry point
├── index.html       # HTML template
└── vite.config.ts   # Vite configuration
```

## Component Architecture

### Component Hierarchy

The component hierarchy is structured for reusability and clarity:

1. **UI Components**: Base components like Button, Input, Card
2. **Layout Components**: Page layouts, navigation, headers
3. **Feature Components**: Domain-specific components for music, analytics, etc.
4. **Page Components**: Full page compositions combining other components

### Component Types

Components are categorized by responsibility:

- **Presentation Components**: Focus on UI rendering with minimal logic
- **Container Components**: Manage state and data fetching for child components
- **Layout Components**: Handle positioning and structure
- **Provider Components**: Supply context or state to component trees

### Component Pattern

Most components follow this pattern:

```tsx
// Example Component Pattern
import { useState, useEffect } from 'react';
import { useQuery } from '@tanstack/react-query';
import { Button } from '@/components/ui/button';
import { apiRequest } from '@/lib/queryClient';

// TypeScript interface for props
interface TrackListProps {
  userId: number;
  onTrackSelect?: (trackId: number) => void;
  limit?: number;
}

// Component implementation
export function TrackList({ userId, onTrackSelect, limit = 10 }: TrackListProps) {
  // Data fetching with TanStack Query
  const { data, isLoading, error } = useQuery({
    queryKey: ['/api/users', userId, 'tracks'],
    queryFn: () => apiRequest(`/api/users/${userId}/tracks?limit=${limit}`),
  });

  // Handle loading state
  if (isLoading) {
    return <div className="loading-spinner" />;
  }

  // Handle error state
  if (error) {
    return <div className="error-message">Failed to load tracks</div>;
  }

  // Render component
  return (
    <div className="track-list">
      <h2 className="text-xl font-bold mb-4">Your Tracks</h2>
      <ul className="space-y-2">
        {data.map((track) => (
          <li key={track.id} className="p-2 hover:bg-slate-100 rounded">
            <div className="flex justify-between items-center">
              <span>{track.title}</span>
              <Button 
                variant="ghost" 
                onClick={() => onTrackSelect?.(track.id)}
              >
                View Details
              </Button>
            </div>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

## State Management

### Local Component State

For component-specific state:

```tsx
function Counter() {
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}
```

### Form State

Form state managed with React Hook Form:

```tsx
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';

// Define schema with Zod
const schema = z.object({
  title: z.string().min(1, 'Title is required'),
  artist: z.string().min(1, 'Artist is required'),
  genre: z.string().min(1, 'Genre is required'),
});

// Infer TypeScript type from schema
type FormValues = z.infer<typeof schema>;

function TrackForm() {
  // Initialize form with schema validation
  const form = useForm<FormValues>({
    resolver: zodResolver(schema),
    defaultValues: {
      title: '',
      artist: '',
      genre: '',
    },
  });
  
  const onSubmit = (data: FormValues) => {
    console.log(data);
    // Submit data to API
  };
  
  return (
    <form onSubmit={form.handleSubmit(onSubmit)}>
      <div>
        <label>Title</label>
        <input {...form.register('title')} />
        {form.formState.errors.title && (
          <p>{form.formState.errors.title.message}</p>
        )}
      </div>
      
      <div>
        <label>Artist</label>
        <input {...form.register('artist')} />
        {form.formState.errors.artist && (
          <p>{form.formState.errors.artist.message}</p>
        )}
      </div>
      
      <div>
        <label>Genre</label>
        <input {...form.register('genre')} />
        {form.formState.errors.genre && (
          <p>{form.formState.errors.genre.message}</p>
        )}
      </div>
      
      <button type="submit">Submit</button>
    </form>
  );
}
```

### Server State

Server state managed with TanStack Query:

```tsx
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { apiRequest } from '@/lib/queryClient';

// Data fetching hook
function useUserTracks(userId: number) {
  return useQuery({
    queryKey: ['/api/users', userId, 'tracks'],
    queryFn: () => apiRequest(`/api/users/${userId}/tracks`),
  });
}

// Data mutation hook
function useCreateTrack() {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: (trackData) => 
      apiRequest('/api/tracks', { method: 'POST', data: trackData }),
    onSuccess: (data, variables, context) => {
      // Invalidate related queries to trigger refetch
      queryClient.invalidateQueries({ queryKey: ['/api/users', variables.userId, 'tracks'] });
    },
  });
}

// Usage in component
function TracksManager({ userId }) {
  const { data, isLoading } = useUserTracks(userId);
  const createTrack = useCreateTrack();
  
  const handleAddTrack = (trackData) => {
    createTrack.mutate({ ...trackData, userId });
  };
  
  // Component JSX
}
```

### Context API

For shared state across components:

```tsx
import { createContext, useContext, useState } from 'react';

// Create context with type
interface ThemeContextType {
  darkMode: boolean;
  toggleDarkMode: () => void;
}

const ThemeContext = createContext<ThemeContextType | undefined>(undefined);

// Provider component
export function ThemeProvider({ children }) {
  const [darkMode, setDarkMode] = useState(false);
  
  const toggleDarkMode = () => setDarkMode(!darkMode);
  
  return (
    <ThemeContext.Provider value={{ darkMode, toggleDarkMode }}>
      {children}
    </ThemeContext.Provider>
  );
}

// Custom hook for consuming context
export function useTheme() {
  const context = useContext(ThemeContext);
  
  if (context === undefined) {
    throw new Error('useTheme must be used within a ThemeProvider');
  }
  
  return context;
}
```

## Routing and Navigation

### Route Configuration

Using React Router DOM or Wouter for routing:

```tsx
import { Route, Switch } from 'wouter';
import Dashboard from '@/pages/Dashboard';
import Tracks from '@/pages/Tracks';
import Releases from '@/pages/Releases';
import Analytics from '@/pages/Analytics';
import Settings from '@/pages/Settings';
import NotFound from '@/pages/NotFound';

function AppRoutes() {
  return (
    <Switch>
      <Route path="/" component={Dashboard} />
      <Route path="/tracks" component={Tracks} />
      <Route path="/tracks/:id" component={TrackDetail} />
      <Route path="/releases" component={Releases} />
      <Route path="/releases/:id" component={ReleaseDetail} />
      <Route path="/analytics" component={Analytics} />
      <Route path="/settings" component={Settings} />
      <Route component={NotFound} />
    </Switch>
  );
}
```

### Protected Routes

Restricting access to authenticated users:

```tsx
import { Route, Redirect } from 'wouter';
import { useAuth } from '@/hooks/useAuth';

interface ProtectedRouteProps {
  component: React.ComponentType<any>;
  path: string;
  requiredRole?: string;
}

function ProtectedRoute({ component: Component, requiredRole, ...rest }: ProtectedRouteProps) {
  const { isAuthenticated, user } = useAuth();
  
  return (
    <Route
      {...rest}
      render={(props) => {
        // Check authentication
        if (!isAuthenticated) {
          return <Redirect to="/login" />;
        }
        
        // Check role if required
        if (requiredRole && user.role !== requiredRole) {
          return <Redirect to="/unauthorized" />;
        }
        
        // Render component if authorized
        return <Component {...props} />;
      }}
    />
  );
}
```

### Navigation Components

Consistent navigation pattern:

```tsx
import { Link, useLocation } from 'wouter';
import { useAuth } from '@/hooks/useAuth';

function Navigation() {
  const [location] = useLocation();
  const { isAuthenticated, user } = useAuth();
  
  return (
    <nav className="w-64 bg-slate-800 text-white h-screen p-4">
      <div className="logo mb-8">TuneMantra</div>
      
      <ul className="space-y-2">
        <li>
          <Link href="/">
            <a className={location === '/' ? 'active-link' : 'nav-link'}>
              Dashboard
            </a>
          </Link>
        </li>
        
        <li>
          <Link href="/tracks">
            <a className={location.startsWith('/tracks') ? 'active-link' : 'nav-link'}>
              Tracks
            </a>
          </Link>
        </li>
        
        <li>
          <Link href="/releases">
            <a className={location.startsWith('/releases') ? 'active-link' : 'nav-link'}>
              Releases
            </a>
          </Link>
        </li>
        
        <li>
          <Link href="/analytics">
            <a className={location.startsWith('/analytics') ? 'active-link' : 'nav-link'}>
              Analytics
            </a>
          </Link>
        </li>
        
        {/* Show admin section only for admin users */}
        {isAuthenticated && user.role === 'admin' && (
          <li>
            <Link href="/admin">
              <a className={location.startsWith('/admin') ? 'active-link' : 'nav-link'}>
                Admin
              </a>
            </Link>
          </li>
        )}
      </ul>
    </nav>
  );
}
```

## Data Fetching

### API Client

Centralized API client for consistent data fetching:

```tsx
// lib/queryClient.ts
import { QueryClient } from '@tanstack/react-query';
import axios from 'axios';

// Create axios instance
const axiosInstance = axios.create({
  baseURL: '/api',
  headers: {
    'Content-Type': 'application/json',
  },
  withCredentials: true, // Include cookies for authentication
});

// Create query client
export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      refetchOnWindowFocus: false,
      retry: 1,
      staleTime: 5 * 60 * 1000, // 5 minutes
    },
  },
});

// API request function
export async function apiRequest(url: string, options = {}) {
  try {
    const response = await axiosInstance(url, options);
    return response.data.data;
  } catch (error) {
    // Extract error message from response
    const message = error.response?.data?.error?.message || 'An error occurred';
    throw new Error(message);
  }
}
```

### Custom Hooks for API Calls

Domain-specific hooks for data operations:

```tsx
// hooks/useTracks.ts
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { apiRequest } from '@/lib/queryClient';
import { Track, InsertTrack } from '@shared/schema';

// Get all tracks for a user
export function useUserTracks(userId: number) {
  return useQuery<Track[]>({
    queryKey: ['/api/users', userId, 'tracks'],
    queryFn: () => apiRequest(`/api/users/${userId}/tracks`),
  });
}

// Get a single track by ID
export function useTrack(trackId: number) {
  return useQuery<Track>({
    queryKey: ['/api/tracks', trackId],
    queryFn: () => apiRequest(`/api/tracks/${trackId}`),
    enabled: !!trackId, // Only run if trackId is provided
  });
}

// Create a new track
export function useCreateTrack() {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: (track: InsertTrack) => 
      apiRequest('/api/tracks', { method: 'POST', data: track }),
    onSuccess: (data, variables) => {
      // Invalidate users tracks query to trigger refetch
      queryClient.invalidateQueries({ 
        queryKey: ['/api/users', variables.userId, 'tracks'] 
      });
    },
  });
}

// Update a track
export function useUpdateTrack() {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: ({ id, ...data }: { id: number, [key: string]: any }) => 
      apiRequest(`/api/tracks/${id}`, { method: 'PATCH', data }),
    onSuccess: (data) => {
      // Invalidate specific track query
      queryClient.invalidateQueries({ 
        queryKey: ['/api/tracks', data.id] 
      });
      // Invalidate user tracks query
      queryClient.invalidateQueries({ 
        queryKey: ['/api/users', data.userId, 'tracks'] 
      });
    },
  });
}
```

## Form Handling

### Form Components with Shadcn UI

Consistent form implementation using Shadcn UI components:

```tsx
import { zodResolver } from '@hookform/resolvers/zod';
import { useForm } from 'react-hook-form';
import * as z from 'zod';
import { Button } from '@/components/ui/button';
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from '@/components/ui/form';
import { Input } from '@/components/ui/input';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { useCreateTrack } from '@/hooks/useTracks';

// Define form schema
const formSchema = z.object({
  title: z.string().min(1, 'Title is required'),
  artist: z.string().min(1, 'Artist is required'),
  genre: z.string().min(1, 'Genre is required'),
  releaseDate: z.string().refine(date => !isNaN(Date.parse(date)), {
    message: 'Invalid date format',
  }),
});

function TrackForm({ userId }) {
  const createTrack = useCreateTrack();
  
  // Initialize form
  const form = useForm<z.infer<typeof formSchema>>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      title: '',
      artist: '',
      genre: '',
      releaseDate: new Date().toISOString().split('T')[0],
    },
  });
  
  // Form submission handler
  function onSubmit(values: z.infer<typeof formSchema>) {
    createTrack.mutate({
      ...values,
      userId,
      status: 'draft',
    });
  }
  
  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
        <FormField
          control={form.control}
          name="title"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Track Title</FormLabel>
              <FormControl>
                <Input {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
        
        <FormField
          control={form.control}
          name="artist"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Artist Name</FormLabel>
              <FormControl>
                <Input {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
        
        <FormField
          control={form.control}
          name="genre"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Genre</FormLabel>
              <Select onValueChange={field.onChange} defaultValue={field.value}>
                <FormControl>
                  <SelectTrigger>
                    <SelectValue placeholder="Select a genre" />
                  </SelectTrigger>
                </FormControl>
                <SelectContent>
                  <SelectItem value="pop">Pop</SelectItem>
                  <SelectItem value="rock">Rock</SelectItem>
                  <SelectItem value="hip_hop">Hip Hop</SelectItem>
                  <SelectItem value="electronic">Electronic</SelectItem>
                  <SelectItem value="classical">Classical</SelectItem>
                </SelectContent>
              </Select>
              <FormMessage />
            </FormItem>
          )}
        />
        
        <FormField
          control={form.control}
          name="releaseDate"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Release Date</FormLabel>
              <FormControl>
                <Input type="date" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
        
        <Button type="submit" disabled={createTrack.isPending}>
          {createTrack.isPending ? 'Saving...' : 'Save Track'}
        </Button>
      </form>
    </Form>
  );
}
```

### File Upload Components

Handling file uploads with progress tracking:

```tsx
import { useState } from 'react';
import { Button } from '@/components/ui/button';
import { Progress } from '@/components/ui/progress';

interface FileUploadProps {
  accept: string;
  onUpload: (file: File) => Promise<void>;
  label: string;
}

function FileUpload({ accept, onUpload, label }: FileUploadProps) {
  const [file, setFile] = useState<File | null>(null);
  const [progress, setProgress] = useState(0);
  const [isUploading, setIsUploading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    if (e.target.files && e.target.files[0]) {
      setFile(e.target.files[0]);
      setError(null);
    }
  };
  
  const handleUpload = async () => {
    if (!file) {
      setError('Please select a file');
      return;
    }
    
    setIsUploading(true);
    setProgress(0);
    
    try {
      // Simulate progress updates
      const progressInterval = setInterval(() => {
        setProgress((prev) => {
          if (prev >= 95) {
            clearInterval(progressInterval);
            return 95;
          }
          return prev + 5;
        });
      }, 300);
      
      // Perform actual upload
      await onUpload(file);
      
      // Complete progress and clear state
      clearInterval(progressInterval);
      setProgress(100);
      setFile(null);
      setError(null);
      
      // Reset form after delay
      setTimeout(() => {
        setProgress(0);
        setIsUploading(false);
      }, 1000);
    } catch (err) {
      setError(err.message || 'Upload failed');
      setIsUploading(false);
      setProgress(0);
    }
  };
  
  return (
    <div className="space-y-4">
      <div className="flex items-center space-x-4">
        <input
          type="file"
          accept={accept}
          onChange={handleFileChange}
          disabled={isUploading}
          className="hidden"
          id="file-upload"
        />
        <label
          htmlFor="file-upload"
          className="px-4 py-2 bg-slate-200 hover:bg-slate-300 rounded cursor-pointer"
        >
          {label}
        </label>
        <span className="text-sm text-gray-500">
          {file ? file.name : 'No file selected'}
        </span>
      </div>
      
      {file && (
        <Button 
          onClick={handleUpload} 
          disabled={isUploading}
          variant="default"
        >
          {isUploading ? 'Uploading...' : 'Upload File'}
        </Button>
      )}
      
      {isUploading && (
        <Progress value={progress} className="w-full" />
      )}
      
      {error && (
        <p className="text-red-500 text-sm">{error}</p>
      )}
    </div>
  );
}
```

## Authentication

### Authentication Context

Centralized authentication management:

```tsx
import { createContext, useContext, useState, useEffect } from 'react';
import { apiRequest } from '@/lib/queryClient';

// Type definitions
interface User {
  id: number;
  username: string;
  email: string;
  fullName: string;
  role: string;
  status: string;
}

interface AuthContextType {
  user: User | null;
  isAuthenticated: boolean;
  isLoading: boolean;
  login: (username: string, password: string) => Promise<void>;
  logout: () => Promise<void>;
  register: (userData: any) => Promise<void>;
}

// Create context
const AuthContext = createContext<AuthContextType | undefined>(undefined);

// Provider component
export function AuthProvider({ children }) {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  
  // Check authentication status on mount
  useEffect(() => {
    const checkAuth = async () => {
      try {
        const userData = await apiRequest('/api/auth/status');
        setUser(userData);
      } catch (error) {
        setUser(null);
      } finally {
        setIsLoading(false);
      }
    };
    
    checkAuth();
  }, []);
  
  // Login function
  const login = async (username: string, password: string) => {
    setIsLoading(true);
    try {
      const userData = await apiRequest('/api/auth/login', {
        method: 'POST',
        data: { username, password },
      });
      setUser(userData);
    } finally {
      setIsLoading(false);
    }
  };
  
  // Logout function
  const logout = async () => {
    setIsLoading(true);
    try {
      await apiRequest('/api/auth/logout', { method: 'POST' });
      setUser(null);
    } finally {
      setIsLoading(false);
    }
  };
  
  // Register function
  const register = async (userData: any) => {
    setIsLoading(true);
    try {
      const newUser = await apiRequest('/api/auth/register', {
        method: 'POST',
        data: userData,
      });
      setUser(newUser);
    } finally {
      setIsLoading(false);
    }
  };
  
  return (
    <AuthContext.Provider
      value={{
        user,
        isAuthenticated: !!user,
        isLoading,
        login,
        logout,
        register,
      }}
    >
      {children}
    </AuthContext.Provider>
  );
}

// Custom hook for using auth context
export function useAuth() {
  const context = useContext(AuthContext);
  
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  
  return context;
}
```

## Data Visualization

### Chart Components

Reusable chart components for analytics:

```tsx
import { 
  LineChart,
  Line,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  Legend,
  ResponsiveContainer 
} from 'recharts';

interface TimeSeriesChartProps {
  data: Array<{ date: string; [key: string]: any }>;
  dataKeys: Array<{ key: string; name: string; color: string }>;
  title: string;
  xAxisLabel?: string;
  yAxisLabel?: string;
}

export function TimeSeriesChart({
  data,
  dataKeys,
  title,
  xAxisLabel = 'Date',
  yAxisLabel,
}: TimeSeriesChartProps) {
  return (
    <div className="bg-white p-4 rounded-lg shadow">
      <h3 className="text-lg font-medium mb-4">{title}</h3>
      
      <div className="h-64 w-full">
        <ResponsiveContainer width="100%" height="100%">
          <LineChart
            data={data}
            margin={{ top: 5, right: 30, left: 20, bottom: 5 }}
          >
            <CartesianGrid strokeDasharray="3 3" />
            <XAxis 
              dataKey="date" 
              label={{ 
                value: xAxisLabel, 
                position: 'insideBottomRight', 
                offset: -10 
              }} 
            />
            <YAxis 
              label={
                yAxisLabel 
                  ? { 
                      value: yAxisLabel, 
                      angle: -90, 
                      position: 'insideLeft' 
                    } 
                  : undefined
              } 
            />
            <Tooltip />
            <Legend />
            
            {dataKeys.map((dataKey) => (
              <Line
                key={dataKey.key}
                type="monotone"
                dataKey={dataKey.key}
                name={dataKey.name}
                stroke={dataKey.color}
                activeDot={{ r: 8 }}
              />
            ))}
          </LineChart>
        </ResponsiveContainer>
      </div>
    </div>
  );
}
```

### Dashboard Components

Comprehensive dashboard layouts:

```tsx
import { useQuery } from '@tanstack/react-query';
import { apiRequest } from '@/lib/queryClient';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { TimeSeriesChart } from '@/components/charts/TimeSeriesChart';
import { PieChart } from '@/components/charts/PieChart';
import { StatCard } from '@/components/ui/stat-card';

function Dashboard() {
  const { data: dashboardData, isLoading } = useQuery({
    queryKey: ['/api/analytics/dashboard'],
    queryFn: () => apiRequest('/api/analytics/dashboard'),
  });
  
  if (isLoading) {
    return <div className="dashboard-loading">Loading dashboard data...</div>;
  }
  
  return (
    <div className="space-y-6">
      <h1 className="text-3xl font-bold">Dashboard</h1>
      
      {/* Summary stats */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
        <StatCard
          title="Total Streams"
          value={dashboardData.summary.totalStreams.toLocaleString()}
          change={dashboardData.summary.streamChange}
          changeLabel="vs last period"
        />
        
        <StatCard
          title="Total Revenue"
          value={`$${dashboardData.summary.totalRevenue.toFixed(2)}`}
          change={dashboardData.summary.revenueChange}
          changeLabel="vs last period"
        />
        
        <StatCard
          title="Active Releases"
          value={dashboardData.summary.activeReleases}
        />
        
        <StatCard
          title="Top Country"
          value={dashboardData.summary.topCountry}
        />
      </div>
      
      {/* Charts */}
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        <TimeSeriesChart
          title="Streams Over Time"
          data={dashboardData.streamTimeSeries}
          dataKeys={[
            { key: 'streams', name: 'Streams', color: '#3b82f6' }
          ]}
          yAxisLabel="Streams"
        />
        
        <TimeSeriesChart
          title="Revenue Over Time"
          data={dashboardData.revenueTimeSeries}
          dataKeys={[
            { key: 'revenue', name: 'Revenue ($)', color: '#10b981' }
          ]}
          yAxisLabel="Revenue ($)"
        />
      </div>
      
      {/* More detailed charts */}
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        <Card>
          <CardHeader>
            <CardTitle>Platform Breakdown</CardTitle>
          </CardHeader>
          <CardContent>
            <PieChart
              data={dashboardData.platformBreakdown}
              dataKey="streams"
              nameKey="platform"
              colors={['#3b82f6', '#ef4444', '#f59e0b', '#10b981', '#8b5cf6']}
            />
          </CardContent>
        </Card>
        
        <Card>
          <CardHeader>
            <CardTitle>Country Breakdown</CardTitle>
          </CardHeader>
          <CardContent>
            <PieChart
              data={dashboardData.countryBreakdown}
              dataKey="streams"
              nameKey="country"
              colors={['#3b82f6', '#ef4444', '#f59e0b', '#10b981', '#8b5cf6']}
            />
          </CardContent>
        </Card>
      </div>
      
      {/* Top performing content */}
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        <Card>
          <CardHeader>
            <CardTitle>Top Tracks</CardTitle>
          </CardHeader>
          <CardContent>
            <ul className="space-y-2">
              {dashboardData.topTracks.map((track) => (
                <li key={track.id} className="flex justify-between items-center p-2 border-b">
                  <span>{track.title}</span>
                  <span>{track.streams.toLocaleString()} streams</span>
                </li>
              ))}
            </ul>
          </CardContent>
        </Card>
        
        <Card>
          <CardHeader>
            <CardTitle>Top Releases</CardTitle>
          </CardHeader>
          <CardContent>
            <ul className="space-y-2">
              {dashboardData.topReleases.map((release) => (
                <li key={release.id} className="flex justify-between items-center p-2 border-b">
                  <span>{release.title}</span>
                  <span>{release.streams.toLocaleString()} streams</span>
                </li>
              ))}
            </ul>
          </CardContent>
        </Card>
      </div>
    </div>
  );
}
```

## Responsive Design

### Responsive Layout Components

Layout components with responsive behavior:

```tsx
// components/layouts/AppLayout.tsx
import { useState } from 'react';
import { Sidebar } from '@/components/layouts/Sidebar';
import { Header } from '@/components/layouts/Header';

interface AppLayoutProps {
  children: React.ReactNode;
}

export function AppLayout({ children }: AppLayoutProps) {
  const [sidebarOpen, setSidebarOpen] = useState(false);
  
  return (
    <div className="min-h-screen bg-slate-50">
      {/* Mobile sidebar */}
      <div className={`md:hidden fixed inset-0 z-50 bg-black bg-opacity-50 transition-opacity ${
        sidebarOpen ? 'opacity-100' : 'opacity-0 pointer-events-none'
      }`}>
        <div className="absolute inset-0" onClick={() => setSidebarOpen(false)} />
        <div className={`fixed inset-y-0 left-0 w-64 bg-white shadow-lg transform transition-transform ${
          sidebarOpen ? 'translate-x-0' : '-translate-x-full'
        }`}>
          <Sidebar onNavItemClick={() => setSidebarOpen(false)} />
        </div>
      </div>
      
      {/* Desktop sidebar */}
      <div className="hidden md:block fixed inset-y-0 left-0 w-64 bg-white shadow-lg">
        <Sidebar />
      </div>
      
      {/* Main content */}
      <div className="md:pl-64 flex flex-col flex-1">
        <Header onMenuClick={() => setSidebarOpen(true)} />
        
        <main className="flex-1 p-6">
          <div className="max-w-7xl mx-auto">
            {children}
          </div>
        </main>
      </div>
    </div>
  );
}
```

### Responsive UI Components

UI components that adapt to different screen sizes:

```tsx
// components/ui/responsive-grid.tsx
import { ReactNode } from 'react';

interface ResponsiveGridProps {
  children: ReactNode;
  columns?: {
    sm?: number;
    md?: number;
    lg?: number;
    xl?: number;
  };
  gap?: string;
}

export function ResponsiveGrid({ 
  children, 
  columns = { sm: 1, md: 2, lg: 3, xl: 4 },
  gap = 'gap-6',
}: ResponsiveGridProps) {
  // Build class string based on column configuration
  const columnClasses = [
    `grid-cols-${columns.sm || 1}`,
    `md:grid-cols-${columns.md || 2}`,
    `lg:grid-cols-${columns.lg || 3}`,
    `xl:grid-cols-${columns.xl || 4}`,
  ].join(' ');
  
  return (
    <div className={`grid ${columnClasses} ${gap}`}>
      {children}
    </div>
  );
}
```

## Error Handling

### Error Boundary Component

Catch and display React component errors:

```tsx
import { Component, ErrorInfo, ReactNode } from 'react';

interface ErrorBoundaryProps {
  children: ReactNode;
  fallback?: ReactNode;
}

interface ErrorBoundaryState {
  hasError: boolean;
  error?: Error;
}

export class ErrorBoundary extends Component<ErrorBoundaryProps, ErrorBoundaryState> {
  constructor(props: ErrorBoundaryProps) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error: Error): ErrorBoundaryState {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo): void {
    // Log error to monitoring service
    console.error('Component error:', error, errorInfo);
  }

  render(): ReactNode {
    if (this.state.hasError) {
      if (this.props.fallback) {
        return this.props.fallback;
      }
      
      return (
        <div className="p-6 bg-red-50 border border-red-200 rounded-lg">
          <h2 className="text-xl font-bold text-red-700 mb-2">Something went wrong</h2>
          <p className="text-red-600 mb-4">
            An error occurred while rendering this component.
          </p>
          {this.state.error && (
            <pre className="bg-white p-4 rounded text-sm overflow-auto">
              {this.state.error.toString()}
            </pre>
          )}
          <button
            className="mt-4 px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700"
            onClick={() => this.setState({ hasError: false, error: undefined })}
          >
            Try again
          </button>
        </div>
      );
    }

    return this.props.children;
  }
}
```

### Error State Components

Standardized error display components:

```tsx
// components/ui/error-display.tsx
import { AlertCircle } from 'lucide-react';
import { Button } from '@/components/ui/button';

interface ErrorDisplayProps {
  title?: string;
  message: string;
  error?: Error;
  showDetails?: boolean;
  onRetry?: () => void;
}

export function ErrorDisplay({
  title = 'Error',
  message,
  error,
  showDetails = false,
  onRetry,
}: ErrorDisplayProps) {
  return (
    <div className="rounded-md bg-red-50 p-4 border border-red-200">
      <div className="flex">
        <div className="flex-shrink-0">
          <AlertCircle className="h-5 w-5 text-red-400" />
        </div>
        <div className="ml-3">
          <h3 className="text-sm font-medium text-red-800">{title}</h3>
          <div className="mt-2 text-sm text-red-700">
            <p>{message}</p>
          </div>
          
          {showDetails && error && (
            <div className="mt-2">
              <details className="text-xs">
                <summary className="cursor-pointer text-red-800 hover:text-red-900">
                  Show technical details
                </summary>
                <pre className="mt-2 whitespace-pre-wrap bg-white p-2 rounded border border-red-200">
                  {error.toString()}
                </pre>
              </details>
            </div>
          )}
          
          {onRetry && (
            <div className="mt-4">
              <Button
                variant="destructive"
                size="sm"
                onClick={onRetry}
              >
                Try Again
              </Button>
            </div>
          )}
        </div>
      </div>
    </div>
  );
}
```

## Notifications

### Toast Notifications

Toast notification system for user feedback:

```tsx
// components/ui/toast.tsx
import * as React from 'react';
import { cn } from '@/lib/utils';
import { Check, X, AlertCircle, Info } from 'lucide-react';

// Toast context
interface ToastContextType {
  toasts: Toast[];
  addToast: (toast: Omit<Toast, 'id'>) => void;
  removeToast: (id: string) => void;
}

interface Toast {
  id: string;
  type: 'success' | 'error' | 'info' | 'warning';
  title: string;
  message?: string;
  duration?: number; // milliseconds
}

const ToastContext = React.createContext<ToastContextType | undefined>(undefined);

// Toast provider
export function ToastProvider({ children }: { children: React.ReactNode }) {
  const [toasts, setToasts] = React.useState<Toast[]>([]);
  
  const addToast = React.useCallback((toast: Omit<Toast, 'id'>) => {
    const id = Date.now().toString();
    const newToast = { ...toast, id };
    
    setToasts((prevToasts) => [...prevToasts, newToast]);
    
    if (toast.duration !== 0) {
      const duration = toast.duration || 5000; // Default 5 seconds
      setTimeout(() => {
        removeToast(id);
      }, duration);
    }
  }, []);
  
  const removeToast = React.useCallback((id: string) => {
    setToasts((prevToasts) => prevToasts.filter((toast) => toast.id !== id));
  }, []);
  
  return (
    <ToastContext.Provider value={{ toasts, addToast, removeToast }}>
      {children}
      <ToastContainer />
    </ToastContext.Provider>
  );
}

// Custom hook for using toasts
export function useToast() {
  const context = React.useContext(ToastContext);
  
  if (context === undefined) {
    throw new Error('useToast must be used within a ToastProvider');
  }
  
  return context;
}

// Toast component
function ToastComponent({ toast, onClose }: { toast: Toast; onClose: () => void }) {
  const { type, title, message } = toast;
  
  const icons = {
    success: <Check className="h-5 w-5 text-green-500" />,
    error: <AlertCircle className="h-5 w-5 text-red-500" />,
    warning: <AlertCircle className="h-5 w-5 text-yellow-500" />,
    info: <Info className="h-5 w-5 text-blue-500" />,
  };
  
  const colorClasses = {
    success: 'border-green-200 bg-green-50',
    error: 'border-red-200 bg-red-50',
    warning: 'border-yellow-200 bg-yellow-50',
    info: 'border-blue-200 bg-blue-50',
  };
  
  return (
    <div
      className={cn(
        'flex w-full max-w-sm overflow-hidden rounded-lg border shadow-lg',
        colorClasses[type]
      )}
    >
      <div className="flex items-center p-4">
        <div className="flex-shrink-0">{icons[type]}</div>
        <div className="ml-3 flex-1">
          <p className="text-sm font-medium">{title}</p>
          {message && <p className="mt-1 text-sm opacity-90">{message}</p>}
        </div>
        <button
          type="button"
          className="ml-4 flex-shrink-0 rounded text-gray-400 hover:text-gray-700 focus:outline-none"
          onClick={onClose}
        >
          <X className="h-5 w-5" />
        </button>
      </div>
    </div>
  );
}

// Toast container (renders all active toasts)
function ToastContainer() {
  const { toasts, removeToast } = useToast();
  
  return (
    <div className="fixed bottom-0 right-0 z-50 p-4 sm:p-6 md:max-w-md space-y-4">
      {toasts.map((toast) => (
        <div
          key={toast.id}
          className="transform transition-all duration-300 ease-in-out"
        >
          <ToastComponent toast={toast} onClose={() => removeToast(toast.id)} />
        </div>
      ))}
    </div>
  );
}
```

## Performance Optimization

### Memoization

Using memo and callback for performance:

```tsx
import { memo, useCallback } from 'react';

interface TrackItemProps {
  id: number;
  title: string;
  artist: string;
  streams: number;
  onSelect: (id: number) => void;
}

const TrackItem = memo(({ id, title, artist, streams, onSelect }: TrackItemProps) => {
  const handleClick = useCallback(() => {
    onSelect(id);
  }, [id, onSelect]);
  
  return (
    <div 
      className="p-4 border rounded-lg hover:bg-slate-50 cursor-pointer"
      onClick={handleClick}
    >
      <h3 className="font-medium">{title}</h3>
      <p className="text-sm text-gray-500">{artist}</p>
      <p className="text-sm mt-2">{streams.toLocaleString()} streams</p>
    </div>
  );
});
TrackItem.displayName = 'TrackItem';

export default TrackItem;
```

### Virtualized Lists

Efficiently rendering large lists:

```tsx
import { useVirtualizer } from '@tanstack/react-virtual';
import { useRef } from 'react';

interface VirtualListProps<T> {
  items: T[];
  renderItem: (item: T, index: number) => React.ReactNode;
  itemHeight: number;
  height: number;
  width: '100%' | number;
}

export function VirtualList<T>({
  items,
  renderItem,
  itemHeight,
  height,
  width = '100%',
}: VirtualListProps<T>) {
  const parentRef = useRef<HTMLDivElement>(null);
  
  const virtualizer = useVirtualizer({
    count: items.length,
    getScrollElement: () => parentRef.current,
    estimateSize: () => itemHeight,
  });
  
  return (
    <div
      ref={parentRef}
      style={{
        height,
        width,
        overflow: 'auto',
      }}
    >
      <div
        style={{
          height: `${virtualizer.getTotalSize()}px`,
          position: 'relative',
        }}
      >
        {virtualizer.getVirtualItems().map((virtualItem) => (
          <div
            key={virtualItem.key}
            style={{
              position: 'absolute',
              top: 0,
              left: 0,
              width: '100%',
              height: `${itemHeight}px`,
              transform: `translateY(${virtualItem.start}px)`,
            }}
          >
            {renderItem(items[virtualItem.index], virtualItem.index)}
          </div>
        ))}
      </div>
    </div>
  );
}

// Usage
function TrackListVirtualized({ tracks }) {
  return (
    <VirtualList
      items={tracks}
      height={500}
      itemHeight={80}
      renderItem={(track) => (
        <div className="p-4 border-b">
          <h3>{track.title}</h3>
          <p>{track.artist}</p>
        </div>
      )}
    />
  );
}
```

### Lazy Loading

Lazy loading components for better initial load time:

```tsx
import { lazy, Suspense } from 'react';
import { Route, Switch } from 'wouter';
import { LoadingSpinner } from '@/components/ui/loading-spinner';

// Lazy load pages
const Dashboard = lazy(() => import('@/pages/Dashboard'));
const Tracks = lazy(() => import('@/pages/Tracks'));
const TrackDetail = lazy(() => import('@/pages/TrackDetail'));
const Releases = lazy(() => import('@/pages/Releases'));
const ReleaseDetail = lazy(() => import('@/pages/ReleaseDetail'));
const Analytics = lazy(() => import('@/pages/Analytics'));
const Settings = lazy(() => import('@/pages/Settings'));

function AppRoutes() {
  return (
    <Suspense fallback={<LoadingSpinner />}>
      <Switch>
        <Route path="/" component={Dashboard} />
        <Route path="/tracks" component={Tracks} />
        <Route path="/tracks/:id" component={TrackDetail} />
        <Route path="/releases" component={Releases} />
        <Route path="/releases/:id" component={ReleaseDetail} />
        <Route path="/analytics" component={Analytics} />
        <Route path="/settings" component={Settings} />
        <Route component={NotFound} />
      </Switch>
    </Suspense>
  );
}
```

## Accessibility

### Focus Management

Proper focus management for accessibility:

```tsx
import { useEffect, useRef } from 'react';

interface FocusTrapProps {
  children: React.ReactNode;
  isActive: boolean;
  onEscape?: () => void;
}

export function FocusTrap({ children, isActive, onEscape }: FocusTrapProps) {
  const containerRef = useRef<HTMLDivElement>(null);
  const previousFocusRef = useRef<HTMLElement | null>(null);
  
  // Save previous focus when trap activates
  useEffect(() => {
    if (isActive) {
      previousFocusRef.current = document.activeElement as HTMLElement;
    }
  }, [isActive]);
  
  // Restore focus when trap deactivates
  useEffect(() => {
    if (!isActive && previousFocusRef.current) {
      previousFocusRef.current.focus();
    }
    
    return () => {
      if (previousFocusRef.current) {
        previousFocusRef.current.focus();
      }
    };
  }, [isActive]);
  
  // Focus first focusable element when trap activates
  useEffect(() => {
    if (isActive && containerRef.current) {
      const focusableElements = containerRef.current.querySelectorAll(
        'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
      );
      
      if (focusableElements.length > 0) {
        (focusableElements[0] as HTMLElement).focus();
      }
    }
  }, [isActive]);
  
  // Handle key events (escape and tab trap)
  useEffect(() => {
    if (!isActive) return;
    
    const handleKeyDown = (event: KeyboardEvent) => {
      // Handle escape
      if (event.key === 'Escape' && onEscape) {
        onEscape();
        return;
      }
      
      // Handle tab trap
      if (event.key === 'Tab' && containerRef.current) {
        const focusableElements = Array.from(
          containerRef.current.querySelectorAll(
            'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
          )
        ) as HTMLElement[];
        
        if (focusableElements.length === 0) return;
        
        const firstElement = focusableElements[0];
        const lastElement = focusableElements[focusableElements.length - 1];
        
        // If shift+tab on first element, move to last element
        if (event.shiftKey && document.activeElement === firstElement) {
          lastElement.focus();
          event.preventDefault();
        } 
        // If tab on last element, move to first element
        else if (!event.shiftKey && document.activeElement === lastElement) {
          firstElement.focus();
          event.preventDefault();
        }
      }
    };
    
    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, [isActive, onEscape]);
  
  return <div ref={containerRef}>{children}</div>;
}
```

### ARIA Support

Components with proper ARIA attributes:

```tsx
import { useState, useId } from 'react';

interface ExpandableSectionProps {
  title: string;
  children: React.ReactNode;
  defaultExpanded?: boolean;
}

export function ExpandableSection({
  title,
  children,
  defaultExpanded = false,
}: ExpandableSectionProps) {
  const [expanded, setExpanded] = useState(defaultExpanded);
  const id = useId();
  const contentId = `content-${id}`;
  const headerId = `header-${id}`;
  
  return (
    <div className="border rounded-lg overflow-hidden">
      <h3>
        <button
          id={headerId}
          aria-expanded={expanded}
          aria-controls={contentId}
          className="flex justify-between items-center w-full px-4 py-3 bg-slate-50 hover:bg-slate-100 focus:outline-none focus:ring-2 focus:ring-blue-500"
          onClick={() => setExpanded(!expanded)}
        >
          <span className="font-medium">{title}</span>
          <svg
            className={`w-5 h-5 transform transition-transform ${
              expanded ? 'rotate-180' : ''
            }`}
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
            xmlns="http://www.w3.org/2000/svg"
          >
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth={2}
              d="M19 9l-7 7-7-7"
            />
          </svg>
        </button>
      </h3>
      <div
        id={contentId}
        role="region"
        aria-labelledby={headerId}
        className={`transition-all duration-300 ease-in-out overflow-hidden ${
          expanded ? 'max-h-96' : 'max-h-0'
        }`}
      >
        <div className="p-4">{children}</div>
      </div>
    </div>
  );
}
```

## Testing

### Component Testing

Testing components with React Testing Library:

```tsx
// TrackList.test.tsx
import { render, screen, fireEvent } from '@testing-library/react';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { TrackList } from './TrackList';

// Mock API responses
jest.mock('@/lib/queryClient', () => ({
  apiRequest: jest.fn().mockImplementation(() => {
    return Promise.resolve([
      { id: 1, title: 'Track 1', artist: 'Artist 1', streams: 1000 },
      { id: 2, title: 'Track 2', artist: 'Artist 2', streams: 2000 },
    ]);
  }),
  queryClient: new QueryClient(),
}));

describe('TrackList', () => {
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: {
        retry: false,
      },
    },
  });
  
  const renderComponent = (props = {}) => {
    return render(
      <QueryClientProvider client={queryClient}>
        <TrackList userId={1} {...props} />
      </QueryClientProvider>
    );
  };
  
  beforeEach(() => {
    queryClient.clear();
  });
  
  it('renders loading state initially', () => {
    renderComponent();
    expect(screen.getByText(/loading/i)).toBeInTheDocument();
  });
  
  it('renders track list when data is loaded', async () => {
    renderComponent();
    
    // Wait for data to load
    const track1 = await screen.findByText('Track 1');
    const track2 = await screen.findByText('Track 2');
    
    expect(track1).toBeInTheDocument();
    expect(track2).toBeInTheDocument();
  });
  
  it('calls onTrackSelect when a track is clicked', async () => {
    const onTrackSelect = jest.fn();
    renderComponent({ onTrackSelect });
    
    // Wait for data to load
    const viewButtons = await screen.findAllByText('View Details');
    expect(viewButtons).toHaveLength(2);
    
    // Click the first view button
    fireEvent.click(viewButtons[0]);
    
    // Check if the callback was called with the correct ID
    expect(onTrackSelect).toHaveBeenCalledWith(1);
  });
});
```

### Hook Testing

Testing custom hooks:

```tsx
// useUserTracks.test.ts
import { renderHook, waitFor } from '@testing-library/react';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { useUserTracks } from './useUserTracks';

// Mock API responses
jest.mock('@/lib/queryClient', () => ({
  apiRequest: jest.fn().mockImplementation(() => {
    return Promise.resolve([
      { id: 1, title: 'Track 1', artist: 'Artist 1' },
      { id: 2, title: 'Track 2', artist: 'Artist 2' },
    ]);
  }),
}));

describe('useUserTracks', () => {
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: {
        retry: false,
      },
    },
  });
  
  const wrapper = ({ children }) => (
    <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
  );
  
  beforeEach(() => {
    queryClient.clear();
  });
  
  it('returns user tracks data when successful', async () => {
    const { result } = renderHook(() => useUserTracks(1), { wrapper });
    
    // Initial state should be loading
    expect(result.current.isLoading).toBe(true);
    expect(result.current.data).toBeUndefined();
    
    // Wait for data to be loaded
    await waitFor(() => expect(result.current.isLoading).toBe(false));
    
    // Check loaded data
    expect(result.current.data).toHaveLength(2);
    expect(result.current.data[0].title).toBe('Track 1');
    expect(result.current.data[1].title).toBe('Track 2');
  });
});
```

## Deployment

### Bundle Optimization

Optimizing the application bundle:

```typescript
// vite.config.ts
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import path from 'path';

export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
      '@shared': path.resolve(__dirname, '../shared'),
    },
  },
  build: {
    target: 'es2015',
    minify: 'terser',
    cssMinify: true,
    rollupOptions: {
      output: {
        manualChunks: {
          react: ['react', 'react-dom'],
          tanstack: ['@tanstack/react-query'],
          charts: ['recharts', 'react-chartjs-2'],
        },
      },
    },
    chunkSizeWarningLimit: 1000,
  },
  server: {
    proxy: {
      '/api': {
        target: 'http://localhost:5000',
        changeOrigin: true,
      },
    },
  },
});
```

### Environment Configuration

Managing environment-specific configuration:

```typescript
// lib/config.ts
interface AppConfig {
  apiUrl: string;
  environment: 'development' | 'production' | 'test';
  features: {
    analytics: boolean;
    distributionService: boolean;
    aiTagging: boolean;
  };
}

export const config: AppConfig = {
  apiUrl: import.meta.env.VITE_API_URL || '',
  environment: (import.meta.env.MODE as 'development' | 'production' | 'test') || 'development',
  features: {
    analytics: import.meta.env.VITE_FEATURE_ANALYTICS === 'true',
    distributionService: import.meta.env.VITE_FEATURE_DISTRIBUTION === 'true',
    aiTagging: import.meta.env.VITE_FEATURE_AI_TAGGING === 'true',
  },
};
```

## Conclusion

TuneMantra's frontend architecture provides a powerful, flexible foundation for a complex music rights management platform. By leveraging modern React patterns, TypeScript, and a component-based approach, the frontend delivers a responsive, accessible, and maintainable user interface.

The architecture emphasizes:

1. **Type Safety**: TypeScript throughout the codebase ensures robust type checking
2. **Component Reusability**: Well-designed components that can be composed for complex interfaces
3. **State Management**: Efficient state management with React Query for server state
4. **Performance**: Optimizations like virtualization, memoization, and lazy loading
5. **Accessibility**: ARIA compliance and keyboard navigation support
6. **Responsiveness**: Mobile-first design that works on all device sizes

This architecture enables developers to efficiently build and maintain the TuneMantra platform while providing users with a robust, intuitive interface for managing their music rights and royalties.

---

## documentation/technical/database/data-models.md

# TuneMantra Data Models

<div align="center">
  <img src="../../diagrams/data-models-header.svg" alt="TuneMantra Data Models" width="800"/>
</div>

## Introduction

This document provides a comprehensive overview of TuneMantra's data models, their relationships, and implementation details. The data architecture is designed around domain-driven principles, with clear boundaries between different functional areas while maintaining the necessary relationships for cross-domain operations.

The database uses PostgreSQL with Drizzle ORM for type-safe access and schema management. The schema is organized by domain contexts with careful consideration for performance, integrity, and scalability.

## Table of Contents

- [Schema Overview](#schema-overview)
- [Core Data Models](#core-data-models)
- [User Management Domain](#user-management-domain)
- [Content Management Domain](#content-management-domain)
- [Distribution Domain](#distribution-domain)
- [Rights Management Domain](#rights-management-domain)
- [Financial Domain](#financial-domain)
- [Analytics Domain](#analytics-domain)
- [Data Relationships](#data-relationships)
- [Schema Evolution](#schema-evolution)

## Schema Overview

TuneMantra's database schema is divided into distinct domains, each representing a core business capability:

<div align="center">
  <img src="../../diagrams/schema-domains.svg" alt="Schema Domains" width="700"/>
</div>

Each domain has its own set of tables with clear responsibilities:

1. **User Management Domain**
   - Handles user accounts, teams, and permissions
   - Manages authentication and authorization data
   - Stores profile and preference information

2. **Content Management Domain**
   - Manages tracks, releases, and artists
   - Handles metadata and assets
   - Tracks content relationships and versions

3. **Distribution Domain**
   - Manages platform connections and delivery
   - Tracks distribution status and availability
   - Stores platform-specific requirements and metadata

4. **Rights Management Domain**
   - Tracks ownership and rights claims
   - Manages splits and shares
   - Stores contracts and agreements

5. **Financial Domain**
   - Processes royalty calculations
   - Manages payment information
   - Tracks transactions and statements

6. **Analytics Domain**
   - Stores performance metrics
   - Manages report data and configurations
   - Tracks user engagement and platform statistics

## Core Data Models

The primary entities that form the foundation of TuneMantra's data model:

### User

The `users` table represents platform users and their core attributes:

```typescript
export const users = pgTable("users", {
  id: serial("id").primaryKey(),
  username: text("username").notNull().unique(),
  email: text("email").notNull().unique(),
  passwordHash: text("password_hash").notNull(),
  firstName: text("first_name"),
  lastName: text("last_name"),
  role: userRoleEnum("role").default("artist").notNull(),
  status: userStatusEnum("status").default("pending").notNull(),
  parentId: integer("parent_id").references(() => users.id),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
  lastLoginAt: timestamp("last_login_at"),
  profileImageUrl: text("profile_image_url"),
  timezone: text("timezone").default("UTC"),
  accountSettings: jsonb("account_settings"),
  notificationPreferences: jsonb("notification_preferences"),
  verificationStatus: approvalStatusEnum("verification_status").default("pending"),
  labelSettings: jsonb("label_settings"),
  marketingConsent: boolean("marketing_consent").default(false),
  taxId: text("tax_id"),
  dateOfBirth: date("date_of_birth"),
  country: text("country"),
  city: text("city"),
  address: text("address"),
  postalCode: text("postal_code"),
  phone: text("phone"),
  website: text("website"),
  biography: text("biography"),
  businessName: text("business_name"),
  businessType: text("business_type"),
  isAdmin: boolean("is_admin").default(false),
  isVerified: boolean("is_verified").default(false),
  isBanned: boolean("is_banned").default(false),
});
```

Key aspects:
- Support for hierarchical relationships (parent labels with sub-users)
- Role-based access control
- Account status tracking
- Rich profile data
- Flexible JSON settings for preferences and configurations
- Verification and compliance tracking

### Track

The `tracks` table represents individual audio recordings and their metadata:

```typescript
export const tracks = pgTable("tracks", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull().references(() => users.id),
  title: text("title").notNull(),
  isrc: text("isrc").unique(),
  duration: integer("duration"),
  releaseDate: date("release_date"),
  recordingDate: date("recording_date"),
  language: text("language"),
  explicit: boolean("explicit").default(false),
  primaryGenre: text("primary_genre"),
  secondaryGenres: text("secondary_genres").array(),
  bpm: integer("bpm"),
  key: text("key"),
  moods: text("moods").array(),
  tags: text("tags").array(),
  lyrics: text("lyrics"),
  description: text("description"),
  audioFileUrl: text("audio_file_url"),
  waveformUrl: text("waveform_url"),
  coverArtUrl: text("cover_art_url"),
  status: text("status").default("draft").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
  primaryArtist: text("primary_artist").notNull(),
  featuredArtists: text("featured_artists").array(),
  composers: text("composers").array(),
  lyricists: text("lyricists").array(),
  producers: text("producers").array(),
  metadata: jsonb("metadata"),
  aiTags: jsonb("ai_tags"),
  royaltyEligible: boolean("royalty_eligible").default(true),
  originalReleaseDate: date("original_release_date"),
  recordLabel: text("record_label"),
  publisher: text("publisher"),
  copyrightText: text("copyright_text"),
  publicationYear: integer("publication_year"),
  contentTags: jsonb("content_tags"),
  aiAnalysis: jsonb("ai_analysis"),
  credits: jsonb("credits"),
  audioMetadata: jsonb("audio_metadata"),
  sampleDetails: jsonb("sample_details"),
  stemFiles: jsonb("stem_files"),
});
```

Key aspects:
- Comprehensive music metadata
- Support for multiple contributors (artists, composers, producers)
- Advanced music attributes (BPM, key, moods)
- Audio file references
- AI-enhanced metadata for discovery
- Detailed rights information
- Technical audio information

### Release

The `releases` table represents collections of tracks for distribution:

```typescript
export const releases = pgTable("releases", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull().references(() => users.id),
  title: text("title").notNull(),
  upc: text("upc").unique(),
  releaseDate: date("release_date"),
  originalReleaseDate: date("original_release_date"),
  recordLabel: text("record_label"),
  catalogNumber: text("catalog_number"),
  primaryGenre: text("primary_genre"),
  secondaryGenres: text("secondary_genres").array(),
  language: text("language"),
  explicit: boolean("explicit").default(false),
  type: text("type").default("single").notNull(),
  status: text("status").default("draft").notNull(),
  coverArtUrl: text("cover_art_url"),
  description: text("description"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
  preOrderDate: date("pre_order_date"),
  primaryArtist: text("primary_artist").notNull(),
  featuredArtists: text("featured_artists").array(),
  compilationArtists: text("compilation_artists").array(),
  metadata: jsonb("metadata"),
  contentWarnings: text("content_warnings").array(),
  copyrightText: text("copyright_text"),
  publishingRights: text("publishing_rights"),
  territoriesExcluded: text("territories_excluded").array(),
  notes: text("notes"),
  visibilitySettings: jsonb("visibility_settings"),
  artwork: jsonb("artwork"),
  distributionStatus: distributionStatusEnum("distribution_status").default("pending"),
  distributionDate: timestamp("distribution_date"),
  contentType: contentTypeEnum("content_type").default("single"),
  contentTags: jsonb("content_tags"),
  aiAnalysis: jsonb("ai_analysis"),
  credits: jsonb("credits"),
  artworkMetadata: jsonb("artwork_metadata"),
});
```

Key aspects:
- Complete release metadata for distribution
- Support for various release types (singles, albums, EPs)
- Territory restrictions and visibility settings
- Distribution status tracking
- Enhanced artwork information
- AI-powered content analysis
- Detailed credits information

### Distribution Records

The `distributionRecords` table tracks the delivery of releases to platforms:

```typescript
export const distributionRecords = pgTable("distribution_records", {
  id: serial("id").primaryKey(),
  releaseId: integer("release_id").notNull().references(() => releases.id),
  platformId: integer("platform_id").notNull().references(() => distributionPlatforms.id),
  status: distributionStatusEnum("status").default("pending").notNull(),
  distributedAt: timestamp("distributed_at"),
  lastStatusUpdate: timestamp("last_status_update").defaultNow().notNull(),
  platformReleaseId: text("platform_release_id"),
  platformUrl: text("platform_url"),
  errors: jsonb("errors"),
  takedownRequested: boolean("takedown_requested").default(false),
  takedownReason: text("takedown_reason"),
  takedownRequestedAt: timestamp("takedown_requested_at"),
  takedownCompletedAt: timestamp("takedown_completed_at"),
  metadata: jsonb("metadata"),
  scheduledAt: timestamp("scheduled_at"),
  attemptCount: integer("attempt_count").default(0),
  deliveryMethod: text("delivery_method").default("api"),
  platformFeedback: jsonb("platform_feedback"),
  territories: text("territories").array(),
  analyticsSource: text("analytics_source"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
  processingDetails: jsonb("processing_details"),
  deliveryPackageUrl: text("delivery_package_url"),
  platformSpecificMetadata: jsonb("platform_specific_metadata"),
  errorCategory: text("error_category"),
  errorDetails: text("error_details"),
  errorResolution: text("error_resolution"),
  distributionBatchId: integer("distribution_batch_id"),
});
```

Key aspects:
- Platform-specific distribution tracking
- Detailed status and error information
- Takedown request handling
- Platform identifiers and URLs
- Territory-specific distribution
- Delivery method and package details
- Error categorization and resolution tracking

### Rights Claims

The `rightsManagement` table tracks ownership claims on content:

```typescript
export const rightsManagement = pgTable("rights_management", {
  id: serial("id").primaryKey(),
  entityType: text("entity_type").notNull(), // "track" or "release"
  entityId: integer("entity_id").notNull(),
  rightType: roleTypeEnum("right_type").notNull(),
  rightHolder: text("right_holder").notNull(),
  rightHolderType: text("right_holder_type").notNull(), // "user", "label", "publisher", "organization"
  rightHolderId: integer("right_holder_id"),
  percentage: numeric("percentage").notNull(),
  startDate: date("start_date").notNull(),
  endDate: date("end_date"),
  territory: text("territory").array(),
  documentUrl: text("document_url"),
  verificationStatus: approvalStatusEnum("verification_status").default("pending"),
  verifiedBy: integer("verified_by").references(() => users.id),
  verifiedAt: timestamp("verified_at"),
  createdBy: integer("created_by").notNull().references(() => users.id),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
  notes: text("notes"),
  metadata: jsonb("metadata"),
  ownershipType: ownershipTypeEnum("ownership_type").default("original"),
  isExclusive: boolean("is_exclusive").default(true),
  agreementType: text("agreement_type"),
  agreementId: text("agreement_id"),
  rightsConflict: boolean("rights_conflict").default(false),
  conflictDetails: jsonb("conflict_details"),
  chainOfTitle: jsonb("chain_of_title"),
});
```

Key aspects:
- Flexible rights tracking for different entity types
- Percentage-based ownership
- Time-bound rights (start/end dates)
- Territory-specific rights
- Verification workflow
- Documentation references
- Conflict detection and resolution
- Chain of title tracking

### Royalty Calculations

The `royaltyCalculations` table tracks financial earning computations:

```typescript
export const royaltyCalculations = pgTable("royalty_calculations", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull().references(() => users.id),
  entityType: text("entity_type").notNull(), // "track" or "release"
  entityId: integer("entity_id").notNull(),
  platformId: integer("platform_id").references(() => distributionPlatforms.id),
  period: text("period").notNull(), // e.g., "2023-03"
  streams: integer("streams"),
  downloads: integer("downloads"),
  amount: numeric("amount").notNull(),
  currency: text("currency").default("USD").notNull(),
  exchangeRate: numeric("exchange_rate").default("1"),
  status: text("status").default("pending").notNull(),
  paidAt: timestamp("paid_at"),
  statementId: integer("statement_id"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
  calculationDetails: jsonb("calculation_details"),
  paymentBatchId: integer("payment_batch_id"),
  adjustments: jsonb("adjustments"),
  splitPayments: jsonb("split_payments"),
  royaltySource: text("royalty_source").default("streaming"),
  royaltyType: royaltyTypeEnum("royalty_type").default("performance"),
  territoryCode: text("territory_code"),
  taxWithheld: numeric("tax_withheld").default("0"),
  grossAmount: numeric("gross_amount"),
  processingFee: numeric("processing_fee").default("0"),
  distributionFee: numeric("distribution_fee").default("0"),
  netAmount: numeric("net_amount"),
  recoupmentApplied: numeric("recoupment_applied").default("0"),
  advanceBalance: numeric("advance_balance"),
  paymentMethod: text("payment_method"),
  transactionId: text("transaction_id"),
  sourceData: jsonb("source_data"),
});
```

Key aspects:
- Track and release earnings
- Platform and territory-specific calculations
- Period-based tracking
- Currency and exchange rate handling
- Detailed calculation components
- Split payment tracking
- Tax withholding
- Fee and deduction transparency
- Advance recoupment tracking
- Comprehensive financial details

## User Management Domain

The user management domain handles all aspects of user accounts, authentication, teams, and permissions:

### User Profiles

Extended user information beyond the core user table:

```typescript
export const userProfiles = pgTable("user_profiles", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull().references(() => users.id).unique(),
  displayName: text("display_name"),
  bio: text("bio"),
  location: text("location"),
  website: text("website"),
  socialLinks: jsonb("social_links"),
  profileCompleteness: integer("profile_completeness").default(0),
  coverImageUrl: text("cover_image_url"),
  genres: text("genres").array(),
  influences: text("influences").array(),
  skills: text("skills").array(),
  yearsActive: integer("years_active"),
  careerLevel: text("career_level"),
  verifiedArtist: boolean("verified_artist").default(false),
  publicProfile: boolean("public_profile").default(true),
  featuredWork: jsonb("featured_work"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});
```

### Teams

Team management for multi-user accounts:

```typescript
export const teams = pgTable("teams", {
  id: serial("id").primaryKey(),
  name: text("name").notNull(),
  ownerId: integer("owner_id").notNull().references(() => users.id),
  description: text("description"),
  avatarUrl: text("avatar_url"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
  type: text("type").default("default"),
  inviteCode: text("invite_code"),
  settings: jsonb("settings"),
  status: text("status").default("active"),
});
```

### Team Members

Connects users to teams with specific roles:

```typescript
export const teamMembers = pgTable("team_members", {
  id: serial("id").primaryKey(),
  teamId: integer("team_id").notNull().references(() => teams.id),
  userId: integer("user_id").notNull().references(() => users.id),
  role: text("role").default("member").notNull(),
  permissions: jsonb("permissions"),
  joinedAt: timestamp("joined_at").defaultNow().notNull(),
  invitedBy: integer("invited_by").references(() => users.id),
  status: text("status").default("active").notNull(),
  lastActiveAt: timestamp("last_active_at"),
});
```

### API Keys

For programmatic access to the platform:

```typescript
export const apiKeys = pgTable("api_keys", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull().references(() => users.id),
  name: text("name").notNull(),
  key: text("key").notNull().unique(),
  scopes: text("scopes").array(),
  expiresAt: timestamp("expires_at"),
  lastUsedAt: timestamp("last_used_at"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
  isActive: boolean("is_active").default(true),
  ipRestrictions: text("ip_restrictions").array(),
  rateLimit: integer("rate_limit"),
});
```

### Sessions

Manages user login sessions:

```typescript
export const sessions = pgTable("sessions", {
  id: text("id").primaryKey(),
  userId: integer("user_id").notNull().references(() => users.id),
  userAgent: text("user_agent"),
  ipAddress: text("ip_address"),
  expiresAt: timestamp("expires_at").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  lastActiveAt: timestamp("last_active_at").defaultNow().notNull(),
  data: jsonb("data"),
  isAdmin: boolean("is_admin").default(false),
});
```

### Audit Logs

Tracks important system and user actions:

```typescript
export const auditLogs = pgTable("audit_logs", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id),
  action: text("action").notNull(),
  entityType: text("entity_type"),
  entityId: text("entity_id"),
  details: jsonb("details"),
  ipAddress: text("ip_address"),
  userAgent: text("user_agent"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  severity: text("severity").default("info"),
  status: text("status").default("success"),
});
```

## Content Management Domain

The content management domain handles tracks, releases, artists, and their metadata:

### Artists

Detailed artist information:

```typescript
export const artists = pgTable("artists", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id),
  name: text("name").notNull(),
  sortName: text("sort_name"),
  type: text("type").default("person").notNull(), // "person", "group", "orchestra", etc.
  biography: text("biography"),
  formedYear: integer("formed_year"),
  dissolvedYear: integer("dissolved_year"),
  country: text("country"),
  website: text("website"),
  socialLinks: jsonb("social_links"),
  imageUrl: text("image_url"),
  genres: text("genres").array(),
  tags: text("tags").array(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
  isVerified: boolean("is_verified").default(false),
  spotifyId: text("spotify_id"),
  appleId: text("apple_id"),
  isni: text("isni"),
  memberArtists: jsonb("member_artists"),
  aliases: jsonb("aliases"),
  primaryLabel: text("primary_label"),
  managementContact: text("management_contact"),
  bookingContact: text("booking_contact"),
  pressContact: text("press_contact"),
});
```

### Track-Release Junction

Connects tracks to releases with ordering information:

```typescript
export const trackReleases = pgTable("track_releases", {
  id: serial("id").primaryKey(),
  trackId: integer("track_id").notNull().references(() => tracks.id),
  releaseId: integer("release_id").notNull().references(() => releases.id),
  trackNumber: integer("track_number").notNull(),
  discNumber: integer("disc_number").default(1).notNull(),
  isBonus: boolean("is_bonus").default(false),
  isInstant: boolean("is_instant").default(false),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});
```

### Assets

Manages digital files associated with content:

```typescript
export const assets = pgTable("assets", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull().references(() => users.id),
  entityType: text("entity_type").notNull(), // "track", "release", "artist", etc.
  entityId: integer("entity_id").notNull(),
  type: text("type").notNull(), // "audio", "image", "document", "video"
  subType: text("sub_type"), // "master", "artwork", "contract", "stems", etc.
  fileUrl: text("file_url").notNull(),
  fileName: text("file_name").notNull(),
  fileSize: integer("file_size"),
  fileType: text("file_type"),
  duration: integer("duration"), // for audio/video
  width: integer("width"), // for images
  height: integer("height"), // for images
  isPublic: boolean("is_public").default(false),
  status: text("status").default("active"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
  metadata: jsonb("metadata"),
  checksum: text("checksum"),
  thumbnailUrl: text("thumbnail_url"),
  storageProvider: text("storage_provider").default("s3"),
  processingStatus: text("processing_status").default("complete"),
  processingError: text("processing_error"),
  replacedById: integer("replaced_by_id").references(() => assets.id),
  originalFileName: text("original_file_name"),
});
```

### Content Tags

Structured tagging system for enhanced discoverability:

```typescript
export const contentTags = pgTable("content_tags", {
  id: serial("id").primaryKey(),
  entityType: text("entity_type").notNull(), // "track", "release", "artist"
  entityId: integer("entity_id").notNull(),
  category: text("category").notNull(), // "genre", "mood", "instrument", "theme"
  tag: text("tag").notNull(),
  source: text("source").default("user"), // "user", "system", "ai"
  confidence: numeric("confidence"), // For AI-generated tags
  createdAt: timestamp("created_at").defaultNow().notNull(),
  createdBy: integer("created_by").references(() => users.id),
  isVerified: boolean("is_verified").default(false),
  verifiedBy: integer("verified_by").references(() => users.id),
  verifiedAt: timestamp("verified_at"),
});
```

### Version History

Tracks changes to content over time:

```typescript
export const versionHistory = pgTable("version_history", {
  id: serial("id").primaryKey(),
  entityType: text("entity_type").notNull(), // "track", "release", etc.
  entityId: integer("entity_id").notNull(),
  versionNumber: integer("version_number").notNull(),
  changes: jsonb("changes").notNull(),
  changedBy: integer("changed_by").references(() => users.id),
  changedAt: timestamp("changed_at").defaultNow().notNull(),
  comment: text("comment"),
  status: text("status").default("active"),
  isAutomated: boolean("is_automated").default(false),
  previousVersionId: integer("previous_version_id").references(() => versionHistory.id),
});
```

## Distribution Domain

The distribution domain manages the delivery of music to streaming platforms:

### Distribution Platforms

Information about connected streaming services:

```typescript
export const distributionPlatforms = pgTable("distribution_platforms", {
  id: serial("id").primaryKey(),
  name: text("name").notNull().unique(),
  logoUrl: text("logo_url"),
  apiEndpoint: text("api_endpoint"),
  apiDocumentation: text("api_documentation"),
  deliveryMethod: text("delivery_method").default("api"), // "api", "sftp", "manual"
  isActive: boolean("is_active").default(true),
  processingTime: text("processing_time"), // Estimated processing time
  territories: text("territories").array(),
  requirements: jsonb("requirements"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
  supportedFormats: text("supported_formats").array(),
  minAudioQuality: text("min_audio_quality"),
  minImageQuality: text("min_image_quality"),
  supportsPreOrders: boolean("supports_pre_orders").default(false),
  supportsTakedowns: boolean("supports_takedowns").default(true),
  supportsMetadataUpdates: boolean("supports_metadata_updates").default(false),
  fees: jsonb("fees"),
  integrationDetails: jsonb("integration_details"),
  rateLimits: jsonb("rate_limits"),
  category: text("category").default("dsp"), // "dsp", "video", "social"
  tier: text("tier").default("standard"), // "premium", "standard", "basic"
});
```

### Platform Credentials

Securely stores connection credentials for platforms:

```typescript
export const platformCredentials = pgTable("platform_credentials", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull().references(() => users.id),
  platformId: integer("platform_id").notNull().references(() => distributionPlatforms.id),
  credentials: jsonb("credentials").notNull(),
  status: text("status").default("active"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
  verificationStatus: text("verification_status").default("pending"),
  verifiedAt: timestamp("verified_at"),
  expiresAt: timestamp("expires_at"),
  isDefault: boolean("is_default").default(false),
  labels: text("labels").array(),
  scope: text("scope").default("all"),
  integrationLevel: text("integration_level").default("basic"),
  connectionType: text("connection_type").default("oauth"),
});
```

### Scheduled Distributions

Manages future-dated content deliveries:

```typescript
export const scheduledDistributions = pgTable("scheduled_distributions", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull().references(() => users.id),
  releaseId: integer("release_id").notNull().references(() => releases.id),
  scheduledAt: timestamp("scheduled_at").notNull(),
  platformIds: integer("platform_ids").array().notNull(),
  status: text("status").default("pending").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
  executedAt: timestamp("executed_at"),
  territoryRestrictions: text("territory_restrictions").array(),
  exclusivePlatforms: integer("exclusive_platforms").array(),
  distributionStrategy: text("distribution_strategy").default("simultaneous"),
  distributionPriority: text("distribution_priority").default("standard"),
  callbackUrl: text("callback_url"),
  deliveryNotificationEmail: text("delivery_notification_email"),
  distributionJobId: text("distribution_job_id"),
  metadata: jsonb("metadata"),
  retryBehavior: jsonb("retry_behavior"),
  failureNotification: boolean("failure_notification").default(true),
});
```

### Distribution Batches

Groups related distribution activities:

```typescript
export const distributionBatches = pgTable("distribution_batches", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull().references(() => users.id),
  name: text("name"),
  description: text("description"),
  status: text("status").default("in_progress").notNull(),
  startedAt: timestamp("started_at").defaultNow().notNull(),
  completedAt: timestamp("completed_at"),
  totalItems: integer("total_items").notNull(),
  processedItems: integer("processed_items").default(0).notNull(),
  successItems: integer("success_items").default(0),
  failedItems: integer("failed_items").default(0),
  batchType: text("batch_type").default("release").notNull(), // "release", "takedown", "update"
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
  metadata: jsonb("metadata"),
  priority: text("priority").default("normal"),
  callbackUrl: text("callback_url"),
  notificationEmail: text("notification_email"),
  batchSource: text("batch_source").default("user"), // "user", "scheduled", "automated"
});
```

## Rights Management Domain

The rights management domain handles ownership, splits, and rights administration:

### Agreements

Tracks contracts and legal documents:

```typescript
export const agreements = pgTable("agreements", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull().references(() => users.id),
  title: text("title").notNull(),
  type: text("type").notNull(), // "recording", "publishing", "distribution", etc.
  status: text("status").default("draft").notNull(),
  startDate: date("start_date"),
  endDate: date("end_date"),
  documentUrl: text("document_url"),
  parties: jsonb("parties").notNull(),
  territoryScope: text("territory_scope").array(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
  signedAt: timestamp("signed_at"),
  metadata: jsonb("metadata"),
  terms: jsonb("terms"),
  rightsGranted: jsonb("rights_granted"),
  royaltyTerms: jsonb("royalty_terms"),
  exclusivity: boolean("exclusivity").default(false),
  confidentiality: boolean("confidentiality").default(true),
  autoRenew: boolean("auto_renew").default(false),
  renewalTerms: jsonb("renewal_terms"),
  terminationClauses: jsonb("termination_clauses"),
  governingLaw: text("governing_law"),
  disputeResolution: text("dispute_resolution"),
  amendmentsHistory: jsonb("amendments_history"),
  relatedAgreements: integer("related_agreements").array(),
});
```

### Royalty Splits

Manages revenue sharing between rights holders:

```typescript
export const royaltySplits = pgTable("royalty_splits", {
  id: serial("id").primaryKey(),
  entityType: text("entity_type").notNull(), // "track", "release"
  entityId: integer("entity_id").notNull(),
  rightType: royaltyTypeEnum("right_type").notNull(),
  recipientType: text("recipient_type").notNull(), // "user", "artist", "organization"
  recipientId: integer("recipient_id"),
  recipientName: text("recipient_name").notNull(),
  percentage: numeric("percentage").notNull(),
  isApproved: boolean("is_approved").default(false),
  approvedBy: integer("approved_by").references(() => users.id),
  approvedAt: timestamp("approved_at"),
  createdBy: integer("created_by").notNull().references(() => users.id),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
  agreementId: integer("agreement_id").references(() => agreements.id),
  effectiveFrom: date("effective_from"),
  effectiveTo: date("effective_to"),
  notes: text("notes"),
  status: text("status").default("active"),
  paymentDetails: jsonb("payment_details"),
  territory: text("territory").array(),
  splitGroupId: integer("split_group_id"),
  version: integer("version").default(1),
});
```

### Split Templates

Reusable split configurations:

```typescript
export const splitTemplates = pgTable("split_templates", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull().references(() => users.id),
  name: text("name").notNull(),
  description: text("description"),
  rightType: royaltyTypeEnum("right_type").notNull(),
  splits: jsonb("splits").notNull(),
  isDefault: boolean("is_default").default(false),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
  applicableTo: text("applicable_to").array(), // "tracks", "releases", etc.
  status: text("status").default("active"),
  templateType: text("template_type").default("standard"), // "standard", "project", "label"
  visibility: text("visibility").default("private"), // "private", "team", "public"
  usageCount: integer("usage_count").default(0),
  tags: text("tags").array(),
});
```

### Rights Conflicts

Tracks and manages ownership disputes:

```typescript
export const rightsConflicts = pgTable("rights_conflicts", {
  id: serial("id").primaryKey(),
  entityType: text("entity_type").notNull(), // "track", "release"
  entityId: integer("entity_id").notNull(),
  rightType: royaltyTypeEnum("right_type").notNull(),
  conflictingClaimIds: integer("conflicting_claim_ids").array().notNull(),
  status: text("status").default("open").notNull(),
  detectedAt: timestamp("detected_at").defaultNow().notNull(),
  resolvedAt: timestamp("resolved_at"),
  resolvedBy: integer("resolved_by").references(() => users.id),
  resolutionNotes: text("resolution_notes"),
  resolutionType: text("resolution_type"), // "accepted_claim", "split_adjusted", "disputed"
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
  severity: text("severity").default("medium"),
  impactedRevenue: numeric("impacted_revenue"),
  disputeDocuments: jsonb("dispute_documents"),
  resolutionDocuments: jsonb("resolution_documents"),
  notifiedParties: jsonb("notified_parties"),
  assignedTo: integer("assigned_to").references(() => users.id),
  escalationLevel: integer("escalation_level").default(0),
  systemActions: jsonb("system_actions"),
});
```

## Financial Domain

The financial domain handles payments, royalties, and financial transactions:

### Payment Methods

Stores user payment information:

```typescript
export const paymentMethods = pgTable("payment_methods", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull().references(() => users.id),
  type: text("type").notNull(), // "bank_account", "paypal", "stripe", etc.
  name: text("name").notNull(),
  details: jsonb("details").notNull(),
  isDefault: boolean("is_default").default(false),
  status: text("status").default("active").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
  verificationStatus: text("verification_status").default("pending"),
  verifiedAt: timestamp("verified_at"),
  lastFourDigits: text("last_four_digits"),
  expiryDate: text("expiry_date"),
  country: text("country"),
  currency: text("currency"),
  metadata: jsonb("metadata"),
  billingAddress: jsonb("billing_address"),
  verification_attempts: integer("verification_attempts").default(0),
  last_verification_attempt: timestamp("last_verification_attempt"),
  verification_notes: text("verification_notes"),
});
```

### Withdrawals

Tracks payment requests from users:

```typescript
export const withdrawals = pgTable("withdrawals", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull().references(() => users.id),
  amount: numeric("amount").notNull(),
  currency: text("currency").default("USD").notNull(),
  status: text("status").default("pending").notNull(),
  paymentMethodId: integer("payment_method_id").notNull().references(() => paymentMethods.id),
  processedAt: timestamp("processed_at"),
  requestedAt: timestamp("requested_at").defaultNow().notNull(),
  reference: text("reference"),
  notes: text("notes"),
  fee: numeric("fee").default("0"),
  taxWithheld: numeric("tax_withheld").default("0"),
  netAmount: numeric("net_amount"),
  exchangeRate: numeric("exchange_rate").default("1"),
  paymentBatchId: integer("payment_batch_id"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
  estimatedArrivalDate: date("estimated_arrival_date"),
  actualArrivalDate: date("actual_arrival_date"),
  paymentDetails: jsonb("payment_details"),
  failureReason: text("failure_reason"),
  retryCount: integer("retry_count").default(0),
  lastRetryAt: timestamp("last_retry_at"),
  adminNotes: text("admin_notes"),
  internalReference: text("internal_reference"),
});
```

### Statements

Provides formal records of earnings:

```typescript
export const statements = pgTable("statements", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull().references(() => users.id),
  period: text("period").notNull(), // e.g., "2023-Q1"
  startDate: date("start_date").notNull(),
  endDate: date("end_date").notNull(),
  totalAmount: numeric("total_amount").notNull(),
  currency: text("currency").default("USD").notNull(),
  status: text("status").default("generated").notNull(),
  generatedAt: timestamp("generated_at").defaultNow().notNull(),
  viewedAt: timestamp("viewed_at"),
  documentUrl: text("document_url"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
  statementType: text("statement_type").default("royalty"),
  summary: jsonb("summary"),
  platformBreakdown: jsonb("platform_breakdown"),
  releaseBreakdown: jsonb("release_breakdown"),
  trackBreakdown: jsonb("track_breakdown"),
  territoryBreakdown: jsonb("territory_breakdown"),
  taxSummary: jsonb("tax_summary"),
  deductionsSummary: jsonb("deductions_summary"),
  paymentStatus: text("payment_status").default("unpaid"),
  paidAmount: numeric("paid_amount"),
  paidAt: timestamp("paid_at"),
  paymentReference: text("payment_reference"),
  statementFormat: text("statement_format").default("standard"),
});
```

### Payment Batches

Manages grouped payment processing:

```typescript
export const paymentBatches = pgTable("payment_batches", {
  id: serial("id").primaryKey(),
  name: text("name"),
  description: text("description"),
  status: text("status").default("pending").notNull(),
  processingStartedAt: timestamp("processing_started_at"),
  processingCompletedAt: timestamp("processing_completed_at"),
  totalAmount: numeric("total_amount").notNull(),
  currency: text("currency").default("USD").notNull(),
  totalPayments: integer("total_payments").notNull(),
  successfulPayments: integer("successful_payments").default(0),
  failedPayments: integer("failed_payments").default(0),
  createdBy: integer("created_by").references(() => users.id),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
  paymentType: text("payment_type").default("royalty"), // "royalty", "advance", "bonus"
  scheduledFor: timestamp("scheduled_for"),
  executionStrategy: text("execution_strategy").default("immediate"),
  paymentMethod: text("payment_method").default("bank_transfer"),
  processedBy: integer("processed_by").references(() => users.id),
  notes: text("notes"),
  batchSettings: jsonb("batch_settings"),
  batchErrors: jsonb("batch_errors"),
  batchWarnings: jsonb("batch_warnings"),
  notificationSent: boolean("notification_sent").default(false),
  externalReference: text("external_reference"),
});
```

### Advances

Tracks prepayments against future earnings:

```typescript
export const advances = pgTable("advances", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull().references(() => users.id),
  amount: numeric("amount").notNull(),
  currency: text("currency").default("USD").notNull(),
  issuedAt: timestamp("issued_at").defaultNow().notNull(),
  status: text("status").default("active").notNull(),
  recoupmentRate: numeric("recoupment_rate").default("1").notNull(), // 1 = 100% recoupment
  recoupedAmount: numeric("recouped_amount").default("0"),
  remainingAmount: numeric("remaining_amount"),
  agreementId: integer("agreement_id").references(() => agreements.id),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
  issuedBy: integer("issued_by").references(() => users.id),
  recoupmentType: text("recoupment_type").default("all_income"), // "all_income", "specific_releases", etc.
  recoupmentSources: jsonb("recoupment_sources"),
  recoupmentPeriod: jsonb("recoupment_period"), // Duration or ending date
  interestRate: numeric("interest_rate").default("0"),
  paymentPlan: jsonb("payment_plan"),
  recoupmentHistory: jsonb("recoupment_history"),
  notes: text("notes"),
  advanceType: text("advance_type").default("standard"),
  approvedBy: integer("approved_by").references(() => users.id),
  paymentStatus: text("payment_status").default("pending"),
  paymentDate: date("payment_date"),
  paymentReference: text("payment_reference"),
});
```

## Analytics Domain

The analytics domain handles performance metrics, reporting, and business intelligence:

### Platform Analytics

Stores performance data from streaming platforms:

```typescript
export const platformAnalytics = pgTable("platform_analytics", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull().references(() => users.id),
  entityType: text("entity_type").notNull(), // "track", "release", "artist"
  entityId: integer("entity_id").notNull(),
  platformId: integer("platform_id").references(() => distributionPlatforms.id),
  date: date("date").notNull(),
  streams: integer("streams").default(0),
  downloads: integer("downloads").default(0),
  revenue: numeric("revenue").default("0"),
  currency: text("currency").default("USD"),
  listeners: integer("listeners"),
  saves: integer("saves"),
  completionRate: numeric("completion_rate"),
  skipRate: numeric("skip_rate"),
  playlists: integer("playlists"),
  shares: integer("shares"),
  comments: integer("comments"),
  likes: integer("likes"),
  followsGained: integer("follows_gained"),
  territoryCode: text("territory_code"),
  deviceType: text("device_type"),
  listeningMethod: text("listening_method"), // "user_collection", "playlist", "radio", etc.
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
  sourceData: jsonb("source_data"),
  isEstimated: boolean("is_estimated").default(false),
  batchId: integer("batch_id"),
  demographicData: jsonb("demographic_data"),
  playbackSource: text("playback_source"), // "user_library", "search", "playlist", etc.
  avgPlaybackDuration: integer("avg_playback_duration"),
  uniqueListeners: integer("unique_listeners"),
  newListeners: integer("new_listeners"),
  returningListeners: integer("returning_listeners"),
});
```

### Audience Demographics

Stores listener demographic information:

```typescript
export const audienceDemographics = pgTable("audience_demographics", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull().references(() => users.id),
  entityType: text("entity_type").notNull(), // "artist", "track", "release"
  entityId: integer("entity_id").notNull(),
  period: text("period").notNull(), // e.g., "2023-03"
  ageRanges: jsonb("age_ranges"), // e.g., {"18-24": 0.35, "25-34": 0.4, ...}
  genders: jsonb("genders"), // e.g., {"male": 0.6, "female": 0.35, "other": 0.05}
  countries: jsonb("countries"), // e.g., {"US": 0.4, "UK": 0.2, ...}
  cities: jsonb("cities"), // Top cities
  platforms: jsonb("platforms"), // e.g., {"spotify": 0.7, "apple": 0.2, ...}
  devices: jsonb("devices"), // e.g., {"mobile": 0.6, "desktop": 0.3, "other": 0.1}
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
  sourceId: integer("source_id"), // Reference to data source
  confidence: numeric("confidence").default("1"),
  dataQuality: text("data_quality").default("high"),
  listeningPreferences: jsonb("listening_preferences"),
  genreAffinities: jsonb("genre_affinities"),
  engagementMetrics: jsonb("engagement_metrics"),
  growthTrends: jsonb("growth_trends"),
  audienceSegments: jsonb("audience_segments"),
  relatedArtists: jsonb("related_artists"),
});
```

### Saved Reports

Stores user-generated reports:

```typescript
export const savedReports = pgTable("saved_reports", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull().references(() => users.id),
  name: text("name").notNull(),
  description: text("description"),
  type: text("type").notNull(), // "performance", "financial", "audience", "custom"
  parameters: jsonb("parameters").notNull(),
  schedule: jsonb("schedule"), // For recurring reports
  lastRunAt: timestamp("last_run_at"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
  format: text("format").default("web"), // "web", "pdf", "excel", "csv"
  isPublic: boolean("is_public").default(false),
  isTemplate: boolean("is_template").default(false),
  category: text("category"),
  tags: text("tags").array(),
  thumbnailUrl: text("thumbnail_url"),
  lastResultUrl: text("last_result_url"),
  queryData: jsonb("query_data"),
  visualizations: jsonb("visualizations"),
  sharing: jsonb("sharing"),
  version: integer("version").default(1),
  parentReportId: integer("parent_report_id").references(() => savedReports.id),
  executionStats: jsonb("execution_stats"),
});
```

### Report Exports

Tracks exported report documents:

```typescript
export const reportExports = pgTable("report_exports", {
  id: serial("id").primaryKey(),
  reportId: integer("report_id").references(() => savedReports.id),
  userId: integer("user_id").notNull().references(() => users.id),
  format: text("format").notNull(), // "pdf", "excel", "csv", "json"
  url: text("url").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  expiresAt: timestamp("expires_at"),
  size: integer("size"),
  downloadCount: integer("download_count").default(0),
  parameters: jsonb("parameters"),
  status: text("status").default("completed"),
  processingTime: integer("processing_time"),
  errorDetails: text("error_details"),
  notificationSent: boolean("notification_sent").default(false),
  recipientEmail: text("recipient_email"),
  jobId: text("job_id"),
  name: text("name"),
  pages: integer("pages"),
  thumbnailUrl: text("thumbnail_url"),
  isPasswordProtected: boolean("is_password_protected").default(false),
  watermarked: boolean("watermarked").default(false),
});
```

## Data Relationships

Key relationships between entities in the data model:

### One-to-Many Relationships

1. **User to Tracks**
   - A user can own many tracks
   - Each track is owned by one user

2. **User to Releases**
   - A user can own many releases
   - Each release is owned by one user

3. **User to PaymentMethods**
   - A user can have multiple payment methods
   - Each payment method belongs to one user

4. **Team to TeamMembers**
   - A team can have many members
   - Each team membership is associated with one team

### Many-to-Many Relationships

1. **Tracks to Releases**
   - A track can be part of multiple releases
   - A release can contain multiple tracks
   - Implemented via the `trackReleases` junction table

2. **Releases to DistributionPlatforms**
   - A release can be distributed to multiple platforms
   - A platform can host many releases
   - Implemented via the `distributionRecords` table

3. **Users to Teams**
   - A user can be a member of multiple teams
   - A team can have multiple user members
   - Implemented via the `teamMembers` table

### Complex Relationships

1. **Polymorphic Associations**
   - Tables like `assets`, `contentTags`, and `rightsManagement` relate to different entity types
   - They use the pattern of `entityType` + `entityId` fields to create flexible relationships

2. **Hierarchical Relationships**
   - Users can have parent-child relationships (label to sub-labels)
   - Implemented via self-referential `parentId` in the users table

3. **Temporal Relationships**
   - Rights claims have effective dates
   - Contracts have start and end dates
   - Ensures proper historical tracking and time-bound relationships

## Schema Evolution

TuneMantra's database schema evolves through controlled migration processes:

### Migration Strategy

1. **Schema Versioning**
   - Every schema change is versioned
   - Migrations are applied sequentially
   - Version history is maintained in the database

2. **Backward Compatibility**
   - Schema changes preserve existing data
   - Breaking changes are avoided when possible
   - Deprecation periods for obsolete fields

3. **Migration Tools**
   - Drizzle Kit for schema migrations
   - Version control for migration scripts
   - Automated testing of migrations

### Schema Changes

Types of schema changes and their handling:

1. **Additive Changes**
   - Adding new tables
   - Adding new columns (with defaults for existing rows)
   - Adding new relationships

2. **Modificative Changes**
   - Renaming columns (with temporary views for backward compatibility)
   - Changing column types (with data conversion)
   - Modifying constraints (with validation)

3. **Removing Fields**
   - Marking as deprecated first
   - Setting up transitional periods
   - Eventually removing after ensuring no dependencies

### Data Migration

Approaches for migrating data during schema changes:

1. **In-Place Migration**
   - Transforming data within the same table
   - Updating values to match new schemas
   - Running data cleanup operations

2. **Copy Migration**
   - Creating new structures
   - Copying and transforming data to new tables
   - Switching over once migration is complete

3. **Background Migration**
   - Running migrations in the background
   - Implementing dual-write patterns during transition
   - Gradually moving to new structures without downtime

---

**Document Information:**
- Version: 2.0
- Last Updated: March 25, 2025
- Contact: database@tunemantra.com

---

## documentation/technical/database/database-schema.md

# Database Schema Documentation

<div align="center">
  <img src="../diagrams/database-schema-header.svg" alt="TuneMantra Database Schema" width="600"/>
</div>

## Overview

This document provides a comprehensive description of the TuneMantra database schema. The database is implemented using PostgreSQL and is accessed through the Drizzle ORM. The schema is designed to support all aspects of the music distribution platform, including user management, content management, distribution tracking, rights management, royalty calculations, and analytics.

## Entity Relationship Diagram

```mermaid
erDiagram
    users ||--o{ api_keys : has
    users ||--o{ tracks : uploads
    users ||--o{ releases : creates
    users ||--o{ payment_methods : registers
    users ||--o{ withdrawals : requests
    users ||--o{ daily_stats : aggregates
    
    releases ||--o{ tracks : contains
    releases ||--o{ revenue_shares : splits
    releases ||--o{ distribution_records : distributes_to
    releases ||--o{ scheduled_distributions : schedules
    
    tracks ||--o{ analytics : generates
    tracks ||--o{ royalty_calculations : calculates
    
    distribution_platforms ||--o{ distribution_records : receives
    
    royalty_calculations }o--|| distribution_records : based_on
    
    super_admins ||--o{ users : manages
    users ||--o{ sub_label_audit_logs : logs_actions
    users ||--o{ permission_templates : assigns
    users ||--o{ release_approvals : approves
    users ||--o{ account_approvals : approves
    users ||--o{ support_tickets : creates
    
    support_tickets ||--o{ support_ticket_messages : contains
```

## Core Tables

### User Management Tables

#### `users` Table

The users table stores information about all users in the system, including artists, label managers, and administrators.

```typescript
export const users = pgTable("users", {
  id: serial("id").primaryKey(),
  username: varchar("username", { length: 50 }).notNull().unique(),
  email: varchar("email", { length: 255 }).notNull().unique(),
  password: varchar("password", { length: 255 }).notNull(),
  fullName: varchar("full_name", { length: 100 }).notNull(),
  role: userRoleEnum("role").notNull().default("artist"),
  status: userStatusEnum("status").notNull().default("pending"),
  profile: jsonb("profile").default({}),
  settings: jsonb("settings").default({}),
  parentLabelId: integer("parent_label_id").references(() => users.id),
  approvalStatus: approvalStatusEnum("approval_status").default("pending"),
  emailVerified: boolean("email_verified").default(false),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});
```

Fields:
- `id`: Unique identifier for the user
- `username`: Unique username for login
- `email`: User's email address
- `password`: Hashed password for authentication
- `fullName`: User's full name
- `role`: User's role in the system (artist, label, admin, etc.)
- `status`: Account status (pending, active, suspended, etc.)
- `profile`: Flexible JSON structure for profile information
- `settings`: User preferences and settings
- `parentLabelId`: For sub-labels, references the parent label
- `approvalStatus`: Status of account approval process
- `emailVerified`: Whether the user's email has been verified
- `createdAt`: Timestamp when the account was created
- `updatedAt`: Timestamp when the account was last updated

#### `api_keys` Table

Stores API keys for programmatic access to the platform.

```typescript
export const apiKeys = pgTable("api_keys", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
  name: varchar("name", { length: 50 }).notNull(),
  key: varchar("key", { length: 64 }).notNull().unique(),
  scopes: text("scopes").array().notNull(),
  lastUsed: timestamp("last_used"),
  expiresAt: timestamp("expires_at"),
  createdAt: timestamp("created_at").defaultNow(),
});
```

Fields:
- `id`: Unique identifier for the API key
- `userId`: ID of the user who owns this API key
- `name`: Name/label for the API key
- `key`: The actual API key string
- `scopes`: Array of permission scopes for this key
- `lastUsed`: Timestamp when the key was last used
- `expiresAt`: Expiration timestamp for the key
- `createdAt`: Timestamp when the key was created

### Content Management Tables

#### `releases` Table

Stores information about music releases (albums, singles, EPs, etc.).

```typescript
export const releases = pgTable("releases", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
  title: varchar("title", { length: 255 }).notNull(),
  type: contentTypeEnum("type").notNull(),
  releaseDate: timestamp("release_date").notNull(),
  artwork: varchar("artwork", { length: 255 }),
  upc: varchar("upc", { length: 20 }).unique(),
  genre: varchar("genre", { length: 50 }),
  language: languageEnum("language").default("english"),
  isExplicit: boolean("is_explicit").default(false),
  description: text("description"),
  artistNames: varchar("artist_names", { length: 255 }).notNull(),
  status: varchar("status", { length: 50 }).default("draft"),
  metadata: jsonb("metadata").default({}),
  tags: jsonb("tags").default({}),
  aiAnalysis: jsonb("ai_analysis").default({}),
  credits: jsonb("credits").default({}),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});
```

Fields:
- `id`: Unique identifier for the release
- `userId`: ID of the user who created the release
- `title`: Title of the release
- `type`: Type of release (single, album, EP, etc.)
- `releaseDate`: Scheduled or actual release date
- `artwork`: Path to artwork image file
- `upc`: Universal Product Code for the release
- `genre`: Primary genre of the release
- `language`: Primary language of the release content
- `isExplicit`: Whether the release contains explicit content
- `description`: Text description of the release
- `artistNames`: Display names of artists on the release
- `status`: Current status of the release
- `metadata`: Flexible JSON structure for extended metadata
- `tags`: Content tags for improved discoverability
- `aiAnalysis`: AI-generated insights and metadata
- `credits`: Detailed credits information
- `createdAt`: Timestamp when the release was created
- `updatedAt`: Timestamp when the release was last updated

#### `tracks` Table

Stores information about individual tracks within releases.

```typescript
export const tracks = pgTable("tracks", {
  id: serial("id").primaryKey(),
  releaseId: integer("release_id").references(() => releases.id, { onDelete: "cascade" }),
  userId: integer("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
  title: varchar("title", { length: 255 }).notNull(),
  artist: varchar("artist", { length: 255 }).notNull(),
  duration: integer("duration"),
  audioFile: varchar("audio_file", { length: 255 }),
  isrc: varchar("isrc", { length: 15 }).unique(),
  trackNumber: integer("track_number"),
  isExplicit: boolean("is_explicit").default(false),
  lyrics: text("lyrics"),
  genre: varchar("genre", { length: 50 }),
  language: languageEnum("language").default("english"),
  bpm: integer("bpm"),
  key: varchar("key", { length: 10 }),
  metadata: jsonb("metadata").default({}),
  tags: jsonb("tags").default({}),
  aiAnalysis: jsonb("ai_analysis").default({}),
  credits: jsonb("credits").default({}),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});
```

Fields:
- `id`: Unique identifier for the track
- `releaseId`: ID of the release this track belongs to
- `userId`: ID of the user who uploaded the track
- `title`: Title of the track
- `artist`: Artist name for the track
- `duration`: Duration of the track in seconds
- `audioFile`: Path to the audio file
- `isrc`: International Standard Recording Code
- `trackNumber`: Position of track within the release
- `isExplicit`: Whether the track contains explicit content
- `lyrics`: Text of the track lyrics
- `genre`: Primary genre of the track
- `language`: Primary language of the track
- `bpm`: Beats per minute (tempo)
- `key`: Musical key of the track
- `metadata`: Flexible JSON structure for extended metadata
- `tags`: Content tags for improved discoverability
- `aiAnalysis`: AI-generated insights and metadata
- `credits`: Detailed credits information
- `createdAt`: Timestamp when the track was created
- `updatedAt`: Timestamp when the track was last updated

### Distribution Management Tables

#### `distribution_platforms` Table

Stores information about external platforms where content can be distributed.

```typescript
export const distributionPlatforms = pgTable("distribution_platforms", {
  id: serial("id").primaryKey(),
  name: varchar("name", { length: 100 }).notNull(),
  logoUrl: varchar("logo_url", { length: 255 }),
  apiEndpoint: varchar("api_endpoint", { length: 255 }),
  apiCredentials: jsonb("api_credentials").default({}),
  status: varchar("status", { length: 20 }).default("active"),
  deliveryMethod: varchar("delivery_method", { length: 50 }).notNull(),
  requirements: jsonb("requirements").default({}),
  formatSpecs: jsonb("format_specs").default({}),
  supportedContent: text("supported_content").array(),
  territoryRestrictions: text("territory_restrictions").array(),
  processingTime: varchar("processing_time", { length: 50 }),
  royaltyRate: decimal("royalty_rate", { precision: 10, scale: 6 }),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});
```

Fields:
- `id`: Unique identifier for the platform
- `name`: Name of the distribution platform
- `logoUrl`: URL to the platform's logo image
- `apiEndpoint`: Base URL for the platform's API
- `apiCredentials`: Securely stored API credentials
- `status`: Current status of the platform integration
- `deliveryMethod`: Method used for content delivery
- `requirements`: Platform-specific content requirements
- `formatSpecs`: Specifications for audio and artwork formats
- `supportedContent`: Types of content supported by the platform
- `territoryRestrictions`: Geographic availability restrictions
- `processingTime`: Estimated processing time for submissions
- `royaltyRate`: Standard royalty rate paid by the platform
- `createdAt`: Timestamp when the platform was added
- `updatedAt`: Timestamp when the platform was last updated

#### `distribution_records` Table

Tracks the status and details of distributions to specific platforms.

```typescript
export const distributionRecords = pgTable("distribution_records", {
  id: serial("id").primaryKey(),
  releaseId: integer("release_id").notNull().references(() => releases.id, { onDelete: "cascade" }),
  platformId: integer("platform_id").notNull().references(() => distributionPlatforms.id),
  status: distributionStatusEnum("status").notNull().default("pending"),
  distributionDate: timestamp("distribution_date"),
  platformReleaseId: varchar("platform_release_id", { length: 100 }),
  platformUrl: varchar("platform_url", { length: 255 }),
  errorDetails: text("error_details"),
  processingDetails: jsonb("processing_details").default({}),
  submissionHistory: jsonb("submission_history").array().default([]),
  lastStatusUpdate: timestamp("last_status_update"),
  metadata: jsonb("metadata").default({}),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});
```

Fields:
- `id`: Unique identifier for the distribution record
- `releaseId`: ID of the distributed release
- `platformId`: ID of the platform the release was distributed to
- `status`: Current status of the distribution
- `distributionDate`: Date when the distribution was processed
- `platformReleaseId`: ID assigned by the platform to the release
- `platformUrl`: URL to the release on the platform
- `errorDetails`: Details of any errors encountered
- `processingDetails`: Additional details about processing
- `submissionHistory`: History of submission attempts
- `lastStatusUpdate`: Timestamp of the last status change
- `metadata`: Flexible JSON structure for extended metadata
- `createdAt`: Timestamp when the record was created
- `updatedAt`: Timestamp when the record was last updated

#### `scheduled_distributions` Table

Manages scheduled future distributions for releases.

```typescript
export const scheduledDistributions = pgTable("scheduled_distributions", {
  id: serial("id").primaryKey(),
  releaseId: integer("release_id").notNull().references(() => releases.id, { onDelete: "cascade" }),
  userId: integer("user_id").notNull().references(() => users.id),
  scheduledDate: timestamp("scheduled_date").notNull(),
  platforms: integer("platform_ids").array().notNull(),
  status: varchar("status", { length: 20 }).notNull().default("pending"),
  completedPlatforms: integer("completed_platform_ids").array().default([]),
  failedPlatforms: jsonb("failed_platforms").default({}),
  notificationSent: boolean("notification_sent").default(false),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});
```

Fields:
- `id`: Unique identifier for the scheduled distribution
- `releaseId`: ID of the release to be distributed
- `userId`: ID of the user who scheduled the distribution
- `scheduledDate`: Date when the distribution should occur
- `platforms`: Array of platform IDs to distribute to
- `status`: Current status of the scheduled distribution
- `completedPlatforms`: Platforms where distribution completed
- `failedPlatforms`: Details of distribution failures
- `notificationSent`: Whether notification was sent on completion
- `createdAt`: Timestamp when the schedule was created
- `updatedAt`: Timestamp when the schedule was last updated

### Royalty Management Tables

#### `royalty_calculations` Table

Stores royalty calculations derived from streams, sales, and other revenue sources.

```typescript
export const royaltyCalculations = pgTable("royalty_calculations", {
  id: serial("id").primaryKey(),
  trackId: integer("track_id").notNull().references(() => tracks.id, { onDelete: "cascade" }),
  platformId: integer("platform_id").references(() => distributionPlatforms.id),
  distributionId: integer("distribution_id").references(() => distributionRecords.id),
  period: varchar("period", { length: 20 }).notNull(),
  streams: integer("streams").default(0),
  revenue: decimal("revenue", { precision: 12, scale: 4 }).default("0"),
  royaltyType: royaltyTypeEnum("royalty_type").notNull(),
  calculationDate: timestamp("calculation_date").notNull(),
  status: varchar("status", { length: 20 }).default("pending"),
  paidDate: timestamp("paid_date"),
  details: jsonb("details").default({}),
  exchangeRate: decimal("exchange_rate", { precision: 10, scale: 6 }),
  currency: varchar("currency", { length: 3 }).default("USD"),
  territory: varchar("territory", { length: 50 }),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});
```

Fields:
- `id`: Unique identifier for the royalty calculation
- `trackId`: ID of the track generating royalties
- `platformId`: ID of the platform generating royalties
- `distributionId`: ID of the related distribution record
- `period`: Time period for the calculation (e.g., "2025-03")
- `streams`: Number of streams for the period
- `revenue`: Revenue generated during the period
- `royaltyType`: Type of royalty (performance, mechanical, etc.)
- `calculationDate`: Date when the calculation was performed
- `status`: Current status of the royalty payment
- `paidDate`: Date when the royalty was paid
- `details`: Detailed breakdown of the calculation
- `exchangeRate`: Exchange rate used for currency conversion
- `currency`: Currency of the original revenue
- `territory`: Geographic region for the royalty
- `createdAt`: Timestamp when the calculation was created
- `updatedAt`: Timestamp when the calculation was last updated

#### `revenue_shares` Table

Defines revenue sharing arrangements between collaborators.

```typescript
export const revenueShares = pgTable("revenue_shares", {
  id: serial("id").primaryKey(),
  releaseId: integer("release_id").references(() => releases.id, { onDelete: "cascade" }),
  trackId: integer("track_id").references(() => tracks.id, { onDelete: "cascade" }),
  userId: integer("user_id").notNull().references(() => users.id),
  percentage: decimal("percentage", { precision: 5, scale: 2 }).notNull(),
  role: varchar("role", { length: 50 }).notNull(),
  name: varchar("name", { length: 100 }).notNull(),
  email: varchar("email", { length: 255 }),
  status: varchar("status", { length: 20 }).default("pending"),
  agreement: varchar("agreement", { length: 255 }),
  splitType: varchar("split_type", { length: 50 }).default("royalty"),
  customTerms: jsonb("custom_terms").default({}),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});
```

Fields:
- `id`: Unique identifier for the revenue share
- `releaseId`: ID of the release (for release-level splits)
- `trackId`: ID of the track (for track-level splits)
- `userId`: ID of the user receiving the share
- `percentage`: Percentage of revenue allocated
- `role`: Role of the contributor (composer, performer, etc.)
- `name`: Display name of the contributor
- `email`: Email address for notifications
- `status`: Current status of the agreement
- `agreement`: Reference to the signed agreement document
- `splitType`: Type of revenue split
- `customTerms`: Any custom terms for this arrangement
- `createdAt`: Timestamp when the split was created
- `updatedAt`: Timestamp when the split was last updated

#### `payment_methods` Table

Stores payment method information for royalty disbursements.

```typescript
export const paymentMethods = pgTable("payment_methods", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
  type: varchar("type", { length: 50 }).notNull(),
  name: varchar("name", { length: 100 }).notNull(),
  details: jsonb("details").notNull(),
  isDefault: boolean("is_default").default(false),
  status: varchar("status", { length: 20 }).default("active"),
  lastUsed: timestamp("last_used"),
  verificationStatus: varchar("verification_status", { length: 20 }).default("pending"),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});
```

Fields:
- `id`: Unique identifier for the payment method
- `userId`: ID of the user who owns this payment method
- `type`: Type of payment method
- `name`: Name/label for the payment method
- `details`: Securely stored payment details
- `isDefault`: Whether this is the default payment method
- `status`: Current status of the payment method
- `lastUsed`: Timestamp when the method was last used
- `verificationStatus`: Status of verification process
- `createdAt`: Timestamp when the method was created
- `updatedAt`: Timestamp when the method was last updated

#### `withdrawals` Table

Tracks withdrawal requests and their status.

```typescript
export const withdrawals = pgTable("withdrawals", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
  paymentMethodId: integer("payment_method_id").notNull().references(() => paymentMethods.id),
  amount: decimal("amount", { precision: 12, scale: 4 }).notNull(),
  currency: varchar("currency", { length: 3 }).default("USD"),
  status: varchar("status", { length: 20 }).default("pending"),
  processingDate: timestamp("processing_date"),
  completionDate: timestamp("completion_date"),
  reference: varchar("reference", { length: 100 }),
  notes: text("notes"),
  adminId: integer("admin_id").references(() => users.id),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});
```

Fields:
- `id`: Unique identifier for the withdrawal
- `userId`: ID of the user requesting the withdrawal
- `paymentMethodId`: ID of the payment method to use
- `amount`: Amount to withdraw
- `currency`: Currency of the withdrawal
- `status`: Current status of the withdrawal
- `processingDate`: Date when processing began
- `completionDate`: Date when the withdrawal completed
- `reference`: External reference number
- `notes`: Additional notes about the transaction
- `adminId`: ID of the admin who processed the withdrawal
- `createdAt`: Timestamp when the withdrawal was requested
- `updatedAt`: Timestamp when the withdrawal was last updated

### Analytics Tables

#### `analytics` Table

Stores detailed analytics data for tracks.

```typescript
export const analytics = pgTable("analytics", {
  id: serial("id").primaryKey(),
  trackId: integer("track_id").notNull().references(() => tracks.id, { onDelete: "cascade" }),
  platformId: integer("platform_id").references(() => distributionPlatforms.id),
  date: date("date").notNull(),
  streams: integer("streams").default(0),
  downloads: integer("downloads").default(0),
  revenue: decimal("revenue", { precision: 12, scale: 4 }).default("0"),
  territory: varchar("territory", { length: 50 }),
  demographicData: jsonb("demographic_data").default({}),
  marketingSource: varchar("marketing_source", { length: 100 }),
  playlistData: jsonb("playlist_data").default({}),
  createdAt: timestamp("created_at").defaultNow(),
});
```

Fields:
- `id`: Unique identifier for the analytics record
- `trackId`: ID of the track being analyzed
- `platformId`: ID of the platform providing the data
- `date`: Date of the analytics data
- `streams`: Number of streams on this date
- `downloads`: Number of downloads on this date
- `revenue`: Revenue generated on this date
- `territory`: Geographic territory for the data
- `demographicData`: Demographic information about listeners
- `marketingSource`: Source of traffic (if applicable)
- `playlistData`: Data about playlist inclusions
- `createdAt`: Timestamp when the record was created

#### `daily_stats` Table

Provides aggregated daily statistics for users.

```typescript
export const dailyStats = pgTable("daily_stats", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
  date: date("date").notNull(),
  totalStreams: integer("total_streams").default(0),
  totalRevenue: decimal("total_revenue", { precision: 12, scale: 4 }).default("0"),
  platformBreakdown: jsonb("platform_breakdown").default({}),
  territoryBreakdown: jsonb("territory_breakdown").default({}),
  trackPerformance: jsonb("track_performance").default({}),
  releasePerformance: jsonb("release_performance").default({}),
  trendData: jsonb("trend_data").default({}),
  createdAt: timestamp("created_at").defaultNow(),
});
```

Fields:
- `id`: Unique identifier for the stats record
- `userId`: ID of the user these stats belong to
- `date`: Date of the statistics
- `totalStreams`: Total streams across all platforms
- `totalRevenue`: Total revenue generated
- `platformBreakdown`: Breakdown of stats by platform
- `territoryBreakdown`: Breakdown of stats by territory
- `trackPerformance`: Performance metrics for individual tracks
- `releasePerformance`: Performance metrics for releases
- `trendData`: Data about trends and growth
- `createdAt`: Timestamp when the record was created

### Rights Management Tables

The rights management tables handle verification, ownership, and licensing of content.

#### `rights_management` Table

Tracks content ownership, licensing, and rights verification.

```typescript
export const rightsManagement = pgTable("rights_management", {
  id: serial("id").primaryKey(),
  releaseId: integer("release_id").references(() => releases.id, { onDelete: "cascade" }),
  trackId: integer("track_id").references(() => tracks.id, { onDelete: "cascade" }),
  userId: integer("user_id").notNull().references(() => users.id),
  ownershipType: ownershipTypeEnum("ownership_type").notNull(),
  verificationStatus: varchar("verification_status", { length: 20 }).default("pending"),
  verificationDate: timestamp("verification_date"),
  verifiedBy: integer("verified_by").references(() => users.id),
  documentationUrl: varchar("documentation_url", { length: 255 }),
  expirationDate: timestamp("expiration_date"),
  territories: text("territories").array(),
  royaltyTerms: jsonb("royalty_terms").default({}),
  licenseTerms: jsonb("license_terms").default({}),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});
```

Fields:
- `id`: Unique identifier for the rights record
- `releaseId`: ID of the release (for release-level rights)
- `trackId`: ID of the track (for track-level rights)
- `userId`: ID of the user claiming ownership
- `ownershipType`: Type of ownership claim
- `verificationStatus`: Status of verification process
- `verificationDate`: Date when verification was completed
- `verifiedBy`: ID of the admin who verified the claim
- `documentationUrl`: URL to supporting documentation
- `expirationDate`: Expiration date for the rights
- `territories`: Geographic territories covered
- `royaltyTerms`: Terms for royalty payments
- `licenseTerms`: Terms for licensing
- `createdAt`: Timestamp when the record was created
- `updatedAt`: Timestamp when the record was last updated

### Administration Tables

#### `support_tickets` Table

Manages support requests from users.

```typescript
export const supportTickets = pgTable("support_tickets", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull().references(() => users.id),
  subject: varchar("subject", { length: 255 }).notNull(),
  description: text("description").notNull(),
  status: varchar("status", { length: 20 }).notNull().default("open"),
  priority: varchar("priority", { length: 20 }).default("medium"),
  category: varchar("category", { length: 50 }).notNull(),
  assignedTo: integer("assigned_to").references(() => users.id),
  lastResponseDate: timestamp("last_response_date"),
  resolution: text("resolution"),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});
```

Fields:
- `id`: Unique identifier for the ticket
- `userId`: ID of the user who created the ticket
- `subject`: Ticket subject line
- `description`: Detailed description of the issue
- `status`: Current status of the ticket
- `priority`: Priority level of the ticket
- `category`: Category of the support issue
- `assignedTo`: ID of the admin assigned to the ticket
- `lastResponseDate`: Timestamp of the last response
- `resolution`: Description of the resolution
- `createdAt`: Timestamp when the ticket was created
- `updatedAt`: Timestamp when the ticket was last updated

#### `support_ticket_messages` Table

Stores messages in support ticket threads.

```typescript
export const supportTicketMessages = pgTable("support_ticket_messages", {
  id: serial("id").primaryKey(),
  ticketId: integer("ticket_id").notNull().references(() => supportTickets.id, { onDelete: "cascade" }),
  userId: integer("user_id").notNull().references(() => users.id),
  message: text("message").notNull(),
  attachments: jsonb("attachments").default([]),
  isInternal: boolean("is_internal").default(false),
  createdAt: timestamp("created_at").defaultNow(),
});
```

Fields:
- `id`: Unique identifier for the message
- `ticketId`: ID of the ticket this message belongs to
- `userId`: ID of the user who sent the message
- `message`: Text content of the message
- `attachments`: Array of attachment metadata
- `isInternal`: Whether the message is only visible to staff
- `createdAt`: Timestamp when the message was created

#### `super_admins` Table

Provides elevated privileges for platform administrators.

```typescript
export const superAdmins = pgTable("super_admins", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull().references(() => users.id).unique(),
  permissions: jsonb("permissions").default({}),
  lastLogin: timestamp("last_login"),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});
```

Fields:
- `id`: Unique identifier for the super admin record
- `userId`: ID of the user with super admin privileges
- `permissions`: Detailed permission configuration
- `lastLogin`: Timestamp of the last login
- `createdAt`: Timestamp when the record was created
- `updatedAt`: Timestamp when the record was last updated

#### `permission_templates` Table

Defines reusable permission sets for user roles.

```typescript
export const permissionTemplates = pgTable("permission_templates", {
  id: serial("id").primaryKey(),
  name: varchar("name", { length: 100 }).notNull(),
  description: text("description"),
  permissions: jsonb("permissions").notNull(),
  isDefault: boolean("is_default").default(false),
  createdBy: integer("created_by").notNull().references(() => users.id),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});
```

Fields:
- `id`: Unique identifier for the template
- `name`: Name of the permission template
- `description`: Description of the template's purpose
- `permissions`: JSON structure defining permissions
- `isDefault`: Whether this is a default template
- `createdBy`: ID of the user who created the template
- `createdAt`: Timestamp when the template was created
- `updatedAt`: Timestamp when the template was last updated

## Data Types & Enumerations

The schema uses several PostgreSQL enumerations to enforce consistent values for certain fields:

### `user_role` Enumeration

```typescript
export const userRoleEnum = pgEnum('user_role', [
  'artist',
  'label',
  'distributor',
  'admin',
  'sub_label',
  'publisher',
  'accountant',
  'marketing',
  'support',
  'viewer'
]);
```

### `user_status` Enumeration

```typescript
export const userStatusEnum = pgEnum('user_status', [
  'pending',
  'active',
  'suspended',
  'deactivated',
  'pending_approval',
  'rejected',
  'locked',
  'verification_required'
]);
```

### `approval_status` Enumeration

```typescript
export const approvalStatusEnum = pgEnum('approval_status', [
  'pending',
  'approved',
  'rejected',
  'needs_info',
  'under_review'
]);
```

### `content_type` Enumeration

```typescript
export const contentTypeEnum = pgEnum('content_type', [
  'single',
  'album',
  'ep',
  'compilation',
  'remix',
  'live'
]);
```

### `language` Enumeration

```typescript
export const languageEnum = pgEnum('language', [
  'english',
  'spanish',
  'french',
  'german',
  'hindi',
  'japanese',
  'korean',
  'portuguese',
  'russian',
  'mandarin',
  'cantonese',
  'arabic',
  'instrumental'
]);
```

### `distribution_status` Enumeration

```typescript
export const distributionStatusEnum = pgEnum('distribution_status', [
  'pending',
  'processing',
  'distributed',
  'failed',
  'scheduled',
  'canceled'
]);
```

### `royalty_type` Enumeration

```typescript
export const royaltyTypeEnum = pgEnum('royalty_type', [
  'performance',
  'mechanical',
  'synchronization',
  'print',
  'digital'
]);
```

### `ownership_type` Enumeration

```typescript
export const ownershipTypeEnum = pgEnum('ownership_type', [
  'original',
  'licensed',
  'public_domain',
  'sample_cleared',
  'remix_authorized'
]);
```

## JSON Structures

Many tables use JSON fields for flexible storage of complex data. Here are the key JSON structures:

### ContentTags Interface

```typescript
export interface ContentTags {
  genres: string[];
  moods: string[];
  themes: string[];
  keywords: string[];
  musicalElements: string[];
  occasions: string[];
  cultures: string[];
  eras: string[];
}
```

### AIAnalysis Interface

```typescript
export interface AIAnalysis {
  summary: string;
  qualityScore: number;
  contentWarnings: string[];
  suggestedImprovements: string[];
  genrePredictions: {
    primaryGenre: string;
    confidence: number;
    secondaryGenres: Array<{genre: string, confidence: number}>;
  };
  moodPredictions: Array<{mood: string, confidence: number}>;
  similarArtists: string[];
  keyPrediction: string;
  bpmPrediction: number;
  energyLevel: number;
  danceability: number;
  marketPotential: {
    streamingPotential: number;
    radioFriendliness: number;
    commercialViability: number;
    targetDemographics: string[];
  };
}
```

### Credits Interface

```typescript
export interface Credits {
  primaryArtist: string[];
  featuredArtists: string[];
  composers: string[];
  lyricists: string[];
  producers: string[];
  mixingEngineers: string[];
  masteringEngineers: string[];
  musicians: Array<{
    name: string;
    role: string;
    instrument?: string;
  }>;
  vocalists: Array<{
    name: string;
    role: string; // e.g., "lead", "backup", "harmony"
  }>;
  additionalPersonnel: Array<{
    name: string;
    role: string;
  }>;
  artworkCredits: {
    designer: string;
    photographer?: string;
    illustrator?: string;
    artDirector?: string;
  };
}
```

## Schema Validation with Zod

The database schema uses Zod for runtime validation of data that is inserted into the database. Here are the key validation schemas:

```typescript
// User insertion schema
export const insertUserSchema = createInsertSchema(users)
  .omit({ id: true, createdAt: true, updatedAt: true })
  .extend({
    email: z.string().email("Invalid email format"),
    password: z.string().min(8, "Password must be at least 8 characters"),
    username: z.string()
      .min(3, "Username must be at least 3 characters")
      .max(50, "Username must be at most 50 characters")
      .regex(/^[a-zA-Z0-9_-]+$/, "Username can only contain letters, numbers, underscores, and hyphens"),
  });

// Track insertion schema
export const insertTrackSchema = createInsertSchema(tracks)
  .omit({ id: true, createdAt: true, updatedAt: true })
  .extend({
    title: z.string().min(1, "Title is required"),
    artist: z.string().min(1, "Artist name is required"),
  });

// Release insertion schema
export const insertReleaseSchema = createInsertSchema(releases)
  .omit({ id: true, createdAt: true, updatedAt: true, upc: true })
  .extend({
    title: z.string().min(1, "Title is required"),
    artistNames: z.string().min(1, "Artist names are required"),
    releaseDate: z.coerce.date(),
  });
```

## Data Relationships

The schema has several important relationships that define how data is connected:

1. **User → Content**: Users create releases and tracks
2. **Release → Tracks**: Releases contain multiple tracks
3. **Content → Distribution**: Releases are distributed to platforms
4. **Content → Analytics**: Tracks generate analytics data
5. **Content → Royalties**: Tracks generate royalty calculations
6. **User → Finance**: Users have payment methods and withdrawals
7. **Content → Rights**: Releases and tracks have rights management records

## Index Strategy

The schema uses strategic indexes to optimize query performance:

```typescript
// Example indexes on the tracks table
export const tracksByUserIdIndex = pgIndex('idx_tracks_user_id').on(tracks).using('btree')([tracks.userId]);
export const tracksByReleaseIdIndex = pgIndex('idx_tracks_release_id').on(tracks).using('btree')([tracks.releaseId]);
export const tracksByIsrcIndex = pgIndex('idx_tracks_isrc').on(tracks).using('btree')([tracks.isrc]);

// Example indexes on the analytics table
export const analyticsByTrackIdIndex = pgIndex('idx_analytics_track_id').on(analytics).using('btree')([analytics.trackId]);
export const analyticsByDateIndex = pgIndex('idx_analytics_date').on(analytics).using('btree')([analytics.date]);
export const analyticsByTrackIdAndDateIndex = pgIndex('idx_analytics_track_id_date').on(analytics).using('btree')([analytics.trackId, analytics.date]);
```

## Migration Strategy

The project uses Drizzle Kit for database schema migrations. To apply schema changes:

1. Update the schema definitions in `shared/schema.ts`
2. Run `npm run db:push` to push schema changes to the database
3. For complex migrations that require data transformation, create a migration script

## Best Practices for Developers

When working with this database schema:

1. **Use Type Inference**: Always use the generated types (e.g., `User`, `Track`) for type-safe code
2. **Validate Input**: Use the Zod schemas (e.g., `insertUserSchema`) to validate input data
3. **Handle Relationships**: Ensure referential integrity by carefully managing relationships
4. **JSON Validation**: Validate JSON data against the defined interfaces before storage
5. **Query Optimization**: Use the provided indexes to optimize query performance
6. **Transactions**: Use transactions for operations that affect multiple tables
7. **Error Handling**: Implement proper error handling for database operations

## Example Database Operations

```typescript
// Example: Create a new user
const newUser: InsertUser = {
  username: 'artist123',
  email: 'artist@example.com',
  password: await hashPassword('securePassword123'),
  fullName: 'John Artist',
  role: 'artist',
};

const user = await db.insert(users).values(newUser).returning();

// Example: Create a release with tracks
const newRelease: InsertRelease = {
  userId: user.id,
  title: 'My First Album',
  type: 'album',
  releaseDate: new Date('2025-07-01'),
  artistNames: 'John Artist',
};

const release = await db.insert(releases).values(newRelease).returning();

const newTrack: InsertTrack = {
  releaseId: release.id,
  userId: user.id,
  title: 'Track One',
  artist: 'John Artist',
  trackNumber: 1,
};

await db.insert(tracks).values(newTrack);

// Example: Query tracks with release data
const tracksWithRelease = await db.query.tracks.findMany({
  with: {
    release: true,
  },
  where: eq(tracks.userId, user.id),
});
```

---

## documentation/technical/database/migrations.md

# Database Migrations

<div align="center">
  <img src="../../diagrams/migrations-header.svg" alt="TuneMantra Database Migrations" width="600"/>
</div>

## Overview

This document explains TuneMantra's database migration system, which uses Drizzle ORM's migration tools to manage schema changes. It covers migration creation, testing, and deployment processes, as well as best practices for ensuring data integrity during schema changes.

*Coming soon - This document is under development*

---

## documentation/technical/database/optimization.md

# Database Optimization

<div align="center">
  <img src="../../diagrams/database-optimization-header.svg" alt="TuneMantra Database Optimization" width="600"/>
</div>

## Overview

This document covers strategies and techniques for optimizing TuneMantra's database performance, including indexing strategies, query optimization, connection pooling, and scaling considerations. It provides guidance for maintaining high performance as the platform's data volume grows.

*Coming soon - This document is under development*

---

## documentation/technical/database-schema.md

# Database Schema Documentation

<div align="center">
  <img src="../diagrams/database-schema-header.svg" alt="TuneMantra Database Schema" width="600"/>
</div>

## Overview

This document provides a comprehensive description of the TuneMantra database schema. The database is implemented using PostgreSQL and is accessed through the Drizzle ORM. The schema is designed to support all aspects of the music distribution platform, including user management, content management, distribution tracking, rights management, royalty calculations, and analytics.

## Entity Relationship Diagram

```mermaid
erDiagram
    users ||--o{ api_keys : has
    users ||--o{ tracks : uploads
    users ||--o{ releases : creates
    users ||--o{ payment_methods : registers
    users ||--o{ withdrawals : requests
    users ||--o{ daily_stats : aggregates
    
    releases ||--o{ tracks : contains
    releases ||--o{ revenue_shares : splits
    releases ||--o{ distribution_records : distributes_to
    releases ||--o{ scheduled_distributions : schedules
    
    tracks ||--o{ analytics : generates
    tracks ||--o{ royalty_calculations : calculates
    
    distribution_platforms ||--o{ distribution_records : receives
    
    royalty_calculations }o--|| distribution_records : based_on
    
    super_admins ||--o{ users : manages
    users ||--o{ sub_label_audit_logs : logs_actions
    users ||--o{ permission_templates : assigns
    users ||--o{ release_approvals : approves
    users ||--o{ account_approvals : approves
    users ||--o{ support_tickets : creates
    
    support_tickets ||--o{ support_ticket_messages : contains
```

## Core Tables

### User Management Tables

#### `users` Table

The users table stores information about all users in the system, including artists, label managers, and administrators.

```typescript
export const users = pgTable("users", {
  id: serial("id").primaryKey(),
  username: varchar("username", { length: 50 }).notNull().unique(),
  email: varchar("email", { length: 255 }).notNull().unique(),
  password: varchar("password", { length: 255 }).notNull(),
  fullName: varchar("full_name", { length: 100 }).notNull(),
  role: userRoleEnum("role").notNull().default("artist"),
  status: userStatusEnum("status").notNull().default("pending"),
  profile: jsonb("profile").default({}),
  settings: jsonb("settings").default({}),
  parentLabelId: integer("parent_label_id").references(() => users.id),
  approvalStatus: approvalStatusEnum("approval_status").default("pending"),
  emailVerified: boolean("email_verified").default(false),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});
```

Fields:
- `id`: Unique identifier for the user
- `username`: Unique username for login
- `email`: User's email address
- `password`: Hashed password for authentication
- `fullName`: User's full name
- `role`: User's role in the system (artist, label, admin, etc.)
- `status`: Account status (pending, active, suspended, etc.)
- `profile`: Flexible JSON structure for profile information
- `settings`: User preferences and settings
- `parentLabelId`: For sub-labels, references the parent label
- `approvalStatus`: Status of account approval process
- `emailVerified`: Whether the user's email has been verified
- `createdAt`: Timestamp when the account was created
- `updatedAt`: Timestamp when the account was last updated

#### `api_keys` Table

Stores API keys for programmatic access to the platform.

```typescript
export const apiKeys = pgTable("api_keys", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
  name: varchar("name", { length: 50 }).notNull(),
  key: varchar("key", { length: 64 }).notNull().unique(),
  scopes: text("scopes").array().notNull(),
  lastUsed: timestamp("last_used"),
  expiresAt: timestamp("expires_at"),
  createdAt: timestamp("created_at").defaultNow(),
});
```

Fields:
- `id`: Unique identifier for the API key
- `userId`: ID of the user who owns this API key
- `name`: Name/label for the API key
- `key`: The actual API key string
- `scopes`: Array of permission scopes for this key
- `lastUsed`: Timestamp when the key was last used
- `expiresAt`: Expiration timestamp for the key
- `createdAt`: Timestamp when the key was created

### Content Management Tables

#### `releases` Table

Stores information about music releases (albums, singles, EPs, etc.).

```typescript
export const releases = pgTable("releases", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
  title: varchar("title", { length: 255 }).notNull(),
  type: contentTypeEnum("type").notNull(),
  releaseDate: timestamp("release_date").notNull(),
  artwork: varchar("artwork", { length: 255 }),
  upc: varchar("upc", { length: 20 }).unique(),
  genre: varchar("genre", { length: 50 }),
  language: languageEnum("language").default("english"),
  isExplicit: boolean("is_explicit").default(false),
  description: text("description"),
  artistNames: varchar("artist_names", { length: 255 }).notNull(),
  status: varchar("status", { length: 50 }).default("draft"),
  metadata: jsonb("metadata").default({}),
  tags: jsonb("tags").default({}),
  aiAnalysis: jsonb("ai_analysis").default({}),
  credits: jsonb("credits").default({}),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});
```

Fields:
- `id`: Unique identifier for the release
- `userId`: ID of the user who created the release
- `title`: Title of the release
- `type`: Type of release (single, album, EP, etc.)
- `releaseDate`: Scheduled or actual release date
- `artwork`: Path to artwork image file
- `upc`: Universal Product Code for the release
- `genre`: Primary genre of the release
- `language`: Primary language of the release content
- `isExplicit`: Whether the release contains explicit content
- `description`: Text description of the release
- `artistNames`: Display names of artists on the release
- `status`: Current status of the release
- `metadata`: Flexible JSON structure for extended metadata
- `tags`: Content tags for improved discoverability
- `aiAnalysis`: AI-generated insights and metadata
- `credits`: Detailed credits information
- `createdAt`: Timestamp when the release was created
- `updatedAt`: Timestamp when the release was last updated

#### `tracks` Table

Stores information about individual tracks within releases.

```typescript
export const tracks = pgTable("tracks", {
  id: serial("id").primaryKey(),
  releaseId: integer("release_id").references(() => releases.id, { onDelete: "cascade" }),
  userId: integer("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
  title: varchar("title", { length: 255 }).notNull(),
  artist: varchar("artist", { length: 255 }).notNull(),
  duration: integer("duration"),
  audioFile: varchar("audio_file", { length: 255 }),
  isrc: varchar("isrc", { length: 15 }).unique(),
  trackNumber: integer("track_number"),
  isExplicit: boolean("is_explicit").default(false),
  lyrics: text("lyrics"),
  genre: varchar("genre", { length: 50 }),
  language: languageEnum("language").default("english"),
  bpm: integer("bpm"),
  key: varchar("key", { length: 10 }),
  metadata: jsonb("metadata").default({}),
  tags: jsonb("tags").default({}),
  aiAnalysis: jsonb("ai_analysis").default({}),
  credits: jsonb("credits").default({}),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});
```

Fields:
- `id`: Unique identifier for the track
- `releaseId`: ID of the release this track belongs to
- `userId`: ID of the user who uploaded the track
- `title`: Title of the track
- `artist`: Artist name for the track
- `duration`: Duration of the track in seconds
- `audioFile`: Path to the audio file
- `isrc`: International Standard Recording Code
- `trackNumber`: Position of track within the release
- `isExplicit`: Whether the track contains explicit content
- `lyrics`: Text of the track lyrics
- `genre`: Primary genre of the track
- `language`: Primary language of the track
- `bpm`: Beats per minute (tempo)
- `key`: Musical key of the track
- `metadata`: Flexible JSON structure for extended metadata
- `tags`: Content tags for improved discoverability
- `aiAnalysis`: AI-generated insights and metadata
- `credits`: Detailed credits information
- `createdAt`: Timestamp when the track was created
- `updatedAt`: Timestamp when the track was last updated

### Distribution Management Tables

#### `distribution_platforms` Table

Stores information about external platforms where content can be distributed.

```typescript
export const distributionPlatforms = pgTable("distribution_platforms", {
  id: serial("id").primaryKey(),
  name: varchar("name", { length: 100 }).notNull(),
  logoUrl: varchar("logo_url", { length: 255 }),
  apiEndpoint: varchar("api_endpoint", { length: 255 }),
  apiCredentials: jsonb("api_credentials").default({}),
  status: varchar("status", { length: 20 }).default("active"),
  deliveryMethod: varchar("delivery_method", { length: 50 }).notNull(),
  requirements: jsonb("requirements").default({}),
  formatSpecs: jsonb("format_specs").default({}),
  supportedContent: text("supported_content").array(),
  territoryRestrictions: text("territory_restrictions").array(),
  processingTime: varchar("processing_time", { length: 50 }),
  royaltyRate: decimal("royalty_rate", { precision: 10, scale: 6 }),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});
```

Fields:
- `id`: Unique identifier for the platform
- `name`: Name of the distribution platform
- `logoUrl`: URL to the platform's logo image
- `apiEndpoint`: Base URL for the platform's API
- `apiCredentials`: Securely stored API credentials
- `status`: Current status of the platform integration
- `deliveryMethod`: Method used for content delivery
- `requirements`: Platform-specific content requirements
- `formatSpecs`: Specifications for audio and artwork formats
- `supportedContent`: Types of content supported by the platform
- `territoryRestrictions`: Geographic availability restrictions
- `processingTime`: Estimated processing time for submissions
- `royaltyRate`: Standard royalty rate paid by the platform
- `createdAt`: Timestamp when the platform was added
- `updatedAt`: Timestamp when the platform was last updated

#### `distribution_records` Table

Tracks the status and details of distributions to specific platforms.

```typescript
export const distributionRecords = pgTable("distribution_records", {
  id: serial("id").primaryKey(),
  releaseId: integer("release_id").notNull().references(() => releases.id, { onDelete: "cascade" }),
  platformId: integer("platform_id").notNull().references(() => distributionPlatforms.id),
  status: distributionStatusEnum("status").notNull().default("pending"),
  distributionDate: timestamp("distribution_date"),
  platformReleaseId: varchar("platform_release_id", { length: 100 }),
  platformUrl: varchar("platform_url", { length: 255 }),
  errorDetails: text("error_details"),
  processingDetails: jsonb("processing_details").default({}),
  submissionHistory: jsonb("submission_history").array().default([]),
  lastStatusUpdate: timestamp("last_status_update"),
  metadata: jsonb("metadata").default({}),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});
```

Fields:
- `id`: Unique identifier for the distribution record
- `releaseId`: ID of the distributed release
- `platformId`: ID of the platform the release was distributed to
- `status`: Current status of the distribution
- `distributionDate`: Date when the distribution was processed
- `platformReleaseId`: ID assigned by the platform to the release
- `platformUrl`: URL to the release on the platform
- `errorDetails`: Details of any errors encountered
- `processingDetails`: Additional details about processing
- `submissionHistory`: History of submission attempts
- `lastStatusUpdate`: Timestamp of the last status change
- `metadata`: Flexible JSON structure for extended metadata
- `createdAt`: Timestamp when the record was created
- `updatedAt`: Timestamp when the record was last updated

#### `scheduled_distributions` Table

Manages scheduled future distributions for releases.

```typescript
export const scheduledDistributions = pgTable("scheduled_distributions", {
  id: serial("id").primaryKey(),
  releaseId: integer("release_id").notNull().references(() => releases.id, { onDelete: "cascade" }),
  userId: integer("user_id").notNull().references(() => users.id),
  scheduledDate: timestamp("scheduled_date").notNull(),
  platforms: integer("platform_ids").array().notNull(),
  status: varchar("status", { length: 20 }).notNull().default("pending"),
  completedPlatforms: integer("completed_platform_ids").array().default([]),
  failedPlatforms: jsonb("failed_platforms").default({}),
  notificationSent: boolean("notification_sent").default(false),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});
```

Fields:
- `id`: Unique identifier for the scheduled distribution
- `releaseId`: ID of the release to be distributed
- `userId`: ID of the user who scheduled the distribution
- `scheduledDate`: Date when the distribution should occur
- `platforms`: Array of platform IDs to distribute to
- `status`: Current status of the scheduled distribution
- `completedPlatforms`: Platforms where distribution completed
- `failedPlatforms`: Details of distribution failures
- `notificationSent`: Whether notification was sent on completion
- `createdAt`: Timestamp when the schedule was created
- `updatedAt`: Timestamp when the schedule was last updated

### Royalty Management Tables

#### `royalty_calculations` Table

Stores royalty calculations derived from streams, sales, and other revenue sources.

```typescript
export const royaltyCalculations = pgTable("royalty_calculations", {
  id: serial("id").primaryKey(),
  trackId: integer("track_id").notNull().references(() => tracks.id, { onDelete: "cascade" }),
  platformId: integer("platform_id").references(() => distributionPlatforms.id),
  distributionId: integer("distribution_id").references(() => distributionRecords.id),
  period: varchar("period", { length: 20 }).notNull(),
  streams: integer("streams").default(0),
  revenue: decimal("revenue", { precision: 12, scale: 4 }).default("0"),
  royaltyType: royaltyTypeEnum("royalty_type").notNull(),
  calculationDate: timestamp("calculation_date").notNull(),
  status: varchar("status", { length: 20 }).default("pending"),
  paidDate: timestamp("paid_date"),
  details: jsonb("details").default({}),
  exchangeRate: decimal("exchange_rate", { precision: 10, scale: 6 }),
  currency: varchar("currency", { length: 3 }).default("USD"),
  territory: varchar("territory", { length: 50 }),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});
```

Fields:
- `id`: Unique identifier for the royalty calculation
- `trackId`: ID of the track generating royalties
- `platformId`: ID of the platform generating royalties
- `distributionId`: ID of the related distribution record
- `period`: Time period for the calculation (e.g., "2025-03")
- `streams`: Number of streams for the period
- `revenue`: Revenue generated during the period
- `royaltyType`: Type of royalty (performance, mechanical, etc.)
- `calculationDate`: Date when the calculation was performed
- `status`: Current status of the royalty payment
- `paidDate`: Date when the royalty was paid
- `details`: Detailed breakdown of the calculation
- `exchangeRate`: Exchange rate used for currency conversion
- `currency`: Currency of the original revenue
- `territory`: Geographic region for the royalty
- `createdAt`: Timestamp when the calculation was created
- `updatedAt`: Timestamp when the calculation was last updated

#### `revenue_shares` Table

Defines revenue sharing arrangements between collaborators.

```typescript
export const revenueShares = pgTable("revenue_shares", {
  id: serial("id").primaryKey(),
  releaseId: integer("release_id").references(() => releases.id, { onDelete: "cascade" }),
  trackId: integer("track_id").references(() => tracks.id, { onDelete: "cascade" }),
  userId: integer("user_id").notNull().references(() => users.id),
  percentage: decimal("percentage", { precision: 5, scale: 2 }).notNull(),
  role: varchar("role", { length: 50 }).notNull(),
  name: varchar("name", { length: 100 }).notNull(),
  email: varchar("email", { length: 255 }),
  status: varchar("status", { length: 20 }).default("pending"),
  agreement: varchar("agreement", { length: 255 }),
  splitType: varchar("split_type", { length: 50 }).default("royalty"),
  customTerms: jsonb("custom_terms").default({}),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});
```

Fields:
- `id`: Unique identifier for the revenue share
- `releaseId`: ID of the release (for release-level splits)
- `trackId`: ID of the track (for track-level splits)
- `userId`: ID of the user receiving the share
- `percentage`: Percentage of revenue allocated
- `role`: Role of the contributor (composer, performer, etc.)
- `name`: Display name of the contributor
- `email`: Email address for notifications
- `status`: Current status of the agreement
- `agreement`: Reference to the signed agreement document
- `splitType`: Type of revenue split
- `customTerms`: Any custom terms for this arrangement
- `createdAt`: Timestamp when the split was created
- `updatedAt`: Timestamp when the split was last updated

#### `payment_methods` Table

Stores payment method information for royalty disbursements.

```typescript
export const paymentMethods = pgTable("payment_methods", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
  type: varchar("type", { length: 50 }).notNull(),
  name: varchar("name", { length: 100 }).notNull(),
  details: jsonb("details").notNull(),
  isDefault: boolean("is_default").default(false),
  status: varchar("status", { length: 20 }).default("active"),
  lastUsed: timestamp("last_used"),
  verificationStatus: varchar("verification_status", { length: 20 }).default("pending"),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});
```

Fields:
- `id`: Unique identifier for the payment method
- `userId`: ID of the user who owns this payment method
- `type`: Type of payment method
- `name`: Name/label for the payment method
- `details`: Securely stored payment details
- `isDefault`: Whether this is the default payment method
- `status`: Current status of the payment method
- `lastUsed`: Timestamp when the method was last used
- `verificationStatus`: Status of verification process
- `createdAt`: Timestamp when the method was created
- `updatedAt`: Timestamp when the method was last updated

#### `withdrawals` Table

Tracks withdrawal requests and their status.

```typescript
export const withdrawals = pgTable("withdrawals", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
  paymentMethodId: integer("payment_method_id").notNull().references(() => paymentMethods.id),
  amount: decimal("amount", { precision: 12, scale: 4 }).notNull(),
  currency: varchar("currency", { length: 3 }).default("USD"),
  status: varchar("status", { length: 20 }).default("pending"),
  processingDate: timestamp("processing_date"),
  completionDate: timestamp("completion_date"),
  reference: varchar("reference", { length: 100 }),
  notes: text("notes"),
  adminId: integer("admin_id").references(() => users.id),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});
```

Fields:
- `id`: Unique identifier for the withdrawal
- `userId`: ID of the user requesting the withdrawal
- `paymentMethodId`: ID of the payment method to use
- `amount`: Amount to withdraw
- `currency`: Currency of the withdrawal
- `status`: Current status of the withdrawal
- `processingDate`: Date when processing began
- `completionDate`: Date when the withdrawal completed
- `reference`: External reference number
- `notes`: Additional notes about the transaction
- `adminId`: ID of the admin who processed the withdrawal
- `createdAt`: Timestamp when the withdrawal was requested
- `updatedAt`: Timestamp when the withdrawal was last updated

### Analytics Tables

#### `analytics` Table

Stores detailed analytics data for tracks.

```typescript
export const analytics = pgTable("analytics", {
  id: serial("id").primaryKey(),
  trackId: integer("track_id").notNull().references(() => tracks.id, { onDelete: "cascade" }),
  platformId: integer("platform_id").references(() => distributionPlatforms.id),
  date: date("date").notNull(),
  streams: integer("streams").default(0),
  downloads: integer("downloads").default(0),
  revenue: decimal("revenue", { precision: 12, scale: 4 }).default("0"),
  territory: varchar("territory", { length: 50 }),
  demographicData: jsonb("demographic_data").default({}),
  marketingSource: varchar("marketing_source", { length: 100 }),
  playlistData: jsonb("playlist_data").default({}),
  createdAt: timestamp("created_at").defaultNow(),
});
```

Fields:
- `id`: Unique identifier for the analytics record
- `trackId`: ID of the track being analyzed
- `platformId`: ID of the platform providing the data
- `date`: Date of the analytics data
- `streams`: Number of streams on this date
- `downloads`: Number of downloads on this date
- `revenue`: Revenue generated on this date
- `territory`: Geographic territory for the data
- `demographicData`: Demographic information about listeners
- `marketingSource`: Source of traffic (if applicable)
- `playlistData`: Data about playlist inclusions
- `createdAt`: Timestamp when the record was created

#### `daily_stats` Table

Provides aggregated daily statistics for users.

```typescript
export const dailyStats = pgTable("daily_stats", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
  date: date("date").notNull(),
  totalStreams: integer("total_streams").default(0),
  totalRevenue: decimal("total_revenue", { precision: 12, scale: 4 }).default("0"),
  platformBreakdown: jsonb("platform_breakdown").default({}),
  territoryBreakdown: jsonb("territory_breakdown").default({}),
  trackPerformance: jsonb("track_performance").default({}),
  releasePerformance: jsonb("release_performance").default({}),
  trendData: jsonb("trend_data").default({}),
  createdAt: timestamp("created_at").defaultNow(),
});
```

Fields:
- `id`: Unique identifier for the stats record
- `userId`: ID of the user these stats belong to
- `date`: Date of the statistics
- `totalStreams`: Total streams across all platforms
- `totalRevenue`: Total revenue generated
- `platformBreakdown`: Breakdown of stats by platform
- `territoryBreakdown`: Breakdown of stats by territory
- `trackPerformance`: Performance metrics for individual tracks
- `releasePerformance`: Performance metrics for releases
- `trendData`: Data about trends and growth
- `createdAt`: Timestamp when the record was created

### Rights Management Tables

The rights management tables handle verification, ownership, and licensing of content.

#### `rights_management` Table

Tracks content ownership, licensing, and rights verification.

```typescript
export const rightsManagement = pgTable("rights_management", {
  id: serial("id").primaryKey(),
  releaseId: integer("release_id").references(() => releases.id, { onDelete: "cascade" }),
  trackId: integer("track_id").references(() => tracks.id, { onDelete: "cascade" }),
  userId: integer("user_id").notNull().references(() => users.id),
  ownershipType: ownershipTypeEnum("ownership_type").notNull(),
  verificationStatus: varchar("verification_status", { length: 20 }).default("pending"),
  verificationDate: timestamp("verification_date"),
  verifiedBy: integer("verified_by").references(() => users.id),
  documentationUrl: varchar("documentation_url", { length: 255 }),
  expirationDate: timestamp("expiration_date"),
  territories: text("territories").array(),
  royaltyTerms: jsonb("royalty_terms").default({}),
  licenseTerms: jsonb("license_terms").default({}),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});
```

Fields:
- `id`: Unique identifier for the rights record
- `releaseId`: ID of the release (for release-level rights)
- `trackId`: ID of the track (for track-level rights)
- `userId`: ID of the user claiming ownership
- `ownershipType`: Type of ownership claim
- `verificationStatus`: Status of verification process
- `verificationDate`: Date when verification was completed
- `verifiedBy`: ID of the admin who verified the claim
- `documentationUrl`: URL to supporting documentation
- `expirationDate`: Expiration date for the rights
- `territories`: Geographic territories covered
- `royaltyTerms`: Terms for royalty payments
- `licenseTerms`: Terms for licensing
- `createdAt`: Timestamp when the record was created
- `updatedAt`: Timestamp when the record was last updated

### Administration Tables

#### `support_tickets` Table

Manages support requests from users.

```typescript
export const supportTickets = pgTable("support_tickets", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull().references(() => users.id),
  subject: varchar("subject", { length: 255 }).notNull(),
  description: text("description").notNull(),
  status: varchar("status", { length: 20 }).notNull().default("open"),
  priority: varchar("priority", { length: 20 }).default("medium"),
  category: varchar("category", { length: 50 }).notNull(),
  assignedTo: integer("assigned_to").references(() => users.id),
  lastResponseDate: timestamp("last_response_date"),
  resolution: text("resolution"),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});
```

Fields:
- `id`: Unique identifier for the ticket
- `userId`: ID of the user who created the ticket
- `subject`: Ticket subject line
- `description`: Detailed description of the issue
- `status`: Current status of the ticket
- `priority`: Priority level of the ticket
- `category`: Category of the support issue
- `assignedTo`: ID of the admin assigned to the ticket
- `lastResponseDate`: Timestamp of the last response
- `resolution`: Description of the resolution
- `createdAt`: Timestamp when the ticket was created
- `updatedAt`: Timestamp when the ticket was last updated

#### `support_ticket_messages` Table

Stores messages in support ticket threads.

```typescript
export const supportTicketMessages = pgTable("support_ticket_messages", {
  id: serial("id").primaryKey(),
  ticketId: integer("ticket_id").notNull().references(() => supportTickets.id, { onDelete: "cascade" }),
  userId: integer("user_id").notNull().references(() => users.id),
  message: text("message").notNull(),
  attachments: jsonb("attachments").default([]),
  isInternal: boolean("is_internal").default(false),
  createdAt: timestamp("created_at").defaultNow(),
});
```

Fields:
- `id`: Unique identifier for the message
- `ticketId`: ID of the ticket this message belongs to
- `userId`: ID of the user who sent the message
- `message`: Text content of the message
- `attachments`: Array of attachment metadata
- `isInternal`: Whether the message is only visible to staff
- `createdAt`: Timestamp when the message was created

#### `super_admins` Table

Provides elevated privileges for platform administrators.

```typescript
export const superAdmins = pgTable("super_admins", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull().references(() => users.id).unique(),
  permissions: jsonb("permissions").default({}),
  lastLogin: timestamp("last_login"),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});
```

Fields:
- `id`: Unique identifier for the super admin record
- `userId`: ID of the user with super admin privileges
- `permissions`: Detailed permission configuration
- `lastLogin`: Timestamp of the last login
- `createdAt`: Timestamp when the record was created
- `updatedAt`: Timestamp when the record was last updated

#### `permission_templates` Table

Defines reusable permission sets for user roles.

```typescript
export const permissionTemplates = pgTable("permission_templates", {
  id: serial("id").primaryKey(),
  name: varchar("name", { length: 100 }).notNull(),
  description: text("description"),
  permissions: jsonb("permissions").notNull(),
  isDefault: boolean("is_default").default(false),
  createdBy: integer("created_by").notNull().references(() => users.id),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});
```

Fields:
- `id`: Unique identifier for the template
- `name`: Name of the permission template
- `description`: Description of the template's purpose
- `permissions`: JSON structure defining permissions
- `isDefault`: Whether this is a default template
- `createdBy`: ID of the user who created the template
- `createdAt`: Timestamp when the template was created
- `updatedAt`: Timestamp when the template was last updated

## Data Types & Enumerations

The schema uses several PostgreSQL enumerations to enforce consistent values for certain fields:

### `user_role` Enumeration

```typescript
export const userRoleEnum = pgEnum('user_role', [
  'artist',
  'label',
  'distributor',
  'admin',
  'sub_label',
  'publisher',
  'accountant',
  'marketing',
  'support',
  'viewer'
]);
```

### `user_status` Enumeration

```typescript
export const userStatusEnum = pgEnum('user_status', [
  'pending',
  'active',
  'suspended',
  'deactivated',
  'pending_approval',
  'rejected',
  'locked',
  'verification_required'
]);
```

### `approval_status` Enumeration

```typescript
export const approvalStatusEnum = pgEnum('approval_status', [
  'pending',
  'approved',
  'rejected',
  'needs_info',
  'under_review'
]);
```

### `content_type` Enumeration

```typescript
export const contentTypeEnum = pgEnum('content_type', [
  'single',
  'album',
  'ep',
  'compilation',
  'remix',
  'live'
]);
```

### `language` Enumeration

```typescript
export const languageEnum = pgEnum('language', [
  'english',
  'spanish',
  'french',
  'german',
  'hindi',
  'japanese',
  'korean',
  'portuguese',
  'russian',
  'mandarin',
  'cantonese',
  'arabic',
  'instrumental'
]);
```

### `distribution_status` Enumeration

```typescript
export const distributionStatusEnum = pgEnum('distribution_status', [
  'pending',
  'processing',
  'distributed',
  'failed',
  'scheduled',
  'canceled'
]);
```

### `royalty_type` Enumeration

```typescript
export const royaltyTypeEnum = pgEnum('royalty_type', [
  'performance',
  'mechanical',
  'synchronization',
  'print',
  'digital'
]);
```

### `ownership_type` Enumeration

```typescript
export const ownershipTypeEnum = pgEnum('ownership_type', [
  'original',
  'licensed',
  'public_domain',
  'sample_cleared',
  'remix_authorized'
]);
```

## JSON Structures

Many tables use JSON fields for flexible storage of complex data. Here are the key JSON structures:

### ContentTags Interface

```typescript
export interface ContentTags {
  genres: string[];
  moods: string[];
  themes: string[];
  keywords: string[];
  musicalElements: string[];
  occasions: string[];
  cultures: string[];
  eras: string[];
}
```

### AIAnalysis Interface

```typescript
export interface AIAnalysis {
  summary: string;
  qualityScore: number;
  contentWarnings: string[];
  suggestedImprovements: string[];
  genrePredictions: {
    primaryGenre: string;
    confidence: number;
    secondaryGenres: Array<{genre: string, confidence: number}>;
  };
  moodPredictions: Array<{mood: string, confidence: number}>;
  similarArtists: string[];
  keyPrediction: string;
  bpmPrediction: number;
  energyLevel: number;
  danceability: number;
  marketPotential: {
    streamingPotential: number;
    radioFriendliness: number;
    commercialViability: number;
    targetDemographics: string[];
  };
}
```

### Credits Interface

```typescript
export interface Credits {
  primaryArtist: string[];
  featuredArtists: string[];
  composers: string[];
  lyricists: string[];
  producers: string[];
  mixingEngineers: string[];
  masteringEngineers: string[];
  musicians: Array<{
    name: string;
    role: string;
    instrument?: string;
  }>;
  vocalists: Array<{
    name: string;
    role: string; // e.g., "lead", "backup", "harmony"
  }>;
  additionalPersonnel: Array<{
    name: string;
    role: string;
  }>;
  artworkCredits: {
    designer: string;
    photographer?: string;
    illustrator?: string;
    artDirector?: string;
  };
}
```

## Schema Validation with Zod

The database schema uses Zod for runtime validation of data that is inserted into the database. Here are the key validation schemas:

```typescript
// User insertion schema
export const insertUserSchema = createInsertSchema(users)
  .omit({ id: true, createdAt: true, updatedAt: true })
  .extend({
    email: z.string().email("Invalid email format"),
    password: z.string().min(8, "Password must be at least 8 characters"),
    username: z.string()
      .min(3, "Username must be at least 3 characters")
      .max(50, "Username must be at most 50 characters")
      .regex(/^[a-zA-Z0-9_-]+$/, "Username can only contain letters, numbers, underscores, and hyphens"),
  });

// Track insertion schema
export const insertTrackSchema = createInsertSchema(tracks)
  .omit({ id: true, createdAt: true, updatedAt: true })
  .extend({
    title: z.string().min(1, "Title is required"),
    artist: z.string().min(1, "Artist name is required"),
  });

// Release insertion schema
export const insertReleaseSchema = createInsertSchema(releases)
  .omit({ id: true, createdAt: true, updatedAt: true, upc: true })
  .extend({
    title: z.string().min(1, "Title is required"),
    artistNames: z.string().min(1, "Artist names are required"),
    releaseDate: z.coerce.date(),
  });
```

## Data Relationships

The schema has several important relationships that define how data is connected:

1. **User → Content**: Users create releases and tracks
2. **Release → Tracks**: Releases contain multiple tracks
3. **Content → Distribution**: Releases are distributed to platforms
4. **Content → Analytics**: Tracks generate analytics data
5. **Content → Royalties**: Tracks generate royalty calculations
6. **User → Finance**: Users have payment methods and withdrawals
7. **Content → Rights**: Releases and tracks have rights management records

## Index Strategy

The schema uses strategic indexes to optimize query performance:

```typescript
// Example indexes on the tracks table
export const tracksByUserIdIndex = pgIndex('idx_tracks_user_id').on(tracks).using('btree')([tracks.userId]);
export const tracksByReleaseIdIndex = pgIndex('idx_tracks_release_id').on(tracks).using('btree')([tracks.releaseId]);
export const tracksByIsrcIndex = pgIndex('idx_tracks_isrc').on(tracks).using('btree')([tracks.isrc]);

// Example indexes on the analytics table
export const analyticsByTrackIdIndex = pgIndex('idx_analytics_track_id').on(analytics).using('btree')([analytics.trackId]);
export const analyticsByDateIndex = pgIndex('idx_analytics_date').on(analytics).using('btree')([analytics.date]);
export const analyticsByTrackIdAndDateIndex = pgIndex('idx_analytics_track_id_date').on(analytics).using('btree')([analytics.trackId, analytics.date]);
```

## Migration Strategy

The project uses Drizzle Kit for database schema migrations. To apply schema changes:

1. Update the schema definitions in `shared/schema.ts`
2. Run `npm run db:push` to push schema changes to the database
3. For complex migrations that require data transformation, create a migration script

## Best Practices for Developers

When working with this database schema:

1. **Use Type Inference**: Always use the generated types (e.g., `User`, `Track`) for type-safe code
2. **Validate Input**: Use the Zod schemas (e.g., `insertUserSchema`) to validate input data
3. **Handle Relationships**: Ensure referential integrity by carefully managing relationships
4. **JSON Validation**: Validate JSON data against the defined interfaces before storage
5. **Query Optimization**: Use the provided indexes to optimize query performance
6. **Transactions**: Use transactions for operations that affect multiple tables
7. **Error Handling**: Implement proper error handling for database operations

## Example Database Operations

```typescript
// Example: Create a new user
const newUser: InsertUser = {
  username: 'artist123',
  email: 'artist@example.com',
  password: await hashPassword('securePassword123'),
  fullName: 'John Artist',
  role: 'artist',
};

const user = await db.insert(users).values(newUser).returning();

// Example: Create a release with tracks
const newRelease: InsertRelease = {
  userId: user.id,
  title: 'My First Album',
  type: 'album',
  releaseDate: new Date('2025-07-01'),
  artistNames: 'John Artist',
};

const release = await db.insert(releases).values(newRelease).returning();

const newTrack: InsertTrack = {
  releaseId: release.id,
  userId: user.id,
  title: 'Track One',
  artist: 'John Artist',
  trackNumber: 1,
};

await db.insert(tracks).values(newTrack);

// Example: Query tracks with release data
const tracksWithRelease = await db.query.tracks.findMany({
  with: {
    release: true,
  },
  where: eq(tracks.userId, user.id),
});
```

---

## documentation/technical/distribution/distribution-system.md

# Distribution System

*Version: 1.0.0 (March 27, 2025)*

## Table of Contents

- [Introduction](#introduction)
- [System Architecture](#system-architecture)
- [Core Components](#core-components)
- [Content Delivery Pipeline](#content-delivery-pipeline)
- [Platform Integrations](#platform-integrations)
- [Distribution Protocols](#distribution-protocols)
- [Monitoring and Status Tracking](#monitoring-and-status-tracking)
- [Error Handling and Recovery](#error-handling-and-recovery)
- [Metadata Management](#metadata-management)
- [Scheduling and Timing Controls](#scheduling-and-timing-controls)
- [Territory Management](#territory-management)
- [Security Measures](#security-measures)
- [Performance Optimization](#performance-optimization)
- [Administration Interface](#administration-interface)
- [Future Developments](#future-developments)
- [Appendix](#appendix)

## Introduction

The TuneMantra Distribution System represents the core delivery infrastructure that connects content creators to global music platforms. This document provides comprehensive details about the system's architecture, components, processes, and capabilities for distributing music content to over 150 digital service providers worldwide.

### Purpose and Scope

This document describes:

- The complete distribution architecture and technology stack
- Core system components and their interactions
- Content delivery processes and protocols
- Platform integration specifications
- Monitoring, error handling, and recovery mechanisms
- Performance characteristics and optimization techniques
- Administration and configuration capabilities

### Background

The digital music distribution landscape requires sophisticated infrastructure to reliably deliver content to diverse platforms with varying technical requirements, metadata standards, and delivery protocols. The TuneMantra Distribution System was developed to address these challenges while providing scale, reliability, and transparency.

Key challenges addressed include:

- Heterogeneous platform requirements for content and metadata
- Complex validation rules across different services
- Significant volume variations (from individual tracks to catalog migrations)
- Strict timing requirements for synchronized global releases
- Comprehensive tracking and status reporting needs
- Different territorial availability patterns and restrictions
- Ongoing platform evolution requiring adaptation capabilities

### Business Objectives

The Distribution System supports the following business objectives:

1. **Reliability**: Ensure consistent, error-free delivery of content
2. **Coverage**: Support comprehensive distribution to all major and niche platforms
3. **Timeliness**: Enable precise release timing and global coordination
4. **Transparency**: Provide clear visibility into distribution status
5. **Efficiency**: Optimize the delivery process for speed and resource usage
6. **Adaptability**: Rapidly incorporate new platforms and changing requirements
7. **Scalability**: Handle growing volume and catalog size without degradation

## System Architecture

The Distribution System is designed as a scalable, microservice-based architecture with specialized components for different aspects of the distribution process.

### High-Level Architecture

The system follows a layered architecture with these primary layers:

1. **Access Layer**: APIs and interfaces for system interaction
2. **Orchestration Layer**: Coordination of distribution workflows
3. **Processing Layer**: Content transformation and preparation
4. **Delivery Layer**: Platform-specific delivery mechanisms
5. **Monitoring Layer**: Status tracking and reporting
6. **Storage Layer**: Content and metadata repositories

### System Context

The Distribution System interacts with:

1. **Content Management System**: Source of releases and tracks
2. **Rights Management System**: Source of ownership and availability rules
3. **User Management System**: Source of permissions and organization info
4. **Analytics System**: Consumer of distribution and performance data
5. **External Platforms**: Destination services for content delivery
6. **Notification System**: Alerting for distribution events and issues

### Technology Stack

The system is built using:

1. **Programming Languages**: TypeScript/Node.js for services, Go for performance-critical components
2. **Container Platform**: Kubernetes for orchestration and scaling
3. **Message Broker**: Kafka for event streaming and async processing
4. **Storage Systems**: S3-compatible object storage for content, PostgreSQL for metadata
5. **Caching Layer**: Redis for high-speed data access
6. **API Gateway**: Custom gateway with rate limiting and authentication
7. **Monitoring Stack**: Prometheus, Grafana, and ELK for observability

### Deployment Model

The system is deployed across:

1. **Multi-region Infrastructure**: Global presence for improved latency
2. **Edge Caching**: CDN integration for content delivery
3. **Regional Processing**: Localized transformation for efficiency
4. **Central Coordination**: Global orchestration and monitoring
5. **Redundant Components**: High-availability for critical services
6. **Auto-scaling Groups**: Dynamic resource allocation based on load

## Core Components

The Distribution System consists of several specialized components, each responsible for specific aspects of the distribution process.

### Distribution Orchestrator

The Distribution Orchestrator serves as the central coordinator for all distribution activities.

#### Responsibilities

1. **Workflow Management**: Coordination of end-to-end distribution processes
2. **Task Allocation**: Assignment of work to specialized components
3. **State Tracking**: Maintenance of distribution job status
4. **Priority Handling**: Execution ordering based on importance and timing
5. **Dependency Management**: Handling of prerequisite relationships
6. **Error Coordination**: Centralized error handling and recovery

#### Key Features

1. **Dynamic Workflow Creation**: Generation of platform-specific workflows
2. **Parallel Processing**: Simultaneous distribution to multiple platforms
3. **Circuit Breaking**: Prevention of cascading failures
4. **Retry Management**: Intelligent handling of transient errors
5. **SLA Monitoring**: Tracking of timing commitments
6. **Audit Trail**: Comprehensive logging of distribution events

### Content Processor

The Content Processor handles transformation and preparation of audio and image assets for platform delivery.

#### Responsibilities

1. **Format Conversion**: Transformation to platform-required formats
2. **Quality Verification**: Validation of technical specifications
3. **Encoding Optimization**: Platform-specific encoding parameters
4. **Watermarking**: Application of digital watermarks when required
5. **Encryption**: Content protection for secure delivery
6. **Packaging**: Bundling of content and metadata for delivery

#### Supported Formats

1. **Audio Formats**: WAV, FLAC, AIFF, MP3, AAC, Opus
2. **Image Formats**: JPG, PNG, TIFF, WebP
3. **Video Formats**: MP4, MOV, WebM
4. **Container Formats**: ZIP, TAR, Custom bundles
5. **Metadata Formats**: JSON, XML, CSV, Platform-specific formats

#### Processing Capabilities

1. **High-Resolution Processing**: Support for 24-bit/192kHz audio
2. **Sample Rate Conversion**: Precise resampling algorithms
3. **Loudness Normalization**: LUFS-based loudness processing
4. **Image Resizing**: High-quality scaling and cropping
5. **Batch Processing**: Efficient handling of multiple assets
6. **Distributed Processing**: Parallel execution across computing resources

### Metadata Transformer

The Metadata Transformer handles the conversion, enrichment, and validation of content metadata for different platforms.

#### Responsibilities

1. **Schema Transformation**: Conversion between metadata models
2. **Validation**: Verification against platform requirements
3. **Enrichment**: Addition of supplementary information
4. **Normalization**: Standardization of text and values
5. **Localization**: Territory-specific metadata adaptation
6. **Compliance Checking**: Verification of content policy adherence

#### Metadata Operations

1. **Field Mapping**: Translation between schema structures
2. **Format Conversion**: Transformation between serialization formats
3. **Value Validation**: Verification against allowed values and patterns
4. **Relationship Mapping**: Preservation of entity relationships
5. **Default Application**: Insertion of standard values when needed
6. **Error Flagging**: Identification of problematic metadata

#### Supported Schemas

1. **Industry Standards**: DDEX ERN, DDEX DSR
2. **Platform-specific**: Spotify, Apple Music, Amazon Music, etc.
3. **Internal Schema**: TuneMantra canonical metadata model
4. **Legacy Formats**: Historical industry schemas
5. **Extensible Support**: Dynamic schema definition capability

### Platform Adapters

Platform Adapters provide specialized interfaces for delivery to specific digital service providers.

#### Responsibilities

1. **Connection Management**: Establishment and maintenance of platform links
2. **Protocol Implementation**: Platform-specific communication methods
3. **Authentication**: Secure access to platform APIs
4. **Delivery Execution**: Transmission of content and metadata
5. **Status Retrieval**: Collection of platform processing status
6. **Error Handling**: Platform-specific error management

#### Adapter Architecture

1. **Modular Design**: Separate adapter for each platform
2. **Common Interface**: Standardized interaction pattern
3. **Configuration-driven**: Adaptable behavior through settings
4. **Version Support**: Handling of API version differences
5. **Circuit Breaking**: Protection against platform failures
6. **Metrics Collection**: Performance and reliability tracking

#### Supported Connection Types

1. **REST APIs**: Standard web service interfaces
2. **SOAP Services**: XML-based API protocols
3. **SFTP Delivery**: Secure file transfer protocol
4. **Direct S3**: Cloud storage integration
5. **Specialized APIs**: Custom platform protocols
6. **Legacy Systems**: Support for older delivery methods

### Status Tracker

The Status Tracker monitors and reports on the status of content across all distribution platforms.

#### Responsibilities

1. **Status Collection**: Gathering of platform processing states
2. **Status Normalization**: Standardization across platforms
3. **State Aggregation**: Combined view of multi-platform status
4. **Notification Generation**: Alerts based on status changes
5. **SLA Monitoring**: Tracking against expected timelines
6. **Historical Recording**: Preservation of status evolution

#### Status Retrieval Methods

1. **Active Polling**: Periodic status inquiries
2. **Webhook Receivers**: Processing of platform callbacks
3. **Event Consumers**: Handling of platform event streams
4. **Email Processing**: Parsing of status notifications
5. **Portal Integration**: Retrieval from web interfaces
6. **Direct Database Access**: Where platform-authorized

#### Status Aggregation

The system provides:

1. **Release-level Status**: Overall state of multi-track packages
2. **Track-level Details**: Individual asset status
3. **Platform-specific Status**: Native state from each service
4. **Normalized Status**: Cross-platform standardized states
5. **Timeline View**: Progression of status over time
6. **Issue Categorization**: Classification of problems by type

### Takedown Manager

The Takedown Manager handles the removal of content from distribution platforms when required.

#### Responsibilities

1. **Takedown Request Processing**: Handling of removal instructions
2. **Platform Notification**: Communication with distribution services
3. **Verification**: Confirmation of successful removal
4. **Partial Takedowns**: Management of territory or track-specific removals
5. **Temporary Suspensions**: Time-limited content withdrawal
6. **Reinstatement**: Return of previously removed content

#### Takedown Capabilities

1. **Emergency Takedowns**: Expedited removal for urgent situations
2. **Scheduled Takedowns**: Future-dated content withdrawal
3. **Selective Takedowns**: Platform, territory, or track-specific removal
4. **Bulk Operations**: Efficient handling of catalog-wide actions
5. **Takedown Reasons**: Structured categorization of removal causes
6. **Compliance Documentation**: Record-keeping for legal requirements

#### Takedown Workflow

The takedown process includes:

1. **Request Validation**: Verification of takedown authority
2. **Impact Assessment**: Evaluation of removal consequences
3. **Execution Planning**: Determination of removal approach
4. **Platform Notification**: Communication with relevant services
5. **Status Tracking**: Monitoring of takedown progress
6. **Completion Verification**: Confirmation of successful removal
7. **Documentation**: Recording of takedown details

## Content Delivery Pipeline

The Distribution System employs a sophisticated pipeline for content delivery, ensuring reliable and efficient distribution to all platforms.

### Intake Stage

The delivery process begins with content intake:

1. **Release Selection**: Identification of content for distribution
2. **Validation Checks**: Initial verification of readiness
3. **Priority Assignment**: Determination of processing order
4. **Resource Allocation**: Assignment of processing capacity
5. **Workflow Creation**: Generation of distribution plan
6. **Job Initialization**: Setup of distribution tracking

### Preparation Stage

Content undergoes preparation for delivery:

1. **Asset Retrieval**: Access to master content files
2. **Technical Analysis**: Evaluation of content characteristics
3. **Format Identification**: Determination of source formats
4. **Quality Assessment**: Verification of technical quality
5. **Metadata Compilation**: Assembly of descriptive information
6. **Dependency Resolution**: Handling of related content

### Transformation Stage

Content is transformed for platform requirements:

1. **Format Conversion**: Transcoding to required formats
2. **Resolution Adjustment**: Sample rate and bit depth conversion
3. **Loudness Processing**: Volume normalization to standards
4. **Metadata Translation**: Conversion to platform schemas
5. **Image Processing**: Artwork resizing and format conversion
6. **Packaging**: Bundling of assets and metadata

### Validation Stage

Comprehensive validation ensures delivery quality:

1. **Technical Validation**: Verification of audio/image specifications
2. **Metadata Validation**: Checking against platform requirements
3. **Completeness Verification**: Confirmation of all required elements
4. **Compliance Checking**: Evaluation against platform policies
5. **Territory Validation**: Verification of geographic availability
6. **Release Date Verification**: Confirmation of timing correctness

### Delivery Stage

Content is transmitted to platforms:

1. **Connection Establishment**: Secure link to platform
2. **Authentication**: Verification of delivery credentials
3. **Transfer Initiation**: Commencement of content transmission
4. **Progress Monitoring**: Tracking of delivery completion
5. **Verification**: Confirmation of successful receipt
6. **Receipt Processing**: Handling of platform acknowledgments

### Post-Delivery Stage

After delivery, the system:

1. **Status Collection**: Gathering of processing information
2. **Issue Detection**: Identification of platform-reported problems
3. **Correction Handling**: Resolution of identified issues
4. **Availability Confirmation**: Verification of live status
5. **Notification**: Communication of distribution outcomes
6. **Documentation**: Recording of distribution details

### Error Recovery Processes

When issues occur, the system provides:

1. **Automatic Retry**: Reattempt after transient failures
2. **Alternative Routing**: Fallback delivery methods
3. **Partial Success Handling**: Management of incomplete deliveries
4. **Manual Intervention**: Tools for operator resolution
5. **Root Cause Analysis**: Identification of failure sources
6. **Learning Mechanisms**: Improvement based on failure patterns

## Platform Integrations

The Distribution System integrates with a comprehensive range of digital service providers, implementing platform-specific requirements and protocols.

### Major Streaming Services

#### Spotify Integration

1. **Delivery Method**: Spotify API with OAuth authentication
2. **Content Requirements**: 
   - Audio: WAV (16-bit/44.1kHz)
   - Images: JPG (3000x3000px, RGB)
3. **Metadata Schema**: Custom JSON format with specific fields
4. **Special Features**:
   - Canvas support (looping video)
   - Storyline integration
   - Enhanced album support
5. **Status Tracking**: Webhook-based status updates
6. **Delivery Time**: Typically 24-48 hours to availability

#### Apple Music Integration

1. **Delivery Method**: Dedicated API endpoints
2. **Content Requirements**:
   - Audio: WAV (24-bit/96kHz preferred)
   - Images: TIFF or JPG (3000x3000px, RGB)
3. **Metadata Schema**: Modified DDEX with extensions
4. **Special Features**:
   - Lyrics synchronization
   - Dolby Atmos support
   - Spatial Audio delivery
5. **Status Tracking**: Pull-based status API
6. **Delivery Time**: Typically 24-72 hours to availability

#### Amazon Music Integration

1. **Delivery Method**: S3 bucket transfer with notification
2. **Content Requirements**:
   - Audio: FLAC (16-bit/44.1kHz minimum)
   - Images: JPG (3000x3000px, RGB)
3. **Metadata Schema**: JSON-based proprietary format
4. **Special Features**:
   - HD Audio labeling
   - X-Ray lyrics
   - Alexa integration
5. **Status Tracking**: Email notifications + API
6. **Delivery Time**: Typically 48-96 hours to availability

### Download Stores

#### iTunes Store

1. **Delivery Method**: Transporter tool API
2. **Content Requirements**:
   - Audio: WAV (24-bit/96kHz)
   - Images: TIFF or JPG (3000x3000px, RGB)
3. **Metadata Schema**: iTunes-specific XML format
4. **Special Features**:
   - Complete My Album
   - Pre-order capability
   - Digital booklet support
5. **Status Tracking**: iTunes Connect API
6. **Delivery Time**: Typically 24-72 hours to availability

#### Beatport

1. **Delivery Method**: SFTP with structured directories
2. **Content Requirements**:
   - Audio: WAV (16-bit/44.1kHz)
   - Images: JPG (3000x3000px, RGB)
3. **Metadata Schema**: Modified DDEX format
4. **Special Features**:
   - DJ metadata (BPM, key)
   - Genre-specific categorization
   - Exclusive content support
5. **Status Tracking**: Email notification + portal
6. **Delivery Time**: Typically 5-10 business days to availability

### Video Platforms

#### YouTube Music

1. **Delivery Method**: YouTube API with asset delivery
2. **Content Requirements**:
   - Audio: WAV or FLAC
   - Video (if applicable): MP4 (H.264)
   - Images: JPG (3000x3000px minimum)
3. **Metadata Schema**: YouTube Content API format
4. **Special Features**:
   - Content ID integration
   - Art track generation
   - Topic channel mapping
5. **Status Tracking**: YouTube API status endpoints
6. **Delivery Time**: Typically 24-72 hours to availability

#### TikTok

1. **Delivery Method**: Commercial Music Library API
2. **Content Requirements**:
   - Audio: WAV (16-bit/44.1kHz)
   - Images: JPG (1000x1000px minimum)
3. **Metadata Schema**: Proprietary JSON format
4. **Special Features**:
   - Sound categorization
   - Creator verification
   - Trend optimization
5. **Status Tracking**: API-based status checks
6. **Delivery Time**: Typically 48-96 hours to availability

### Regional Platforms

#### JioSaavn (India)

1. **Delivery Method**: SFTP batch delivery
2. **Content Requirements**:
   - Audio: MP3 (320kbps)
   - Images: JPG (1000x1000px minimum)
3. **Metadata Schema**: Custom CSV format
4. **Special Features**:
   - Bollywood categorization
   - Regional language support
   - Artist verification
5. **Status Tracking**: Email notification + portal
6. **Delivery Time**: Typically 1-2 weeks to availability

#### QQ Music (China)

1. **Delivery Method**: Dedicated API endpoints
2. **Content Requirements**:
   - Audio: WAV or MP3 (320kbps)
   - Images: JPG (1000x1000px minimum)
3. **Metadata Schema**: Specialized XML format
4. **Special Features**:
   - Simplified Chinese metadata
   - Lyric translation
   - China-specific content filtering
5. **Status Tracking**: API-based status reporting
6. **Delivery Time**: Typically 2-3 weeks to availability

### Metadata Aggregators

#### Gracenote

1. **Delivery Method**: SFTP batch delivery
2. **Content Requirements**:
   - Audio: Reference files in MP3
   - Images: JPG (500x500px minimum)
3. **Metadata Schema**: Gracenote XML format
4. **Special Features**:
   - Acoustic fingerprinting
   - Extended metadata enrichment
   - Global identifier mapping
5. **Status Tracking**: Portal-based verification
6. **Delivery Time**: Typically 1-2 weeks to availability

#### MusicBrainz

1. **Delivery Method**: API-based submission
2. **Content Requirements**:
   - No audio required
   - Images: Optional JPG
3. **Metadata Schema**: MusicBrainz database schema
4. **Special Features**:
   - Open data integration
   - Community verification
   - Relationship mapping
5. **Status Tracking**: Portal-based verification
6. **Delivery Time**: Typically 1-4 weeks depending on community review

## Distribution Protocols

The Distribution System implements various delivery protocols to accommodate diverse platform requirements.

### Direct API Integration

For platforms with API-based delivery:

1. **Authentication Methods**:
   - OAuth 2.0 with client credentials
   - API key authorization
   - JWT token authentication
   - Custom authentication schemes
2. **Request Patterns**:
   - REST API calls with JSON payloads
   - GraphQL queries for flexible data retrieval
   - RPC-style method invocation
   - Batch API operations for efficiency
3. **Data Formats**:
   - JSON for most modern interfaces
   - XML for legacy or specialized systems
   - Protocol Buffers for efficient serialization
   - Custom binary formats for specific platforms
4. **API Capabilities**:
   - Content upload with multipart encoding
   - Metadata update operations
   - Status polling mechanisms
   - Content management functions
5. **Implementation Approaches**:
   - Dedicated adapter per platform
   - Standardized client libraries
   - Rate limiting and backoff strategies
   - Connection pooling for efficiency

### File Transfer Integration

For platforms using file-based delivery:

1. **Transfer Protocols**:
   - SFTP (SSH File Transfer Protocol)
   - FTPS (FTP with SSL/TLS)
   - SCP (Secure Copy Protocol)
   - Direct S3/Cloud Storage upload
2. **File Organization**:
   - Structured directory hierarchies
   - Naming conventions for content identification
   - Manifest files for batch processing
   - Checksum verification for integrity
3. **Delivery Patterns**:
   - Complete package delivery
   - Delta updates for changes only
   - Atomic operations with temporary directories
   - Notification files for processing triggers
4. **Security Measures**:
   - Key-based authentication
   - IP restriction for access control
   - Encrypted transfer channels
   - Temporary credential management
5. **Operational Features**:
   - Transfer resumption for large files
   - Bandwidth throttling where needed
   - Scheduled transfer windows
   - Automated cleanup procedures

### Webhook-Based Communication

For event-driven interactions:

1. **Webhook Registration**:
   - Dynamic endpoint registration
   - Verification challenges
   - Subscription management
   - Topic-based filtering
2. **Event Processing**:
   - Asynchronous event handling
   - Idempotent processing design
   - Event ordering preservation
   - Dead letter queues for failures
3. **Security Considerations**:
   - Payload signature verification
   - IP validation
   - Rate limiting protection
   - Replay attack prevention
4. **Implementation Features**:
   - Event buffering for traffic spikes
   - Retry mechanisms with backoff
   - Event persistence for reliability
   - Circuit breaking for downstream protection

### Batch Processing Integration

For scheduled bulk operations:

1. **Batch Types**:
   - Periodic data exports (daily, weekly, monthly)
   - Threshold-triggered batches
   - Manual batch creation
   - Incremental update batches
2. **Batch Structure**:
   - Manifest files with batch details
   - Content bundles with multiple assets
   - Metadata packages in standardized formats
   - Control files for processing instructions
3. **Processing Patterns**:
   - Sequential processing with dependencies
   - Parallel processing where possible
   - Checkpoint-based progress tracking
   - Resumable batch processing
4. **Verification Methods**:
   - Checksums for data integrity
   - Record counts for completeness
   - Cross-reference validation
   - Sample-based quality checks

## Monitoring and Status Tracking

The Distribution System provides comprehensive monitoring and status tracking capabilities for complete visibility into the distribution process.

### Status Model

The system uses a comprehensive status model:

1. **Core Status States**:
   - `Pending`: Awaiting processing
   - `Processing`: Currently being handled
   - `Delivered`: Successfully sent to platform
   - `Live`: Available on platform
   - `Rejected`: Refused by platform
   - `Error`: Failed during processing
   - `Taken Down`: Removed from platform
2. **Substates for Detail**:
   - Platform-specific processing states
   - Error categorization
   - Verification stages
   - Availability qualifiers
3. **Status Attributes**:
   - Timestamp information
   - Source identifiers
   - Message details
   - Action requirements

### Status Collection

Status information is gathered through:

1. **Active Methods**:
   - Scheduled API polling
   - Portal scraping where necessary
   - Direct database queries (where permitted)
   - Automated email processing
2. **Passive Methods**:
   - Webhook event reception
   - Notification processing
   - File drop monitoring
   - Message queue consumption
3. **Manual Supplements**:
   - Operator status updates
   - Support ticket integration
   - Platform representative communication

### Status Aggregation

The system provides aggregated views:

1. **Hierarchical Aggregation**:
   - Track-level detail
   - Release-level summary
   - Catalog-level overview
   - Platform-level status
2. **Temporal Aggregation**:
   - Current status snapshot
   - Historical progression
   - Time-to-live measurements
   - SLA compliance tracking
3. **Organizational Views**:
   - Label-specific dashboards
   - Artist-oriented views
   - Admin monitoring consoles
   - Executive summaries

### Status Notifications

Alerts and notifications include:

1. **Event-triggered Alerts**:
   - Status change notifications
   - Error alerts
   - Completion notifications
   - SLA breach warnings
2. **Scheduled Reports**:
   - Daily status summaries
   - Weekly delivery reports
   - Monthly performance metrics
   - Quarterly trend analysis
3. **Notification Methods**:
   - In-system alerts
   - Email notifications
   - SMS for critical issues
   - Push notifications
   - Slack/Teams integration

### Operational Monitoring

System health monitoring includes:

1. **Infrastructure Metrics**:
   - Server health and load
   - Network performance
   - Storage utilization
   - Queue depths
2. **Application Metrics**:
   - Processing throughput
   - Error rates
   - Response times
   - Queue latency
3. **Business Metrics**:
   - Delivery volumes
   - Success rates
   - Platform performance
   - SLA compliance

### Visualization Capabilities

Status information is visualized through:

1. **Dashboards**:
   - Real-time status overview
   - Platform-specific views
   - Release monitoring panels
   - Error tracking interfaces
2. **Status Timeline**:
   - Chronological progression
   - Milestone indicators
   - Comparative timelines
   - Projection vs. actual
3. **Distribution Maps**:
   - Geographic availability visualization
   - Platform coverage maps
   - Territory status differences
   - Regional performance indicators

## Error Handling and Recovery

The Distribution System implements robust error handling and recovery mechanisms to ensure reliability and resilience.

### Error Classification

Errors are categorized for appropriate handling:

1. **Technical Errors**:
   - Connection failures
   - Timeout issues
   - Resource limitations
   - System unavailability
2. **Content Errors**:
   - Format problems
   - Quality issues
   - Missing assets
   - Corrupt files
3. **Metadata Errors**:
   - Schema violations
   - Missing required fields
   - Validation failures
   - Inconsistent information
4. **Business Rule Errors**:
   - Policy violations
   - Rights conflicts
   - Scheduling issues
   - Compliance problems
5. **Platform Errors**:
   - Service-specific rejections
   - Processing failures
   - Quota limitations
   - API changes

### Error Detection

The system detects errors through:

1. **Active Monitoring**:
   - Process outcome verification
   - Expected result validation
   - Status confirmation checks
   - Heartbeat monitoring
2. **Exception Handling**:
   - Try-catch mechanisms
   - Promise rejection handling
   - Error boundary implementation
   - Global error interceptors
3. **External Notifications**:
   - Platform error messages
   - Webhook failure events
   - Status API error reports
   - Support ticket information

### Recovery Strategies

Recovery approaches include:

1. **Automatic Retries**:
   - Exponential backoff implementation
   - Retry count limitations
   - Conditional retry logic
   - Circuit breaking for persistent failures
2. **Alternative Routing**:
   - Fallback delivery methods
   - Secondary API endpoints
   - Alternative authentication approaches
   - Backup processing paths
3. **Resource Adjustment**:
   - Dynamic timeout extension
   - Increased resource allocation
   - Throttling and rate adjustment
   - Batch size optimization
4. **Content Adaptation**:
   - Automatic format correction
   - Metadata enrichment
   - Alternative asset selection
   - Rule-based content adjustment

### Manual Intervention

For non-recoverable errors:

1. **Error Queues**:
   - Prioritized issue lists
   - Categorized problem buckets
   - Assignment to specialists
   - Resolution tracking
2. **Intervention Tools**:
   - Manual delivery controls
   - Content editing capabilities
   - Override mechanisms
   - Direct platform communication tools
3. **Workflow Integration**:
   - Ticket creation
   - Notification to responsible parties
   - Escalation procedures
   - Knowledge base integration

### Learning Mechanisms

The system improves through:

1. **Error Pattern Analysis**:
   - Frequency and distribution tracking
   - Common failure mode identification
   - Correlation with system changes
   - Platform-specific issue patterns
2. **Preventative Updates**:
   - Pre-validation improvement
   - Process optimization
   - Documentation enhancement
   - Platform-specific adaptations
3. **Knowledge Capture**:
   - Solution documentation
   - Error resolution playbooks
   - Platform quirk recording
   - Best practice evolution

## Metadata Management

The Distribution System includes sophisticated capabilities for handling the complex metadata requirements of music distribution.

### Metadata Model

The core metadata model includes:

1. **Release Metadata**:
   - Title information
   - Artist details
   - Release date
   - Genre and style
   - Copyright information
   - UPC/EAN code
2. **Track Metadata**:
   - Title information
   - Artist details
   - Composer information
   - Producer credits
   - ISRC code
   - Duration and BPM
3. **Contributor Metadata**:
   - Primary artists
   - Featured artists
   - Composers and lyricists
   - Producers and engineers
   - Remixers
   - Session musicians
4. **Rights Metadata**:
   - Ownership information
   - Publishing details
   - Licensing terms
   - Territory restrictions
   - Explicit content flags
   - Release restrictions

### Metadata Transformation

The system provides transformation capabilities:

1. **Schema Mapping**:
   - Field-to-field mappings
   - Value transformations
   - Default value application
   - Conditional logic
2. **Format Conversion**:
   - JSON/XML/CSV generation
   - Custom format serialization
   - Binary format conversion
   - Legacy format support
3. **Metadata Enrichment**:
   - Auto-completion of missing fields
   - Reference data integration
   - Language translation
   - Formatting standardization
4. **Validation Rules**:
   - Platform-specific constraints
   - Business rule validation
   - Format verification
   - Consistency checking

### Platform-specific Adaptations

The system handles diverse platform requirements:

1. **Field Mapping Variations**:
   - Platform-specific field names
   - Different cardinality rules
   - Required vs. optional fields
   - Platform-unique attributes
2. **Value Formatting**:
   - Date format differences
   - Text length limitations
   - Character set restrictions
   - Genre taxonomy mapping
3. **Structural Differences**:
   - Hierarchical vs. flat models
   - Grouping variations
   - Relationship modeling differences
   - Inheritance patterns

### Metadata Storage

Metadata is managed through:

1. **Canonical Storage**:
   - Master metadata repository
   - Version control for changes
   - Full history preservation
   - Relationship management
2. **Derived Storage**:
   - Platform-specific renditions
   - Cached transformations
   - Delivery-optimized formats
   - Distribution records
3. **Metadata Services**:
   - Retrieval APIs
   - Search capabilities
   - Batch export functions
   - Update mechanisms

### Special Metadata Features

The system supports advanced metadata capabilities:

1. **Multi-language Support**:
   - Localized title/description
   - Character set handling
   - Transliteration services
   - Language-specific formatting
2. **Media Type-specific Metadata**:
   - Audio-specific attributes
   - Image-specific attributes
   - Video-specific attributes
   - Bundle-specific attributes
3. **Extended Attributes**:
   - Mood and theme tagging
   - Keyword enrichment
   - Promotional text
   - SEO optimization
4. **Contextual Information**:
   - Release background
   - Artist biography
   - Recording information
   - Label context

## Scheduling and Timing Controls

The Distribution System provides sophisticated controls for release timing and scheduling.

### Release Date Management

Capabilities for release timing include:

1. **Global Release Coordination**:
   - Friday global release support
   - Time zone-aware scheduling
   - Regional release patterns
   - Embargoed content handling
2. **Pre-release Workflow**:
   - Advance distribution timeframes
   - Platform-specific lead times
   - Pre-order enablement
   - Pre-save/pre-add support
3. **Release Modifications**:
   - Date change handling
   - Rush release support
   - Emergency timeframe compression
   - Postponement management

### Scheduling Controls

Scheduling capabilities include:

1. **Distribution Schedules**:
   - Platform-optimized timing
   - Priority-based sequencing
   - Resource-aware scheduling
   - Dependency-based ordering
2. **Batch Management**:
   - Grouped release handling
   - Volume-based batching
   - Efficiency optimization
   - Peak avoidance
3. **Time-based Features**:
   - Timed metadata updates
   - Phased content release
   - Scheduled takedowns
   - Automated redelivery

### Calendar Integration

The system provides calendar features:

1. **Release Calendar**:
   - Visual timeline display
   - Deadline tracking
   - Conflict identification
   - Resource allocation view
2. **Platform Calendars**:
   - Service-specific deadlines
   - Processing time visibility
   - Holiday/downtime awareness
   - Maintenance window tracking
3. **Planning Tools**:
   - Lead time calculator
   - Deadline visualization
   - Resource forecasting
   - Timeline modeling

### Timing Analytics

Timing analytics provide:

1. **Performance Metrics**:
   - Actual vs. planned timing
   - Platform processing times
   - End-to-end delivery duration
   - SLA compliance rates
2. **Trend Analysis**:
   - Seasonal variation patterns
   - Platform performance changes
   - Volume correlation effects
   - Improvement over time
3. **Optimization Insights**:
   - Optimal submission windows
   - Resource allocation guidance
   - Process bottleneck identification
   - Lead time recommendations

## Territory Management

The Distribution System provides comprehensive territory management for global music distribution.

### Territory Model

The territory model includes:

1. **Geographic Entities**:
   - Countries (ISO 3166-1)
   - Regions (continents, subcontinents)
   - Custom territory groupings
   - Global designation
2. **Territory Attributes**:
   - Language preferences
   - Currency information
   - Regulatory requirements
   - Platform availability
3. **Territory Relationships**:
   - Inclusion hierarchies
   - Exclusion patterns
   - Priority designations
   - Market categorization

### Availability Controls

Territory availability is managed through:

1. **Inclusion Models**:
   - Worldwide availability
   - Specific territory selection
   - Regional grouping
   - Market-based selection
2. **Exclusion Models**:
   - Global with exceptions
   - Blacklist territories
   - Temporary restrictions
   - Phased availability
3. **Modification Patterns**:
   - Territory expansion
   - Territory restriction
   - Temporary availability changes
   - Region-specific takedowns

### Platform Territory Mapping

The system handles platform territory differences:

1. **Territory Code Mapping**:
   - Platform-specific country codes
   - Territory group translation
   - Legacy territory handling
   - Custom region mapping
2. **Availability Expression**:
   - Platform-specific territory formats
   - Inclusion/exclusion conversion
   - Territory list optimization
   - Conflict resolution
3. **Territory Validation**:
   - Platform territory support checking
   - Availability conflict detection
   - Rights territory verification
   - Geographic coherence checking

### Territory-specific Features

The system supports:

1. **Regional Metadata**:
   - Territory-specific titles
   - Local language descriptions
   - Regional categorization
   - Market-specific artwork
2. **Price Tiering**:
   - Territory-based pricing
   - Currency settings
   - Market-specific offers
   - Regional discount support
3. **Compliance Features**:
   - Territory-specific content rules
   - Regulatory adherence tools
   - Regional age rating
   - Market-specific requirements

## Security Measures

The Distribution System incorporates robust security measures to protect content and ensure secure operations.

### Content Protection

Content security includes:

1. **Asset Protection**:
   - Secure storage with encryption
   - Access control for content
   - Watermarking capability
   - Digital fingerprinting
2. **Transfer Security**:
   - Encrypted transmission channels
   - Secure protocols (SFTP, HTTPS)
   - Integrity verification
   - Access token protection
3. **Platform Security**:
   - Credential management
   - IP restriction where supported
   - Session security
   - Key rotation practices

### Access Controls

System access is protected through:

1. **Authentication**:
   - Multi-factor authentication
   - Role-based access control
   - Permission granularity
   - Session management
2. **Authorization**:
   - Catalog-level permissions
   - Platform-specific rights
   - Action-based controls
   - Organization boundaries
3. **Audit Features**:
   - Comprehensive action logging
   - Access tracking
   - Change history
   - Anomaly detection

### Data Security

Data protection includes:

1. **Storage Security**:
   - Database encryption
   - File system protection
   - Backup encryption
   - Secure deletion practices
2. **Data Handling**:
   - Sensitive data identification
   - Minimized data collection
   - Retention policy enforcement
   - Secure transfer methods
3. **Privacy Controls**:
   - Personal data protection
   - Consent management
   - Access request handling
   - Data portability support

### Operational Security

Operational safeguards include:

1. **System Hardening**:
   - Minimal attack surface
   - Regular updates and patching
   - Configuration security
   - Defense in depth
2. **Monitoring and Detection**:
   - Security event monitoring
   - Intrusion detection
   - Anomaly identification
   - Vulnerability scanning
3. **Incident Response**:
   - Security incident procedures
   - Escalation processes
   - Containment strategies
   - Recovery methods

## Performance Optimization

The Distribution System incorporates various optimizations to ensure efficient operation at scale.

### Throughput Optimization

Throughput improvements include:

1. **Parallel Processing**:
   - Multi-threaded execution
   - Worker pool management
   - Sharded processing
   - Pipeline parallelization
2. **Batch Optimization**:
   - Optimal batch sizing
   - Grouped operations
   - Bulk API utilization
   - Transaction batching
3. **Resource Management**:
   - CPU affinity optimization
   - Memory usage tuning
   - I/O operation minimization
   - Network optimization

### Latency Reduction

Latency improvements include:

1. **Caching Strategies**:
   - Multi-level caching
   - Data locality optimization
   - Predictive pre-loading
   - Cache invalidation control
2. **Process Streamlining**:
   - Critical path optimization
   - Unnecessary step elimination
   - Blocking operation minimization
   - Asynchronous processing
3. **Network Optimization**:
   - Connection pooling
   - Keep-alive management
   - Request pipelining
   - Data compression

### Resource Efficiency

Efficiency measures include:

1. **Compute Optimization**:
   - Right-sized instances
   - Auto-scaling implementation
   - Spot instance utilization
   - Load-based provisioning
2. **Storage Optimization**:
   - Tiered storage utilization
   - Compression strategies
   - Deduplication
   - Lifecycle management
3. **Network Efficiency**:
   - Traffic shaping
   - Bandwidth allocation
   - CDN utilization
   - Regional routing

### Scalability Features

Scalability is enabled through:

1. **Horizontal Scaling**:
   - Stateless service design
   - Consistent hashing
   - Distributed processing
   - Load balancing
2. **Vertical Scaling**:
   - Resource limit adjustment
   - Memory optimization
   - CPU utilization improvements
   - I/O enhancement
3. **Database Scaling**:
   - Read replica utilization
   - Write sharding strategies
   - Connection pooling
   - Query optimization

## Administration Interface

The Distribution System provides comprehensive administration capabilities for system management and oversight.

### Distribution Control Center

The main administration interface includes:

1. **Dashboard Views**:
   - System status overview
   - Active distribution jobs
   - Performance metrics
   - Issue monitoring
2. **Search and Filtering**:
   - Release lookup
   - Status-based filtering
   - Platform-specific views
   - Date range selection
3. **Action Controls**:
   - Distribution initiation
   - Process intervention
   - Manual status update
   - Error resolution

### Configuration Management

System configuration capabilities include:

1. **Platform Settings**:
   - Connection parameters
   - Delivery options
   - Authentication management
   - Feature flags
2. **Process Configuration**:
   - Workflow definitions
   - Validation rules
   - Processing parameters
   - Notification settings
3. **Schedule Management**:
   - Job scheduling
   - Maintenance windows
   - Processing calendars
   - Resource allocation

### Monitoring and Reporting

Administrative monitoring includes:

1. **Real-time Monitoring**:
   - Active job status
   - System health metrics
   - Queue depths
   - Error conditions
2. **Historical Reporting**:
   - Performance trends
   - Success rates
   - Volume statistics
   - SLA compliance
3. **Alert Management**:
   - Notification configuration
   - Alert routing
   - Escalation rules
   - Status subscriptions

### Operational Tools

Administrative tools include:

1. **Troubleshooting Utilities**:
   - Log exploration
   - Diagnostic tools
   - Test delivery capability
   - Connection verification
2. **Manual Controls**:
   - Force redelivery
   - Status override
   - Priority adjustment
   - Process termination
3. **Maintenance Functions**:
   - Cache management
   - Queue administration
   - Credential rotation
   - Configuration updates

## Future Developments

The Distribution System continues to evolve with planned enhancements and expansions.

### Near-term Roadmap

Upcoming enhancements include:

1. **Platform Expansion**:
   - Integration with emerging platforms
   - Enhanced social media distribution
   - Web3 platform support
   - Live streaming service integration
2. **Process Improvements**:
   - AI-enhanced metadata processing
   - Automated error correction
   - Predictive delivery optimization
   - Enhanced batching strategies
3. **Performance Enhancements**:
   - Improved parallel processing
   - Enhanced caching architecture
   - Lower latency status tracking
   - Optimized resource utilization

### Strategic Directions

Long-term vision includes:

1. **Intelligent Distribution**:
   - ML-based delivery optimization
   - Predictive timing models
   - Automated platform selection
   - Self-healing error recovery
2. **Enhanced Analytics**:
   - Real-time distribution insights
   - Comparative platform metrics
   - Predictive availability models
   - Release strategy optimization
3. **Extended Capabilities**:
   - Video distribution enhancements
   - Interactive content support
   - Virtual/augmented reality assets
   - NFT and blockchain integration

## Appendix

### Glossary

- **DSP (Digital Service Provider)**: Platform that distributes digital music
- **Delivery**: Process of transferring content to a platform
- **Ingestion**: Platform's process of accepting and processing content
- **Takedown**: Removal of content from platforms
- **Asset**: Digital file such as audio or image
- **Metadata**: Descriptive information about music content
- **Territory**: Geographic region for content availability
- **DDEX**: Digital Data Exchange standard for the music industry
- **XML**: Extensible Markup Language, a format for data interchange
- **JSON**: JavaScript Object Notation, a lightweight data format
- **API**: Application Programming Interface for software interaction
- **SFTP**: Secure File Transfer Protocol for file transmission
- **Webhook**: HTTP callback for event notification

### Reference Documents

- Original Distribution Network Architecture (August 2023)
- Platform Integration Guide v3.0 (January 2024)
- Metadata Transformation Specification v2.5 (March 2024)
- Error Handling Procedures v1.8 (June 2024)
- Performance Optimization Framework v1.5 (October 2024)
- Current System Implementation (March 2025)

---

© 2023-2025 TuneMantra. All rights reserved.

---

## documentation/technical/distribution/manual-distribution.md

# Manual Distribution System

## Overview

While TuneMantra provides automated distribution to major digital service providers (DSPs), the Manual Distribution System addresses special cases, niche platforms, physical distribution, and custom delivery requirements that fall outside standard digital distribution channels. This system enables a human-in-the-loop approach for specialized distribution scenarios.

## Use Cases

### Platform Types for Manual Distribution

Manual distribution is typically utilized for:

- **Physical Media**: CD, vinyl, cassette, and other physical formats
- **Specialized Platforms**: Niche or genre-specific platforms without API integration
- **Emerging Markets**: Platforms in developing markets with custom submission requirements
- **Direct-to-Listener**: Direct distribution through artist websites or private platforms
- **Custom Retail**: Specialized retail arrangements with custom delivery requirements
- **B2B Licensing**: Business-to-business content licensing
- **Alternative Distribution**: Non-traditional distribution channels
- **Private Distribution**: Private or limited-access distribution

### Typical Scenarios

Common scenarios requiring manual distribution include:

1. **Vinyl Production**: Coordinating artwork, mastering, and manufacturing for vinyl releases
2. **Limited-Edition Physical Releases**: Special physical releases with custom packaging
3. **Industry-Specific Platforms**: Platforms serving specific niches (e.g., classical music, liturgical)
4. **Regional Platforms**: Local platforms requiring region-specific submission processes
5. **Private Collections**: Distribution to private or membership-based platforms
6. **Enterprise Licensing**: Business licensing for commercial use
7. **Educational Distribution**: Distribution to educational institutions
8. **Archive Submissions**: Submissions to cultural or historical archives

## Manual Distribution Workflow

### Standard Manual Distribution Process

The typical manual distribution workflow includes:

1. **Request Initiation**: Distribution request created (by artist/label)
2. **Distribution Assessment**: Evaluation of manual distribution requirements
3. **Distribution Planning**: Create distribution plan with timeline and requirements
4. **Asset Preparation**: Format content according to target requirements
5. **Quality Control**: Manual quality verification
6. **Metadata Formatting**: Adapt metadata to match target requirements
7. **Submission Package**: Create comprehensive submission package
8. **Delivery Execution**: Deliver content through appropriate channels
9. **Follow-up Communication**: Manage post-submission communication
10. **Status Tracking**: Track manual distribution status
11. **Confirmation**: Verify successful distribution
12. **Documentation**: Record all distribution details

### Physical Distribution Process

The physical distribution workflow adds specific steps:

1. **Manufacturing Specification**: Define physical product specifications
2. **Vendor Selection**: Choose appropriate manufacturing partners
3. **Artwork Preparation**: Prepare physical packaging artwork
4. **Master Preparation**: Create master suitable for physical production
5. **Sample Approval**: Review and approve production samples
6. **Production Scheduling**: Schedule manufacturing production
7. **Inventory Management**: Track physical inventory
8. **Logistics Coordination**: Coordinate shipping and delivery
9. **Retailer Relations**: Manage relationships with physical retailers
10. **Restocking**: Monitor inventory and restock as needed

### Niche Platform Process

The process for niche platforms includes:

1. **Platform Research**: Research platform requirements and audience
2. **Account Establishment**: Create account or relationship with platform
3. **Format Adaptation**: Adapt content to platform-specific formats
4. **Custom Metadata**: Prepare platform-specific metadata
5. **Manual Submission**: Submit content according to platform guidelines
6. **Communication Management**: Handle platform communication
7. **Verification**: Verify content availability on platform
8. **Performance Monitoring**: Track content performance manually
9. **Update Management**: Handle content updates as needed

## Database Structure

The manual distribution system utilizes a dedicated database schema:

```sql
-- Manual Distribution Requests
CREATE TABLE manual_distribution_requests (
  id SERIAL PRIMARY KEY,
  release_id INTEGER NOT NULL, -- Reference to release
  requester_id INTEGER NOT NULL, -- User who requested
  distribution_type VARCHAR(50) NOT NULL, -- 'physical', 'niche_platform', 'direct', etc.
  target_platforms TEXT[], -- Intended distribution targets
  special_requirements TEXT,
  timeline_requirements TEXT,
  quantity INTEGER, -- For physical distribution
  priority VARCHAR(20) DEFAULT 'normal', -- 'low', 'normal', 'high', 'urgent'
  status VARCHAR(30) DEFAULT 'pending', -- 'pending', 'in_progress', 'completed', 'cancelled'
  assigned_to INTEGER, -- Staff member assigned
  requested_at TIMESTAMP DEFAULT NOW(),
  due_date TIMESTAMP,
  completed_at TIMESTAMP,
  notes TEXT,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- Physical Manufacturing Details
CREATE TABLE physical_manufacturing (
  id SERIAL PRIMARY KEY,
  distribution_request_id INTEGER REFERENCES manual_distribution_requests(id),
  format_type VARCHAR(50) NOT NULL, -- 'cd', 'vinyl', 'cassette', etc.
  format_details JSONB, -- Format-specific details
  quantity INTEGER NOT NULL,
  vendor_id INTEGER, -- Reference to vendor
  manufacturing_spec TEXT,
  artwork_files TEXT[], -- Paths to artwork files
  master_file_path VARCHAR(500), -- Path to manufacturing master
  proof_approval_status VARCHAR(30) DEFAULT 'pending',
  proof_approved_by INTEGER, -- User who approved
  proof_approved_at TIMESTAMP,
  production_status VARCHAR(30),
  estimated_completion_date TIMESTAMP,
  actual_completion_date TIMESTAMP,
  quality_check_status VARCHAR(30),
  quality_checked_by INTEGER,
  inventory_location VARCHAR(255),
  cost_details JSONB,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- Manual Platform Submissions
CREATE TABLE manual_platform_submissions (
  id SERIAL PRIMARY KEY,
  distribution_request_id INTEGER REFERENCES manual_distribution_requests(id),
  platform_name VARCHAR(255) NOT NULL,
  platform_type VARCHAR(50), -- Type/category of platform
  submission_method VARCHAR(50), -- 'email', 'web_form', 'ftp', 'api', 'mail', etc.
  platform_url VARCHAR(500),
  platform_contact VARCHAR(255),
  account_details JSONB, -- Account information for the platform
  submission_requirements TEXT,
  assets_submitted JSONB, -- Record of what was submitted
  submission_date TIMESTAMP,
  submitted_by INTEGER, -- User who submitted
  confirmation_reference VARCHAR(255), -- Reference number or ID from platform
  follow_up_required BOOLEAN DEFAULT false,
  follow_up_date TIMESTAMP,
  status VARCHAR(30) DEFAULT 'pending', -- 'pending', 'submitted', 'live', 'rejected', etc.
  verification_status VARCHAR(30) DEFAULT 'pending',
  verified_by INTEGER,
  verified_at TIMESTAMP,
  platform_url_after_release VARCHAR(500), -- URL where content can be found
  notes TEXT,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- Physical Distribution Shipments
CREATE TABLE physical_distribution_shipments (
  id SERIAL PRIMARY KEY,
  manufacturing_id INTEGER REFERENCES physical_manufacturing(id),
  shipment_type VARCHAR(50), -- 'retailer', 'distributor', 'direct', etc.
  recipient_name VARCHAR(255),
  recipient_details JSONB, -- Address and contact info
  items_included JSONB, -- What's being shipped
  quantity INTEGER NOT NULL,
  tracking_number VARCHAR(100),
  carrier VARCHAR(100),
  shipping_date TIMESTAMP,
  estimated_arrival_date TIMESTAMP,
  actual_arrival_date TIMESTAMP,
  shipping_status VARCHAR(30),
  proof_of_delivery VARCHAR(500), -- Document reference
  shipping_cost DECIMAL(10,2),
  notes TEXT,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- Manual Distribution Status Updates
CREATE TABLE manual_distribution_status_updates (
  id SERIAL PRIMARY KEY,
  distribution_request_id INTEGER REFERENCES manual_distribution_requests(id),
  update_type VARCHAR(50), -- 'status_change', 'note', 'issue', 'milestone'
  previous_status VARCHAR(30),
  new_status VARCHAR(30),
  description TEXT,
  updated_by INTEGER, -- User who made update
  external_reference VARCHAR(255), -- External reference/confirmation
  attachment_paths TEXT[], -- Paths to any attached files
  created_at TIMESTAMP DEFAULT NOW()
);

-- Vendor Directory (for physical manufacturing and distribution)
CREATE TABLE distribution_vendors (
  id SERIAL PRIMARY KEY,
  vendor_name VARCHAR(255) NOT NULL,
  vendor_type VARCHAR(50), -- 'manufacturer', 'distributor', 'retailer', etc.
  services_offered TEXT[],
  contact_details JSONB,
  address JSONB,
  website VARCHAR(255),
  account_number VARCHAR(100),
  account_manager VARCHAR(100),
  typical_turnaround VARCHAR(100),
  quality_rating INTEGER, -- 1-5 rating
  cost_tier VARCHAR(20), -- 'economy', 'standard', 'premium'
  active BOOLEAN DEFAULT true,
  notes TEXT,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);
```

## Key Manual Distribution Components

### Physical Media Management

The system includes tools for managing physical media production:

- **Format Templates**: Templates for common physical formats
- **Specification Builder**: Tool to create detailed manufacturing specs
- **Vendor Management**: Database of manufacturing vendors
- **Physical Artwork Tools**: Tools for physical artwork preparation
- **Barcode Generation**: Generate physical product barcodes
- **Sample Tracking**: Track and manage manufacturing samples
- **Inventory System**: Monitor physical inventory levels
- **Cost Calculator**: Calculate manufacturing and distribution costs

### Specialized Platform Management

Tools for managing distribution to specialized platforms:

- **Platform Directory**: Database of niche and specialized platforms
- **Requirement Templates**: Templates for common submission requirements
- **Format Converter**: Tools to convert content to platform-specific formats
- **Account Manager**: Store and manage platform login credentials
- **Submission Tracker**: Track manual submission status
- **Communication Logger**: Log all platform communications
- **Performance Collector**: Tools to manually collect performance data
- **Platform Relationship Manager**: Manage platform contacts and relationships

### Direct Distribution Management

Tools for direct-to-consumer distribution:

- **Direct Store Integration**: Connect to artist or label online stores
- **Bundle Creator**: Create and manage product bundles
- **Campaign Manager**: Plan and execute direct distribution campaigns
- **Fulfillment Integration**: Connect with fulfillment services
- **Customer Database**: Manage direct customer relationships
- **Direct Sales Analytics**: Track direct distribution performance
- **Merchandising Tools**: Integrate music with merchandise

## User Interfaces

### Artist Manual Distribution Interface

Artists interact with manual distribution through:

- **Request Form**: Submit manual distribution requests
- **Specification Builder**: Define physical product specifications
- **Status Tracker**: Monitor manual distribution progress
- **Inventory Monitor**: Track physical product inventory
- **Direct Distribution Dashboard**: Manage direct-to-fan distribution
- **Physical Sales Tracker**: Monitor physical sales performance
- **Reorder Interface**: Initiate reorders of physical products

### Label Manual Distribution Interface

Labels have access to expanded manual distribution tools:

- **Multi-Artist Management**: Manage across artist roster
- **Bulk Distribution**: Tools for batch manual distribution
- **Vendor Relationships**: Manage manufacturing vendor relationships
- **Physical Distribution Network**: Manage physical distribution channels
- **Cost Management**: Track and analyze distribution costs
- **Retail Relationships**: Manage relationships with retailers
- **Specialized Platform Strategy**: Coordinate platform-specific strategies

### Administrator Interface

Platform administrators have comprehensive manual distribution tools:

- **Distribution Queue**: Manage all manual distribution requests
- **Task Assignment**: Assign tasks to distribution staff
- **Vendor Management**: Maintain vendor database
- **Platform Directory**: Maintain specialized platform directory
- **Template Library**: Manage distribution templates
- **Process Optimization**: Analyze and optimize manual processes
- **Quality Control**: Ensure distribution quality standards

## Integration with Core Distribution

### Coordinated Distribution Strategy

Manual and automated distribution are coordinated through:

- **Unified Release Planning**: Coordinate all distribution channels
- **Timeline Synchronization**: Align manual and automated timelines
- **Metadata Consistency**: Ensure consistent metadata across channels
- **Cross-Channel Reporting**: Consolidated reporting across all channels
- **Integrated Strategy**: Unified distribution strategy
- **Complementary Targeting**: Strategic use of different channel strengths
- **Performance Comparison**: Compare channel performance

### Workflow Integration

Manual distribution workflows integrate with automated workflows:

- **Status Sharing**: Share status updates between systems
- **Asset Reuse**: Reuse assets across distribution types
- **Parallel Processing**: Process different distribution types simultaneously
- **Sequential Dependencies**: Manage dependencies between distribution types
- **Common Notification System**: Unified notification system
- **Escalation Handling**: Cross-system issue escalation
- **Centralized Documentation**: Documentation across distribution types

## Physical Distribution Partners

The system supports various physical distribution partners:

| Partner Type | Description | Typical Timeline |
|--------------|-------------|------------------|
| Vinyl Manufacturers | Production of vinyl records | 12-16 weeks |
| CD Manufacturers | Production of CDs | 2-4 weeks |
| Cassette Manufacturers | Production of cassette tapes | 3-6 weeks |
| Physical Distributors | Distribution to physical retailers | 2-4 weeks lead time |
| Specialty Retailers | Direct to specialty music stores | Varies by retailer |
| Major Retailers | Chain and department stores | 4-8 weeks lead time |
| International Distributors | Physical distribution globally | 6-12 weeks lead time |
| Fulfillment Centers | Direct-to-consumer fulfillment | 1-2 weeks setup |

## Specialized Platform Directory

The system maintains a directory of specialized platforms:

| Platform Category | Examples | Submission Method |
|-------------------|----------|------------------|
| Genre-Specific | Classical, Jazz, Folk, Electronic | Custom web portal |
| Regional | Local streaming services, Radio stations | Email/FTP |
| Audiophile | High-resolution audio platforms | Custom specification |
| Community-Based | Artist collectives, Fan communities | Direct upload |
| Professional Use | Production music libraries, Sync licensing | Custom portal |
| Educational | University collections, Educational resources | Formal submission |
| Cultural Archives | National libraries, Heritage collections | Formal application |
| Blockchain/Web3 | NFT marketplaces, Web3 music platforms | Wallet-based submission |

## Best Practices

### Physical Distribution Best Practices

Best practices for physical distribution include:

- **Early Planning**: Start physical production well ahead of release date
- **Quality Control**: Implement rigorous quality checks
- **Vendor Relationships**: Maintain strong manufacturer relationships
- **Realistic Timelines**: Allow buffer time in manufacturing schedules
- **Test Pressings**: Always review test pressings/samples
- **Shipping Insurance**: Insure valuable physical shipments
- **Inventory Management**: Maintain appropriate inventory levels
- **Retailer Communication**: Clear communication with physical retailers
- **Distribution Diversity**: Work with multiple distributors for resilience
- **Efficient Packaging**: Optimize packaging for cost and sustainability

### Niche Platform Best Practices

Best practices for specialized platform distribution include:

- **Platform Research**: Thoroughly understand platform requirements
- **Relationship Building**: Build personal relationships with platform managers
- **Format Optimization**: Tailor content specifically for each platform
- **Metadata Customization**: Customize metadata to platform standards
- **Regular Follow-up**: Maintain communication after submission
- **Performance Monitoring**: Establish process for manual performance tracking
- **Compliance Adherence**: Ensure compliance with all platform requirements
- **Content Freshness**: Keep content updated on manual platforms
- **Documentation**: Maintain detailed records of all submissions
- **Platform-Specific Strategy**: Develop unique strategy for each platform

## Manual Distribution Analytics

The system tracks key metrics for manual distribution:

- **Physical Sales**: Track sales of physical products
- **Production Costs**: Monitor manufacturing and production costs
- **Turnaround Time**: Measure time from request to completion
- **Fulfillment Rate**: Percentage of successfully fulfilled requests
- **Quality Issues**: Track quality problems in physical production
- **Regional Performance**: Performance by geographic region
- **Format Performance**: Compare performance across formats
- **Channel Comparison**: Compare manual vs. digital distribution
- **Niche Platform ROI**: Return on investment for specialized platforms
- **Direct Sales Metrics**: Performance of direct-to-consumer sales

## Common Challenges and Solutions

### Physical Distribution Challenges

| Challenge | Solution |
|-----------|----------|
| Manufacturing Delays | Build buffer into timelines; maintain relationships with multiple vendors |
| Quality Control Issues | Implement rigorous sample approval process; develop clear quality standards |
| Inventory Management | Use data-driven inventory forecasting; implement just-in-time where possible |
| High Production Costs | Negotiate volume discounts; optimize production specifications |
| International Shipping | Work with experienced international logistics partners; understand customs requirements |
| Retailer Relationships | Maintain consistent communication; provide promotional support |
| Returns Management | Create clear return policies; track and analyze return reasons |
| Environmental Concerns | Implement sustainable manufacturing and packaging options |

### Niche Platform Challenges

| Challenge | Solution |
|-----------|----------|
| Diverse Requirements | Maintain detailed platform requirement documentation; use templates |
| Limited API Access | Develop semi-automated workflows where possible; build platform relationships |
| Manual Performance Tracking | Implement scheduled performance check procedures; request regular reports |
| Communication Gaps | Establish clear communication protocols; maintain contact database |
| Content Inconsistency | Create platform-specific delivery checklists; conduct pre-submission reviews |
| Evolving Platforms | Schedule regular platform requirement reviews; maintain active relationships |
| Resource Intensity | Prioritize platforms based on ROI; implement efficient workflows |
| Verification Difficulties | Establish clear verification procedures; document all submissions thoroughly |

## Development Evolution

The manual distribution system has evolved through several phases:

1. **Basic Capabilities (PPv1)**: Simple manual distribution request system
2. **Physical Focus (3march)**: Enhanced physical distribution capabilities
3. **Expanded Platforms (8march258)**: Support for more specialized platforms
4. **Process Optimization (12march547)**: Streamlined manual distribution workflows
5. **Integrated Approach (17032025)**: Tighter integration with automated distribution
6. **Enhanced Analytics (190320250630)**: Improved tracking and reporting

## Future Enhancements

Planned enhancements to the manual distribution system include:

- **Semi-Automation**: Partial automation of manual processes
- **AI-Assisted Formatting**: Intelligent content formatting for specialized platforms
- **Predictive Inventory**: AI-driven physical inventory management
- **Enhanced Vendor Integration**: Deeper integration with manufacturing vendors
- **Blockchain Verification**: Verification of physical products via blockchain
- **Sustainable Manufacturing**: Enhanced support for eco-friendly production
- **Advanced Bundling**: Sophisticated bundling of physical and digital products
- **Direct-to-Fan Expansion**: Enhanced direct distribution capabilities

## References

For additional information, refer to:

- [Physical Distribution Guide](physical-distribution-guide.md)
- [Specialized Platform Directory](specialized-platform-directory.md)
- [Vendor Relations Guide](vendor-relations-guide.md)
- [Direct Distribution Best Practices](direct-distribution-best-practices.md)
- [User Guide: Manual Distribution](../../user/manual-distribution-guide.md)

---

*This documentation is maintained based on the manual distribution features found across multiple development branches.*

---

## documentation/technical/frontend.md

# Frontend Architecture Documentation

## Overview

TuneMantra's frontend is built using React with TypeScript, providing a responsive and intuitive user interface for artists, labels, and administrators. The architecture follows modern best practices with a focus on component reusability, state management, and user experience.

## Technology Stack

### Core Technologies

- **React**: Library for building user interfaces
- **TypeScript**: Typed superset of JavaScript for better developer experience
- **Vite**: Build tool for faster development and optimized production builds
- **TanStack Query**: Data fetching, caching, and state management
- **React Router DOM**: Routing and navigation
- **Wouter**: Lightweight routing alternative

### UI Framework

- **Tailwind CSS**: Utility-first CSS framework
- **Shadcn/UI**: Component library built on Radix UI primitives
- **Radix UI**: Unstyled, accessible UI components
- **Lucide React**: Icon library
- **Framer Motion**: Animation library

### Form Management

- **React Hook Form**: Form state management and validation
- **Zod**: Schema validation library
- **@hookform/resolvers**: Integration between React Hook Form and Zod

### Data Visualization

- **Recharts**: Composable charting library
- **React ChartJS**: ChartJS wrapper for React
- **D3.js**: Low-level data visualization library (for complex visualizations)

## Architecture Principles

The frontend follows these core principles:

1. **Component-Based Architecture**: Encapsulated, reusable components
2. **Typed Interfaces**: TypeScript for type safety across the application
3. **Separation of Concerns**: Clear boundaries between presentation, state, and logic
4. **Responsive Design**: Mobile-first approach to support all device sizes
5. **Accessibility**: WCAG compliance throughout the interface
6. **Performance Optimization**: Efficient rendering and loading strategies

## Application Structure

The frontend code is organized into the following structure:

```
client/
├── public/          # Static assets
├── src/
│   ├── components/  # React components
│   │   ├── ui/      # Base UI components
│   │   ├── layouts/ # Layout components
│   │   ├── forms/   # Form components
│   │   ├── charts/  # Data visualization components
│   │   └── feature/ # Feature-specific components
│   ├── hooks/       # Custom React hooks
│   ├── lib/         # Utility functions and constants
│   ├── pages/       # Page components
│   ├── schemas/     # Validation schemas
│   ├── services/    # API service functions
│   ├── styles/      # Global styles and Tailwind configuration
│   ├── types/       # TypeScript types and interfaces
│   ├── App.tsx      # Main application component
│   └── main.tsx     # Application entry point
├── index.html       # HTML template
└── vite.config.ts   # Vite configuration
```

## Component Architecture

### Component Hierarchy

The component hierarchy is structured for reusability and clarity:

1. **UI Components**: Base components like Button, Input, Card
2. **Layout Components**: Page layouts, navigation, headers
3. **Feature Components**: Domain-specific components for music, analytics, etc.
4. **Page Components**: Full page compositions combining other components

### Component Types

Components are categorized by responsibility:

- **Presentation Components**: Focus on UI rendering with minimal logic
- **Container Components**: Manage state and data fetching for child components
- **Layout Components**: Handle positioning and structure
- **Provider Components**: Supply context or state to component trees

### Component Pattern

Most components follow this pattern:

```tsx
// Example Component Pattern
import { useState, useEffect } from 'react';
import { useQuery } from '@tanstack/react-query';
import { Button } from '@/components/ui/button';
import { apiRequest } from '@/lib/queryClient';

// TypeScript interface for props
interface TrackListProps {
  userId: number;
  onTrackSelect?: (trackId: number) => void;
  limit?: number;
}

// Component implementation
export function TrackList({ userId, onTrackSelect, limit = 10 }: TrackListProps) {
  // Data fetching with TanStack Query
  const { data, isLoading, error } = useQuery({
    queryKey: ['/api/users', userId, 'tracks'],
    queryFn: () => apiRequest(`/api/users/${userId}/tracks?limit=${limit}`),
  });

  // Handle loading state
  if (isLoading) {
    return <div className="loading-spinner" />;
  }

  // Handle error state
  if (error) {
    return <div className="error-message">Failed to load tracks</div>;
  }

  // Render component
  return (
    <div className="track-list">
      <h2 className="text-xl font-bold mb-4">Your Tracks</h2>
      <ul className="space-y-2">
        {data.map((track) => (
          <li key={track.id} className="p-2 hover:bg-slate-100 rounded">
            <div className="flex justify-between items-center">
              <span>{track.title}</span>
              <Button 
                variant="ghost" 
                onClick={() => onTrackSelect?.(track.id)}
              >
                View Details
              </Button>
            </div>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

## State Management

### Local Component State

For component-specific state:

```tsx
function Counter() {
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}
```

### Form State

Form state managed with React Hook Form:

```tsx
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';

// Define schema with Zod
const schema = z.object({
  title: z.string().min(1, 'Title is required'),
  artist: z.string().min(1, 'Artist is required'),
  genre: z.string().min(1, 'Genre is required'),
});

// Infer TypeScript type from schema
type FormValues = z.infer<typeof schema>;

function TrackForm() {
  // Initialize form with schema validation
  const form = useForm<FormValues>({
    resolver: zodResolver(schema),
    defaultValues: {
      title: '',
      artist: '',
      genre: '',
    },
  });
  
  const onSubmit = (data: FormValues) => {
    console.log(data);
    // Submit data to API
  };
  
  return (
    <form onSubmit={form.handleSubmit(onSubmit)}>
      <div>
        <label>Title</label>
        <input {...form.register('title')} />
        {form.formState.errors.title && (
          <p>{form.formState.errors.title.message}</p>
        )}
      </div>
      
      <div>
        <label>Artist</label>
        <input {...form.register('artist')} />
        {form.formState.errors.artist && (
          <p>{form.formState.errors.artist.message}</p>
        )}
      </div>
      
      <div>
        <label>Genre</label>
        <input {...form.register('genre')} />
        {form.formState.errors.genre && (
          <p>{form.formState.errors.genre.message}</p>
        )}
      </div>
      
      <button type="submit">Submit</button>
    </form>
  );
}
```

### Server State

Server state managed with TanStack Query:

```tsx
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { apiRequest } from '@/lib/queryClient';

// Data fetching hook
function useUserTracks(userId: number) {
  return useQuery({
    queryKey: ['/api/users', userId, 'tracks'],
    queryFn: () => apiRequest(`/api/users/${userId}/tracks`),
  });
}

// Data mutation hook
function useCreateTrack() {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: (trackData) => 
      apiRequest('/api/tracks', { method: 'POST', data: trackData }),
    onSuccess: (data, variables, context) => {
      // Invalidate related queries to trigger refetch
      queryClient.invalidateQueries({ queryKey: ['/api/users', variables.userId, 'tracks'] });
    },
  });
}

// Usage in component
function TracksManager({ userId }) {
  const { data, isLoading } = useUserTracks(userId);
  const createTrack = useCreateTrack();
  
  const handleAddTrack = (trackData) => {
    createTrack.mutate({ ...trackData, userId });
  };
  
  // Component JSX
}
```

### Context API

For shared state across components:

```tsx
import { createContext, useContext, useState } from 'react';

// Create context with type
interface ThemeContextType {
  darkMode: boolean;
  toggleDarkMode: () => void;
}

const ThemeContext = createContext<ThemeContextType | undefined>(undefined);

// Provider component
export function ThemeProvider({ children }) {
  const [darkMode, setDarkMode] = useState(false);
  
  const toggleDarkMode = () => setDarkMode(!darkMode);
  
  return (
    <ThemeContext.Provider value={{ darkMode, toggleDarkMode }}>
      {children}
    </ThemeContext.Provider>
  );
}

// Custom hook for consuming context
export function useTheme() {
  const context = useContext(ThemeContext);
  
  if (context === undefined) {
    throw new Error('useTheme must be used within a ThemeProvider');
  }
  
  return context;
}
```

## Routing and Navigation

### Route Configuration

Using React Router DOM or Wouter for routing:

```tsx
import { Route, Switch } from 'wouter';
import Dashboard from '@/pages/Dashboard';
import Tracks from '@/pages/Tracks';
import Releases from '@/pages/Releases';
import Analytics from '@/pages/Analytics';
import Settings from '@/pages/Settings';
import NotFound from '@/pages/NotFound';

function AppRoutes() {
  return (
    <Switch>
      <Route path="/" component={Dashboard} />
      <Route path="/tracks" component={Tracks} />
      <Route path="/tracks/:id" component={TrackDetail} />
      <Route path="/releases" component={Releases} />
      <Route path="/releases/:id" component={ReleaseDetail} />
      <Route path="/analytics" component={Analytics} />
      <Route path="/settings" component={Settings} />
      <Route component={NotFound} />
    </Switch>
  );
}
```

### Protected Routes

Restricting access to authenticated users:

```tsx
import { Route, Redirect } from 'wouter';
import { useAuth } from '@/hooks/useAuth';

interface ProtectedRouteProps {
  component: React.ComponentType<any>;
  path: string;
  requiredRole?: string;
}

function ProtectedRoute({ component: Component, requiredRole, ...rest }: ProtectedRouteProps) {
  const { isAuthenticated, user } = useAuth();
  
  return (
    <Route
      {...rest}
      render={(props) => {
        // Check authentication
        if (!isAuthenticated) {
          return <Redirect to="/login" />;
        }
        
        // Check role if required
        if (requiredRole && user.role !== requiredRole) {
          return <Redirect to="/unauthorized" />;
        }
        
        // Render component if authorized
        return <Component {...props} />;
      }}
    />
  );
}
```

### Navigation Components

Consistent navigation pattern:

```tsx
import { Link, useLocation } from 'wouter';
import { useAuth } from '@/hooks/useAuth';

function Navigation() {
  const [location] = useLocation();
  const { isAuthenticated, user } = useAuth();
  
  return (
    <nav className="w-64 bg-slate-800 text-white h-screen p-4">
      <div className="logo mb-8">TuneMantra</div>
      
      <ul className="space-y-2">
        <li>
          <Link href="/">
            <a className={location === '/' ? 'active-link' : 'nav-link'}>
              Dashboard
            </a>
          </Link>
        </li>
        
        <li>
          <Link href="/tracks">
            <a className={location.startsWith('/tracks') ? 'active-link' : 'nav-link'}>
              Tracks
            </a>
          </Link>
        </li>
        
        <li>
          <Link href="/releases">
            <a className={location.startsWith('/releases') ? 'active-link' : 'nav-link'}>
              Releases
            </a>
          </Link>
        </li>
        
        <li>
          <Link href="/analytics">
            <a className={location.startsWith('/analytics') ? 'active-link' : 'nav-link'}>
              Analytics
            </a>
          </Link>
        </li>
        
        {/* Show admin section only for admin users */}
        {isAuthenticated && user.role === 'admin' && (
          <li>
            <Link href="/admin">
              <a className={location.startsWith('/admin') ? 'active-link' : 'nav-link'}>
                Admin
              </a>
            </Link>
          </li>
        )}
      </ul>
    </nav>
  );
}
```

## Data Fetching

### API Client

Centralized API client for consistent data fetching:

```tsx
// lib/queryClient.ts
import { QueryClient } from '@tanstack/react-query';
import axios from 'axios';

// Create axios instance
const axiosInstance = axios.create({
  baseURL: '/api',
  headers: {
    'Content-Type': 'application/json',
  },
  withCredentials: true, // Include cookies for authentication
});

// Create query client
export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      refetchOnWindowFocus: false,
      retry: 1,
      staleTime: 5 * 60 * 1000, // 5 minutes
    },
  },
});

// API request function
export async function apiRequest(url: string, options = {}) {
  try {
    const response = await axiosInstance(url, options);
    return response.data.data;
  } catch (error) {
    // Extract error message from response
    const message = error.response?.data?.error?.message || 'An error occurred';
    throw new Error(message);
  }
}
```

### Custom Hooks for API Calls

Domain-specific hooks for data operations:

```tsx
// hooks/useTracks.ts
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { apiRequest } from '@/lib/queryClient';
import { Track, InsertTrack } from '@shared/schema';

// Get all tracks for a user
export function useUserTracks(userId: number) {
  return useQuery<Track[]>({
    queryKey: ['/api/users', userId, 'tracks'],
    queryFn: () => apiRequest(`/api/users/${userId}/tracks`),
  });
}

// Get a single track by ID
export function useTrack(trackId: number) {
  return useQuery<Track>({
    queryKey: ['/api/tracks', trackId],
    queryFn: () => apiRequest(`/api/tracks/${trackId}`),
    enabled: !!trackId, // Only run if trackId is provided
  });
}

// Create a new track
export function useCreateTrack() {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: (track: InsertTrack) => 
      apiRequest('/api/tracks', { method: 'POST', data: track }),
    onSuccess: (data, variables) => {
      // Invalidate users tracks query to trigger refetch
      queryClient.invalidateQueries({ 
        queryKey: ['/api/users', variables.userId, 'tracks'] 
      });
    },
  });
}

// Update a track
export function useUpdateTrack() {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: ({ id, ...data }: { id: number, [key: string]: any }) => 
      apiRequest(`/api/tracks/${id}`, { method: 'PATCH', data }),
    onSuccess: (data) => {
      // Invalidate specific track query
      queryClient.invalidateQueries({ 
        queryKey: ['/api/tracks', data.id] 
      });
      // Invalidate user tracks query
      queryClient.invalidateQueries({ 
        queryKey: ['/api/users', data.userId, 'tracks'] 
      });
    },
  });
}
```

## Form Handling

### Form Components with Shadcn UI

Consistent form implementation using Shadcn UI components:

```tsx
import { zodResolver } from '@hookform/resolvers/zod';
import { useForm } from 'react-hook-form';
import * as z from 'zod';
import { Button } from '@/components/ui/button';
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from '@/components/ui/form';
import { Input } from '@/components/ui/input';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { useCreateTrack } from '@/hooks/useTracks';

// Define form schema
const formSchema = z.object({
  title: z.string().min(1, 'Title is required'),
  artist: z.string().min(1, 'Artist is required'),
  genre: z.string().min(1, 'Genre is required'),
  releaseDate: z.string().refine(date => !isNaN(Date.parse(date)), {
    message: 'Invalid date format',
  }),
});

function TrackForm({ userId }) {
  const createTrack = useCreateTrack();
  
  // Initialize form
  const form = useForm<z.infer<typeof formSchema>>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      title: '',
      artist: '',
      genre: '',
      releaseDate: new Date().toISOString().split('T')[0],
    },
  });
  
  // Form submission handler
  function onSubmit(values: z.infer<typeof formSchema>) {
    createTrack.mutate({
      ...values,
      userId,
      status: 'draft',
    });
  }
  
  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
        <FormField
          control={form.control}
          name="title"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Track Title</FormLabel>
              <FormControl>
                <Input {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
        
        <FormField
          control={form.control}
          name="artist"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Artist Name</FormLabel>
              <FormControl>
                <Input {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
        
        <FormField
          control={form.control}
          name="genre"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Genre</FormLabel>
              <Select onValueChange={field.onChange} defaultValue={field.value}>
                <FormControl>
                  <SelectTrigger>
                    <SelectValue placeholder="Select a genre" />
                  </SelectTrigger>
                </FormControl>
                <SelectContent>
                  <SelectItem value="pop">Pop</SelectItem>
                  <SelectItem value="rock">Rock</SelectItem>
                  <SelectItem value="hip_hop">Hip Hop</SelectItem>
                  <SelectItem value="electronic">Electronic</SelectItem>
                  <SelectItem value="classical">Classical</SelectItem>
                </SelectContent>
              </Select>
              <FormMessage />
            </FormItem>
          )}
        />
        
        <FormField
          control={form.control}
          name="releaseDate"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Release Date</FormLabel>
              <FormControl>
                <Input type="date" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
        
        <Button type="submit" disabled={createTrack.isPending}>
          {createTrack.isPending ? 'Saving...' : 'Save Track'}
        </Button>
      </form>
    </Form>
  );
}
```

### File Upload Components

Handling file uploads with progress tracking:

```tsx
import { useState } from 'react';
import { Button } from '@/components/ui/button';
import { Progress } from '@/components/ui/progress';

interface FileUploadProps {
  accept: string;
  onUpload: (file: File) => Promise<void>;
  label: string;
}

function FileUpload({ accept, onUpload, label }: FileUploadProps) {
  const [file, setFile] = useState<File | null>(null);
  const [progress, setProgress] = useState(0);
  const [isUploading, setIsUploading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    if (e.target.files && e.target.files[0]) {
      setFile(e.target.files[0]);
      setError(null);
    }
  };
  
  const handleUpload = async () => {
    if (!file) {
      setError('Please select a file');
      return;
    }
    
    setIsUploading(true);
    setProgress(0);
    
    try {
      // Simulate progress updates
      const progressInterval = setInterval(() => {
        setProgress((prev) => {
          if (prev >= 95) {
            clearInterval(progressInterval);
            return 95;
          }
          return prev + 5;
        });
      }, 300);
      
      // Perform actual upload
      await onUpload(file);
      
      // Complete progress and clear state
      clearInterval(progressInterval);
      setProgress(100);
      setFile(null);
      setError(null);
      
      // Reset form after delay
      setTimeout(() => {
        setProgress(0);
        setIsUploading(false);
      }, 1000);
    } catch (err) {
      setError(err.message || 'Upload failed');
      setIsUploading(false);
      setProgress(0);
    }
  };
  
  return (
    <div className="space-y-4">
      <div className="flex items-center space-x-4">
        <input
          type="file"
          accept={accept}
          onChange={handleFileChange}
          disabled={isUploading}
          className="hidden"
          id="file-upload"
        />
        <label
          htmlFor="file-upload"
          className="px-4 py-2 bg-slate-200 hover:bg-slate-300 rounded cursor-pointer"
        >
          {label}
        </label>
        <span className="text-sm text-gray-500">
          {file ? file.name : 'No file selected'}
        </span>
      </div>
      
      {file && (
        <Button 
          onClick={handleUpload} 
          disabled={isUploading}
          variant="default"
        >
          {isUploading ? 'Uploading...' : 'Upload File'}
        </Button>
      )}
      
      {isUploading && (
        <Progress value={progress} className="w-full" />
      )}
      
      {error && (
        <p className="text-red-500 text-sm">{error}</p>
      )}
    </div>
  );
}
```

## Authentication

### Authentication Context

Centralized authentication management:

```tsx
import { createContext, useContext, useState, useEffect } from 'react';
import { apiRequest } from '@/lib/queryClient';

// Type definitions
interface User {
  id: number;
  username: string;
  email: string;
  fullName: string;
  role: string;
  status: string;
}

interface AuthContextType {
  user: User | null;
  isAuthenticated: boolean;
  isLoading: boolean;
  login: (username: string, password: string) => Promise<void>;
  logout: () => Promise<void>;
  register: (userData: any) => Promise<void>;
}

// Create context
const AuthContext = createContext<AuthContextType | undefined>(undefined);

// Provider component
export function AuthProvider({ children }) {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  
  // Check authentication status on mount
  useEffect(() => {
    const checkAuth = async () => {
      try {
        const userData = await apiRequest('/api/auth/status');
        setUser(userData);
      } catch (error) {
        setUser(null);
      } finally {
        setIsLoading(false);
      }
    };
    
    checkAuth();
  }, []);
  
  // Login function
  const login = async (username: string, password: string) => {
    setIsLoading(true);
    try {
      const userData = await apiRequest('/api/auth/login', {
        method: 'POST',
        data: { username, password },
      });
      setUser(userData);
    } finally {
      setIsLoading(false);
    }
  };
  
  // Logout function
  const logout = async () => {
    setIsLoading(true);
    try {
      await apiRequest('/api/auth/logout', { method: 'POST' });
      setUser(null);
    } finally {
      setIsLoading(false);
    }
  };
  
  // Register function
  const register = async (userData: any) => {
    setIsLoading(true);
    try {
      const newUser = await apiRequest('/api/auth/register', {
        method: 'POST',
        data: userData,
      });
      setUser(newUser);
    } finally {
      setIsLoading(false);
    }
  };
  
  return (
    <AuthContext.Provider
      value={{
        user,
        isAuthenticated: !!user,
        isLoading,
        login,
        logout,
        register,
      }}
    >
      {children}
    </AuthContext.Provider>
  );
}

// Custom hook for using auth context
export function useAuth() {
  const context = useContext(AuthContext);
  
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  
  return context;
}
```

## Data Visualization

### Chart Components

Reusable chart components for analytics:

```tsx
import { 
  LineChart,
  Line,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  Legend,
  ResponsiveContainer 
} from 'recharts';

interface TimeSeriesChartProps {
  data: Array<{ date: string; [key: string]: any }>;
  dataKeys: Array<{ key: string; name: string; color: string }>;
  title: string;
  xAxisLabel?: string;
  yAxisLabel?: string;
}

export function TimeSeriesChart({
  data,
  dataKeys,
  title,
  xAxisLabel = 'Date',
  yAxisLabel,
}: TimeSeriesChartProps) {
  return (
    <div className="bg-white p-4 rounded-lg shadow">
      <h3 className="text-lg font-medium mb-4">{title}</h3>
      
      <div className="h-64 w-full">
        <ResponsiveContainer width="100%" height="100%">
          <LineChart
            data={data}
            margin={{ top: 5, right: 30, left: 20, bottom: 5 }}
          >
            <CartesianGrid strokeDasharray="3 3" />
            <XAxis 
              dataKey="date" 
              label={{ 
                value: xAxisLabel, 
                position: 'insideBottomRight', 
                offset: -10 
              }} 
            />
            <YAxis 
              label={
                yAxisLabel 
                  ? { 
                      value: yAxisLabel, 
                      angle: -90, 
                      position: 'insideLeft' 
                    } 
                  : undefined
              } 
            />
            <Tooltip />
            <Legend />
            
            {dataKeys.map((dataKey) => (
              <Line
                key={dataKey.key}
                type="monotone"
                dataKey={dataKey.key}
                name={dataKey.name}
                stroke={dataKey.color}
                activeDot={{ r: 8 }}
              />
            ))}
          </LineChart>
        </ResponsiveContainer>
      </div>
    </div>
  );
}
```

### Dashboard Components

Comprehensive dashboard layouts:

```tsx
import { useQuery } from '@tanstack/react-query';
import { apiRequest } from '@/lib/queryClient';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { TimeSeriesChart } from '@/components/charts/TimeSeriesChart';
import { PieChart } from '@/components/charts/PieChart';
import { StatCard } from '@/components/ui/stat-card';

function Dashboard() {
  const { data: dashboardData, isLoading } = useQuery({
    queryKey: ['/api/analytics/dashboard'],
    queryFn: () => apiRequest('/api/analytics/dashboard'),
  });
  
  if (isLoading) {
    return <div className="dashboard-loading">Loading dashboard data...</div>;
  }
  
  return (
    <div className="space-y-6">
      <h1 className="text-3xl font-bold">Dashboard</h1>
      
      {/* Summary stats */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
        <StatCard
          title="Total Streams"
          value={dashboardData.summary.totalStreams.toLocaleString()}
          change={dashboardData.summary.streamChange}
          changeLabel="vs last period"
        />
        
        <StatCard
          title="Total Revenue"
          value={`$${dashboardData.summary.totalRevenue.toFixed(2)}`}
          change={dashboardData.summary.revenueChange}
          changeLabel="vs last period"
        />
        
        <StatCard
          title="Active Releases"
          value={dashboardData.summary.activeReleases}
        />
        
        <StatCard
          title="Top Country"
          value={dashboardData.summary.topCountry}
        />
      </div>
      
      {/* Charts */}
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        <TimeSeriesChart
          title="Streams Over Time"
          data={dashboardData.streamTimeSeries}
          dataKeys={[
            { key: 'streams', name: 'Streams', color: '#3b82f6' }
          ]}
          yAxisLabel="Streams"
        />
        
        <TimeSeriesChart
          title="Revenue Over Time"
          data={dashboardData.revenueTimeSeries}
          dataKeys={[
            { key: 'revenue', name: 'Revenue ($)', color: '#10b981' }
          ]}
          yAxisLabel="Revenue ($)"
        />
      </div>
      
      {/* More detailed charts */}
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        <Card>
          <CardHeader>
            <CardTitle>Platform Breakdown</CardTitle>
          </CardHeader>
          <CardContent>
            <PieChart
              data={dashboardData.platformBreakdown}
              dataKey="streams"
              nameKey="platform"
              colors={['#3b82f6', '#ef4444', '#f59e0b', '#10b981', '#8b5cf6']}
            />
          </CardContent>
        </Card>
        
        <Card>
          <CardHeader>
            <CardTitle>Country Breakdown</CardTitle>
          </CardHeader>
          <CardContent>
            <PieChart
              data={dashboardData.countryBreakdown}
              dataKey="streams"
              nameKey="country"
              colors={['#3b82f6', '#ef4444', '#f59e0b', '#10b981', '#8b5cf6']}
            />
          </CardContent>
        </Card>
      </div>
      
      {/* Top performing content */}
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        <Card>
          <CardHeader>
            <CardTitle>Top Tracks</CardTitle>
          </CardHeader>
          <CardContent>
            <ul className="space-y-2">
              {dashboardData.topTracks.map((track) => (
                <li key={track.id} className="flex justify-between items-center p-2 border-b">
                  <span>{track.title}</span>
                  <span>{track.streams.toLocaleString()} streams</span>
                </li>
              ))}
            </ul>
          </CardContent>
        </Card>
        
        <Card>
          <CardHeader>
            <CardTitle>Top Releases</CardTitle>
          </CardHeader>
          <CardContent>
            <ul className="space-y-2">
              {dashboardData.topReleases.map((release) => (
                <li key={release.id} className="flex justify-between items-center p-2 border-b">
                  <span>{release.title}</span>
                  <span>{release.streams.toLocaleString()} streams</span>
                </li>
              ))}
            </ul>
          </CardContent>
        </Card>
      </div>
    </div>
  );
}
```

## Responsive Design

### Responsive Layout Components

Layout components with responsive behavior:

```tsx
// components/layouts/AppLayout.tsx
import { useState } from 'react';
import { Sidebar } from '@/components/layouts/Sidebar';
import { Header } from '@/components/layouts/Header';

interface AppLayoutProps {
  children: React.ReactNode;
}

export function AppLayout({ children }: AppLayoutProps) {
  const [sidebarOpen, setSidebarOpen] = useState(false);
  
  return (
    <div className="min-h-screen bg-slate-50">
      {/* Mobile sidebar */}
      <div className={`md:hidden fixed inset-0 z-50 bg-black bg-opacity-50 transition-opacity ${
        sidebarOpen ? 'opacity-100' : 'opacity-0 pointer-events-none'
      }`}>
        <div className="absolute inset-0" onClick={() => setSidebarOpen(false)} />
        <div className={`fixed inset-y-0 left-0 w-64 bg-white shadow-lg transform transition-transform ${
          sidebarOpen ? 'translate-x-0' : '-translate-x-full'
        }`}>
          <Sidebar onNavItemClick={() => setSidebarOpen(false)} />
        </div>
      </div>
      
      {/* Desktop sidebar */}
      <div className="hidden md:block fixed inset-y-0 left-0 w-64 bg-white shadow-lg">
        <Sidebar />
      </div>
      
      {/* Main content */}
      <div className="md:pl-64 flex flex-col flex-1">
        <Header onMenuClick={() => setSidebarOpen(true)} />
        
        <main className="flex-1 p-6">
          <div className="max-w-7xl mx-auto">
            {children}
          </div>
        </main>
      </div>
    </div>
  );
}
```

### Responsive UI Components

UI components that adapt to different screen sizes:

```tsx
// components/ui/responsive-grid.tsx
import { ReactNode } from 'react';

interface ResponsiveGridProps {
  children: ReactNode;
  columns?: {
    sm?: number;
    md?: number;
    lg?: number;
    xl?: number;
  };
  gap?: string;
}

export function ResponsiveGrid({ 
  children, 
  columns = { sm: 1, md: 2, lg: 3, xl: 4 },
  gap = 'gap-6',
}: ResponsiveGridProps) {
  // Build class string based on column configuration
  const columnClasses = [
    `grid-cols-${columns.sm || 1}`,
    `md:grid-cols-${columns.md || 2}`,
    `lg:grid-cols-${columns.lg || 3}`,
    `xl:grid-cols-${columns.xl || 4}`,
  ].join(' ');
  
  return (
    <div className={`grid ${columnClasses} ${gap}`}>
      {children}
    </div>
  );
}
```

## Error Handling

### Error Boundary Component

Catch and display React component errors:

```tsx
import { Component, ErrorInfo, ReactNode } from 'react';

interface ErrorBoundaryProps {
  children: ReactNode;
  fallback?: ReactNode;
}

interface ErrorBoundaryState {
  hasError: boolean;
  error?: Error;
}

export class ErrorBoundary extends Component<ErrorBoundaryProps, ErrorBoundaryState> {
  constructor(props: ErrorBoundaryProps) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error: Error): ErrorBoundaryState {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo): void {
    // Log error to monitoring service
    console.error('Component error:', error, errorInfo);
  }

  render(): ReactNode {
    if (this.state.hasError) {
      if (this.props.fallback) {
        return this.props.fallback;
      }
      
      return (
        <div className="p-6 bg-red-50 border border-red-200 rounded-lg">
          <h2 className="text-xl font-bold text-red-700 mb-2">Something went wrong</h2>
          <p className="text-red-600 mb-4">
            An error occurred while rendering this component.
          </p>
          {this.state.error && (
            <pre className="bg-white p-4 rounded text-sm overflow-auto">
              {this.state.error.toString()}
            </pre>
          )}
          <button
            className="mt-4 px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700"
            onClick={() => this.setState({ hasError: false, error: undefined })}
          >
            Try again
          </button>
        </div>
      );
    }

    return this.props.children;
  }
}
```

### Error State Components

Standardized error display components:

```tsx
// components/ui/error-display.tsx
import { AlertCircle } from 'lucide-react';
import { Button } from '@/components/ui/button';

interface ErrorDisplayProps {
  title?: string;
  message: string;
  error?: Error;
  showDetails?: boolean;
  onRetry?: () => void;
}

export function ErrorDisplay({
  title = 'Error',
  message,
  error,
  showDetails = false,
  onRetry,
}: ErrorDisplayProps) {
  return (
    <div className="rounded-md bg-red-50 p-4 border border-red-200">
      <div className="flex">
        <div className="flex-shrink-0">
          <AlertCircle className="h-5 w-5 text-red-400" />
        </div>
        <div className="ml-3">
          <h3 className="text-sm font-medium text-red-800">{title}</h3>
          <div className="mt-2 text-sm text-red-700">
            <p>{message}</p>
          </div>
          
          {showDetails && error && (
            <div className="mt-2">
              <details className="text-xs">
                <summary className="cursor-pointer text-red-800 hover:text-red-900">
                  Show technical details
                </summary>
                <pre className="mt-2 whitespace-pre-wrap bg-white p-2 rounded border border-red-200">
                  {error.toString()}
                </pre>
              </details>
            </div>
          )}
          
          {onRetry && (
            <div className="mt-4">
              <Button
                variant="destructive"
                size="sm"
                onClick={onRetry}
              >
                Try Again
              </Button>
            </div>
          )}
        </div>
      </div>
    </div>
  );
}
```

## Notifications

### Toast Notifications

Toast notification system for user feedback:

```tsx
// components/ui/toast.tsx
import * as React from 'react';
import { cn } from '@/lib/utils';
import { Check, X, AlertCircle, Info } from 'lucide-react';

// Toast context
interface ToastContextType {
  toasts: Toast[];
  addToast: (toast: Omit<Toast, 'id'>) => void;
  removeToast: (id: string) => void;
}

interface Toast {
  id: string;
  type: 'success' | 'error' | 'info' | 'warning';
  title: string;
  message?: string;
  duration?: number; // milliseconds
}

const ToastContext = React.createContext<ToastContextType | undefined>(undefined);

// Toast provider
export function ToastProvider({ children }: { children: React.ReactNode }) {
  const [toasts, setToasts] = React.useState<Toast[]>([]);
  
  const addToast = React.useCallback((toast: Omit<Toast, 'id'>) => {
    const id = Date.now().toString();
    const newToast = { ...toast, id };
    
    setToasts((prevToasts) => [...prevToasts, newToast]);
    
    if (toast.duration !== 0) {
      const duration = toast.duration || 5000; // Default 5 seconds
      setTimeout(() => {
        removeToast(id);
      }, duration);
    }
  }, []);
  
  const removeToast = React.useCallback((id: string) => {
    setToasts((prevToasts) => prevToasts.filter((toast) => toast.id !== id));
  }, []);
  
  return (
    <ToastContext.Provider value={{ toasts, addToast, removeToast }}>
      {children}
      <ToastContainer />
    </ToastContext.Provider>
  );
}

// Custom hook for using toasts
export function useToast() {
  const context = React.useContext(ToastContext);
  
  if (context === undefined) {
    throw new Error('useToast must be used within a ToastProvider');
  }
  
  return context;
}

// Toast component
function ToastComponent({ toast, onClose }: { toast: Toast; onClose: () => void }) {
  const { type, title, message } = toast;
  
  const icons = {
    success: <Check className="h-5 w-5 text-green-500" />,
    error: <AlertCircle className="h-5 w-5 text-red-500" />,
    warning: <AlertCircle className="h-5 w-5 text-yellow-500" />,
    info: <Info className="h-5 w-5 text-blue-500" />,
  };
  
  const colorClasses = {
    success: 'border-green-200 bg-green-50',
    error: 'border-red-200 bg-red-50',
    warning: 'border-yellow-200 bg-yellow-50',
    info: 'border-blue-200 bg-blue-50',
  };
  
  return (
    <div
      className={cn(
        'flex w-full max-w-sm overflow-hidden rounded-lg border shadow-lg',
        colorClasses[type]
      )}
    >
      <div className="flex items-center p-4">
        <div className="flex-shrink-0">{icons[type]}</div>
        <div className="ml-3 flex-1">
          <p className="text-sm font-medium">{title}</p>
          {message && <p className="mt-1 text-sm opacity-90">{message}</p>}
        </div>
        <button
          type="button"
          className="ml-4 flex-shrink-0 rounded text-gray-400 hover:text-gray-700 focus:outline-none"
          onClick={onClose}
        >
          <X className="h-5 w-5" />
        </button>
      </div>
    </div>
  );
}

// Toast container (renders all active toasts)
function ToastContainer() {
  const { toasts, removeToast } = useToast();
  
  return (
    <div className="fixed bottom-0 right-0 z-50 p-4 sm:p-6 md:max-w-md space-y-4">
      {toasts.map((toast) => (
        <div
          key={toast.id}
          className="transform transition-all duration-300 ease-in-out"
        >
          <ToastComponent toast={toast} onClose={() => removeToast(toast.id)} />
        </div>
      ))}
    </div>
  );
}
```

## Performance Optimization

### Memoization

Using memo and callback for performance:

```tsx
import { memo, useCallback } from 'react';

interface TrackItemProps {
  id: number;
  title: string;
  artist: string;
  streams: number;
  onSelect: (id: number) => void;
}

const TrackItem = memo(({ id, title, artist, streams, onSelect }: TrackItemProps) => {
  const handleClick = useCallback(() => {
    onSelect(id);
  }, [id, onSelect]);
  
  return (
    <div 
      className="p-4 border rounded-lg hover:bg-slate-50 cursor-pointer"
      onClick={handleClick}
    >
      <h3 className="font-medium">{title}</h3>
      <p className="text-sm text-gray-500">{artist}</p>
      <p className="text-sm mt-2">{streams.toLocaleString()} streams</p>
    </div>
  );
});
TrackItem.displayName = 'TrackItem';

export default TrackItem;
```

### Virtualized Lists

Efficiently rendering large lists:

```tsx
import { useVirtualizer } from '@tanstack/react-virtual';
import { useRef } from 'react';

interface VirtualListProps<T> {
  items: T[];
  renderItem: (item: T, index: number) => React.ReactNode;
  itemHeight: number;
  height: number;
  width: '100%' | number;
}

export function VirtualList<T>({
  items,
  renderItem,
  itemHeight,
  height,
  width = '100%',
}: VirtualListProps<T>) {
  const parentRef = useRef<HTMLDivElement>(null);
  
  const virtualizer = useVirtualizer({
    count: items.length,
    getScrollElement: () => parentRef.current,
    estimateSize: () => itemHeight,
  });
  
  return (
    <div
      ref={parentRef}
      style={{
        height,
        width,
        overflow: 'auto',
      }}
    >
      <div
        style={{
          height: `${virtualizer.getTotalSize()}px`,
          position: 'relative',
        }}
      >
        {virtualizer.getVirtualItems().map((virtualItem) => (
          <div
            key={virtualItem.key}
            style={{
              position: 'absolute',
              top: 0,
              left: 0,
              width: '100%',
              height: `${itemHeight}px`,
              transform: `translateY(${virtualItem.start}px)`,
            }}
          >
            {renderItem(items[virtualItem.index], virtualItem.index)}
          </div>
        ))}
      </div>
    </div>
  );
}

// Usage
function TrackListVirtualized({ tracks }) {
  return (
    <VirtualList
      items={tracks}
      height={500}
      itemHeight={80}
      renderItem={(track) => (
        <div className="p-4 border-b">
          <h3>{track.title}</h3>
          <p>{track.artist}</p>
        </div>
      )}
    />
  );
}
```

### Lazy Loading

Lazy loading components for better initial load time:

```tsx
import { lazy, Suspense } from 'react';
import { Route, Switch } from 'wouter';
import { LoadingSpinner } from '@/components/ui/loading-spinner';

// Lazy load pages
const Dashboard = lazy(() => import('@/pages/Dashboard'));
const Tracks = lazy(() => import('@/pages/Tracks'));
const TrackDetail = lazy(() => import('@/pages/TrackDetail'));
const Releases = lazy(() => import('@/pages/Releases'));
const ReleaseDetail = lazy(() => import('@/pages/ReleaseDetail'));
const Analytics = lazy(() => import('@/pages/Analytics'));
const Settings = lazy(() => import('@/pages/Settings'));

function AppRoutes() {
  return (
    <Suspense fallback={<LoadingSpinner />}>
      <Switch>
        <Route path="/" component={Dashboard} />
        <Route path="/tracks" component={Tracks} />
        <Route path="/tracks/:id" component={TrackDetail} />
        <Route path="/releases" component={Releases} />
        <Route path="/releases/:id" component={ReleaseDetail} />
        <Route path="/analytics" component={Analytics} />
        <Route path="/settings" component={Settings} />
        <Route component={NotFound} />
      </Switch>
    </Suspense>
  );
}
```

## Accessibility

### Focus Management

Proper focus management for accessibility:

```tsx
import { useEffect, useRef } from 'react';

interface FocusTrapProps {
  children: React.ReactNode;
  isActive: boolean;
  onEscape?: () => void;
}

export function FocusTrap({ children, isActive, onEscape }: FocusTrapProps) {
  const containerRef = useRef<HTMLDivElement>(null);
  const previousFocusRef = useRef<HTMLElement | null>(null);
  
  // Save previous focus when trap activates
  useEffect(() => {
    if (isActive) {
      previousFocusRef.current = document.activeElement as HTMLElement;
    }
  }, [isActive]);
  
  // Restore focus when trap deactivates
  useEffect(() => {
    if (!isActive && previousFocusRef.current) {
      previousFocusRef.current.focus();
    }
    
    return () => {
      if (previousFocusRef.current) {
        previousFocusRef.current.focus();
      }
    };
  }, [isActive]);
  
  // Focus first focusable element when trap activates
  useEffect(() => {
    if (isActive && containerRef.current) {
      const focusableElements = containerRef.current.querySelectorAll(
        'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
      );
      
      if (focusableElements.length > 0) {
        (focusableElements[0] as HTMLElement).focus();
      }
    }
  }, [isActive]);
  
  // Handle key events (escape and tab trap)
  useEffect(() => {
    if (!isActive) return;
    
    const handleKeyDown = (event: KeyboardEvent) => {
      // Handle escape
      if (event.key === 'Escape' && onEscape) {
        onEscape();
        return;
      }
      
      // Handle tab trap
      if (event.key === 'Tab' && containerRef.current) {
        const focusableElements = Array.from(
          containerRef.current.querySelectorAll(
            'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
          )
        ) as HTMLElement[];
        
        if (focusableElements.length === 0) return;
        
        const firstElement = focusableElements[0];
        const lastElement = focusableElements[focusableElements.length - 1];
        
        // If shift+tab on first element, move to last element
        if (event.shiftKey && document.activeElement === firstElement) {
          lastElement.focus();
          event.preventDefault();
        } 
        // If tab on last element, move to first element
        else if (!event.shiftKey && document.activeElement === lastElement) {
          firstElement.focus();
          event.preventDefault();
        }
      }
    };
    
    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, [isActive, onEscape]);
  
  return <div ref={containerRef}>{children}</div>;
}
```

### ARIA Support

Components with proper ARIA attributes:

```tsx
import { useState, useId } from 'react';

interface ExpandableSectionProps {
  title: string;
  children: React.ReactNode;
  defaultExpanded?: boolean;
}

export function ExpandableSection({
  title,
  children,
  defaultExpanded = false,
}: ExpandableSectionProps) {
  const [expanded, setExpanded] = useState(defaultExpanded);
  const id = useId();
  const contentId = `content-${id}`;
  const headerId = `header-${id}`;
  
  return (
    <div className="border rounded-lg overflow-hidden">
      <h3>
        <button
          id={headerId}
          aria-expanded={expanded}
          aria-controls={contentId}
          className="flex justify-between items-center w-full px-4 py-3 bg-slate-50 hover:bg-slate-100 focus:outline-none focus:ring-2 focus:ring-blue-500"
          onClick={() => setExpanded(!expanded)}
        >
          <span className="font-medium">{title}</span>
          <svg
            className={`w-5 h-5 transform transition-transform ${
              expanded ? 'rotate-180' : ''
            }`}
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
            xmlns="http://www.w3.org/2000/svg"
          >
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth={2}
              d="M19 9l-7 7-7-7"
            />
          </svg>
        </button>
      </h3>
      <div
        id={contentId}
        role="region"
        aria-labelledby={headerId}
        className={`transition-all duration-300 ease-in-out overflow-hidden ${
          expanded ? 'max-h-96' : 'max-h-0'
        }`}
      >
        <div className="p-4">{children}</div>
      </div>
    </div>
  );
}
```

## Testing

### Component Testing

Testing components with React Testing Library:

```tsx
// TrackList.test.tsx
import { render, screen, fireEvent } from '@testing-library/react';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { TrackList } from './TrackList';

// Mock API responses
jest.mock('@/lib/queryClient', () => ({
  apiRequest: jest.fn().mockImplementation(() => {
    return Promise.resolve([
      { id: 1, title: 'Track 1', artist: 'Artist 1', streams: 1000 },
      { id: 2, title: 'Track 2', artist: 'Artist 2', streams: 2000 },
    ]);
  }),
  queryClient: new QueryClient(),
}));

describe('TrackList', () => {
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: {
        retry: false,
      },
    },
  });
  
  const renderComponent = (props = {}) => {
    return render(
      <QueryClientProvider client={queryClient}>
        <TrackList userId={1} {...props} />
      </QueryClientProvider>
    );
  };
  
  beforeEach(() => {
    queryClient.clear();
  });
  
  it('renders loading state initially', () => {
    renderComponent();
    expect(screen.getByText(/loading/i)).toBeInTheDocument();
  });
  
  it('renders track list when data is loaded', async () => {
    renderComponent();
    
    // Wait for data to load
    const track1 = await screen.findByText('Track 1');
    const track2 = await screen.findByText('Track 2');
    
    expect(track1).toBeInTheDocument();
    expect(track2).toBeInTheDocument();
  });
  
  it('calls onTrackSelect when a track is clicked', async () => {
    const onTrackSelect = jest.fn();
    renderComponent({ onTrackSelect });
    
    // Wait for data to load
    const viewButtons = await screen.findAllByText('View Details');
    expect(viewButtons).toHaveLength(2);
    
    // Click the first view button
    fireEvent.click(viewButtons[0]);
    
    // Check if the callback was called with the correct ID
    expect(onTrackSelect).toHaveBeenCalledWith(1);
  });
});
```

### Hook Testing

Testing custom hooks:

```tsx
// useUserTracks.test.ts
import { renderHook, waitFor } from '@testing-library/react';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { useUserTracks } from './useUserTracks';

// Mock API responses
jest.mock('@/lib/queryClient', () => ({
  apiRequest: jest.fn().mockImplementation(() => {
    return Promise.resolve([
      { id: 1, title: 'Track 1', artist: 'Artist 1' },
      { id: 2, title: 'Track 2', artist: 'Artist 2' },
    ]);
  }),
}));

describe('useUserTracks', () => {
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: {
        retry: false,
      },
    },
  });
  
  const wrapper = ({ children }) => (
    <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
  );
  
  beforeEach(() => {
    queryClient.clear();
  });
  
  it('returns user tracks data when successful', async () => {
    const { result } = renderHook(() => useUserTracks(1), { wrapper });
    
    // Initial state should be loading
    expect(result.current.isLoading).toBe(true);
    expect(result.current.data).toBeUndefined();
    
    // Wait for data to be loaded
    await waitFor(() => expect(result.current.isLoading).toBe(false));
    
    // Check loaded data
    expect(result.current.data).toHaveLength(2);
    expect(result.current.data[0].title).toBe('Track 1');
    expect(result.current.data[1].title).toBe('Track 2');
  });
});
```

## Deployment

### Bundle Optimization

Optimizing the application bundle:

```typescript
// vite.config.ts
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import path from 'path';

export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
      '@shared': path.resolve(__dirname, '../shared'),
    },
  },
  build: {
    target: 'es2015',
    minify: 'terser',
    cssMinify: true,
    rollupOptions: {
      output: {
        manualChunks: {
          react: ['react', 'react-dom'],
          tanstack: ['@tanstack/react-query'],
          charts: ['recharts', 'react-chartjs-2'],
        },
      },
    },
    chunkSizeWarningLimit: 1000,
  },
  server: {
    proxy: {
      '/api': {
        target: 'http://localhost:5000',
        changeOrigin: true,
      },
    },
  },
});
```

### Environment Configuration

Managing environment-specific configuration:

```typescript
// lib/config.ts
interface AppConfig {
  apiUrl: string;
  environment: 'development' | 'production' | 'test';
  features: {
    analytics: boolean;
    distributionService: boolean;
    aiTagging: boolean;
  };
}

export const config: AppConfig = {
  apiUrl: import.meta.env.VITE_API_URL || '',
  environment: (import.meta.env.MODE as 'development' | 'production' | 'test') || 'development',
  features: {
    analytics: import.meta.env.VITE_FEATURE_ANALYTICS === 'true',
    distributionService: import.meta.env.VITE_FEATURE_DISTRIBUTION === 'true',
    aiTagging: import.meta.env.VITE_FEATURE_AI_TAGGING === 'true',
  },
};
```

## Conclusion

TuneMantra's frontend architecture provides a powerful, flexible foundation for a complex music rights management platform. By leveraging modern React patterns, TypeScript, and a component-based approach, the frontend delivers a responsive, accessible, and maintainable user interface.

The architecture emphasizes:

1. **Type Safety**: TypeScript throughout the codebase ensures robust type checking
2. **Component Reusability**: Well-designed components that can be composed for complex interfaces
3. **State Management**: Efficient state management with React Query for server state
4. **Performance**: Optimizations like virtualization, memoization, and lazy loading
5. **Accessibility**: ARIA compliance and keyboard navigation support
6. **Responsiveness**: Mobile-first design that works on all device sizes

This architecture enables developers to efficiently build and maintain the TuneMantra platform while providing users with a robust, intuitive interface for managing their music rights and royalties.

---

## documentation/technical/operations/deployment-guide.md

# TuneMantra Deployment Guide

<div align="center">
  <img src="../../diagrams/deployment-guide-header.svg" alt="TuneMantra Deployment Guide" width="800"/>
</div>

## Introduction

This document provides comprehensive guidelines for deploying TuneMantra in various environments, from development to production. It covers infrastructure requirements, deployment processes, configuration management, and best practices to ensure reliable, secure, and performant deployments.

This documentation is intended for DevOps engineers, system administrators, and technical operations staff responsible for deploying and maintaining TuneMantra instances.

## Table of Contents

- [Deployment Overview](#deployment-overview)
- [Environment Requirements](#environment-requirements)
- [Infrastructure Setup](#infrastructure-setup)
- [Deployment Pipeline](#deployment-pipeline)
- [Environment Configuration](#environment-configuration)
- [Database Management](#database-management)
- [Monitoring Setup](#monitoring-setup)
- [Scaling Considerations](#scaling-considerations)
- [Deployment Verification](#deployment-verification)
- [Rollback Procedures](#rollback-procedures)
- [Maintenance Operations](#maintenance-operations)
- [Troubleshooting](#troubleshooting)

## Deployment Overview

### Deployment Architecture

TuneMantra follows a containerized deployment model:

<div align="center">
  <img src="../../diagrams/deployment-architecture.svg" alt="Deployment Architecture" width="700"/>
</div>

The deployment architecture includes:

1. **Container Orchestration**
   - Kubernetes-based deployment
   - Helm charts for application components
   - Stateless service design
   - Horizontal scaling capabilities

2. **Database Layer**
   - PostgreSQL database (managed service recommended)
   - Connection pooling
   - Read replicas for scaling read operations
   - Automated backups and point-in-time recovery

3. **Object Storage**
   - S3-compatible storage for media files
   - CDN integration for public assets
   - Tiered storage strategy
   - Lifecycle policies for cost optimization

4. **Caching Layer**
   - Redis for application caching
   - Distributed caching architecture
   - Session storage
   - Rate limiting implementation

5. **Search Layer**
   - Elasticsearch for full-text search
   - Index replication
   - Shard management
   - Query optimization

### Environment Strategy

TuneMantra uses a multi-environment strategy:

1. **Development Environment**
   - Used by developers for daily work
   - Local environments with Docker Compose
   - Integration environments for feature testing
   - Limited resource allocation

2. **Testing Environment**
   - Automated testing environment
   - QA testing environment
   - Performance testing environment
   - Security testing environment

3. **Staging Environment**
   - Production-like configuration
   - Data subset from production
   - Pre-release validation
   - Final UAT (User Acceptance Testing)

4. **Production Environment**
   - High availability configuration
   - Multi-zone deployment
   - Full monitoring and alerting
   - Compliance with all security requirements

### CI/CD Pipeline

TuneMantra uses a comprehensive CI/CD pipeline:

1. **Continuous Integration**
   - Automated code building
   - Unit and integration testing
   - Code quality checks
   - Security scanning

2. **Continuous Delivery**
   - Automated deployment to development and testing
   - Manual approval for staging and production
   - Automated smoke tests
   - Canary deployments for risk mitigation

3. **Infrastructure as Code**
   - Terraform for cloud infrastructure
   - Kubernetes manifests for application deployment
   - Helm charts for packaging
   - GitOps workflow for deployment management

## Environment Requirements

### Hardware Requirements

Recommended specifications for different environment types:

#### Development Environment

| Component | Specification |
|-----------|---------------|
| CPU | 4 cores |
| Memory | 8 GB |
| Storage | 100 GB SSD |
| Network | 1 Gbps |

#### Testing/Staging Environment

| Component | Specification |
|-----------|---------------|
| CPU | 8 cores |
| Memory | 16 GB |
| Storage | 250 GB SSD |
| Network | 1 Gbps |

#### Production Environment (Base Configuration)

| Component | Specification |
|-----------|---------------|
| CPU | 16 cores (scalable) |
| Memory | 32 GB (scalable) |
| Storage | 500 GB SSD (expandable) |
| Network | 10 Gbps |

### Software Requirements

Required software components:

#### Core Platform

| Component | Version | Purpose |
|-----------|---------|---------|
| Docker | 20.10+ | Containerization |
| Kubernetes | 1.24+ | Container orchestration |
| Helm | 3.8+ | Package management |
| PostgreSQL | 14+ | Database |
| Redis | 6.2+ | Caching and session storage |
| Elasticsearch | 7.17+ | Search functionality |
| Node.js | 18.x | Application runtime |

#### Supporting Tools

| Tool | Version | Purpose |
|------|---------|---------|
| Terraform | 1.2+ | Infrastructure as Code |
| ArgoCD | 2.4+ | GitOps deployment |
| Prometheus | 2.36+ | Monitoring |
| Grafana | 9.0+ | Dashboards and visualization |
| ELK Stack | 7.17+ | Logging |
| Istio | 1.14+ | Service mesh |
| Cert-Manager | 1.8+ | Certificate management |

### Network Requirements

Network configuration requirements:

1. **Ingress Traffic**
   - HTTPS (443/TCP) for web and API access
   - SSH (22/TCP) for management (restricted)

2. **Egress Traffic**
   - HTTPS (443/TCP) for external API access
   - SMTP (587/TCP) for email sending
   - Custom ports for specific integrations

3. **Internal Communication**
   - Service mesh for service-to-service communication
   - Network policies for micro-segmentation
   - Encrypted pod-to-pod communication

4. **DNS Requirements**
   - Wildcard DNS for dynamic environments
   - Static entries for production services
   - Internal DNS for service discovery

## Infrastructure Setup

### Cloud Provider Setup

Instructions for setting up on major cloud providers:

#### AWS Setup

1. **VPC Configuration**
   - Create VPC with multiple AZs
   - Set up public and private subnets
   - Configure NAT Gateways
   - Set up security groups

2. **EKS Cluster**
   - Deploy EKS cluster across AZs
   - Configure node groups
   - Set up autoscaling
   - Install required add-ons

3. **Database Services**
   - Deploy RDS PostgreSQL with Multi-AZ
   - Configure parameter groups
   - Set up read replicas
   - Configure automated backups

4. **Supporting Services**
   - ElastiCache for Redis
   - S3 buckets for storage
   - CloudFront for CDN
   - AWS Certificate Manager for SSL

#### Azure Setup

1. **Virtual Network**
   - Create Virtual Network with multiple zones
   - Configure subnets and NSGs
   - Set up Virtual Network Gateway
   - Configure Azure Firewall

2. **AKS Cluster**
   - Deploy AKS across availability zones
   - Configure node pools
   - Set up virtual node scaling
   - Install required add-ons

3. **Database Services**
   - Azure Database for PostgreSQL with geo-redundancy
   - Configure server parameters
   - Set up read replicas
   - Configure automated backups

4. **Supporting Services**
   - Azure Cache for Redis
   - Blob Storage for files
   - Azure CDN
   - Azure Key Vault for secrets

#### Google Cloud Setup

1. **VPC Network**
   - Create VPC with regional subnets
   - Configure Cloud NAT
   - Set up firewall rules
   - Configure Cloud Router

2. **GKE Cluster**
   - Deploy GKE with regional configuration
   - Configure node pools
   - Set up Autopilot or autoscaling
   - Install required add-ons

3. **Database Services**
   - Cloud SQL for PostgreSQL with high availability
   - Configure database flags
   - Set up read replicas
   - Configure automated backups

4. **Supporting Services**
   - Memorystore for Redis
   - Cloud Storage for files
   - Cloud CDN
   - Secret Manager for secrets

### Kubernetes Cluster Setup

Detailed Kubernetes configuration:

1. **Cluster Architecture**
   - Control plane configuration
   - Worker node pools
   - Network plugin (Calico recommended)
   - Storage classes

2. **Core Add-ons**
   - Metrics Server
   - Cluster Autoscaler
   - External DNS
   - NGINX Ingress Controller

3. **Monitoring Stack**
   - Prometheus Operator
   - Grafana
   - Alert Manager
   - Node Exporter

4. **Security Components**
   - Pod Security Policies
   - Network Policies
   - Secret management (Sealed Secrets or external provider)
   - RBAC configuration

### Database Setup

PostgreSQL database configuration:

1. **Instance Configuration**
   - CPU and memory allocation
   - Storage configuration
   - Network access control
   - Backup configuration

2. **Performance Tuning**
   - Shared buffers
   - Work memory
   - Effective cache size
   - Max connections
   - WAL settings

3. **High Availability**
   - Replication configuration
   - Failover mechanism
   - Connection pooling
   - Backup strategy

4. **Security Configuration**
   - Access control
   - Encryption settings
   - Audit logging
   - Network security

## Deployment Pipeline

### CI/CD Setup

Setting up the continuous integration and deployment pipeline:

1. **Source Control Integration**
   - GitHub repository setup
   - Branch protection rules
   - GitHub Actions workflow configuration
   - Pull request templates and checkpoints

2. **Build Process**
   - Dockerfile optimization
   - Multi-stage builds
   - Dependency caching
   - Image tagging strategy

3. **Testing Integration**
   - Unit test automation
   - Integration test suites
   - End-to-end testing
   - Security scanning integration

4. **Deployment Automation**
   - Environment-specific deployments
   - GitOps workflow with ArgoCD
   - Deployment approval gates
   - Rollback triggers

### GitHub Actions Workflow

Example GitHub Actions workflow for CI/CD:

```yaml
name: TuneMantra CI/CD

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
      - name: Install dependencies
        run: npm ci
      - name: Run tests
        run: npm test
      - name: Run linting
        run: npm run lint
      - name: Security scan
        uses: snyk/actions/node@master
        with:
          args: --severity-threshold=high

  build:
    needs: test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
      - name: Login to DockerHub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v4
        with:
          images: tunemantra/app
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=sha,format=short
      - name: Build and push
        uses: docker/build-push-action@v3
        with:
          push: ${{ github.event_name != 'pull_request' }}
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy-dev:
    if: github.ref == 'refs/heads/develop'
    needs: build
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Set up Kustomize
        uses: imranismail/setup-kustomize@v1
      - name: Update kustomization.yaml
        run: |
          cd deploy/overlays/dev
          kustomize edit set image tunemantra/app:$(echo $GITHUB_SHA | cut -c1-7)
      - name: Commit and push changes
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git commit -am "Update development image tag"
          git push

  deploy-prod:
    if: github.ref == 'refs/heads/main'
    needs: build
    runs-on: ubuntu-latest
    environment: production
    steps:
      - uses: actions/checkout@v3
      - name: Set up Kustomize
        uses: imranismail/setup-kustomize@v1
      - name: Update kustomization.yaml
        run: |
          cd deploy/overlays/prod
          kustomize edit set image tunemantra/app:$(echo $GITHUB_SHA | cut -c1-7)
      - name: Commit and push changes
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git commit -am "Update production image tag"
          git push
```

### ArgoCD Configuration

GitOps deployment with ArgoCD:

1. **Application Configuration**

```yaml
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: tunemantra
  namespace: argocd
spec:
  project: default
  source:
    repoURL: https://github.com/tunemantra/deployment.git
    targetRevision: HEAD
    path: deploy/overlays/prod
  destination:
    server: https://kubernetes.default.svc
    namespace: tunemantra
  syncPolicy:
    automated:
      prune: true
      selfHeal: true
    syncOptions:
      - CreateNamespace=true
    retry:
      limit: 5
      backoff:
        duration: 5s
        factor: 2
        maxDuration: 3m
```

2. **Syncing Strategy**
   - Automatic sync for non-production
   - Manual approval for production
   - Health check requirements
   - Rollback thresholds

3. **RBAC Configuration**
   - Project-based access control
   - Role definitions
   - User and group assignments
   - SSO integration

### Helm Chart Structure

Structure of the Helm chart for deployment:

```
tunemantra/
├── Chart.yaml
├── values.yaml
├── values-dev.yaml
├── values-staging.yaml
├── values-prod.yaml
├── templates/
│   ├── _helpers.tpl
│   ├── deployment.yaml
│   ├── service.yaml
│   ├── ingress.yaml
│   ├── configmap.yaml
│   ├── secret.yaml
│   ├── hpa.yaml
│   └── pdb.yaml
└── charts/
    ├── postgresql/
    └── redis/
```

Key configuration values:

```yaml
# values.yaml (example)
replicaCount: 2

image:
  repository: tunemantra/app
  tag: latest
  pullPolicy: IfNotPresent

service:
  type: ClusterIP
  port: 80

ingress:
  enabled: true
  annotations:
    kubernetes.io/ingress.class: nginx
    cert-manager.io/cluster-issuer: letsencrypt-prod
  hosts:
    - host: app.tunemantra.com
      paths:
        - /

resources:
  limits:
    cpu: 1000m
    memory: 2Gi
  requests:
    cpu: 500m
    memory: 1Gi

autoscaling:
  enabled: true
  minReplicas: 2
  maxReplicas: 10
  targetCPUUtilizationPercentage: 80
  targetMemoryUtilizationPercentage: 80

nodeSelector: {}
tolerations: []
affinity: {}

postgresql:
  enabled: true
  auth:
    database: tunemantra
    username: tunemantra
    existingSecret: tunemantra-db-credentials
  primary:
    persistence:
      size: 100Gi

redis:
  enabled: true
  auth:
    existingSecret: tunemantra-redis-credentials
  master:
    persistence:
      size: 20Gi
```

## Environment Configuration

### Configuration Management

Managing application configuration:

1. **Environment Variables**
   - Critical configuration
   - Sensitive information (credentials)
   - Environment-specific settings
   - Runtime behavior controls

2. **ConfigMaps**
   - Non-sensitive configuration
   - Application settings
   - Feature flags
   - Resource locations

3. **Secrets Management**
   - API keys
   - Database credentials
   - Encryption keys
   - OAuth secrets

4. **External Configuration Services**
   - AWS Parameter Store or Secrets Manager
   - Azure Key Vault
   - Google Secret Manager
   - HashiCorp Vault

### Secret Management

Securing sensitive information:

1. **Secret Storage Options**
   - Kubernetes Secrets
   - External secret stores
   - Sealed Secrets for GitOps
   - Cloud provider secret management

2. **Secret Rotation**
   - Automated rotation procedures
   - Rotation scheduling
   - Zero-downtime rotation
   - Credential leakage detection

3. **Access Control**
   - RBAC for secret access
   - Audit logging
   - Least privilege principle
   - Service account management

4. **Integration Patterns**
   - Sidecar injection
   - Init container configuration
   - CSI drivers
   - Direct API integration

### Environment-Specific Configuration

Managing different environments:

1. **Development Configuration**
   - Local development defaults
   - Mocked external services
   - Debug-friendly settings
   - Reduced resource requirements

2. **Testing Configuration**
   - Test data setup
   - Isolated external services
   - Performance test settings
   - Test coverage configuration

3. **Staging Configuration**
   - Production-like settings
   - Sanitized data
   - Final validation settings
   - Pre-production feature flags

4. **Production Configuration**
   - Optimized performance settings
   - High availability configuration
   - Security hardening
   - Compliance-related settings

## Database Management

### Schema Management

Managing the database schema:

1. **Migration Strategy**
   - Drizzle migration setup
   - Version control integration
   - Backward compatibility
   - Rollback procedures

2. **Schema Versioning**
   - Migration naming convention
   - Tracking applied migrations
   - Schema version in application
   - Schema compatibility verification

3. **Data Migration**
   - Large table migration strategies
   - Data transformation during migration
   - Data validation post-migration
   - Performance considerations

4. **Database Maintenance**
   - Index management
   - Vacuum and analyze scheduling
   - Statistics collection
   - Performance monitoring

### Backup and Recovery

Protecting database data:

1. **Backup Strategy**
   - Full daily backups
   - Incremental backups
   - Point-in-time recovery with WAL
   - Cross-region backup replication

2. **Backup Storage**
   - Encrypted backup storage
   - Immutable backups
   - Retention policies
   - Access controls

3. **Recovery Procedures**
   - Full database restoration
   - Point-in-time recovery
   - Single table restoration
   - Testing recovery procedures

4. **Disaster Recovery**
   - Cross-region failover
   - Recovery time objectives (RTOs)
   - Recovery point objectives (RPOs)
   - Disaster recovery testing

### Database Scaling

Scaling database capacity:

1. **Vertical Scaling**
   - Instance size upgrades
   - Storage expansion
   - Performance optimization
   - Resource allocation

2. **Horizontal Scaling**
   - Read replica deployment
   - Connection pooling
   - Query routing
   - Read/write splitting

3. **Sharding Strategies**
   - Tenant-based sharding
   - Hash-based sharding
   - Range-based sharding
   - Shard management

4. **Database Caching**
   - Query result caching
   - Object caching
   - Distributed cache invalidation
   - Cache warming strategies

## Monitoring Setup

### Metrics Collection

Setting up comprehensive metrics:

1. **Infrastructure Metrics**
   - Node CPU, memory, disk, network
   - Kubernetes pod and node metrics
   - Database performance metrics
   - Network throughput and latency

2. **Application Metrics**
   - Request rates and latencies
   - Error rates
   - Business metrics
   - Custom application metrics

3. **User Experience Metrics**
   - Page load times
   - API response times
   - Client-side errors
   - User journey completion rates

4. **Business Metrics**
   - Conversion rates
   - User engagement
   - Feature usage
   - Revenue metrics

### Logging Configuration

Centralized logging setup:

1. **Log Collection**
   - Application logs (structured JSON)
   - System logs
   - Kubernetes logs
   - Database logs

2. **Log Storage**
   - Elasticsearch storage
   - Log retention policies
   - Log archiving
   - Compliance requirements

3. **Log Processing**
   - Filtering and normalization
   - Enrichment with metadata
   - Pattern recognition
   - Anomaly detection

4. **Log Access Control**
   - Role-based access
   - Log data classification
   - Sensitive data masking
   - Audit trail for log access

### Alerting Setup

Configuring effective alerts:

1. **Alert Definitions**
   - SLO-based alerts
   - Error rate thresholds
   - Resource utilization alerts
   - Business metric anomalies

2. **Alert Routing**
   - On-call schedules
   - Escalation policies
   - Notification channels
   - Alert grouping

3. **Alert Management**
   - Alert acknowledgment
   - Incident tracking
   - Postmortem process
   - Alert tuning

4. **Notification Channels**
   - Email notifications
   - SMS alerts
   - Chat integrations (Slack, Teams)
   - Phone calls for critical issues

### Dashboard Configuration

Creating informative dashboards:

1. **Overview Dashboards**
   - System health
   - SLO compliance
   - Error rates
   - User activity

2. **Operational Dashboards**
   - Service performance
   - Database metrics
   - API endpoint status
   - Infrastructure utilization

3. **Business Dashboards**
   - User signups and activity
   - Feature adoption
   - Revenue metrics
   - Content metrics

4. **Custom Dashboards**
   - Team-specific views
   - Role-specific information
   - Custom metric combinations
   - Special investigation dashboards

## Scaling Considerations

### Horizontal Scaling

Scaling application instances:

1. **Autoscaling Configuration**
   - CPU and memory based scaling
   - Custom metric scaling
   - Minimum and maximum instances
   - Scale-up and scale-down behavior

2. **Load Balancing**
   - Service discovery
   - Session affinity
   - Health checking
   - Traffic distribution algorithms

3. **Stateless Design**
   - Externalized session storage
   - Shared-nothing architecture
   - Coordination through databases or message queues
   - Idempotent request handling

4. **Deployment Strategies**
   - Rolling updates
   - Blue/green deployments
   - Canary releases
   - Traffic shifting

### Database Scaling

Growing database capacity:

1. **Read Scaling**
   - Read replica deployment
   - Read query routing
   - Replica lag monitoring
   - Cross-region replicas

2. **Write Scaling**
   - Connection pooling
   - Statement batching
   - Optimistic locking
   - Command queuing

3. **Data Partitioning**
   - Table partitioning
   - Foreign data wrappers
   - Multi-tenancy isolation
   - Archive strategies

4. **Query Optimization**
   - Index optimization
   - Query analysis
   - Plan forcing
   - Materialized views

### Caching Strategy

Implementing effective caching:

1. **Application Caching**
   - Memory-based caching
   - Object caching
   - Query result caching
   - Computed value caching

2. **Distributed Caching**
   - Redis cache configuration
   - Cache invalidation strategy
   - Cache synchronization
   - Failover handling

3. **CDN Configuration**
   - Static asset caching
   - Dynamic content caching
   - Cache control headers
   - Purging strategies

4. **Browser Caching**
   - Cache control headers
   - Asset versioning
   - Service worker caching
   - Offline capabilities

### Traffic Management

Handling increased load:

1. **Rate Limiting**
   - API rate limit configuration
   - Client identification
   - Rate limit policies
   - Throttling behavior

2. **Traffic Prioritization**
   - Critical path prioritization
   - User tier-based prioritization
   - Request classification
   - Resource allocation

3. **Circuit Breaking**
   - Failure detection
   - Circuit trip thresholds
   - Half-open state behavior
   - Circuit health metrics

4. **Traffic Shaping**
   - Request queuing
   - Request scheduling
   - Concurrency limiting
   - Backpressure mechanisms

## Deployment Verification

### Pre-deployment Checks

Validation before deployment:

1. **Code Quality Checks**
   - Unit test coverage
   - Integration test results
   - Code quality metrics
   - Security scan results

2. **Infrastructure Validation**
   - Configuration validation
   - Resource availability
   - Access checks
   - Dependency verification

3. **Database Readiness**
   - Migration dry-run
   - Schema compatibility
   - Space requirements
   - Backup verification

4. **External Dependencies**
   - API endpoint availability
   - Service account validity
   - Third-party service status
   - Credential validation

### Deployment Testing

Testing during and after deployment:

1. **Smoke Testing**
   - Basic functionality verification
   - Critical path testing
   - Authentication checks
   - Data access validation

2. **Canary Analysis**
   - Performance comparison
   - Error rate monitoring
   - User experience metrics
   - Business metric impact

3. **Integration Verification**
   - End-to-end transaction testing
   - Cross-service functionality
   - External API integration
   - Notification delivery

4. **Performance Validation**
   - Response time measurement
   - Resource utilization
   - Database performance
   - Throughput verification

### Post-deployment Checks

Validation after deployment:

1. **Health Monitoring**
   - Service health checks
   - Database connection verification
   - Cache connectivity
   - External service access

2. **User Impact Assessment**
   - Error rate monitoring
   - User journey completion
   - Support ticket analysis
   - Feature usage metrics

3. **Performance Analysis**
   - Response time comparison
   - Resource utilization trends
   - Database query performance
   - Cache hit rates

4. **Security Verification**
   - Permission checks
   - Access control validation
   - Encryption verification
   - Vulnerability scanning

## Rollback Procedures

### Rollback Scenarios

Identifying when to roll back:

1. **Critical Failures**
   - Service unavailability
   - Data corruption
   - Security vulnerabilities
   - Payment processing issues

2. **Performance Degradation**
   - Severe response time increase
   - Resource exhaustion
   - Database overload
   - Excessive error rates

3. **Functional Issues**
   - Core functionality breakage
   - Authentication/authorization failures
   - Integration failures
   - Data inconsistency

4. **Compliance Concerns**
   - Security control bypasses
   - Privacy violations
   - Regulatory requirements
   - Legal considerations

### Rollback Process

Executing a successful rollback:

1. **Decision Making**
   - Impact assessment
   - Rollback authorization
   - Communication plan
   - Execution timing

2. **Application Rollback**
   - Previous version deployment
   - Configuration rollback
   - Feature flag deactivation
   - Client notification

3. **Database Rollback**
   - Schema rollback procedure
   - Data recovery if needed
   - Verification steps
   - Consistency checks

4. **Post-Rollback Actions**
   - Verification testing
   - Incident documentation
   - Root cause analysis
   - User communication

### Partial Rollbacks

Targeted rollback approaches:

1. **Feature Toggles**
   - Feature-specific deactivation
   - Targeted user group impact
   - A/B testing infrastructure
   - Progressive rollout control

2. **Traffic Shifting**
   - Partial traffic redirection
   - Blue/green deployment switching
   - Canary deployment adjustment
   - User segment isolation

3. **Component Isolation**
   - Microservice specific rollback
   - API version pinning
   - Circuit breaking activation
   - Fallback implementation

4. **Data Remediation**
   - Targeted data correction
   - Transaction replay
   - State reconciliation
   - Audit trail review

## Maintenance Operations

### Routine Maintenance

Regular maintenance procedures:

1. **System Updates**
   - Security patches
   - Dependency updates
   - OS updates
   - Runtime version upgrades

2. **Database Maintenance**
   - Index rebuilding
   - Statistics updates
   - Vacuum operations
   - Storage reclamation

3. **Backup Verification**
   - Backup integrity testing
   - Restoration testing
   - Recovery time measurement
   - Backup strategy review

4. **Security Maintenance**
   - Credential rotation
   - Certificate renewal
   - Permission review
   - Vulnerability scanning

### Planned Downtime

Managing necessary outages:

1. **Downtime Planning**
   - Impact assessment
   - Scheduling considerations
   - User notification
   - Approval process

2. **Execution Process**
   - Pre-downtime checklist
   - Maintenance window procedures
   - Progress tracking
   - Rollback preparation

3. **Verification Process**
   - Post-maintenance testing
   - Service restoration
   - Performance verification
   - User verification

4. **Documentation**
   - Maintenance records
   - Configuration changes
   - Issue resolution
   - Lessons learned

### Zero-Downtime Maintenance

Minimizing service disruption:

1. **Database Updates**
   - Online schema changes
   - Read replica updates first
   - Backward compatible changes
   - Rolling deployments

2. **Application Updates**
   - Rolling deployments
   - Blue/green deployments
   - Shadow testing
   - Canary releases

3. **Infrastructure Updates**
   - Node rotation
   - Zone-by-zone updates
   - Redundancy maintenance
   - Traffic shifting

4. **External Dependency Changes**
   - Service discovery updates
   - Graceful connection handling
   - Circuit breaking implementation
   - Fallback mechanisms

## Troubleshooting

### Common Issues

Addressing frequent problems:

1. **Deployment Failures**
   - Image pull errors
   - Resource constraints
   - Configuration errors
   - Permission issues

2. **Application Errors**
   - API errors
   - Service crashes
   - Memory leaks
   - CPU bottlenecks

3. **Database Issues**
   - Connection pool exhaustion
   - Query performance
   - Lock contention
   - Storage limitations

4. **Network Problems**
   - DNS resolution
   - Load balancer issues
   - Service discovery failures
   - Network policy restrictions

### Debugging Tools

Essential troubleshooting tools:

1. **Logging Analysis**
   - Log aggregation tools
   - Log search capabilities
   - Log correlation
   - Pattern recognition

2. **Performance Profiling**
   - CPU and memory profiling
   - Distributed tracing
   - Database query analysis
   - Network traffic analysis

3. **Kubernetes Troubleshooting**
   - kubectl describe
   - kubectl logs
   - kubectl exec
   - Resource monitoring

4. **Database Diagnostics**
   - Query analysis
   - Execution plans
   - Lock monitoring
   - Table statistics

### Incident Response

Handling production issues:

1. **Incident Detection**
   - Alert monitoring
   - User reports
   - Synthetic monitoring
   - Anomaly detection

2. **Initial Response**
   - Severity assessment
   - Team mobilization
   - Communication initiation
   - Initial mitigation steps

3. **Investigation Process**
   - Root cause analysis
   - Impact assessment
   - Mitigation planning
   - Resolution implementation

4. **Post-Incident Activities**
   - Incident documentation
   - Post-mortem review
   - Corrective actions
   - Process improvements

### Escalation Procedures

When and how to escalate issues:

1. **Escalation Criteria**
   - Severity thresholds
   - Time-based escalation
   - Impact escalation
   - Special conditions

2. **Escalation Paths**
   - First-level support
   - Engineering escalation
   - Management notification
   - Executive escalation

3. **Communication Templates**
   - Status updates
   - Customer communications
   - Management briefings
   - Resolution notifications

4. **External Support**
   - Vendor support engagement
   - Cloud provider support
   - External consultant involvement
   - Open source community resources

---

**Document Information:**
- Version: 2.0
- Last Updated: March 25, 2025
- Contact: devops@tunemantra.com

---

## documentation/technical/operations/security-procedures.md

# TuneMantra Security Procedures

<div align="center">
  <img src="../../diagrams/security-procedures-header.svg" alt="TuneMantra Security Procedures" width="800"/>
</div>

## Introduction

This document outlines the comprehensive security procedures, policies, and best practices implemented in the TuneMantra platform to protect user data, music assets, and financial information. It covers all aspects of application security, infrastructure protection, data privacy, and compliance requirements.

This documentation is intended for security team members, system administrators, compliance officers, and developers responsible for maintaining the security posture of the TuneMantra platform.

## Table of Contents

- [Security Framework](#security-framework)
- [Account Security](#account-security)
- [Application Security](#application-security)
- [Infrastructure Security](#infrastructure-security)
- [Data Protection](#data-protection)
- [Access Control](#access-control)
- [Security Monitoring](#security-monitoring)
- [Incident Response](#incident-response)
- [Compliance](#compliance)
- [Security Testing](#security-testing)
- [Security Updates](#security-updates)
- [Vendor Security](#vendor-security)
- [Physical Security](#physical-security)

## Security Framework

### Security Principles

TuneMantra's security framework is built on these core principles:

1. **Defense in Depth**
   - Multiple security controls at different layers
   - No single point of failure
   - Overlapping security mechanisms
   - Compartmentalization of security domains

2. **Least Privilege**
   - Minimal access rights for users and systems
   - Role-based access control (RBAC)
   - Just-in-time access provisioning
   - Regular access reviews

3. **Secure by Design**
   - Security built into the development process
   - Threat modeling during design phase
   - Security requirements in product specifications
   - Privacy by design principles

4. **Zero Trust Architecture**
   - Verify explicitly
   - Use least privilege access
   - Assume breach mentality
   - Identity-based security controls

### Security Governance

Security governance structure:

1. **Security Team Structure**
   - Chief Information Security Officer (CISO)
   - Security architects
   - Security operations center (SOC) analysts
   - Security engineers
   - Compliance specialists

2. **Security Committees**
   - Executive security council
   - Security architecture review board
   - Incident response team
   - Vendor security assessment team

3. **Security Policies**
   - Information security policy
   - Acceptable use policy
   - Data classification policy
   - Third-party risk management policy
   - Security incident response policy

4. **Security Standards**
   - Password complexity standards
   - Encryption standards
   - Network security standards
   - Cloud security standards
   - API security standards

### Risk Management

Security risk management process:

1. **Risk Assessment**
   - Annual comprehensive risk assessment
   - Quarterly focused risk reviews
   - Continuous monitoring for emerging threats
   - Threat intelligence integration

2. **Risk Evaluation**
   - Risk scoring methodology
   - Risk acceptance criteria
   - Business impact analysis
   - Security risk register

3. **Risk Treatment**
   - Risk mitigation strategies
   - Risk acceptance process
   - Risk transfer options
   - Risk avoidance mechanisms

4. **Risk Monitoring**
   - Key risk indicators (KRIs)
   - Risk treatment plan tracking
   - Risk register reviews
   - Risk trending analysis

## Account Security

### User Authentication

Securing user access:

1. **Password Requirements**
   - Minimum 12 characters
   - Complexity requirements (uppercase, lowercase, numbers, symbols)
   - Password history enforcement (previous 24 passwords)
   - Maximum password age of 90 days

2. **Multi-Factor Authentication (MFA)**
   - Required for all admin and privileged accounts
   - Optional but encouraged for standard users
   - Supported methods: authenticator apps, security keys, SMS (fallback only)
   - MFA enforcement for high-risk actions

3. **Single Sign-On (SSO)**
   - SAML 2.0 integration
   - OAuth 2.0 and OpenID Connect support
   - Identity provider partnerships
   - Just-in-time provisioning

4. **Authentication Monitoring**
   - Failed login attempt limitations
   - Brute force protection
   - Suspicious login detection
   - Geographic login analysis

### Session Management

Securing user sessions:

1. **Session Configuration**
   - Secure cookie attributes (HttpOnly, Secure, SameSite)
   - Anti-CSRF tokens
   - Session timeout (30 minutes of inactivity)
   - Absolute session expiration (12 hours)

2. **Session Security Controls**
   - Session regeneration on privilege level change
   - Concurrent session limitations
   - Forced re-authentication for sensitive operations
   - Session revocation capabilities

3. **Session Tracking**
   - Device fingerprinting
   - Session activity logging
   - Anomalous session detection
   - Session hijacking protection

4. **Client-Side Controls**
   - Browser security headers
   - Content Security Policy implementation
   - Local storage security
   - Service worker security

### Account Recovery

Secure account recovery processes:

1. **Recovery Methods**
   - Email verification with secure links (limited time validity)
   - Secondary email verification
   - Recovery codes (pre-generated one-time use)
   - Delegated recovery options

2. **Identity Verification**
   - Knowledge-based authentication questions
   - Document verification for high-value accounts
   - Identity validation procedures
   - Cooling-off periods for changes

3. **Recovery Limitations**
   - Rate limiting of recovery attempts
   - Notification of recovery events
   - Account lockout after multiple failed recovery attempts
   - Administrator intervention for sensitive accounts

4. **Account Takeover Protection**
   - Email change confirmation
   - Phone number change verification
   - Suspicious activity monitoring
   - Critical change notifications

## Application Security

### Secure Development

Embedding security in development:

1. **Secure Development Lifecycle**
   - Security requirements gathering
   - Threat modeling
   - Security design reviews
   - Secure coding standards

2. **Security Testing in Development**
   - Static application security testing (SAST)
   - Dynamic application security testing (DAST)
   - Interactive application security testing (IAST)
   - Software composition analysis (SCA)

3. **Code Security Reviews**
   - Automated security linting
   - Peer code reviews with security focus
   - Security champions program
   - Security defect tracking

4. **Security Training for Developers**
   - Secure coding training
   - Language-specific security training
   - Security vulnerabilities awareness
   - Security tools training

### API Security

Protecting application APIs:

1. **API Authentication**
   - OAuth 2.0 implementation
   - API key management
   - JWT token security
   - Client certificate authentication

2. **API Authorization**
   - Granular permission control
   - Scope-based access control
   - API rate limiting
   - Quota enforcement

3. **API Input Validation**
   - Schema validation
   - Input sanitization
   - Parameter constraint enforcement
   - Content type validation

4. **API Monitoring**
   - Abnormal usage detection
   - API abuse monitoring
   - Error rate monitoring
   - API performance tracking

### Web Security Controls

Securing web interfaces:

1. **Input Validation**
   - Client-side validation
   - Server-side validation
   - Sanitization of user inputs
   - Encoding of output

2. **Output Encoding**
   - Context-aware encoding
   - HTML entity encoding
   - JavaScript encoding
   - URL encoding

3. **Security Headers**
   - Content-Security-Policy (CSP)
   - X-Content-Type-Options
   - X-Frame-Options
   - Strict-Transport-Security (HSTS)

4. **Client-Side Protection**
   - Subresource Integrity (SRI)
   - Cross-Origin Resource Sharing (CORS) policy
   - Feature-Policy/Permissions-Policy
   - DOM-based XSS protection

### Mobile Security

Securing mobile applications:

1. **Mobile App Security Controls**
   - Certificate pinning
   - App transport security
   - Secure local storage
   - Anti-tampering mechanisms

2. **Mobile Authentication**
   - Biometric authentication integration
   - Secure authentication tokens
   - Offline authentication
   - Device binding

3. **Mobile Data Protection**
   - Encrypted local storage
   - Secure keychain/keystore usage
   - Data minimization
   - Secure data synchronization

4. **Mobile App Deployment**
   - App store security review compliance
   - In-app update mechanisms
   - App signing and verification
   - Runtime security controls

## Infrastructure Security

### Network Security

Securing the network layer:

1. **Network Architecture**
   - Network segmentation
   - Demilitarized zones (DMZ)
   - Microsegmentation
   - Software-defined networking (SDN)

2. **Network Access Controls**
   - Firewall configuration
   - Network access control lists (NACLs)
   - VPN access
   - Bastion hosts

3. **DDoS Protection**
   - Edge protection
   - Traffic scrubbing
   - Rate limiting
   - Anycast network architecture

4. **Network Monitoring**
   - Intrusion detection systems (IDS)
   - Intrusion prevention systems (IPS)
   - Network traffic analysis
   - Netflow monitoring

### Cloud Security

Securing cloud infrastructure:

1. **Cloud Architecture Security**
   - Multi-account strategy
   - Private subnets for sensitive workloads
   - Transit network architecture
   - Serverless security architecture

2. **Cloud Security Controls**
   - Identity and Access Management (IAM)
   - Security groups configuration
   - Network ACLs
   - Resource policies

3. **Cloud Service Configuration**
   - Security baseline configurations
   - Service-specific security controls
   - Config management
   - Infrastructure as Code security reviews

4. **Cloud Security Monitoring**
   - Cloud trail logging
   - Cloud security posture management
   - Cloud-native security tools
   - Third-party security monitoring

### Container Security

Securing containerized workloads:

1. **Container Image Security**
   - Base image security
   - Image scanning
   - Image signing and verification
   - Image registry security

2. **Container Runtime Security**
   - Container hardening
   - Container isolation
   - Privileged container restrictions
   - Runtime vulnerability scanning

3. **Kubernetes Security**
   - Pod security policies
   - RBAC configuration
   - Network policies
   - Secret management

4. **Container Orchestration Security**
   - Control plane security
   - Worker node security
   - Admission controllers
   - Supply chain security

### Endpoint Security

Securing endpoint devices:

1. **Endpoint Protection**
   - Endpoint detection and response (EDR)
   - Anti-malware solutions
   - Host-based firewalls
   - Data loss prevention (DLP)

2. **Endpoint Configuration**
   - Secure baseline configuration
   - Patch management
   - Configuration drift monitoring
   - Endpoint compliance checks

3. **Endpoint Access Control**
   - Device authentication
   - Device authorization
   - Device health attestation
   - Conditional access policies

4. **Remote Work Security**
   - VPN security
   - Remote desktop security
   - Split tunneling controls
   - Remote device management

## Data Protection

### Data Classification

Organizing data for protection:

1. **Classification Levels**
   - Public information
   - Internal information
   - Confidential information
   - Restricted information

2. **Classification Criteria**
   - Sensitivity
   - Regulatory requirements
   - Business impact
   - Intellectual property value

3. **Data Labeling**
   - Visual markings
   - Metadata tagging
   - Classification headers/footers
   - Digital rights management tags

4. **Classification Processes**
   - Manual classification
   - Automated classification
   - Content inspection
   - Classification reviews

### Data Encryption

Protecting data confidentiality:

1. **Encryption at Rest**
   - Database encryption
   - File system encryption
   - Backup encryption
   - Media encryption

2. **Encryption in Transit**
   - TLS configuration
   - Perfect forward secrecy
   - Secure cipher suite selection
   - Certificate management

3. **Encryption in Use**
   - Confidential computing technologies
   - Trusted execution environments
   - Tokenization
   - Format-preserving encryption

4. **Encryption Key Management**
   - Key generation
   - Key rotation
   - Key backup and recovery
   - Key access control

### Data Retention

Managing data lifecycle:

1. **Retention Policies**
   - Data type-specific retention periods
   - Regulatory retention requirements
   - Retention exemptions
   - Legal hold process

2. **Data Archiving**
   - Archive storage security
   - Archive access controls
   - Archive integrity verification
   - Archive encryption

3. **Data Deletion**
   - Secure deletion methods
   - Cryptographic erasure
   - Media sanitization
   - Deletion verification

4. **Data Minimization**
   - Data collection limitations
   - Purpose-driven retention
   - Automated data purging
   - Data anonymization

### Data Loss Prevention

Preventing unauthorized data exfiltration:

1. **DLP Policy Configuration**
   - Content identification rules
   - Context-aware policies
   - User group-specific policies
   - Remediation actions

2. **DLP Coverage Areas**
   - Email DLP
   - Endpoint DLP
   - Network DLP
   - Cloud DLP

3. **DLP Response Actions**
   - Block and notify
   - Quarantine
   - Encrypt
   - User justification workflow

4. **DLP Monitoring**
   - Policy violation tracking
   - False positive management
   - DLP effectiveness reporting
   - Control tuning

## Access Control

### Identity Management

Managing digital identities:

1. **Identity Lifecycle**
   - Provisioning
   - Authentication
   - Authorization
   - De-provisioning

2. **Identity Sources**
   - Directory services
   - Identity providers
   - Federation services
   - Just-in-time provisioning

3. **Identity Governance**
   - Access certification
   - Segregation of duties
   - Privileged access workflow
   - Identity analytics

4. **Identity Repository Security**
   - Directory security
   - Credential protection
   - Identity metadata security
   - Identity store monitoring

### Authorization Model

Controlling access to resources:

1. **Role-Based Access Control (RBAC)**
   - Role definition
   - Role assignment
   - Role hierarchy
   - Role constraints

2. **Attribute-Based Access Control (ABAC)**
   - User attributes
   - Resource attributes
   - Environmental attributes
   - Policy evaluation engine

3. **Permission Management**
   - Permission definition
   - Permission aggregation
   - Permission inheritance
   - Temporary permission elevation

4. **Access Policies**
   - Policy definition language
   - Policy enforcement points
   - Policy decision points
   - Policy administration

### Privileged Access Management

Securing privileged accounts:

1. **Privileged Account Inventory**
   - Discovery of privileged accounts
   - Classification of privileges
   - Privileged account mapping
   - Service account inventory

2. **Privileged Access Workflow**
   - Just-in-time access
   - Approval workflows
   - Emergency access process
   - Privileged session time limits

3. **Privileged Session Management**
   - Session recording
   - Session monitoring
   - Command filtering
   - Session termination capabilities

4. **Credential Vaulting**
   - Password vault
   - Key vault
   - Certificate storage
   - Secret rotation

### Federation and SSO

Managing cross-domain access:

1. **Federation Protocols**
   - SAML 2.0 implementation
   - OpenID Connect
   - WS-Federation
   - OAuth 2.0

2. **Federation Trust Configuration**
   - Identity provider configuration
   - Service provider settings
   - Certificate management
   - Metadata exchange

3. **Federation Security Controls**
   - Signature verification
   - Encryption of assertions
   - Audience restriction
   - Authentication context

4. **User Experience Considerations**
   - Silent authentication
   - Single logout
   - Identity provider discovery
   - Fallback authentication

## Security Monitoring

### Security Information and Event Management (SIEM)

Centralizing security monitoring:

1. **Log Collection**
   - Application logs
   - Infrastructure logs
   - Security device logs
   - Network logs

2. **Event Correlation**
   - Correlation rules
   - Pattern recognition
   - Baseline deviation detection
   - Threat intelligence integration

3. **Alert Management**
   - Alert prioritization
   - Alert enrichment
   - Alert routing
   - Alert response tracking

4. **SIEM Use Cases**
   - Authentication monitoring
   - Privileged activity monitoring
   - Data access monitoring
   - Network attack detection

### Security Monitoring

Continuous security oversight:

1. **Continuous Monitoring Strategy**
   - Critical asset monitoring
   - Vulnerability monitoring
   - Configuration monitoring
   - Threat monitoring

2. **Monitoring Data Sources**
   - System logs
   - Network traffic
   - User activity
   - External intelligence

3. **Monitoring Technology**
   - Log aggregation
   - Endpoint monitoring
   - Network monitoring
   - Cloud security monitoring

4. **Monitoring Processes**
   - Real-time monitoring
   - Daily security reviews
   - Weekly security hunting
   - Monthly trend analysis

### Vulnerability Management

Identifying and remediating vulnerabilities:

1. **Vulnerability Scanning**
   - Network vulnerability scanning
   - Application vulnerability scanning
   - Container vulnerability scanning
   - Cloud configuration scanning

2. **Vulnerability Prioritization**
   - Risk-based prioritization
   - Exploitability assessment
   - Business impact consideration
   - Remediation difficulty factor

3. **Patch Management**
   - Patch testing process
   - Patch deployment schedule
   - Emergency patching procedure
   - Patch verification

4. **Vulnerability Metrics**
   - Mean time to remediate (MTTR)
   - Vulnerability aging
   - Patch compliance rate
   - Vulnerability density

### Threat Intelligence

Leveraging external threat information:

1. **Threat Intelligence Sources**
   - Commercial threat feeds
   - Open-source intelligence
   - Industry sharing groups
   - Government advisories

2. **Threat Intelligence Integration**
   - SIEM integration
   - Firewall/IPS integration
   - EDR integration
   - Vulnerability management integration

3. **Threat Analysis**
   - Indicator analysis
   - Threat actor tracking
   - Campaign analysis
   - Trend analysis

4. **Threat Intelligence Sharing**
   - Internal distribution
   - Partner sharing
   - Industry contribution
   - Regulatory reporting

## Incident Response

### Incident Response Plan

Preparing for security incidents:

1. **Incident Response Process**
   - Preparation
   - Detection and analysis
   - Containment
   - Eradication and recovery
   - Post-incident activities

2. **Incident Response Team**
   - First responders
   - Technical investigators
   - Management representatives
   - Legal and communications personnel

3. **Incident Classification**
   - Severity levels
   - Incident types
   - Escalation criteria
   - Notification thresholds

4. **Incident Response Documentation**
   - Incident response playbooks
   - Contact information
   - Escalation procedures
   - Communication templates

### Incident Response Procedures

Executing the incident response process:

1. **Detection Procedures**
   - Alert triage
   - Initial investigation
   - Evidence collection
   - Incident declaration

2. **Containment Strategies**
   - Short-term containment
   - Long-term containment
   - Evidence preservation
   - Service continuity

3. **Eradication and Recovery**
   - Root cause removal
   - System restoration
   - Vulnerability remediation
   - Recovery verification

4. **Lessons Learned**
   - Post-incident analysis
   - Process improvement
   - Documentation updates
   - Knowledge sharing

### Security Breach Handling

Managing significant security incidents:

1. **Breach Assessment**
   - Impact determination
   - Scope identification
   - Data compromise evaluation
   - Legal and regulatory implications

2. **Breach Notification**
   - Internal notification
   - Customer notification
   - Regulatory notification
   - Law enforcement engagement

3. **Breach Remediation**
   - Immediate security measures
   - Long-term security improvements
   - Monitoring enhancements
   - Trust restoration

4. **Breach Documentation**
   - Investigation timeline
   - Evidence collection
   - Remediation actions
   - Prevention measures

### Digital Forensics

Investigating security incidents:

1. **Forensic Readiness**
   - Forensic data sources
   - Data collection mechanisms
   - Forensic tool preparation
   - Chain of custody procedures

2. **Evidence Collection**
   - Live system data collection
   - Disk imaging
   - Memory capture
   - Network traffic capture

3. **Forensic Analysis**
   - Timeline reconstruction
   - Log analysis
   - Artifact examination
   - Root cause determination

4. **Forensic Reporting**
   - Technical findings
   - Incident narrative
   - Attribution analysis
   - Recommendations

## Compliance

### Regulatory Compliance

Meeting legal requirements:

1. **Compliance Framework**
   - Regulatory mapping
   - Control implementation
   - Compliance monitoring
   - Gap remediation

2. **Key Regulations**
   - GDPR (General Data Protection Regulation)
   - CCPA/CPRA (California Consumer Privacy Act)
   - HIPAA (Health Insurance Portability and Accountability Act)
   - PCI DSS (Payment Card Industry Data Security Standard)

3. **Compliance Documentation**
   - Policies and procedures
   - Control evidence
   - Risk assessments
   - Compliance attestations

4. **Compliance Reporting**
   - Internal compliance reporting
   - External compliance reporting
   - Executive dashboards
   - Regulatory filings

### Privacy Compliance

Protecting personal data:

1. **Privacy Program**
   - Privacy by design principles
   - Data protection impact assessments
   - Privacy controls
   - Privacy monitoring

2. **Data Subject Rights**
   - Right to access
   - Right to rectification
   - Right to erasure
   - Right to data portability

3. **Consent Management**
   - Consent collection
   - Consent management
   - Preference center
   - Consent withdrawal

4. **Cross-Border Data Transfers**
   - Transfer mechanism identification
   - Standard contractual clauses
   - Binding corporate rules
   - Transfer impact assessments

### Audit Management

Preparing for and managing audits:

1. **Internal Audit**
   - Audit planning
   - Control testing
   - Finding remediation
   - Audit committee reporting

2. **External Audit**
   - Audit preparation
   - Evidence collection
   - Auditor coordination
   - Finding management

3. **Audit Trail Management**
   - Audit log generation
   - Audit log protection
   - Audit log retention
   - Audit log review

4. **Continuous Compliance**
   - Control monitoring
   - Configuration compliance
   - Automated testing
   - Compliance validation

### Contractual Compliance

Meeting partner and customer requirements:

1. **Security Contractual Requirements**
   - Service level agreements (SLAs)
   - Security requirements
   - Privacy requirements
   - Compliance commitments

2. **Contract Management**
   - Security clause review
   - Compliance tracking
   - Obligation management
   - Requirement mapping

3. **Attestation Management**
   - Security questionnaire responses
   - Certification sharing
   - Audit report distribution
   - Compliance evidence

4. **Compliance Reporting to Customers**
   - Security status reporting
   - Incident notification
   - Compliance updates
   - Audit findings sharing

## Security Testing

### Penetration Testing

Simulating attacks to identify vulnerabilities:

1. **Penetration Testing Program**
   - Testing scope
   - Testing frequency
   - Methodology selection
   - Rules of engagement

2. **Penetration Testing Types**
   - External network testing
   - Internal network testing
   - Web application testing
   - API security testing
   - Mobile application testing

3. **Penetration Testing Process**
   - Reconnaissance
   - Vulnerability identification
   - Exploitation
   - Post-exploitation
   - Reporting

4. **Penetration Testing Results Management**
   - Finding severity classification
   - Remediation planning
   - Verification testing
   - Lessons learned

### Vulnerability Assessments

Systematically identifying vulnerabilities:

1. **Vulnerability Assessment Scope**
   - Technical scope
   - Business process scope
   - Third-party scope
   - Assessment frequency

2. **Vulnerability Assessment Methods**
   - Automated scanning
   - Manual testing
   - Configuration review
   - Architecture review

3. **Vulnerability Assessment Tools**
   - Network vulnerability scanners
   - Web application scanners
   - Database vulnerability scanners
   - Cloud security posture management

4. **Vulnerability Remediation Process**
   - Vulnerability validation
   - Remediation prioritization
   - Fix implementation
   - Verification testing

### Red Team Exercises

Advanced adversary simulation:

1. **Red Team Planning**
   - Objective definition
   - Threat modeling
   - Scenario development
   - Timeline establishment

2. **Red Team Operations**
   - Initial access techniques
   - Persistence methods
   - Privilege escalation
   - Lateral movement
   - Data exfiltration testing

3. **Blue Team Integration**
   - Detection capabilities assessment
   - Response effectiveness evaluation
   - Recovery process testing
   - Security control validation

4. **Red Team Reporting**
   - Attack path documentation
   - Security control bypass methods
   - Detection gaps
   - Strategic recommendations

### Security Testing Automation

Continuous security validation:

1. **Automated Security Testing**
   - CI/CD pipeline integration
   - Pre-deployment testing
   - Configuration validation
   - Compliance verification

2. **Security Unit Testing**
   - Security functionality testing
   - Boundary testing
   - Input validation testing
   - Authentication testing

3. **Security Regression Testing**
   - Change-based testing
   - Critical path testing
   - Security fix verification
   - Integration testing

4. **Continuous Security Validation**
   - Attack simulation
   - Control validation
   - Detection testing
   - Response exercise

## Security Updates

### Patch Management

Keeping systems updated:

1. **Patch Management Policy**
   - Patching priorities
   - Patching schedule
   - Patching exceptions
   - Emergency patching

2. **Patch Management Process**
   - Patch identification
   - Patch testing
   - Patch deployment
   - Patch verification

3. **Patch Deployment Methods**
   - Automated deployment
   - Staged deployment
   - Manual deployment
   - Forced deployment

4. **Patch Compliance Monitoring**
   - Patch status reporting
   - Missing patch identification
   - Vulnerability correlation
   - Compliance reporting

### Security Baseline Updates

Maintaining secure configurations:

1. **Baseline Definition**
   - Operating system baselines
   - Application baselines
   - Infrastructure baselines
   - Container baselines

2. **Baseline Management**
   - Baseline version control
   - Baseline approval process
   - Baseline implementation
   - Baseline verification

3. **Baseline Deviation Management**
   - Deviation detection
   - Deviation approval
   - Deviation documentation
   - Deviation remediation

4. **Baseline Improvement**
   - Security enhancement identification
   - Risk-based evaluation
   - Baseline update process
   - Baseline deployment

### Deprecation and End-of-Life Management

Managing technology obsolescence:

1. **Technology Lifecycle Tracking**
   - Support timeline monitoring
   - End-of-life notification
   - Risk assessment
   - Migration planning

2. **Unsupported Technology Inventory**
   - Discovery process
   - Risk classification
   - Compensating control documentation
   - Remediation prioritization

3. **Mitigation Strategies**
   - Extended support contracts
   - Isolation methods
   - Enhanced monitoring
   - Compensating controls

4. **Technology Refresh Process**
   - Replacement evaluation
   - Migration planning
   - Implementation scheduling
   - Verification testing

### Third-Party Component Updates

Managing external dependencies:

1. **Dependency Management**
   - Dependency inventory
   - Vulnerability tracking
   - Update notifications
   - Compatibility testing

2. **Dependency Update Process**
   - Update evaluation
   - Update testing
   - Update deployment
   - Functionality verification

3. **Automated Dependency Management**
   - Dependency scanning
   - Automated updates
   - Breaking change detection
   - Vulnerability alerting

4. **Supply Chain Security**
   - Dependency source verification
   - Integrity verification
   - Vendor security assessment
   - Alternative source planning

## Vendor Security

### Vendor Risk Assessment

Evaluating third-party security:

1. **Vendor Security Questionnaire**
   - Security control assessment
   - Compliance verification
   - Service delivery security
   - Security program maturity

2. **Vendor Security Documentation**
   - Security certifications
   - Audit reports
   - Penetration test results
   - Security policies

3. **Vendor Risk Scoring**
   - Inherent risk evaluation
   - Control effectiveness assessment
   - Residual risk calculation
   - Risk acceptance criteria

4. **Vendor Remediation Management**
   - Gap identification
   - Remediation planning
   - Remediation verification
   - Continuous improvement

### Vendor Contractual Requirements

Establishing security expectations:

1. **Security Requirements**
   - Minimum security controls
   - Compliance requirements
   - Service level agreements
   - Right-to-audit clauses

2. **Incident Management Requirements**
   - Incident notification
   - Incident response
   - Breach notification
   - Investigation cooperation

3. **Data Protection Requirements**
   - Data handling requirements
   - Data location restrictions
   - Data retention limitations
   - Data destruction requirements

4. **Subprocessor Management**
   - Approval requirements
   - Security flow-down
   - Assessment requirements
   - Contractual obligations

### Vendor Security Monitoring

Ongoing vendor oversight:

1. **Continuous Monitoring**
   - External security posture monitoring
   - Vulnerability tracking
   - Public security incident tracking
   - Compliance status verification

2. **Periodic Assessment**
   - Annual reassessment
   - Control validation
   - Compliance verification
   - Service delivery security review

3. **Service Level Monitoring**
   - Security-related SLA tracking
   - Incident response time monitoring
   - Remediation effectiveness
   - Security improvement progress

4. **Vendor Security Reporting**
   - Executive vendor risk summary
   - Vendor security status reporting
   - Incident notification
   - Emerging risk identification

### Vendor Offboarding

Securely terminating vendor relationships:

1. **Offboarding Planning**
   - Data inventory
   - Access inventory
   - Transition planning
   - Security verification

2. **Data Return and Destruction**
   - Data return process
   - Data destruction requirements
   - Destruction verification
   - Certification of destruction

3. **Access Termination**
   - Account deactivation
   - Credential revocation
   - VPN/network access termination
   - Physical access revocation

4. **Post-Termination Security**
   - Confidentiality requirements
   - Intellectual property protection
   - Return of security materials
   - Non-disclosure agreement enforcement

## Physical Security

### Facility Security

Securing physical locations:

1. **Physical Access Controls**
   - Access card systems
   - Biometric access
   - Visitor management
   - Physical access logs

2. **Environmental Security**
   - Fire protection
   - Water damage protection
   - Temperature and humidity control
   - Power protection

3. **Monitoring and Surveillance**
   - CCTV coverage
   - Security guard services
   - Intrusion detection
   - Alarm systems

4. **Physical Security Zones**
   - Public areas
   - Office areas
   - Restricted areas
   - High-security areas

### Data Center Security

Protecting infrastructure facilities:

1. **Data Center Access Control**
   - Multi-factor authentication
   - Mantrap entrances
   - Access logging
   - Escort requirements

2. **Data Center Monitoring**
   - 24/7 monitoring
   - Environmental monitoring
   - Security monitoring
   - Operational monitoring

3. **Data Center Resilience**
   - Redundant power
   - Redundant cooling
   - Fire suppression
   - Structural protection

4. **Data Center Compliance**
   - SOC 2 compliance
   - ISO 27001 certification
   - Uptime Institute certification
   - Industry-specific compliance

### Asset Management

Tracking physical security assets:

1. **Asset Inventory**
   - Hardware asset tracking
   - Software asset tracking
   - Media tracking
   - Documentation

2. **Asset Classification**
   - Criticality assessment
   - Security requirements
   - Handling requirements
   - Lifecycle stage

3. **Asset Handling**
   - Asset acquisition
   - Asset deployment
   - Asset maintenance
   - Asset disposal

4. **Asset Disposal**
   - Data sanitization
   - Physical destruction
   - Disposal verification
   - Chain of custody

### Remote Work Security

Securing distributed work environments:

1. **Remote Work Policy**
   - Acceptable use guidelines
   - Security requirements
   - Equipment requirements
   - Data handling requirements

2. **Remote Device Security**
   - Device encryption
   - Security configurations
   - Patch management
   - Anti-malware protection

3. **Remote Access Security**
   - VPN requirements
   - Multi-factor authentication
   - Network security monitoring
   - Access restrictions

4. **Remote Work Training**
   - Security awareness training
   - Physical security guidance
   - Data protection training
   - Incident reporting procedures

---

**Document Information:**
- Version: 2.0
- Last Updated: March 25, 2025
- Contact: security@tunemantra.com

---

## documentation/technical/platforms/mobile-application.md

# Mobile Application Documentation

<div align="center">
  <img src="../../diagrams/mobile-app-header.svg" alt="TuneMantra Mobile Application" width="800"/>
</div>

## Introduction

The TuneMantra Mobile Application extends the platform's capabilities to iOS and Android devices, enabling artists, labels, and rights holders to manage their music catalogs, track performance, and handle royalties on the go. This document provides comprehensive details on the mobile application's architecture, features, and implementation.

## Table of Contents

- [Platform Overview](#platform-overview)
- [Architecture](#architecture)
- [Feature Modules](#feature-modules)
- [User Interface](#user-interface)
- [Data Synchronization](#data-synchronization)
- [Offline Capabilities](#offline-capabilities)
- [Push Notifications](#push-notifications)
- [Security Features](#security-features)
- [Performance Optimization](#performance-optimization)
- [Deployment Workflow](#deployment-workflow)
- [Analytics and Monitoring](#analytics-and-monitoring)
- [QA and Testing](#qa-and-testing)

## Platform Overview

### Supported Platforms

TuneMantra's mobile presence spans multiple platforms:

1. **iOS Application**
   - iOS 14.0+
   - iPhone optimization
   - iPad compatibility
   - macOS Catalyst support
   - Apple Watch companion app

2. **Android Application**
   - Android 7.0+ (API level 24)
   - Phone optimization
   - Tablet support
   - Chrome OS compatibility
   - Android Auto integration

3. **Progressive Web App**
   - Mobile browser support
   - Installation capability
   - Offline functionality
   - Push notification support
   - Responsiveness across devices

4. **Platform Extensions**
   - App Clips (iOS)
   - Instant Apps (Android)
   - Widgets for both platforms
   - Voice assistant integrations
   - Wearable companions

### Target Users

The mobile app is designed for several user types:

1. **Artists**
   - Independent musicians
   - Signed artists
   - Artist managers
   - Band members
   - Songwriters and composers

2. **Label Representatives**
   - Label executives
   - A&R professionals
   - Marketing teams
   - Label administrators
   - Catalog managers

3. **Rights Holders**
   - Publishers
   - Investors
   - Estate managers
   - Licensing professionals
   - Collection agency representatives

4. **Support Users**
   - TuneMantra support staff
   - Artist support teams
   - Financial administrators
   - Legal representatives
   - Platform administrators

## Architecture

### Technology Stack

The mobile application is built using modern technologies:

1. **Core Framework**
   - React Native (cross-platform)
   - TypeScript for type safety
   - Redux for state management
   - React Navigation for routing
   - Native modules for platform-specific features

2. **UI Components**
   - Customized component library
   - Platform-specific design adaptations
   - Responsive layout system
   - Animation framework
   - Accessibility-enhanced components

3. **Network Layer**
   - RESTful API client
   - GraphQL integration
   - WebSocket for real-time features
   - Offline request queueing
   - JWT authentication

4. **Native Integrations**
   - Camera access for scanning
   - Audio playback engine
   - File system interaction
   - Biometric authentication
   - Geolocation services

### Application Structure

<div align="center">
  <img src="../../diagrams/mobile-app-architecture.svg" alt="Mobile App Architecture" width="700"/>
</div>

The application follows a modular architecture:

1. **Core Layer**
   - Application bootstrapping
   - Configuration management
   - Navigation infrastructure
   - Theme management
   - Localization system

2. **Feature Modules**
   - Catalog management
   - Analytics and reporting
   - Royalty management
   - Rights management
   - User administration

3. **Service Layer**
   - API services
   - Authentication service
   - Notification service
   - Storage service
   - Analytics service

4. **Platform Adaptation Layer**
   - Platform-specific implementations
   - Device feature detection
   - Platform UI adaptations
   - Native module bridges
   - Performance optimizations

### State Management

Managing application state efficiently:

1. **Redux Implementation**
   - Domain-based store structure
   - Middleware configuration
   - Action creators
   - Selectors
   - Immutable state pattern

2. **Persistence Strategy**
   - Selective state persistence
   - Encryption for sensitive data
   - Migration handling
   - Versioning support
   - Storage optimization

3. **Real-time Synchronization**
   - WebSocket integration
   - State reconciliation
   - Conflict resolution
   - Optimistic updates
   - Recovery mechanisms

4. **Performance Considerations**
   - Selective rendering
   - Memoization patterns
   - Normalized state shape
   - Efficient selectors
   - Middleware optimizations

## Feature Modules

### Catalog Management

Mobile-optimized catalog management capabilities:

1. **Browse Interface**
   - Grid and list views
   - Advanced filtering
   - Search functionality
   - Sorting options
   - Batch selection

2. **Track Management**
   - Track metadata viewing
   - Basic metadata editing
   - Audio preview
   - Track grouping
   - Status monitoring

3. **Release Management**
   - Release overview
   - Track listing
   - Release status tracking
   - Cover art display
   - Release timeline

4. **Upload Capabilities**
   - Photo capture for artwork
   - Audio recording for demos
   - Document scanning
   - Cloud storage integration
   - Upload queue management

### Analytics Dashboard

Performance tracking on mobile devices:

1. **Overview Dashboard**
   - Key performance indicators
   - Recent activity summary
   - Trend visualization
   - Performance alerts
   - Quick action buttons

2. **Track Performance**
   - Stream count tracking
   - Platform breakdown
   - Historical comparison
   - Geographic distribution
   - Listener demographics

3. **Revenue Tracking**
   - Revenue summary
   - Payment status
   - Earning trends
   - Platform contribution
   - Currency breakdown

4. **Custom Reporting**
   - Report template selection
   - Custom date ranges
   - Parameter configuration
   - Report sharing
   - Scheduled report access

### Financial Management

Managing financial aspects on mobile:

1. **Payment Dashboard**
   - Payment summary
   - Upcoming payments
   - Payment history
   - Withdrawal capabilities
   - Balance tracking

2. **Withdrawal Interface**
   - Withdrawal request creation
   - Payment method selection
   - Amount configuration
   - Status tracking
   - Payment history

3. **Split Management**
   - Split overview
   - Collaborator listing
   - Payment verification
   - Split agreement access
   - Contact capabilities

4. **Financial Reporting**
   - Statement access
   - Export options
   - Tax document access
   - Financial calendar
   - Notification settings

### Distribution Management

Control over distribution from mobile devices:

1. **Distribution Status**
   - Platform availability
   - Distribution progress
   - Error notifications
   - Take-down status
   - Update tracking

2. **Platform Management**
   - Platform selection
   - Territory configuration
   - Release date management
   - Pricing controls
   - Feature opt-in

3. **Schedule Management**
   - Release calendar
   - Scheduled updates
   - Timeline visualization
   - Schedule modification
   - Notification configuration

4. **Issue Resolution**
   - Error notification
   - Guided troubleshooting
   - Re-delivery options
   - Support ticket creation
   - Resolution tracking

### Rights Management

Managing rights on mobile devices:

1. **Ownership Dashboard**
   - Rights overview
   - Share visualization
   - Verification status
   - Claim monitoring
   - Dispute tracking

2. **Licensing Interface**
   - License request review
   - Basic approval workflow
   - License agreement access
   - License status tracking
   - Communication with requestors

3. **Blockchain Integration**
   - Registration status
   - Transaction history
   - Ownership verification
   - Token management
   - Wallet connection

4. **Documentation Access**
   - Contract viewing
   - Document signing
   - Document organization
   - Share documentation
   - Version history

## User Interface

### Design System

Consistent design principles across the application:

1. **Visual Language**
   - Typography system
   - Color palette
   - Iconography
   - Spacing system
   - Motion design

2. **Component Library**
   - Form elements
   - Data visualization
   - Navigation components
   - Cards and containers
   - Feedback elements

3. **Platform Adaptations**
   - iOS-specific components
   - Android material design integration
   - Platform-specific interactions
   - Gesture support
   - Hardware button handling

4. **Accessibility Features**
   - Screen reader support
   - High contrast mode
   - Large text compatibility
   - Reduced motion option
   - Voice control integration

### Key Screens

Primary user interface experiences:

1. **Dashboard**
   - Personalized overview
   - Activity feed
   - Performance snapshot
   - Quick actions
   - Notification center

2. **Catalog Explorer**
   - Catalog navigation
   - Detail views
   - Action menus
   - Batch operation interface
   - Filter and search interface

3. **Analytics Views**
   - Performance graphs
   - Data tables
   - Map visualizations
   - Comparative analysis
   - Trend indicators

4. **Profile and Settings**
   - Account management
   - Preference configuration
   - Security settings
   - Notification preferences
   - Support access

### Interaction Patterns

User interaction design standards:

1. **Navigation System**
   - Tab-based primary navigation
   - Hierarchical drill-down
   - Modal dialogs
   - Side menu for secondary functions
   - Deep linking support

2. **Gesture Controls**
   - Swipe actions
   - Pull-to-refresh
   - Pinch-to-zoom
   - Long press menus
   - Multi-touch support

3. **Form Interactions**
   - Inline validation
   - Progressive disclosure
   - Contextual keyboards
   - Auto-completion
   - Smart defaults

4. **Feedback Systems**
   - Loading indicators
   - Success confirmations
   - Error handling
   - Instructional tooltips
   - Empty states

## Data Synchronization

### Synchronization Architecture

Keeping mobile and server data consistent:

1. **Sync Protocol**
   - Efficient data transfer
   - Delta updates
   - Priority-based syncing
   - Bandwidth optimization
   - Battery usage consideration

2. **Conflict Resolution**
   - Timestamp-based resolution
   - Merge strategies
   - User-guided resolution
   - Conflict notification
   - History preservation

3. **Background Synchronization**
   - Periodic background sync
   - Connectivity-aware scheduling
   - Battery-aware operation
   - Notification integration
   - Sync status reporting

4. **Initial Data Loading**
   - Progressive data loading
   - Essential data prioritization
   - Lazy loading strategies
   - Preloading optimization
   - Cache warming

### Offline Data Management

Handling data during offline operation:

1. **Offline Storage**
   - SQLite database
   - Secure storage for sensitive data
   - File caching
   - Storage quotas
   - Cleanup policies

2. **Offline Mutations**
   - Offline action queueing
   - Operation retry logic
   - Dependency tracking
   - Conflict detection
   - Status indication

3. **Data Persistence Strategy**
   - Entity prioritization
   - Time-based expiration
   - Usage-based retention
   - Size-based limitations
   - Critical data protection

4. **Recovery Mechanisms**
   - Data integrity checking
   - Self-healing capabilities
   - Incremental recovery
   - Full resynchronization
   - User-initiated reset

## Offline Capabilities

### Offline-First Design

Ensuring functionality without connectivity:

1. **Core Offline Features**
   - Catalog browsing
   - Basic analytics review
   - Content preview
   - Data entry and editing
   - Documentation access

2. **Data Availability**
   - Recently accessed content
   - User-prioritized content
   - Critical reference data
   - Pending work items
   - User preferences

3. **User Interface Adaptation**
   - Offline mode indicators
   - Feature availability messaging
   - Graceful degradation
   - Operation queuing interfaces
   - Reconnection handling

4. **Storage Optimization**
   - Smart caching strategies
   - Resource compression
   - Storage usage monitoring
   - Cache eviction policies
   - User-controlled cache clearing

### Offline Workflow Support

Supporting key workflows without connectivity:

1. **Content Creation**
   - Offline draft creation
   - Media capture and storage
   - Metadata editing
   - Work queue management
   - Pending upload indication

2. **Data Analysis**
   - Cached report viewing
   - Limited historical data
   - Pre-generated insights
   - Visualizations from cached data
   - Export of offline reports

3. **Approval Workflows**
   - Offline decision recording
   - Approval queue management
   - Policy-based auto decisions
   - Pending action indicators
   - Conflict detection

4. **Documentation Management**
   - Offline document access
   - Form completion
   - Electronic signature capture
   - Document markup
   - Sync queue management

## Push Notifications

### Notification Types

Categories of mobile alerts:

1. **Operational Notifications**
   - Distribution status updates
   - Processing completions
   - Error alerts
   - System maintenance notices
   - Platform status changes

2. **Financial Notifications**
   - Payment receipts
   - Threshold alerts
   - Statement availability
   - Withdrawal status updates
   - Royalty calculation completions

3. **Engagement Notifications**
   - Performance milestones
   - Trending content alerts
   - New opportunity notifications
   - Recommendation alerts
   - Feature usage suggestions

4. **Administrative Notifications**
   - Account status changes
   - Permission updates
   - Security alerts
   - Document review requests
   - Task assignments

### Notification Management

Handling notifications efficiently:

1. **Delivery System**
   - Firebase Cloud Messaging (Android)
   - Apple Push Notification Service (iOS)
   - Web Push API (PWA)
   - In-app messaging
   - Email fallback

2. **User Preferences**
   - Granular notification controls
   - Category-based settings
   - Time-based quiet periods
   - Priority settings
   - Channel preferences

3. **Notification Center**
   - Centralized notification history
   - Read/unread status
   - Actionable notifications
   - Grouping and categorization
   - Archiving capabilities

4. **Analytics Integration**
   - Delivery tracking
   - Engagement measurement
   - Effectiveness analysis
   - A/B testing support
   - Optimization insights

### Rich Notifications

Enhanced notification experiences:

1. **Interactive Elements**
   - Action buttons
   - Quick reply functionality
   - Progress indicators
   - Expandable content
   - Media previews

2. **Content Customization**
   - Dynamic content generation
   - Personalization
   - Localization
   - Contextual relevance
   - Brand consistency

3. **Deep Linking**
   - Direct navigation to relevant screens
   - Context preservation
   - Parameter passing
   - State restoration
   - Back navigation handling

4. **Multi-device Coordination**
   - Cross-device notification status
   - Action synchronization
   - Device-appropriate content
   - Read status synchronization
   - Notification silencing logic

## Security Features

### Authentication

Secure access on mobile devices:

1. **Login Methods**
   - Email/password authentication
   - Single Sign-On integration
   - Biometric authentication
   - Two-factor authentication
   - Social login options

2. **Session Management**
   - Secure token storage
   - Session timeout controls
   - Multiple device awareness
   - Suspicious login detection
   - Remote session termination

3. **Credential Management**
   - Secure credential storage
   - Automatic fill support
   - Credential update handling
   - Password strength enforcement
   - Password reset workflow

4. **Authentication UX**
   - Streamlined login process
   - Biometric promotion
   - Login assistance
   - Error messaging
   - Account recovery

### Data Protection

Securing user and business data:

1. **Local Encryption**
   - Encrypted database
   - File-level encryption
   - Keychain/Keystore integration
   - Encryption key management
   - Secure deletion

2. **Secure Communication**
   - Certificate pinning
   - TLS configuration
   - API security
   - WebSocket security
   - Man-in-the-middle protection

3. **Content Security**
   - DRM integration for premium content
   - Screenshot prevention
   - Secure playback
   - Watermarking
   - Expiring content

4. **Sensitive Data Handling**
   - PII protection
   - Financial data security
   - Classification-based protection
   - Data minimization
   - Secure data sharing

### Security Monitoring

Ongoing security assurance:

1. **Threat Detection**
   - Jailbreak/root detection
   - Tamper detection
   - Unusual behavior monitoring
   - API abuse detection
   - Vulnerability scanning

2. **Security Reporting**
   - Security event logging
   - Anomaly reporting
   - Compliance monitoring
   - Audit trail
   - Security metrics

3. **Incident Response**
   - Automated countermeasures
   - Remote kill switch capabilities
   - Account protection measures
   - Communication protocols
   - Recovery procedures

4. **Privacy Controls**
   - Permissions management
   - Data access transparency
   - User consent management
   - Data retention controls
   - Data export capabilities

## Performance Optimization

### Rendering Performance

Ensuring smooth user interface:

1. **UI Optimization**
   - Component memoization
   - List virtualization
   - Lazy loading
   - Incremental rendering
   - Offscreen rendering management

2. **Animation Performance**
   - Hardware acceleration
   - Animation throttling
   - Frame rate management
   - Animation simplification
   - Gesture response optimization

3. **Asset Management**
   - Image optimization
   - Resolution-appropriate assets
   - Progressive loading
   - On-demand resource loading
   - Cache management

4. **Responsiveness**
   - Main thread offloading
   - Background processing
   - Interaction prioritization
   - Input handling optimization
   - Render throttling

### Network Optimization

Efficient data transfer:

1. **Request Management**
   - Request batching
   - Request prioritization
   - Cancellation handling
   - Retry strategies
   - Connection pooling

2. **Data Transfer Efficiency**
   - Compression
   - Delta updates
   - GraphQL optimization
   - JSON minimization
   - Binary protocols where appropriate

3. **Caching Strategy**
   - HTTP caching
   - Application-level caching
   - Cache invalidation
   - Stale-while-revalidate pattern
   - Prefetching for critical paths

4. **Connection Handling**
   - Connection type detection
   - Adaptive quality
   - Offline fallback
   - Low-bandwidth mode
   - Background transfer scheduling

### Memory Management

Controlling application memory usage:

1. **Resource Management**
   - Image memory management
   - Audio/video buffer control
   - Cache size limitations
   - Resource recycling
   - Garbage collection optimization

2. **State Management**
   - Selective persistence
   - State size monitoring
   - Memory-efficient data structures
   - Object pooling
   - Reference management

3. **Large Dataset Handling**
   - Pagination
   - Virtual scrolling
   - On-demand loading
   - Data windowing
   - Incremental processing

4. **Memory Monitoring**
   - Memory usage tracking
   - Leak detection
   - Memory pressure handling
   - Out-of-memory recovery
   - Performance metrics

### Battery Optimization

Minimizing energy impact:

1. **Processing Efficiency**
   - Batch processing
   - Operation scheduling
   - Algorithm optimization
   - Computation distribution
   - Background task management

2. **Network Efficiency**
   - Connection consolidation
   - Transfer scheduling
   - Payload optimization
   - Radio state management
   - Background transfer limitations

3. **Location and Sensor Use**
   - Location precision selection
   - Sensor sampling optimization
   - Geofencing instead of tracking
   - Batched sensor reading
   - Conditional activation

4. **Background Activity**
   - Background execution limitations
   - Task prioritization
   - Wake lock management
   - Background refresh optimization
   - Energy-aware scheduling

## Deployment Workflow

### Build Configuration

Managing application builds:

1. **Build Variants**
   - Development build
   - Staging build
   - Production build
   - QA build
   - Feature demonstration build

2. **Environment Configuration**
   - API endpoint configuration
   - Feature flag management
   - Third-party service keys
   - Analytics configuration
   - Logging levels

3. **Code Signing**
   - Certificate management
   - Signing identity configuration
   - Provisioning profile handling
   - Keystore management
   - Code signing automation

4. **Build Customization**
   - White labeling capabilities
   - Resource customization
   - Feature toggles
   - Distribution channels
   - Partner customizations

### Continuous Integration

Automated build and test processes:

1. **CI Pipeline**
   - Source control integration
   - Automated build triggers
   - Dependency management
   - Build caching
   - Parallel execution

2. **Automated Testing**
   - Unit test execution
   - Integration test automation
   - UI test automation
   - Screenshot testing
   - Performance testing

3. **Code Quality**
   - Static analysis
   - Code linting
   - Type checking
   - Security scanning
   - Dependency auditing

4. **Build Artifacts**
   - IPA generation
   - APK/AAB packaging
   - Symbol file management
   - Versioning
   - Release notes generation

### App Distribution

Releasing applications to users:

1. **Internal Distribution**
   - App Center distribution
   - TestFlight delivery
   - Firebase App Distribution
   - Enterprise deployment
   - Device management integration

2. **Public Distribution**
   - App Store submission
   - Google Play deployment
   - Review process management
   - Phased rollout
   - Category and metadata management

3. **Version Management**
   - Semantic versioning
   - Update notifications
   - Force update mechanism
   - Version compatibility
   - Legacy version support

4. **Release Process**
   - Release candidate preparation
   - Approval workflow
   - Go/no-go decision process
   - Release announcement
   - Post-release monitoring

## Analytics and Monitoring

### User Analytics

Understanding user behavior:

1. **Usage Tracking**
   - Screen analytics
   - Feature engagement
   - User flow analysis
   - Session metrics
   - Retention analysis

2. **Behavior Analysis**
   - Funnel analysis
   - Event sequence analysis
   - Cohort analysis
   - Segment comparison
   - Usage patterns

3. **Performance Measurement**
   - Screen load times
   - Interaction responsiveness
   - API request performance
   - Synchronization timing
   - Battery impact

4. **User Feedback Integration**
   - In-app feedback collection
   - User satisfaction measurement
   - Feature request tracking
   - User interview recruitment
   - A/B test participation

### Crash Reporting

Managing application stability:

1. **Crash Detection**
   - Exception tracking
   - Signal handler integration
   - Native crash capture
   - ANR monitoring (Android)
   - Watchdog monitoring

2. **Crash Analytics**
   - Stack trace analysis
   - Affected user tracking
   - Device/OS correlation
   - Trend analysis
   - Impact assessment

3. **Issue Management**
   - Issue categorization
   - Priority assignment
   - Developer assignment
   - Status tracking
   - Regression monitoring

4. **User Communication**
   - Crash apology
   - Recovery guidance
   - Alternative workflow suggestion
   - Update notifications
   - Compensation mechanisms

### Performance Monitoring

Tracking application performance:

1. **Metrics Collection**
   - Startup time
   - Frame rate
   - Memory usage
   - API response time
   - Battery consumption

2. **Performance Alerting**
   - Threshold-based alerts
   - Trend-based warnings
   - Regression detection
   - Outlier identification
   - User impact estimation

3. **User Experience Correlation**
   - Performance to engagement correlation
   - Performance to retention impact
   - Revenue impact analysis
   - Satisfaction correlation
   - Abandonment analysis

4. **Optimization Targeting**
   - Hotspot identification
   - Opportunity sizing
   - Device-specific targeting
   - OS version correlation
   - Network condition impact

## QA and Testing

### Test Strategy

Comprehensive quality assurance approach:

1. **Test Types**
   - Unit testing
   - Integration testing
   - UI automation testing
   - Manual testing
   - Beta testing

2. **Test Coverage**
   - Core functionality
   - Edge cases
   - Error handling
   - Platform-specific features
   - Backward compatibility

3. **Test Environments**
   - Device lab
   - Emulator/simulator testing
   - Cloud testing services
   - Remote device testing
   - Crowd testing

4. **Test Data Management**
   - Test account management
   - Data generation
   - Data reset capabilities
   - Realistic data simulation
   - Edge case data sets

### Automated Testing

Efficiency through automation:

1. **Unit Testing**
   - Component testing
   - Service testing
   - Utility function testing
   - Redux testing
   - Snapshot testing

2. **Integration Testing**
   - API integration testing
   - Service interaction testing
   - Data flow verification
   - State management testing
   - Event handling testing

3. **UI Automation**
   - Screen navigation testing
   - Component interaction testing
   - Visual regression testing
   - Accessibility testing
   - Localization testing

4. **Performance Testing**
   - Load time testing
   - Frame rate testing
   - Memory leak detection
   - Battery impact testing
   - Network condition simulation

### QA Processes

Quality assurance workflows:

1. **Bug Management**
   - Issue tracking
   - Reproducibility documentation
   - Severity classification
   - Priority assignment
   - Regression verification

2. **Release Validation**
   - Release candidate testing
   - Smoke testing
   - Regression testing
   - Release criteria verification
   - Go/no-go decision support

3. **Continuous Quality**
   - Automated quality gates
   - Code review process
   - Design review process
   - Accessibility validation
   - Security review

4. **User Feedback Integration**
   - Beta tester management
   - Feedback collection
   - Issue triage
   - Prioritization
   - Validation with users

---

**Document Information:**
- Version: 1.0
- Last Updated: March 25, 2025
- Contact: mobile-team@tunemantra.com

---

## documentation/technical/platforms/multi-tenant-system.md

# Multi-tenant Sub-label Management System

<div align="center">
  <img src="../../diagrams/multi-tenant-header.svg" alt="TuneMantra Multi-tenant Management" width="800"/>
</div>

## Introduction

The TuneMantra Multi-tenant Sub-label Management System provides a comprehensive hierarchical structure for music labels to create, manage, and oversee sub-labels within their organization. This feature enables major labels to delegate authority, manage catalog segmentation, and enforce fine-grained access control across their entire music business operation while maintaining centralized oversight and reporting.

## Table of Contents

- [System Overview](#system-overview)
- [Architecture](#architecture)
- [Hierarchy Management](#hierarchy-management)
- [Permission System](#permission-system)
- [Revenue Management](#revenue-management)
- [Analytics & Reporting](#analytics--reporting)
- [Security Model](#security-model)
- [Audit & Compliance](#audit--compliance)
- [User Experience](#user-experience)
- [Integration Points](#integration-points)
- [Implementation Guidelines](#implementation-guidelines)
- [API Reference](#api-reference)

## System Overview

### Core Capabilities

The Multi-tenant Sub-label Management System offers the following key capabilities:

1. **Hierarchical Label Structure**
   - Unlimited hierarchy depth for label organization
   - Customizable sub-label configuration
   - Independent branding and identity for each sub-label
   - Inheritance of parent label policies and settings
   - Unified catalog management across all levels

2. **Role-Based Access Control**
   - Fine-grained permission management
   - Role templates for quick user setup
   - Permission inheritance through label hierarchy
   - Temporary access delegation
   - Emergency access protocols

3. **Financial Management**
   - Multi-level revenue sharing configuration
   - Automated royalty calculations across hierarchy
   - Custom payment schedules per label level
   - Financial reporting at any hierarchy node
   - Consolidated billing and statements

4. **Catalog Segmentation**
   - Genre-based label divisions
   - Artist roster management by sub-label
   - Release catalog organization
   - Territorial rights management
   - Content ownership tracking

### Business Value

The multi-tenant structure delivers significant business value to music labels:

1. **Operational Efficiency**
   - Delegated administration reduces bottlenecks
   - Specialized teams for different catalog segments
   - Streamlined approval workflows
   - Resource allocation optimization
   - Reduced administrative overhead

2. **Strategic Growth**
   - Easy expansion into new music genres
   - Acquisition integration framework
   - Brand diversification support
   - Market-specific label creation
   - Artist development programs

3. **Enhanced Control**
   - Centralized policy enforcement
   - Comprehensive audit trails
   - Real-time activity monitoring
   - Financial oversight at all levels
   - Compliance management across organization

4. **Improved Analytics**
   - Cross-label performance comparison
   - Aggregated reporting capabilities
   - Market segment analysis
   - Resource utilization metrics
   - ROI tracking by label division

## Architecture

### System Design

<div align="center">
  <img src="../../diagrams/multi-tenant-architecture.svg" alt="Multi-tenant Architecture" width="700"/>
</div>

The Multi-tenant Sub-label Management System uses a sophisticated architecture:

1. **Core Components**
   - Tenant Manager - Central authority management
   - Hierarchy Engine - Relationship management
   - Permission Service - Access control enforcement
   - Inheritance Resolver - Policy propagation
   - Tenant Isolation Service - Data separation

2. **Data Architecture**
   - Multi-tenant database schema
   - Hierarchical data structure
   - Cross-tenant reference management
   - Tenant-aware query execution
   - Isolated data storage with shared schema

3. **Integration Layer**
   - Identity management integration
   - Financial system connectors
   - Analytics data pipeline
   - Catalog management interface
   - Distribution platform integration

4. **Service Interface**
   - RESTful API for tenant management
   - GraphQL for hierarchy queries
   - WebSocket for real-time updates
   - Event-driven notification system
   - Batch processing for high-volume operations

### Tenant Isolation

The system ensures proper tenant isolation:

1. **Data Segregation**
   - Row-level security implementation
   - Tenant-specific encryption keys
   - Query filtering by tenant context
   - Access pattern monitoring
   - Cross-tenant access controls

2. **Application Isolation**
   - Multi-tenant aware authentication
   - Tenant context propagation
   - Session management
   - Request routing
   - Resource allocation by tenant

3. **Security Boundaries**
   - Hierarchical permission inheritance
   - Strict cross-tenant access policies
   - Audit logging for boundary crossings
   - Sensitive data isolation
   - Configurable isolation policies

4. **Shared Infrastructure**
   - Resource pools with tenant quotas
   - Shared service layer with tenant context
   - Common codebase with tenant-specific configuration
   - Centralized monitoring
   - Consolidated maintenance

### Tenant Hierarchy Model

The system implements a flexible hierarchy model:

1. **Entity Relationships**
   - Parent-child label relationships
   - Many-to-one hierarchical structure
   - Inheritance paths for policies
   - Cross-hierarchy references
   - Logical and organizational groupings

2. **Hierarchy Rules**
   - Maximum depth configuration
   - Circular reference prevention
   - Mandatory parent-child validation
   - Hierarchy constraints enforcement
   - Path traversal optimization

3. **Identification System**
   - Globally unique identifiers
   - Hierarchical path encoding
   - Friendly name mapping
   - Namespace management
   - ID resolution services

4. **Transition Management**
   - Hierarchy restructuring
   - Tenant migration
   - Parent reassignment
   - Orphan prevention
   - Historical relationship tracking

## Hierarchy Management

### Sub-label Creation

The process for creating new sub-labels:

1. **Creation Flow**
   - Sub-label template selection
   - Configuration wizard
   - Parent label approval workflow
   - Initial administrator assignment
   - Resource allocation

2. **Initial Setup**
   - Branding configuration
   - Default user roles creation
   - System integration configuration
   - Financial account setup
   - Communication settings

3. **Validation Process**
   - Name uniqueness verification
   - Hierarchy position validation
   - Permission assignment check
   - Resource availability confirmation
   - Compliance verification

4. **Post-Creation**
   - Notification to stakeholders
   - Onboarding workflow initiation
   - Dashboard provisioning
   - Access credential generation
   - Documentation provision

### Management Operations

Key operations for maintaining the label hierarchy:

1. **Sub-label Configuration**
   - Label profile management
   - Contact information
   - Visual identity settings
   - Default distribution platforms
   - Default revenue splits

2. **Structural Changes**
   - Sub-label transfer
   - Hierarchy reorganization
   - Merger of sub-labels
   - Sub-label archiving
   - Catalog reassignment

3. **Policy Management**
   - Default permission templates
   - Content approval workflows
   - Financial thresholds
   - Distribution requirements
   - Reporting schedules

4. **Administration**
   - Administrator assignment
   - Bulk user management
   - System notification configuration
   - Quota adjustment
   - Feature enablement

### Template System

Using templates for efficient sub-label setup:

1. **Template Types**
   - Genre-specific sub-label templates
   - Regional sub-label templates
   - Artist development label templates
   - Acquisition integration templates
   - Specialty distribution templates

2. **Template Components**
   - Role configuration
   - Default permission sets
   - Financial setup
   - Workflow definitions
   - Branding guidelines

3. **Customization Options**
   - Template parameter overrides
   - Selective component application
   - Custom extension points
   - Parent label overrides
   - Mandatory vs. optional settings

4. **Template Management**
   - Template version control
   - Template sharing
   - Usage analytics
   - Template effectiveness metrics
   - Template library

## Permission System

### Role-Based Access Control

Sophisticated permissions model:

1. **Role Definition**
   - Predefined system roles
   - Custom role creation
   - Role hierarchy
   - Role composition (role inheritance)
   - Time-limited roles

2. **Permission Assignment**
   - Direct permission assignment
   - Role-based permission bundles
   - Context-specific permissions
   - Temporary permission elevation
   - Emergency access protocols

3. **Access Scope**
   - Label-specific access
   - Catalog segment access
   - Artist roster access
   - Financial data access
   - Analytic data access

4. **Permission Inheritance**
   - Downward permission propagation
   - Override mechanisms
   - Inheritance blocking
   - Explicit vs. implicit permissions
   - Permission resolution rules

### Common Permission Sets

Standard permission configurations:

1. **Label Administrator**
   - Full control of label settings
   - User management
   - Financial overview access
   - Approval authority
   - System configuration

2. **Catalog Manager**
   - Release management
   - Metadata editing
   - Distribution control
   - Content upload
   - Basic analytics access

3. **Financial Manager**
   - Revenue data access
   - Payment processing
   - Statement generation
   - Financial reporting
   - Split configuration

4. **Marketing Role**
   - Promotional content management
   - Basic catalog access
   - Analytics viewing
   - Playlist management
   - Marketing performance data

5. **Artist Manager**
   - Artist profile management
   - Release scheduling
   - Performance tracking
   - Communication management
   - Limited financial access

### Cross-Label Access

Managing access across label boundaries:

1. **Global Roles**
   - Super-admin access
   - Cross-label analysts
   - Financial controllers
   - System administrators
   - Compliance officers

2. **Delegation Mechanisms**
   - Temporary access grants
   - Project-based collaboration
   - Shared roster management
   - Cross-label release collaboration
   - Joint venture handling

3. **Access Request Workflow**
   - Request submission
   - Approval routing
   - Justification requirements
   - Time-limited access grants
   - Usage tracking

4. **Boundary Controls**
   - Data export limitations
   - Sensitive information masking
   - Activity monitoring
   - Rate limiting
   - Access revocation triggers

## Revenue Management

### Financial Hierarchy

Managing finances across the label structure:

1. **Account Structure**
   - Parent-child account relationships
   - Revenue collection accounts
   - Distribution accounts
   - Reserve accounts
   - Operating expense accounts

2. **Revenue Flow**
   - Upstream revenue collection
   - Hierarchical distribution
   - Split calculations
   - Fee deductions
   - Payment disbursement

3. **Financial Controls**
   - Approval thresholds
   - Spending limits
   - Payment authorization
   - Financial reporting requirements
   - Compliance checks

4. **Balance Management**
   - Minimum balance requirements
   - Overdraft protection
   - Automatic transfers
   - Balance alerts
   - Interest allocation

### Revenue Sharing Configuration

Configuring revenue division across labels:

1. **Split Hierarchy**
   - Parent label percentage
   - Sub-label percentage
   - Artist share configuration
   - Service fee structure
   - Platform fee handling

2. **Split Types**
   - Fixed percentage splits
   - Tiered revenue splits
   - Time-based split adjustments
   - Performance-based splits
   - Overhead contribution models

3. **Special Arrangements**
   - Joint venture accounting
   - Acquisition earn-out models
   - Development funding recoupment
   - Advance repayment tracking
   - Marketing contribution accounting

4. **Split Management**
   - Split template creation
   - Bulk update capabilities
   - Historical split tracking
   - Split auditing
   - Split modeling and simulation

### Financial Reporting

Comprehensive financial visibility:

1. **Report Types**
   - Label revenue summary
   - Hierarchical revenue breakdown
   - Profitability analysis
   - Platform performance comparison
   - Period-over-period comparison

2. **Consolidation Levels**
   - Individual label reporting
   - Sub-label rollup
   - Complete hierarchy view
   - Custom grouping
   - Division-level reporting

3. **Report Access**
   - Role-based report availability
   - Custom report creation
   - Scheduled report delivery
   - Interactive dashboards
   - Export capabilities

4. **Financial Analytics**
   - Trend analysis
   - Revenue forecasting
   - Expense tracking
   - ROI calculation
   - Business unit comparison

## Analytics & Reporting

### Multi-level Analytics

Analyzing performance across the hierarchy:

1. **Aggregation Levels**
   - Individual track performance
   - Release performance
   - Artist performance
   - Label performance
   - Parent label consolidated view

2. **Cross-label Analysis**
   - Label comparison
   - Genre performance
   - Territory analysis
   - Platform effectiveness
   - Marketing campaign impact

3. **Performance Metrics**
   - Stream counts
   - Revenue generation
   - Audience growth
   - Market share
   - Artist development indicators

4. **Time-based Analysis**
   - Trend identification
   - Seasonal patterns
   - Year-over-year comparison
   - Release cycle analysis
   - Long-term catalog performance

### Dashboard System

Custom visualization for different roles:

1. **Executive Dashboard**
   - High-level performance indicators
   - Critical alerts
   - Strategic overview
   - Comparative analysis
   - Goal tracking

2. **Label Manager Dashboard**
   - Label-specific performance
   - Catalog management
   - Team productivity
   - Release planning
   - Financial snapshot

3. **Sub-label Dashboard**
   - Sub-label KPIs
   - Artist roster performance
   - Release timeline
   - Marketing effectiveness
   - Revenue breakdown

4. **Operational Dashboards**
   - Day-to-day activity tracking
   - Task management
   - Workflow status
   - Pending approvals
   - Resource utilization

### Reporting Capabilities

Comprehensive reporting system:

1. **Standard Reports**
   - Catalog performance reports
   - Financial statements
   - User activity reports
   - Distribution status reports
   - Rights management reports

2. **Custom Reporting**
   - Report builder interface
   - Custom metric definition
   - Advanced filtering
   - Personalized layouts
   - Scheduling options

3. **Delivery Options**
   - In-app reporting
   - Email delivery
   - Scheduled exports
   - API access
   - Integration with external analytics

4. **Compliance Reporting**
   - Audit trail reports
   - Policy compliance
   - Financial control adherence
   - Usage monitoring
   - Access pattern analysis

## Security Model

### User Management

Secure user handling across the tenant hierarchy:

1. **User Provisioning**
   - Centralized user creation
   - Self-service registration
   - Bulk user import
   - Role assignment
   - Sub-label user allocation

2. **Authentication**
   - Multi-factor authentication
   - Single sign-on integration
   - Password policies
   - Session management
   - Login monitoring

3. **User Lifecycle**
   - Onboarding workflow
   - Status management (active, suspended, archived)
   - Role transitions
   - Label transfers
   - Offboarding process

4. **Identity Management**
   - User profile maintenance
   - Contact information verification
   - Group membership
   - Access certification
   - Privilege review

### Tenant Security

Protecting tenant boundaries:

1. **Tenant Isolation**
   - Data access control
   - Service separation
   - Resource allocation
   - Monitoring boundaries
   - Cross-tenant controls

2. **Security Policies**
   - Customizable by tenant level
   - Policy inheritance
   - Mandatory vs. discretionary controls
   - Exception management
   - Policy enforcement

3. **Access Monitoring**
   - Real-time monitoring
   - Suspicious activity detection
   - Cross-tenant access logging
   - Usage pattern analysis
   - Alert generation

4. **Incident Response**
   - Security incident management
   - Tenant-level response procedures
   - Isolation capabilities
   - Forensic tools
   - Recovery processes

### Compliance Controls

Ensuring regulatory compliance:

1. **Regulatory Framework**
   - Global compliance capabilities
   - Regional requirement adaptation
   - Industry standard adherence
   - Contract enforcement
   - Licensing compliance

2. **Audit Controls**
   - Comprehensive audit logging
   - Change tracking
   - Access recording
   - Financial transaction logging
   - Configuration change history

3. **Compliance Reporting**
   - Compliance dashboard
   - Violation tracking
   - Remediation management
   - Certification documentation
   - Evidence collection

4. **Data Governance**
   - Data classification
   - Retention policies
   - Privacy controls
   - Data sharing agreements
   - Right to be forgotten support

## Audit & Compliance

### Activity Tracking

Comprehensive audit capabilities:

1. **Audit Scope**
   - System configuration changes
   - User management actions
   - Permission changes
   - Financial transactions
   - Content modifications

2. **Audit Detail**
   - Actor identification
   - Timestamp
   - Action details
   - Before/after state
   - Context information

3. **Storage & Retention**
   - Tamper-proof storage
   - Configurable retention periods
   - Archiving capabilities
   - Search and retrieval
   - Export functionality

4. **Audit Analysis**
   - Pattern detection
   - Anomaly identification
   - Compliance reporting
   - Investigation support
   - Historical comparison

### Change Management

Controlled system evolution:

1. **Change Control**
   - Change request workflow
   - Impact assessment
   - Approval routing
   - Implementation planning
   - Rollback capability

2. **Version Control**
   - Configuration versioning
   - Permission set versioning
   - Policy versioning
   - Template versioning
   - Differential comparison

3. **Release Management**
   - Feature rollout control
   - Tenant-specific deployments
   - Testing environments
   - Progressive activation
   - Feature flagging

4. **Change Communication**
   - Change notification
   - Documentation updates
   - Training materials
   - Support readiness
   - User acceptance testing

### Compliance Framework

Meeting regulatory requirements:

1. **Compliance Management**
   - Compliance requirement tracking
   - Control mapping
   - Evidence collection
   - Gap analysis
   - Remediation planning

2. **Industry Standards**
   - Music industry compliance
   - Financial controls (SOX, etc.)
   - Data protection (GDPR, CCPA)
   - Security standards (ISO 27001, SOC 2)
   - Contractual obligation tracking

3. **Audit Support**
   - External audit preparation
   - Audit evidence collection
   - Finding remediation
   - Continuous monitoring
   - Certification maintenance

4. **Legal Requirements**
   - Rights management compliance
   - Royalty calculation accuracy
   - Tax reporting
   - Contract fulfillment
   - Intellectual property protection

## User Experience

### Label Management Interfaces

User interfaces for hierarchy management:

1. **Label Dashboard**
   - Performance overview
   - Sub-label summary
   - Recent activity
   - Quick actions
   - Alert notifications

2. **Hierarchy Visualization**
   - Interactive organization chart
   - Hierarchical tree view
   - Relationship mapping
   - Drill-down navigation
   - Context-sensitive actions

3. **Configuration Interfaces**
   - Label settings management
   - Permission configuration
   - Integration setup
   - Template management
   - Workflow design

4. **Bulk Operations**
   - Multi-label updates
   - User batch management
   - Content bulk processing
   - Mass communication
   - Reporting across labels

### Mobile Experience

Mobile access to multi-tenant features:

1. **Mobile Dashboard**
   - Performance snapshots
   - Approval workflows
   - Notification management
   - Quick actions
   - Status monitoring

2. **On-the-go Management**
   - User permission adjustments
   - Basic configuration changes
   - Performance monitoring
   - Release approval
   - Financial review

3. **Responsive Design**
   - Device-optimized interfaces
   - Touch-friendly controls
   - Simplified hierarchy navigation
   - Essential feature access
   - Offline capability

4. **Mobile Notifications**
   - Push notification integration
   - Priority-based alerting
   - Action-enabled notifications
   - Status updates
   - Escalation management

### Customization Options

Tailoring the experience for each label:

1. **Visual Customization**
   - Label-specific branding
   - Custom color schemes
   - Logo integration
   - Layout preferences
   - Typography options

2. **Functional Customization**
   - Dashboard widget selection
   - Feature enablement
   - Workflow customization
   - Report personalization
   - Notification preferences

3. **Integration Preferences**
   - Third-party service connections
   - Data import/export configuration
   - External tool integration
   - API usage settings
   - Authentication preferences

4. **Language & Localization**
   - Multi-language support
   - Regional formatting
   - Time zone preferences
   - Currency display options
   - Cultural adaptations

## Integration Points

### External Systems

Connecting to broader ecosystems:

1. **Financial Integrations**
   - Accounting systems
   - Payment processors
   - Banking platforms
   - Tax reporting systems
   - Royalty processors

2. **Distribution Platforms**
   - Streaming services
   - Download stores
   - Physical distribution
   - Synchronization platforms
   - Social media services

3. **Enterprise Systems**
   - CRM integration
   - ERP connectivity
   - Business intelligence platforms
   - Data warehouses
   - Document management systems

4. **Industry Connections**
   - Rights societies
   - Publishing administrators
   - Licensing platforms
   - Industry databases
   - Chart reporting services

### API Ecosystem

Programmatic access to multi-tenant functionality:

1. **Core APIs**
   - Tenant management API
   - User and permission API
   - Catalog management API
   - Financial API
   - Analytics API

2. **Integration Patterns**
   - RESTful endpoints
   - GraphQL for complex queries
   - Webhook notifications
   - Batch processing APIs
   - Real-time streaming

3. **Developer Resources**
   - API documentation
   - SDK availability
   - Code examples
   - Testing environment
   - Rate limit information

4. **Authentication & Security**
   - OAuth 2.0 implementation
   - API key management
   - Scoped access tokens
   - CORS configuration
   - Request signing

### Data Exchange

Moving data between systems:

1. **Import Capabilities**
   - User bulk import
   - Catalog data import
   - Financial data ingestion
   - Rights data import
   - Historical data migration

2. **Export Functionality**
   - Reporting exports
   - Catalog extracts
   - Financial data exports
   - User data extraction
   - System configuration backup

3. **Synchronization**
   - Real-time data synchronization
   - Scheduled synchronization
   - Conflict resolution
   - Delta synchronization
   - Validation and error handling

4. **Exchange Formats**
   - Standard format support (CSV, XML, JSON)
   - Industry-specific formats
   - Custom format mapping
   - Schema validation
   - Transformation capabilities

## Implementation Guidelines

### Setup Process

Steps for implementing the multi-tenant system:

1. **Planning Phase**
   - Hierarchy design
   - Tenant structure planning
   - Permission strategy development
   - Integration requirements
   - Migration approach

2. **Initial Configuration**
   - Root tenant setup
   - Master administrator provisioning
   - System parameter configuration
   - Base templates creation
   - Security policy establishment

3. **Tenant Hierarchy Creation**
   - Parent label setup
   - Sub-label creation
   - Relationship definition
   - Policy inheritance configuration
   - Resource allocation

4. **User Onboarding**
   - Administrator training
   - User import and setup
   - Role assignment
   - Initial permission configuration
   - Access testing

### Best Practices

Recommended approaches for multi-tenant management:

1. **Hierarchy Design**
   - Keep hierarchy depth manageable (3-5 levels recommended)
   - Define clear organizational boundaries
   - Establish consistent naming conventions
   - Document hierarchy purpose and relationships
   - Plan for future expansion

2. **Permission Management**
   - Use role templates for consistency
   - Implement least-privilege principle
   - Regularly review access rights
   - Establish permission request workflow
   - Document role definitions

3. **Financial Setup**
   - Define clear revenue sharing rules
   - Document special financial arrangements
   - Implement approval workflows for financial changes
   - Establish financial reporting cadence
   - Set up financial alerts

4. **Performance Optimization**
   - Implement caching strategies
   - Optimize database queries for hierarchy
   - Use eager loading for related data
   - Apply pagination for large datasets
   - Schedule resource-intensive operations

### Migration Strategies

Approaches for moving to the multi-tenant system:

1. **Phased Migration**
   - Begin with core parent label
   - Gradually migrate sub-labels
   - Phase functionality adoption
   - Incremental user onboarding
   - Progressive feature activation

2. **Data Migration**
   - User mapping strategy
   - Historical data import
   - Catalog association planning
   - Financial data reconciliation
   - Rights and ownership transfer

3. **Integration Approach**
   - Legacy system coexistence
   - API-first integration
   - Data synchronization strategy
   - Authentication bridging
   - Reporting consolidation

4. **Verification & Validation**
   - Hierarchy validation
   - Permission testing
   - Financial calculation verification
   - Report accuracy confirmation
   - User acceptance testing

## API Reference

### Tenant Management API

Core API endpoints for tenant operations:

1. **Sub-label Management**
   ```
   POST /api/tenants/sub-labels - Create new sub-label
   GET /api/tenants/sub-labels - List sub-labels
   GET /api/tenants/sub-labels/{id} - Get sub-label details
   PUT /api/tenants/sub-labels/{id} - Update sub-label
   DELETE /api/tenants/sub-labels/{id} - Archive sub-label
   ```

2. **Hierarchy Operations**
   ```
   GET /api/tenants/hierarchy - Get full hierarchy
   GET /api/tenants/hierarchy/{id}/children - Get child labels
   GET /api/tenants/hierarchy/{id}/parent - Get parent label
   PUT /api/tenants/hierarchy/{id}/parent - Change parent label
   GET /api/tenants/hierarchy/{id}/path - Get full path to root
   ```

3. **Template Management**
   ```
   POST /api/tenants/templates - Create template
   GET /api/tenants/templates - List templates
   GET /api/tenants/templates/{id} - Get template details
   PUT /api/tenants/templates/{id} - Update template
   POST /api/tenants/sub-labels/{id}/apply-template - Apply template
   ```

4. **Bulk Operations**
   ```
   POST /api/tenants/bulk/import - Bulk import sub-labels
   POST /api/tenants/bulk/update - Bulk update sub-labels
   POST /api/tenants/bulk/move - Bulk move sub-labels
   GET /api/tenants/bulk/status/{jobId} - Check bulk operation status
   ```

### Permission API

Endpoints for managing access control:

1. **Role Management**
   ```
   POST /api/permissions/roles - Create role
   GET /api/permissions/roles - List roles
   GET /api/permissions/roles/{id} - Get role details
   PUT /api/permissions/roles/{id} - Update role
   DELETE /api/permissions/roles/{id} - Delete role
   ```

2. **Permission Assignment**
   ```
   POST /api/permissions/users/{userId}/roles - Assign role to user
   DELETE /api/permissions/users/{userId}/roles/{roleId} - Remove role
   GET /api/permissions/users/{userId}/permissions - Get effective permissions
   POST /api/permissions/users/{userId}/permissions - Grant direct permission
   DELETE /api/permissions/users/{userId}/permissions/{permId} - Remove permission
   ```

3. **Access Control**
   ```
   GET /api/permissions/check - Check permission
   POST /api/permissions/request - Request additional access
   GET /api/permissions/requests - List access requests
   PUT /api/permissions/requests/{id} - Update request status
   GET /api/permissions/audit - Get permission audit log
   ```

4. **Cross-Label Access**
   ```
   POST /api/permissions/cross-label - Create cross-label access
   GET /api/permissions/cross-label - List cross-label access
   PUT /api/permissions/cross-label/{id} - Update cross-label access
   DELETE /api/permissions/cross-label/{id} - Remove cross-label access
   GET /api/permissions/cross-label/audit - Get cross-label audit log
   ```

### Analytics API

Endpoints for multi-level analytics:

1. **Performance Data**
   ```
   GET /api/analytics/tenants/{id}/performance - Get tenant performance
   GET /api/analytics/tenants/{id}/catalog - Get catalog performance
   GET /api/analytics/tenants/{id}/artists - Get artist performance
   GET /api/analytics/tenants/{id}/releases - Get release performance
   GET /api/analytics/tenants/{id}/tracks - Get track performance
   ```

2. **Comparison Analytics**
   ```
   GET /api/analytics/compare/tenants - Compare tenants
   GET /api/analytics/compare/periods - Compare time periods
   GET /api/analytics/benchmarks - Get benchmarks
   GET /api/analytics/trends - Get trend analysis
   GET /api/analytics/forecasts - Get performance forecasts
   ```

3. **Financial Analytics**
   ```
   GET /api/analytics/tenants/{id}/revenue - Get revenue analysis
   GET /api/analytics/tenants/{id}/expenses - Get expense analysis
   GET /api/analytics/tenants/{id}/profitability - Get profitability analysis
   GET /api/analytics/tenants/{id}/splits - Get split analysis
   GET /api/analytics/tenants/{id}/forecasts - Get financial forecasts
   ```

4. **Custom Reporting**
   ```
   POST /api/analytics/reports - Create custom report
   GET /api/analytics/reports - List reports
   GET /api/analytics/reports/{id} - Get report data
   PUT /api/analytics/reports/{id} - Update report
   POST /api/analytics/reports/{id}/schedule - Schedule report
   ```

---

**Document Information:**
- Version: 1.0
- Last Updated: March 26, 2025
- Contact: product-team@tunemantra.com

---

## documentation/technical/rights_management/royalty-management-system.md

# Royalty Management System

*Version: 1.0.0 (March 27, 2025)*

## Table of Contents

- [Introduction](#introduction)
- [System Overview](#system-overview)
- [Core Components](#core-components)
- [Data Model](#data-model)
- [Process Flows](#process-flows)
- [Integration Points](#integration-points)
- [Configuration Options](#configuration-options)
- [Reporting Capabilities](#reporting-capabilities)
- [Security and Compliance](#security-and-compliance)
- [Performance Considerations](#performance-considerations)
- [Troubleshooting](#troubleshooting)
- [Future Enhancements](#future-enhancements)
- [Appendix](#appendix)

## Introduction

The TuneMantra Royalty Management System is a comprehensive solution for tracking, calculating, processing, and distributing royalty payments to rights holders for music distribution across multiple platforms. This document provides detailed information about the system's architecture, components, processes, and capabilities.

### Purpose and Scope

This document covers:

- The complete royalty management lifecycle
- System architecture and components
- Data models and processing algorithms
- Integration with external systems
- Configuration, reporting, and administration
- Security, compliance, and performance considerations

### Background

The music industry's complex rights and royalty landscape requires sophisticated systems to handle multi-tiered payment structures, varied revenue sources, and multiple rightsholders. TuneMantra's Royalty Management System was designed to address these challenges while providing flexibility, accuracy, and transparency.

Key challenges addressed include:

- Processing data from 150+ digital service providers
- Handling multiple royalty schemes and calculation models
- Supporting complex split hierarchies and inheritance
- Ensuring accurate currency conversions and tax handling
- Maintaining a complete audit trail for all transactions
- Supporting timely and accurate payments to thousands of rights holders

### Business Objectives

The Royalty Management System supports the following business objectives:

1. **Accuracy**: Ensure precise calculation and attribution of royalties
2. **Transparency**: Provide clear visibility into royalty sources and calculations
3. **Timeliness**: Process royalties efficiently to support regular payment schedules
4. **Flexibility**: Adapt to diverse revenue models and distribution arrangements
5. **Compliance**: Adhere to industry standards and regulatory requirements
6. **Scalability**: Support growth in catalog size, transaction volume, and user base

## System Overview

The Royalty Management System functions as a central component of the TuneMantra platform, connecting with multiple subsystems and external services.

### High-Level Architecture

The system follows a modular architecture with the following layers:

1. **Data Collection Layer**: Interfaces with platforms to gather revenue data
2. **Processing Layer**: Core engines for calculation and allocation
3. **Storage Layer**: Persistent storage for royalty data and configurations
4. **Reporting Layer**: Visualization and reporting capabilities
5. **Integration Layer**: Connections to payment systems and external services

### System Context

The Royalty Management System interacts with:

1. **Digital Service Providers**: Sources of streaming, download, and usage data
2. **Rights Management System**: Source of ownership and split information
3. **Financial System**: Destination for payment instructions
4. **User Management System**: Source of user and organization information
5. **Analytics System**: Consumer of royalty data for advanced analytics
6. **External Payment Providers**: Services for executing payments

### Key Functions

The system provides the following key functions:

1. **Revenue Collection**: Gathering and normalization of revenue data
2. **Royalty Calculation**: Application of rates, deals, and splits
3. **Payment Processing**: Generation and execution of payment instructions
4. **Statement Generation**: Creation of detailed royalty statements
5. **Reporting and Analytics**: Insights into revenue trends and distributions
6. **Audit Trail**: Complete history of all royalty transactions

## Core Components

The Royalty Management System consists of several specialized components, each handling specific aspects of the royalty process.

### Revenue Collection Service

The Revenue Collection Service handles the acquisition, validation, and normalization of revenue data from multiple sources.

#### Features

1. **Platform Adapters**: Specialized connectors for each service provider
2. **Data Validation**: Verification of incoming data integrity
3. **Normalization Engine**: Standardization of revenue data formats
4. **Reconciliation Tool**: Cross-checking of revenue against expected values
5. **Error Handling**: Automated and manual resolution of data issues
6. **Schedule Management**: Control of data collection timing and frequency

#### Supported Platforms

The service supports data collection from:

1. **Major Streaming Services**: Spotify, Apple Music, Amazon Music, etc.
2. **Download Stores**: iTunes, Amazon MP3, etc.
3. **Video Platforms**: YouTube, TikTok, etc.
4. **Social Media**: Instagram, Facebook, etc.
5. **Performance Rights Organizations**: ASCAP, BMI, SESAC, etc.
6. **International Collecting Societies**: PRS, GEMA, SACEM, etc.

#### Data Acquisition Methods

Revenue data is acquired through:

1. **API Integration**: Direct connections to platform APIs
2. **SFTP Download**: Automated retrieval of data files
3. **Portal Scraping**: Structured extraction from provider portals
4. **Manual Import**: User-initiated uploads of revenue files
5. **EDI Integration**: Electronic Data Interchange for standardized formats
6. **Direct Database Connections**: Secure database links where available

### Calculation Engine

The Calculation Engine processes raw revenue data to determine royalty amounts based on ownership, splits, rates, and deals.

#### Features

1. **Rule-based Processing**: Flexible rules for different revenue types
2. **Multi-currency Support**: Handling of 30+ currencies with historical rates
3. **Split Application**: Implementation of complex ownership hierarchies
4. **Rate Card Support**: Application of tiered and negotiated rates
5. **Minimum Guarantees**: Enforcement of minimum payment thresholds
6. **Advances and Recoupments**: Management of advances and recovery

#### Calculation Models

The engine supports multiple calculation models:

1. **Percentage-based**: Standard percentage of revenue
2. **Per-unit**: Fixed amount per stream or download
3. **Tiered Rates**: Variable rates based on volume tiers
4. **Minimum Guarantees**: Floor values regardless of actual revenue
5. **Custom Formulas**: Complex calculations for special arrangements
6. **Hybrid Models**: Combinations of different calculation approaches

#### Processing Modes

The engine operates in several processing modes:

1. **Real-time Processing**: Immediate calculation for user-initiated requests
2. **Batch Processing**: Scheduled processing of bulk revenue data
3. **Incremental Processing**: Updates based on new or changed data
4. **Recalculation**: Complete reprocessing based on rule or data changes
5. **Simulation**: What-if calculations for planning and verification
6. **Manual Override**: Administrator-controlled adjustments

### Payment Processing Service

The Payment Processing Service manages the preparation, execution, and tracking of royalty payments to rights holders.

#### Features

1. **Payment Scheduling**: Flexible payment calendars and frequencies
2. **Threshold Management**: Enforcement of minimum payment amounts
3. **Payment Grouping**: Consolidation of multiple royalty streams
4. **Multi-method Support**: Multiple payment execution methods
5. **Tax Handling**: Withholding calculation and documentation
6. **Failed Payment Management**: Resolution of payment issues

#### Payment Methods

Supported payment methods include:

1. **Bank Transfers**: ACH, SEPA, and international wire transfers
2. **Digital Payment Services**: PayPal, Stripe, etc.
3. **Check Issuance**: Physical checks for traditional payments
4. **Virtual Wallets**: Digital wallet transfers
5. **Cryptocurrency**: Bitcoin, Ethereum, and stablecoin payments
6. **Internal Ledger**: Balance adjustments without external transfer

#### Payment Workflow

The payment workflow consists of:

1. **Eligibility Determination**: Identification of payable amounts
2. **Payee Verification**: Validation of payment destination information
3. **Batch Creation**: Grouping of payments for efficient processing
4. **Approval Workflow**: Multi-level review and authorization
5. **Execution**: Transmission to payment providers
6. **Reconciliation**: Verification of successful execution
7. **Documentation**: Generation of payment records and receipts

### Statement Generation Service

The Statement Generation Service creates detailed royalty statements for rights holders, providing transparency into earnings sources and calculations.

#### Features

1. **Multi-format Support**: Statements in PDF, Excel, CSV, and online formats
2. **White-labeling**: Organization-branded statements
3. **Multi-level Detail**: Adjustable granularity from summary to track-level
4. **Historical Access**: Archive of past statements
5. **Automated Distribution**: Scheduled delivery via email or portal
6. **Interactive Statements**: Online exploration of statement data

#### Statement Types

The service generates various statement types:

1. **Period Statements**: Regular reporting for defined time periods
2. **Ad-hoc Statements**: User-requested statements for custom periods
3. **Preview Statements**: Preliminary views of in-progress periods
4. **Correction Statements**: Documentation of adjustments to prior periods
5. **Consolidated Statements**: Combined view across multiple catalogs or labels
6. **Tax Statements**: Specialized reports for tax compliance

#### Statement Sections

Comprehensive statements include:

1. **Summary Section**: Top-level earning overview
2. **Platform Breakdown**: Earnings by distribution platform
3. **Release Details**: Earnings by album, EP, or single
4. **Track-level Information**: Per-track performance and revenue
5. **Territory Analysis**: Geographic distribution of earnings
6. **Historical Comparison**: Trends compared to previous periods
7. **Payment Information**: Details of associated payments
8. **Adjustment Section**: Documentation of corrections and special items

### Administration Console

The Administration Console provides control and oversight capabilities for system operators and administrators.

#### Features

1. **Configuration Management**: Control of system parameters and rules
2. **Status Monitoring**: Real-time visibility into processing status
3. **Manual Intervention**: Tools for handling exceptions and special cases
4. **Audit Controls**: Access to complete transaction history
5. **Performance Dashboard**: Metrics on system health and throughput
6. **User Management**: Control of system access and permissions

#### Administrative Functions

Key functions include:

1. **Revenue Import Control**: Management of data ingestion processes
2. **Calculation Oversight**: Monitoring and control of processing jobs
3. **Payment Authorization**: Approval workflows for payment execution
4. **Exception Handling**: Resolution of flagged issues and edge cases
5. **Rate Card Management**: Configuration of royalty rates and deals
6. **System Configuration**: Control of global and tenant-specific settings

## Data Model

The Royalty Management System uses a comprehensive data model to represent the complex relationships between rights holders, revenue sources, and payments.

### Core Entities

The primary entities in the data model include:

1. **Revenue Records**: Individual revenue items from platforms
2. **Royalty Calculations**: Processed royalty amounts with attribution
3. **Rights Holders**: Entities entitled to receive royalties
4. **Payment Records**: Executed and pending payments
5. **Statements**: Generated royalty statements
6. **Rate Cards**: Configured royalty rates and terms

### Revenue Data Model

Revenue data is structured around:

1. **Platform**: Source of the revenue (Spotify, Apple Music, etc.)
2. **Revenue Type**: Stream, download, subscription, ad-supported, etc.
3. **Content Item**: Specific track, release, or asset
4. **Time Period**: Reporting period for the revenue
5. **Territory**: Geographic region where revenue was generated
6. **Currency**: Original currency of the reported revenue
7. **Amount**: Monetary value of the revenue item
8. **Units**: Count of streams, downloads, or other consumption units
9. **Metadata**: Additional platform-specific information

### Calculation Data Model

Calculated royalties include:

1. **Revenue Reference**: Link to the source revenue record
2. **Rights Holder**: Entity entitled to the royalty
3. **Split Information**: Applicable rights percentage
4. **Rate Information**: Applied royalty rate or formula
5. **Gross Amount**: Pre-deduction royalty amount
6. **Deductions**: Fees, taxes, and other reductions
7. **Net Amount**: Final royalty amount
8. **Currency**: Currency of the calculated amount
9. **Status**: Processing state of the royalty item
10. **Calculation Date**: When the calculation was performed
11. **Rule Reference**: Applied calculation rule or model

### Payment Data Model

Payment records include:

1. **Payee Information**: Rights holder receiving payment
2. **Payment Method**: Mechanism used for payment
3. **Currency**: Currency of the payment
4. **Amount**: Total payment amount
5. **Status**: Current state of the payment
6. **Scheduled Date**: When payment is/was scheduled
7. **Execution Date**: When payment was processed
8. **Reference Number**: External payment identifier
9. **Royalty References**: Links to included royalty items
10. **Tax Information**: Withholding and tax documentation

### Hierarchical Relationships

The data model supports complex hierarchies:

1. **Organization Hierarchy**: Parent labels, sub-labels, and imprints
2. **Content Hierarchy**: Catalogs, releases, and tracks
3. **Rights Hierarchy**: Primary and secondary rights holders
4. **Split Hierarchy**: Multi-level percentage allocations
5. **Payment Hierarchy**: Consolidated payments across levels

## Process Flows

The Royalty Management System operates through several key process flows that handle the royalty lifecycle from revenue collection to payment execution.

### Revenue Collection Process

The revenue collection process follows these steps:

1. **Schedule Initiation**: Automated or manual triggering of collection
2. **Platform Connection**: Establishment of secure connection to the platform
3. **Data Retrieval**: Acquisition of revenue data through appropriate method
4. **Initial Validation**: Basic format and integrity checking
5. **Normalization**: Conversion to standard internal format
6. **Deduplication**: Identification and resolution of duplicate records
7. **Enhanced Validation**: Cross-checking against expected patterns
8. **Error Resolution**: Automated or manual handling of identified issues
9. **Staging**: Preparation of validated data for calculation
10. **Notification**: Alerting of relevant users about collection completion

### Royalty Calculation Process

The calculation process involves:

1. **Calculation Triggering**: Scheduled or manual initiation
2. **Revenue Selection**: Identification of records for processing
3. **Rights Lookup**: Retrieval of applicable ownership information
4. **Rate Determination**: Selection of appropriate royalty rates
5. **Split Application**: Distribution according to ownership percentages
6. **Currency Conversion**: Standardization to payment currencies
7. **Deduction Application**: Fees, taxes, and other withholdings
8. **Minimum Guarantee Evaluation**: Application of floor values
9. **Advance Recoupment**: Recovery of previously paid advances
10. **Result Validation**: Verification of calculation integrity
11. **Finalization**: Commitment of calculated values
12. **Audit Recording**: Comprehensive logging of calculation details

### Payment Processing Flow

The payment workflow consists of:

1. **Payment Cycle Initiation**: Scheduled or manual triggering
2. **Eligibility Assessment**: Identification of payable royalties
3. **Threshold Evaluation**: Filtering based on minimum payment amounts
4. **Payment Consolidation**: Grouping by payee and payment method
5. **Tax Calculation**: Determination of withholding requirements
6. **Approval Workflow**: Multi-level review and authorization
7. **Payment Preparation**: Formatting for payment provider
8. **Execution**: Transmission to payment systems
9. **Status Monitoring**: Tracking of payment processing
10. **Confirmation Handling**: Processing of success/failure notifications
11. **Reconciliation**: Verification against expected payments
12. **Status Update**: Recording of final payment outcomes
13. **Documentation**: Generation of payment confirmations

### Statement Generation Process

The statement creation process includes:

1. **Statement Scheduling**: Calendar-based or ad-hoc triggering
2. **Data Collection**: Gathering of relevant royalty and payment data
3. **Template Selection**: Choice of appropriate statement format
4. **Data Aggregation**: Summarization and grouping by various dimensions
5. **Calculation**: Derivation of totals, subtotals, and comparisons
6. **Format Rendering**: Generation in target output formats
7. **Quality Control**: Validation of statement accuracy and completeness
8. **Distribution**: Delivery via portal, email, or download
9. **Archiving**: Storage for historical reference
10. **Notification**: Alerting of recipients about statement availability

### Adjustment and Reconciliation Process

The adjustment process handles corrections and reconciliations:

1. **Discrepancy Identification**: Detection of errors or mismatches
2. **Investigation**: Analysis of root causes
3. **Correction Determination**: Decision on appropriate adjustments
4. **Approval Workflow**: Authorization for significant corrections
5. **Adjustment Application**: Recording of corrective transactions
6. **Recalculation**: Reprocessing of affected royalties
7. **Documentation**: Detailed logging of adjustments and reasons
8. **Notification**: Communication to affected parties
9. **Statement Update**: Generation of corrected statements
10. **Payment Adjustment**: Processing of additional payments or recoveries

## Integration Points

The Royalty Management System integrates with multiple internal and external systems to provide comprehensive functionality.

### Platform Integrations

Integrations with digital service providers include:

1. **Spotify**: Direct API and reporting portal integration
2. **Apple Music**: Connect API and sales reports
3. **Amazon Music**: Reporting API and dashboard integration
4. **YouTube**: Content ID and Partner API integration
5. **TikTok**: Commercial Music Library API
6. **Social Platforms**: API-based usage reporting

#### Integration Methods

Platform integrations use various methods:

1. **REST APIs**: Standard web service interfaces
2. **SOAP Services**: Legacy XML-based interfaces
3. **SFTP Access**: Secure file transfer for reports
4. **OAuth Authentication**: Secure delegated access
5. **Webhooks**: Event-driven notifications
6. **Batch Files**: Scheduled data file exchanges

### Internal System Integrations

The system integrates with other TuneMantra subsystems:

1. **Rights Management System**: Source of ownership and split data
2. **Content Management System**: Source of catalog and metadata
3. **User Management System**: Authentication and organization data
4. **Analytics System**: Advanced reporting and insights
5. **Financial System**: Accounting and financial management
6. **Distribution System**: Release and availability information

#### Integration Mechanisms

Internal integrations use:

1. **Service APIs**: Direct service-to-service communication
2. **Message Queue**: Asynchronous event processing
3. **Shared Database**: Controlled access to common data
4. **Event Streaming**: Real-time data flow
5. **Batch Processing**: Scheduled data synchronization
6. **Shared Storage**: Common access to content assets

### Payment Provider Integrations

Payment execution relies on integrations with:

1. **Banking Partners**: ACH, SEPA, and wire transfer services
2. **PayPal**: Mass payment and payout services
3. **Stripe**: Connect and transfer capabilities
4. **Accounting Systems**: Financial record synchronization
5. **Tax Authorities**: Withholding and reporting
6. **Currency Exchange Services**: FX rate and conversion services

#### Payment Integration Features

Payment integrations support:

1. **Batch Payments**: Efficient processing of multiple payments
2. **Status Tracking**: Monitoring of payment processing
3. **Notification Handling**: Processing of success/failure alerts
4. **Reconciliation**: Matching of payments to internal records
5. **Multi-currency Support**: Handling of global payment requirements
6. **Compliance Verification**: Adherence to financial regulations

### External Reporting Integrations

The system provides data to external reporting systems:

1. **Business Intelligence Tools**: PowerBI, Tableau, etc.
2. **Financial Systems**: Accounting and ERP platforms
3. **Compliance Systems**: Regulatory reporting tools
4. **Artist Portals**: Performer and songwriter dashboards
5. **Label Dashboards**: Client reporting systems
6. **Industry Organizations**: Collective management systems

## Configuration Options

The Royalty Management System offers extensive configuration capabilities to adapt to diverse business requirements.

### System-level Configuration

Global system settings include:

1. **Processing Schedule**: Timing of collection and calculation jobs
2. **Currency Settings**: Base currency and exchange rate sources
3. **Default Rates**: Standard royalty rates by revenue type
4. **Threshold Values**: Minimum amounts for statements and payments
5. **Retention Policies**: Data preservation timeframes
6. **Notification Rules**: Alert and communication settings

### Organization-level Configuration

Settings specific to each organization include:

1. **Statement Format**: Customized statement templates
2. **Payment Schedule**: Organization-specific payment frequency
3. **Default Split Rules**: Standard royalty division arrangements
4. **Approval Workflows**: Authorization requirements for payments
5. **Rate Card Definitions**: Organization-specific royalty rates
6. **Branding Settings**: White-labeled statement appearance

### Rights Holder Configuration

Individual rights holder settings include:

1. **Payment Methods**: Preferred payment mechanisms
2. **Payment Thresholds**: Custom minimum payment amounts
3. **Currency Preferences**: Desired payment currencies
4. **Statement Delivery**: Preferred statement formats and delivery
5. **Tax Information**: Withholding requirements and documentation
6. **Banking Details**: Secure payment destination information

### Calculation Rule Configuration

Flexible calculation rules control:

1. **Platform-specific Rates**: Different rates by distribution channel
2. **Territory Rules**: Variations by geographic region
3. **Time-based Rules**: Changes in rates over time
4. **Revenue Type Rules**: Different handling by revenue source
5. **Special Arrangement Rules**: Custom deals and exceptions
6. **Deduction Rules**: Fee structures and withholding arrangements

### User Interface Configuration

User experience settings include:

1. **Dashboard Configuration**: Customizable monitoring views
2. **Reporting Presets**: Saved reporting parameters
3. **Notification Preferences**: Alert delivery options
4. **Data Visibility**: Controlled access to information
5. **Workflow Assignments**: Task routing and responsibilities
6. **Language and Locale**: Regional display preferences

## Reporting Capabilities

The Royalty Management System provides comprehensive reporting capabilities to monitor performance, analyze trends, and facilitate decision-making.

### Standard Reports

Built-in reports include:

1. **Period Summary Report**: Overview of royalties by period
2. **Platform Performance Report**: Revenue and royalties by platform
3. **Catalog Performance Report**: Analysis by release and track
4. **Territory Analysis Report**: Geographic distribution of royalties
5. **Rights Holder Summary**: Earnings by payee
6. **Payment Status Report**: Overview of payment execution

### Interactive Dashboards

Real-time dashboards provide:

1. **Executive Overview**: High-level performance metrics
2. **Revenue Trends**: Historical and comparative analysis
3. **Top Performers**: Highest earning content and rights holders
4. **Processing Status**: Current state of royalty operations
5. **Financial Projections**: Anticipated future royalties
6. **Anomaly Indicators**: Unusual patterns requiring attention

### Ad-hoc Reporting

Flexible analysis capabilities include:

1. **Custom Report Builder**: User-defined report creation
2. **Dimensional Analysis**: Multi-faceted data exploration
3. **Comparative Tools**: Period-over-period and benchmark analysis
4. **Export Options**: Data extraction in various formats
5. **Scheduled Distribution**: Automated report delivery
6. **Saved Configurations**: Reusable report definitions

### Data Visualization

Visual reporting elements include:

1. **Trend Charts**: Time-based performance visualization
2. **Distribution Graphs**: Proportional allocation displays
3. **Geographic Maps**: Territorial performance visualization
4. **Heat Maps**: Intensity-based pattern identification
5. **Comparative Gauges**: Performance against targets
6. **Interactive Filters**: Dynamic report adjustment

### Performance Analytics

Advanced analytics provide:

1. **Trend Analysis**: Identification of long-term patterns
2. **Seasonal Patterns**: Recognition of cyclical behaviors
3. **Platform Comparison**: Relative performance across channels
4. **Catalog Analysis**: Evaluation of content performance
5. **Forecasting Models**: Predictive royalty projections
6. **Anomaly Detection**: Identification of unusual patterns

## Security and Compliance

The Royalty Management System incorporates robust security measures and compliance capabilities to protect sensitive financial data.

### Data Security

Protection measures include:

1. **Encryption at Rest**: Secure storage of sensitive data
2. **Encryption in Transit**: TLS for all communications
3. **Tokenization**: Protection of payment information
4. **Data Masking**: Limited visibility of sensitive details
5. **Access Controls**: Principle of least privilege enforcement
6. **Audit Logging**: Comprehensive activity tracking

### Access Control

User access is managed through:

1. **Role-based Access Control**: Permission assignment through roles
2. **Multi-factor Authentication**: Enhanced login security
3. **Session Management**: Secure handling of user sessions
4. **IP Restrictions**: Location-based access controls
5. **Approval Hierarchies**: Multi-level authorization for sensitive actions
6. **Segregation of Duties**: Prevention of control conflicts

### Audit Capabilities

Comprehensive auditing includes:

1. **Transaction Logging**: Complete history of all operations
2. **User Activity Tracking**: Record of all user actions
3. **Change Tracking**: History of configuration changes
4. **Access Logs**: Documentation of system access
5. **Approval Records**: Evidence of authorization processes
6. **Version Control**: Historical record of system states

### Compliance Features

Compliance support includes:

1. **Financial Reporting**: Accurate record-keeping for accounting
2. **Tax Compliance**: Proper withholding and documentation
3. **Data Protection**: GDPR and privacy regulation compliance
4. **Industry Standards**: Adherence to music industry practices
5. **Contractual Compliance**: Enforcement of deal terms
6. **Regulatory Reporting**: Support for required disclosures

## Performance Considerations

The Royalty Management System is optimized for high-volume data processing while maintaining accuracy and responsiveness.

### Scalability Features

Scalable architecture supports:

1. **Horizontal Scaling**: Distributed processing across servers
2. **Load Balancing**: Efficient distribution of processing load
3. **Resource Allocation**: Dynamic assignment based on workload
4. **Multi-threading**: Parallel execution of compatible operations
5. **Batch Optimization**: Efficient processing of large datasets
6. **Incremental Processing**: Focused handling of changed data

### Performance Optimizations

Optimizations include:

1. **Query Optimization**: Efficient database access patterns
2. **Caching Strategy**: Multi-level caching of frequently accessed data
3. **Database Indexing**: Strategic indexes for common queries
4. **Data Partitioning**: Segmentation for improved access
5. **Bulk Operations**: Batched processing for efficiency
6. **Asynchronous Processing**: Non-blocking operations for responsiveness

### Throughput Capabilities

The system supports high-volume processing:

1. **Revenue Records**: Millions of records per processing cycle
2. **Calculation Throughput**: 10,000+ royalty calculations per second
3. **Payment Processing**: Thousands of payments per batch
4. **Statement Generation**: Hundreds of statements per hour
5. **Concurrent Users**: Hundreds of simultaneous system users
6. **API Capacity**: Thousands of API requests per minute

### Resource Management

Efficient resource utilization includes:

1. **Connection Pooling**: Optimized database connections
2. **Memory Management**: Controlled memory utilization
3. **CPU Optimization**: Efficient processor usage
4. **I/O Efficiency**: Minimized disk and network operations
5. **Job Scheduling**: Coordination of resource-intensive tasks
6. **Graceful Degradation**: Managed behavior under heavy load

## Troubleshooting

The Royalty Management System includes comprehensive tools and procedures for identifying and resolving issues.

### Common Issues

Frequently encountered challenges include:

1. **Data Discrepancies**: Mismatches between expected and actual values
2. **Processing Delays**: Extended calculation or payment times
3. **Platform Integration Issues**: Connectivity or format problems
4. **Calculation Anomalies**: Unexpected royalty results
5. **Payment Failures**: Unsuccessful payment execution
6. **Statement Errors**: Inaccuracies in generated statements

### Diagnostic Tools

Issue identification tools include:

1. **System Logs**: Detailed operation records
2. **Monitoring Dashboards**: Real-time system status
3. **Audit Trails**: Historical transaction records
4. **Validation Reports**: Data integrity checking
5. **Performance Metrics**: Processing time and throughput
6. **Alert Management**: Notification of detected issues

### Resolution Procedures

Issue resolution follows structured procedures:

1. **Triage Process**: Priority and impact assessment
2. **Root Cause Analysis**: Identification of underlying issues
3. **Resolution Planning**: Determination of corrective actions
4. **Implementation**: Execution of fixes or workarounds
5. **Verification**: Confirmation of successful resolution
6. **Documentation**: Recording of issue and resolution

### Preventative Measures

Proactive issue prevention includes:

1. **Automated Validation**: Continuous data quality checking
2. **Predictive Monitoring**: Identification of emerging issues
3. **Regular Maintenance**: Scheduled system optimization
4. **Configuration Review**: Periodic settings verification
5. **Performance Testing**: Regular capacity validation
6. **Failover Testing**: Verification of redundancy measures

## Future Enhancements

The Royalty Management System roadmap includes planned improvements and expansions.

### Near-term Enhancements

Upcoming features include:

1. **Advanced AI Analytics**: Machine learning for royalty optimization
2. **Enhanced Mobile Access**: Improved mobile statement viewing
3. **Real-time Dashboard**: Live performance visualization
4. **Expanded Platform Integrations**: Additional DSP connections
5. **Improved Payment Options**: Additional payment methods
6. **Enhanced Reporting**: More visualization and analysis tools

### Long-term Vision

Strategic direction includes:

1. **Blockchain Integration**: Decentralized rights verification
2. **Predictive Analytics**: Forecast modeling and optimization
3. **Natural Language Processing**: Conversational reporting interface
4. **Global Expansion**: Support for additional territories and regulations
5. **Smart Contracts**: Automated agreement execution
6. **Open API Ecosystem**: Developer platform for extensions

## Appendix

### Glossary

- **DSP (Digital Service Provider)**: Platforms that distribute digital music
- **Revenue**: Income generated from music consumption or licensing
- **Royalty**: Payment to rights holders based on usage of their content
- **Split**: Division of royalties among multiple rights holders
- **Statement**: Detailed report of royalty calculations and sources
- **Rate Card**: Defined royalty rates for different usage types
- **Rights Holder**: Entity entitled to receive royalties
- **Recoupment**: Recovery of advances from royalty earnings

### Reference Documents

- Original Royalty System Design (February 2023)
- Calculation Algorithm Specification v2.5 (July 2023)
- Platform Integration Guide v3.0 (January 2024)
- Statement Format Specification v1.8 (May 2024)
- Payment Provider Integration Guide v2.2 (August 2024)
- Current System Implementation (March 2025)

---

© 2023-2025 TuneMantra. All rights reserved.

---

## documentation/technical/security/security-model.md

# TuneMantra Security Model

*Version: 1.0.0 (March 27, 2025)*

## Table of Contents

- [Introduction](#introduction)
- [Security Architecture](#security-architecture)
- [Identity and Access Management](#identity-and-access-management)
- [Data Protection](#data-protection)
- [Network Security](#network-security)
- [Application Security](#application-security)
- [API Security](#api-security)
- [Infrastructure Security](#infrastructure-security)
- [Compliance Framework](#compliance-framework)
- [Security Operations](#security-operations)
- [Threat Modeling](#threat-modeling)
- [Security Testing](#security-testing)
- [Incident Response](#incident-response)
- [Future Enhancements](#future-enhancements)
- [Appendix](#appendix)

## Introduction

This document describes the comprehensive security model implemented in the TuneMantra platform. It covers all aspects of security from architecture to operations, detailing the controls, processes, and technologies used to protect the platform, its users, and their data.

### Purpose and Scope

This document:

- Defines the security architecture of the TuneMantra platform
- Details security controls implemented across all system layers
- Describes security procedures for operations and incident response
- Outlines compliance mechanisms for regulatory requirements
- Serves as a reference for security audits and assessments

### Security Principles

TuneMantra's security model is built on these core principles:

1. **Defense in Depth**: Multiple layers of security controls
2. **Least Privilege**: Minimal access rights for every user and component
3. **Secure by Design**: Security built into the architecture from the beginning
4. **Zero Trust**: Verification of all access requests regardless of source
5. **Data-Centric Security**: Protection focused on securing the data itself
6. **Privacy by Design**: Privacy controls built into all processes
7. **Continuous Improvement**: Ongoing enhancement of security measures

### Critical Assets Protection

The security model prioritizes protection of these critical assets:

1. **User Authentication Credentials**: Account access information
2. **Financial Data**: Royalty, payment, and banking information
3. **Intellectual Property**: Music content and associated rights
4. **Personal Information**: User and artist data
5. **Business Logic**: Proprietary algorithms and processes
6. **Configuration Data**: System settings and environment information
7. **Access Controls**: Permission and authorization information

## Security Architecture

The security architecture provides a structured approach to protecting all aspects of the platform through layered defenses.

### High-Level Security Architecture

The security architecture consists of these core layers:

1. **Perimeter Security**: Edge protection and external boundary controls
2. **Network Security**: Protection of communication channels
3. **Host Security**: Operating system and infrastructure protection
4. **Application Security**: Protection of application components
5. **Data Security**: Protection of data at rest, in use, and in transit
6. **Identity Security**: Authentication and authorization controls

### Security Domains

Security is implemented across these domains:

1. **User Domain**: End-user devices and access points
2. **Service Domain**: Application services and APIs
3. **Data Domain**: Storage systems and databases
4. **Management Domain**: Administrative interfaces and tools
5. **Integration Domain**: External system connections
6. **Monitoring Domain**: Security monitoring and alerting

### Trust Boundaries

The system defines these trust boundaries:

1. **External Boundary**: Separates external users from the system
2. **Service Boundary**: Isolates each microservice
3. **Data Boundary**: Controls access to stored information
4. **Administrative Boundary**: Restricts management functions
5. **Tenant Boundary**: Separates different organizations
6. **Integration Boundary**: Controls external system interactions

### Security Controls Classification

Security controls are categorized as:

1. **Preventative Controls**: Block security incidents before they occur
2. **Detective Controls**: Identify security incidents as they happen
3. **Corrective Controls**: Mitigate the impact of security incidents
4. **Deterrent Controls**: Discourage potential attackers
5. **Recovery Controls**: Restore system function after incidents
6. **Compensating Controls**: Provide alternatives when primary controls aren't feasible

## Identity and Access Management

The identity and access management system provides comprehensive controls for authentication, authorization, and account management.

### Authentication System

The multi-layered authentication system includes:

1. **Primary Authentication**:
   - Password-based (with strong complexity requirements)
   - Social authentication (with identity verification)
   - Single sign-on (supporting SAML 2.0 and OpenID Connect)

2. **Multi-factor Authentication**:
   - Time-based one-time passwords (TOTP)
   - Push notifications to verified mobile devices
   - SMS verification (with fallbacks)
   - WebAuthn/FIDO2 support for hardware keys

3. **Authentication Policies**:
   - Risk-based authentication requirements
   - Location-based access controls
   - Device fingerprinting
   - Failed attempt limiting
   - Session timeout controls

4. **Session Management**:
   - Secure session token generation
   - Anti-hijacking measures
   - Concurrent session controls
   - Inactivity timeouts
   - Forced re-authentication for sensitive operations

### Authorization Framework

The fine-grained authorization system implements:

1. **Role-Based Access Control (RBAC)**:
   - Hierarchical role structure
   - Role inheritance
   - Separation of duties
   - Job-function alignment
   - Principle of least privilege

2. **Attribute-Based Access Control (ABAC)**:
   - Context-aware permissions
   - Dynamic access decisions
   - Environmental conditions
   - Time-based restrictions
   - Attribute combination logic

3. **Resource-Based Controls**:
   - Resource-level permissions
   - Content-specific access
   - Ownership-based controls
   - Organization boundary enforcement
   - Classification-based restrictions

4. **Policy Engine**:
   - Centralized policy definition
   - Real-time policy evaluation
   - Policy version control
   - Conflict resolution
   - Policy simulation and testing

### Identity Lifecycle Management

The system manages the complete identity lifecycle:

1. **Provisioning**:
   - Self-registration with verification
   - Administrative creation
   - Identity federation
   - Just-in-time provisioning
   - Bulk user creation

2. **Account Maintenance**:
   - Self-service profile management
   - Password reset mechanisms
   - Contact information verification
   - Recovery options management
   - Forced update for compliance

3. **Access Certification**:
   - Periodic access review
   - Manager attestation
   - Risk-based certification
   - Automated revocation
   - Exception handling

4. **Deprovisioning**:
   - Immediate access termination
   - Scheduled account removal
   - Data preservation options
   - Access history maintenance
   - Reactivation capabilities

### Directory Services

The user directory infrastructure provides:

1. **Centralized User Repository**:
   - Comprehensive user attributes
   - Extensible schema
   - High-availability design
   - Backup and recovery
   - Historical record preservation

2. **Organization Structure**:
   - Multi-level hierarchy support
   - Cross-organization relationships
   - Attribute inheritance
   - Organizational unit management
   - Dynamic group membership

3. **External Directory Integration**:
   - Active Directory/LDAP connectivity
   - Identity federation
   - Just-in-time provisioning
   - Attribute mapping
   - Authentication delegation

### Privileged Access Management

Special controls for administrative access include:

1. **Privileged Account Controls**:
   - Just-in-time elevation
   - Limited duration access
   - Approval workflows
   - Session recording
   - Enhanced monitoring

2. **Administrative Separation**:
   - Segregation of administrative roles
   - Multi-person approval requirements
   - Function-specific privileges
   - Emergency access procedures
   - Administrative audit trails

## Data Protection

Comprehensive data protection measures safeguard information throughout its lifecycle.

### Data Classification

The data classification framework includes:

1. **Sensitivity Levels**:
   - Public: Information without restrictions
   - Internal: Business information with limited distribution
   - Confidential: Sensitive business data requiring protection
   - Restricted: Highly sensitive data with stringent controls

2. **Classification Process**:
   - Automated classification
   - User-applied labels
   - Policy-based classification
   - Inheritance from containers
   - Regular classification review

3. **Handling Requirements**:
   - Classification-specific controls
   - Required protection measures
   - Sharing restrictions
   - Retention requirements
   - Disposal procedures

### Encryption Framework

Data encryption is implemented through:

1. **Encryption at Rest**:
   - Database-level encryption
   - Filesystem encryption
   - Object storage encryption
   - Hardware security module integration
   - Key rotation mechanisms

2. **Encryption in Transit**:
   - TLS 1.3 enforcement
   - Certificate management
   - Modern cipher requirements
   - Perfect forward secrecy
   - HSTS implementation

3. **End-to-End Encryption**:
   - Sensitive communications protection
   - Client-side encryption
   - Key management services
   - Secure key exchange
   - Key recovery mechanisms

4. **Key Management**:
   - Hardware security modules
   - Key lifecycle management
   - Segregation of duties
   - Key backup and recovery
   - Certificate authority management

### Data Loss Prevention

Data leakage is prevented through:

1. **Content Inspection**:
   - Pattern matching
   - Fingerprinting
   - Machine learning classification
   - Contextual analysis
   - Metadata examination

2. **Control Points**:
   - API gateway inspection
   - Email monitoring
   - Endpoint controls
   - Cloud application monitoring
   - Network monitoring

3. **Prevention Actions**:
   - Blocking unauthorized transfers
   - Quarantine capabilities
   - Automated encryption
   - User notification
   - Administrator alerting

### Privacy Controls

Privacy protection includes:

1. **Personal Data Handling**:
   - Minimization of collection
   - Purpose limitation
   - Consent management
   - Data subject rights support
   - Special category handling

2. **Anonymization/Pseudonymization**:
   - Irreversible anonymization techniques
   - Pseudonymization for processing
   - Re-identification prevention
   - Aggregation methods
   - Synthetic data generation

3. **Cross-border Controls**:
   - Geographic data restrictions
   - Adequacy determination
   - Transfer impact assessment
   - Standard contractual clauses
   - Binding corporate rules

### Secure Data Lifecycle

Data is protected throughout its lifecycle through:

1. **Secure Creation**:
   - Classification at creation
   - Automatic protection application
   - Creator attribution
   - Lineage tracking
   - Initial access control

2. **Secure Storage**:
   - Appropriate security controls
   - Redundancy for availability
   - Backup integration
   - Tamper protection
   - Secure deletion capability

3. **Secure Processing**:
   - Memory protection
   - Processing isolation
   - Temporary data protection
   - Access monitoring
   - Security in compute

4. **Secure Archiving**:
   - Long-term integrity
   - Accessibility preservation
   - Classification maintenance
   - Retrieval controls
   - Compliance preservation

5. **Secure Deletion**:
   - Complete removal
   - Verification process
   - Hardware destruction where needed
   - Certificate of destruction
   - Deletion audit trail

## Network Security

Multiple layers of network protection safeguard communications and prevent unauthorized access.

### Network Architecture

The secure network design includes:

1. **Network Segmentation**:
   - Separate security zones
   - Microsegmentation
   - Virtual network isolation
   - Purpose-specific subnets
   - Cross-zone traffic controls

2. **Defense in Depth**:
   - Multiple security layers
   - Overlapping protection
   - Independent control mechanisms
   - Diverse security technologies
   - Redundant protection paths

3. **Security Zones**:
   - Internet-facing DMZ
   - Application services zone
   - Database zone
   - Management zone
   - Internal services zone

### Perimeter Protection

Edge security includes:

1. **DDoS Protection**:
   - Volumetric attack mitigation
   - Application layer protection
   - Traffic scrubbing
   - Rate limiting
   - Resource preservation

2. **Web Application Firewall**:
   - OWASP protection
   - Custom rule sets
   - Anomaly detection
   - Bot protection
   - API abuse prevention

3. **Network Firewall**:
   - Stateful packet inspection
   - Next-generation capabilities
   - Traffic filtering
   - Protocol validation
   - Virtual private networking

### Traffic Management

Network traffic control includes:

1. **Load Balancing**:
   - Traffic distribution
   - Health checking
   - SSL termination
   - Application-aware routing
   - Rate limiting

2. **API Gateway**:
   - Request validation
   - Traffic management
   - Authentication enforcement
   - Rate limiting
   - Request/response transformation

3. **Content Delivery Network**:
   - Edge caching
   - DDoS protection
   - Geographic distribution
   - SSL offloading
   - Edge security

### Internal Network Security

Internal protection includes:

1. **Internal Firewalls**:
   - Zone separation
   - Lateral movement prevention
   - Microsegmentation
   - Service isolation
   - Traffic monitoring

2. **Network Access Control**:
   - Device authentication
   - Health validation
   - Policy enforcement
   - Device quarantine
   - Guest network isolation

3. **Zero Trust Network Access**:
   - Identity-based authentication
   - Device validation
   - Continuous verification
   - Least privilege access
   - Session monitoring

### Cloud Network Security

Cloud-specific controls include:

1. **Virtual Network Security**:
   - Software-defined networking
   - Private connectivity
   - Virtual network peering
   - Service endpoints
   - Private link services

2. **Cloud Access Security**:
   - Cloud service protection
   - Identity-aware access
   - Service-specific controls
   - Multi-cloud security
   - Cloud security posture management

## Application Security

Comprehensive application security measures protect the platform from design through implementation.

### Secure Development Lifecycle

Security is integrated into development through:

1. **Security Requirements**:
   - Threat modeling
   - Security user stories
   - Compliance requirements
   - Business risk assessment
   - Technical risk assessment

2. **Secure Design**:
   - Security architecture review
   - Design pattern selection
   - Attack surface analysis
   - Trust boundary identification
   - Authentication and authorization design

3. **Secure Implementation**:
   - Secure coding standards
   - Code security analysis
   - Dependency scanning
   - Manual code review
   - Security unit testing

4. **Security Testing**:
   - Dynamic application security testing
   - Static application security testing
   - Interactive application security testing
   - Penetration testing
   - Fuzz testing

5. **Security Deployment**:
   - Secure configuration
   - Secret management
   - Hardening standards
   - Vulnerability scanning
   - Deployment verification

### Web Application Security

Web protection includes:

1. **Input Validation**:
   - Parameter validation
   - Content type verification
   - Schema validation
   - Sanitization
   - Canonicalization

2. **Output Encoding**:
   - Context-aware encoding
   - XSS prevention
   - Header security
   - Content Security Policy
   - Safe rendering patterns

3. **Session Security**:
   - Secure session management
   - Anti-hijacking measures
   - Token protection
   - Cookie security
   - CSRF protection

4. **Authentication Security**:
   - Secure credential handling
   - Brute force protection
   - Multi-factor options
   - Account recovery security
   - Authentication feedback

5. **Client-side Security**:
   - Secure JavaScript practices
   - Browser security headers
   - Subresource Integrity
   - Safe dependency management
   - Frontend vulnerability scanning

### API Security

API protection includes:

1. **API Authentication**:
   - OAuth 2.0 implementation
   - API key management
   - Token validation
   - Certificate-based authentication
   - Mutual TLS

2. **API Authorization**:
   - Scope-based permissions
   - Fine-grained access control
   - Token inspection
   - Role-based permissions
   - Context-aware authorization

3. **Request Validation**:
   - Schema validation
   - Parameter checking
   - Rate limiting
   - Size constraints
   - Content validation

4. **Response Security**:
   - Data minimization
   - Appropriate status codes
   - Error handling security
   - Response filtering
   - Information leakage prevention

5. **API Gateway Protection**:
   - Traffic management
   - Request inspection
   - Bot detection
   - API abuse prevention
   - Anomaly detection

### Security Features

Security functionality includes:

1. **Secure File Handling**:
   - File type validation
   - Virus scanning
   - Content verification
   - Metadata stripping
   - Safe storage

2. **Cryptography**:
   - Modern algorithm selection
   - Secure implementation
   - Library validation
   - Key management
   - Crypto agility

3. **Error Handling**:
   - Security-conscious errors
   - Information disclosure prevention
   - Graceful failure
   - Appropriate logging
   - User feedback security

4. **Audit Logging**:
   - Comprehensive event capture
   - Tamper-evident logging
   - Secure transmission
   - Standardized format
   - Retention management

### Dependency Management

Third-party component security includes:

1. **Dependency Scanning**:
   - Vulnerability detection
   - License compliance
   - Version management
   - Transitive dependency analysis
   - Dependency health monitoring

2. **Supply Chain Security**:
   - Vendor security assessment
   - Provenance verification
   - Build integrity validation
   - Artifact signing
   - Bill of materials maintenance

3. **Update Management**:
   - Vulnerability patching
   - Dependency lifecycle management
   - Deprecation handling
   - Breaking change assessment
   - Automatic update pipelines

## API Security

Specialized controls protect the platform's API infrastructure, which serves as the primary interface for integrations.

### API Gateway Security

The API gateway provides:

1. **Traffic Control**:
   - Request rate limiting
   - Quota management
   - Traffic shaping
   - Circuit breaking
   - Load shedding

2. **Request Validation**:
   - Schema validation
   - Parameter sanitization
   - Content type verification
   - Size limitation
   - Header validation

3. **Authentication Enforcement**:
   - Credential validation
   - Token verification
   - Certificate validation
   - API key management
   - Multi-factor coordination

4. **Request Processing**:
   - Request transformation
   - Sensitive data filtering
   - Header normalization
   - Canonical request formatting
   - Protocol conversion

5. **Monitoring and Analytics**:
   - Usage tracking
   - Anomaly detection
   - Error rate monitoring
   - Performance measurement
   - Availability tracking

### OAuth 2.0 Implementation

The OAuth 2.0 framework includes:

1. **Grant Types**:
   - Authorization code with PKCE
   - Client credentials
   - Resource owner password (limited cases)
   - Refresh token
   - Device authorization

2. **Token Security**:
   - JWT signing and encryption
   - Short-lived access tokens
   - Audience validation
   - Token binding
   - Scope restriction

3. **Authorization Server**:
   - Secure client registration
   - Token issuance security
   - Token introspection
   - Token revocation
   - Authorization code security

4. **OpenID Connect**:
   - Identity token issuance
   - Claims management
   - UserInfo endpoint
   - Subject identifier management
   - Session management

### API Versioning and Lifecycle

API evolution is managed through:

1. **Version Control**:
   - Semantic versioning
   - Version compatibility
   - Deprecation policy
   - Version sunset planning
   - Migration support

2. **Documentation**:
   - OpenAPI specification
   - Security requirements
   - Authentication documentation
   - Example secure usage
   - Error response documentation

3. **Change Management**:
   - Breaking change identification
   - Backward compatibility
   - Security enhancement introduction
   - Notification process
   - Transition period

### API Access Control

API-specific access controls include:

1. **API Permissions**:
   - Operation-level permissions
   - Resource-based access
   - Scope-based authorization
   - Content filtering
   - Field-level security

2. **Application Registration**:
   - Developer onboarding
   - Application verification
   - Purpose limitation
   - Usage monitoring
   - Terms enforcement

3. **Partner-specific Controls**:
   - Partner authentication
   - Custom rate limits
   - Enhanced capabilities
   - Specialized endpoints
   - Partner monitoring

### API Threat Protection

API-specific threat mitigation includes:

1. **Attack Detection**:
   - Injection attack identification
   - Parameter tampering
   - Protocol abuse
   - Resource exhaustion attempts
   - Business logic abuse

2. **Bot Management**:
   - Bot identification
   - Good bot allowlisting
   - Bad bot blocking
   - CAPTCHA integration
   - Behavioral analysis

3. **Anomaly Detection**:
   - Unusual request patterns
   - Abnormal data access
   - Geographic anomalies
   - Timing analysis
   - Volume monitoring

## Infrastructure Security

Comprehensive security controls protect the underlying infrastructure hosting the platform.

### Cloud Security

Cloud infrastructure protection includes:

1. **Identity and Access Management**:
   - Cloud IAM configuration
   - Role-based access
   - Just-in-time privileges
   - Service account management
   - Cross-cloud identity federation

2. **Resource Protection**:
   - Secure configuration
   - Cloud security posture management
   - Infrastructure as Code security
   - Resource tagging and inventory
   - Compliance validation

3. **Network Security**:
   - Virtual network segmentation
   - Cloud firewall configuration
   - Private connectivity
   - Service endpoints
   - DDoS protection

4. **Data Protection**:
   - Storage encryption
   - Key management
   - Secure access methods
   - Backup security
   - Deletion verification

5. **Monitoring and Logging**:
   - Cloud audit logging
   - Resource monitoring
   - Activity tracking
   - Threat detection
   - Security information and event management

### Containerization Security

Container protection includes:

1. **Image Security**:
   - Base image security
   - Vulnerability scanning
   - Image signing
   - Image registry security
   - Minimal image design

2. **Container Runtime Security**:
   - Runtime protection
   - Immutable containers
   - Privileged container prevention
   - Resource limitations
   - Capability restrictions

3. **Orchestration Security**:
   - Kubernetes security configuration
   - Network policy enforcement
   - Pod security standards
   - Secret management
   - Admission control

4. **Container Monitoring**:
   - Runtime monitoring
   - Behavioral analysis
   - Anomaly detection
   - Compliance verification
   - Vulnerability management

### Infrastructure as Code Security

IaC security includes:

1. **Secure Development**:
   - Code security scanning
   - Policy as code
   - Security testing
   - Version control
   - Peer review

2. **Deployment Security**:
   - Pipeline security controls
   - Approval workflows
   - Drift detection
   - Change validation
   - Rollback capability

3. **Configuration Management**:
   - Secure default configurations
   - Configuration validation
   - Compliance verification
   - Secrets management
   - Immutable infrastructure

### Server Security

Host-level security includes:

1. **Operating System Hardening**:
   - Minimal installation
   - Security configuration
   - Unnecessary service removal
   - Kernel hardening
   - File system security

2. **Endpoint Protection**:
   - Anti-malware
   - Host-based firewall
   - File integrity monitoring
   - Application control
   - Exploit prevention

3. **Patch Management**:
   - Vulnerability scanning
   - Critical patch application
   - Patch testing
   - Update automation
   - Compliance reporting

4. **Access Control**:
   - Privileged access management
   - SSH hardening
   - MFA for server access
   - Bastion host architecture
   - Just-in-time access

## Compliance Framework

The platform maintains compliance with relevant regulations and standards through a comprehensive framework.

### Regulatory Compliance

The platform addresses these key regulations:

1. **Data Protection**:
   - GDPR (General Data Protection Regulation)
   - CCPA/CPRA (California Consumer Privacy Act)
   - LGPD (Brazil General Data Protection Law)
   - Global privacy regulations

2. **Financial Compliance**:
   - PCI DSS (Payment Card Industry Data Security Standard)
   - SOX (Sarbanes-Oxley Act)
   - Regional financial regulations

3. **Industry-specific**:
   - DMCA (Digital Millennium Copyright Act)
   - Copyright directives
   - Music licensing regulations
   - Digital rights management requirements

### Standards Adherence

The platform follows these security standards:

1. **ISO Standards**:
   - ISO/IEC 27001 (Information Security Management)
   - ISO/IEC 27017 (Cloud Security)
   - ISO/IEC 27018 (Cloud Privacy)
   - ISO/IEC 27701 (Privacy Information Management)

2. **Industry Standards**:
   - NIST Cybersecurity Framework
   - NIST 800-53 security controls
   - CIS Controls
   - OWASP Application Security Verification Standard

3. **Cloud Security**:
   - Cloud Security Alliance STAR
   - Cloud Controls Matrix
   - Well-Architected frameworks

### Compliance Controls

Compliance is maintained through:

1. **Policy Framework**:
   - Information security policies
   - Data protection policies
   - Acceptable use policies
   - Risk management policies
   - Compliance policies

2. **Control Implementation**:
   - Technical controls
   - Administrative controls
   - Physical controls
   - Compensating controls
   - Detective controls

3. **Assessment Program**:
   - Internal audits
   - External assessments
   - Vulnerability management
   - Penetration testing
   - Compliance monitoring

4. **Documentation**:
   - Control documentation
   - Evidence collection
   - Audit trail maintenance
   - Compliance reporting
   - Policy attestation

### Privacy Program

The privacy framework includes:

1. **Privacy Governance**:
   - Privacy office
   - Data protection officer
   - Privacy policies
   - Privacy impact assessment
   - Privacy by design

2. **Data Subject Rights**:
   - Access request handling
   - Correction mechanisms
   - Deletion capabilities
   - Portability support
   - Consent management

3. **Cross-border Data Transfers**:
   - Transfer impact assessment
   - Adequacy mechanisms
   - Standard contractual clauses
   - Binding corporate rules
   - Certification frameworks

4. **Privacy Controls**:
   - Data minimization
   - Purpose limitation
   - Storage limitation
   - Data accuracy measures
   - De-identification techniques

## Security Operations

Operational security processes ensure ongoing protection of the platform and rapid response to security events.

### Security Monitoring

Continuous monitoring includes:

1. **Security Information and Event Management**:
   - Log collection
   - Event correlation
   - Anomaly detection
   - Alert generation
   - Incident triggering

2. **Threat Detection**:
   - Signature-based detection
   - Behavioral analysis
   - Machine learning models
   - Threat intelligence integration
   - User and entity behavior analytics

3. **Monitoring Coverage**:
   - Network traffic
   - System logs
   - Application logs
   - Authentication events
   - Cloud resource activity
   - Database activity

4. **Alert Management**:
   - Alert prioritization
   - False positive reduction
   - Alert escalation
   - Notification routing
   - Response tracking

### Vulnerability Management

Ongoing vulnerability handling includes:

1. **Vulnerability Scanning**:
   - Network scanning
   - Web application scanning
   - Container scanning
   - Cloud configuration scanning
   - Code scanning

2. **Patch Management**:
   - Vulnerability assessment
   - Patch prioritization
   - Testing process
   - Deployment automation
   - Verification

3. **Risk Assessment**:
   - Vulnerability scoring
   - Business impact analysis
   - Exploitation likelihood
   - Remediation planning
   - Acceptance criteria

4. **Remediation Process**:
   - Fix development
   - Implementation planning
   - Change management
   - Verification testing
   - Risk reassessment

### Security Awareness

Security culture is fostered through:

1. **Training Program**:
   - Onboarding security training
   - Role-specific training
   - Developer security training
   - Compliance training
   - Refresher courses

2. **Awareness Campaigns**:
   - Phishing simulations
   - Security newsletters
   - Awareness events
   - Security champions
   - Executive communications

3. **Policy Communication**:
   - Policy distribution
   - Acceptable use acknowledgment
   - Policy updates notification
   - Compliance reminders
   - Consequence awareness

### Third-party Risk Management

External risk is managed through:

1. **Vendor Assessment**:
   - Security questionnaires
   - Control validation
   - Compliance verification
   - Service level agreements
   - Right to audit

2. **Continuous Monitoring**:
   - Vendor security ratings
   - Threat intelligence monitoring
   - Breach notification handling
   - Performance measurement
   - Compliance maintenance

3. **Integration Security**:
   - Connection security
   - Data exchange protection
   - Authentication and authorization
   - Monitoring and logging
   - Change management

## Threat Modeling

Systematic threat modeling identifies and addresses security risks throughout the platform.

### Threat Modeling Methodology

The threat modeling process includes:

1. **System Decomposition**:
   - Component identification
   - Data flow mapping
   - Trust boundary identification
   - Entry point analysis
   - Privilege levels

2. **Threat Identification**:
   - STRIDE categorization
   - Attack tree analysis
   - Attack vector identification
   - Threat library utilization
   - Attack surface analysis

3. **Risk Assessment**:
   - Impact evaluation
   - Likelihood determination
   - Risk scoring
   - Risk prioritization
   - Acceptance criteria

4. **Mitigation Planning**:
   - Control identification
   - Design adjustments
   - Implementation recommendations
   - Verification methods
   - Residual risk assessment

### Common Threats

Key threats addressed include:

1. **Authentication Threats**:
   - Credential theft
   - Brute force attacks
   - Session hijacking
   - Authentication bypass
   - Multi-factor compromise

2. **Authorization Threats**:
   - Privilege escalation
   - Insecure direct object references
   - Missing function-level access control
   - Horizontal privilege escalation
   - JWT attacks

3. **Data Protection Threats**:
   - Data exfiltration
   - Unauthorized access
   - Data tampering
   - Cryptographic weaknesses
   - Key management failures

4. **API Threats**:
   - API abuse
   - Parameter tampering
   - Schema validation bypass
   - Race conditions
   - Business logic abuse

5. **Infrastructure Threats**:
   - Service misconfiguration
   - Container escape
   - Insecure defaults
   - Unnecessary services
   - Component vulnerabilities

### Threat Modeling by Component

Threat models are developed for:

1. **Authentication System**:
   - Login process
   - MFA implementation
   - Password reset
   - Session management
   - API authentication

2. **Payment Processing**:
   - Payment capture
   - Payment distribution
   - Financial data storage
   - Payment provider integration
   - Reconciliation process

3. **Content Distribution**:
   - Content upload
   - Metadata processing
   - Platform delivery
   - Content protection
   - Takedown processes

4. **Administrative Functions**:
   - User management
   - System configuration
   - Access control management
   - Report generation
   - Audit functions

## Security Testing

Comprehensive testing verifies the effectiveness of security controls and identifies vulnerabilities.

### Testing Methodology

The security testing program includes:

1. **Testing Types**:
   - Static application security testing (SAST)
   - Dynamic application security testing (DAST)
   - Interactive application security testing (IAST)
   - Software composition analysis (SCA)
   - Penetration testing
   - Red team exercises

2. **Testing Frequency**:
   - Continuous integration testing
   - Pre-release testing
   - Periodic scheduled testing
   - Post-incident testing
   - Change-triggered testing

3. **Testing Scope**:
   - Authentication and authorization
   - Data protection
   - API security
   - Infrastructure security
   - Network security
   - Application security

4. **Testing Process**:
   - Preparation and planning
   - Test execution
   - Result analysis
   - Vulnerability validation
   - Remediation tracking

### Penetration Testing

External security validation includes:

1. **Testing Approach**:
   - Black box testing
   - Gray box testing
   - White box testing
   - Red team simulation
   - Purple team exercises

2. **Testing Areas**:
   - Web application testing
   - API security testing
   - Network infrastructure testing
   - Cloud configuration testing
   - Social engineering testing

3. **Testing Methodology**:
   - OWASP testing guide
   - NIST penetration testing framework
   - PTES (Penetration Testing Execution Standard)
   - Custom test scenarios
   - Industry-specific testing

4. **Reporting and Remediation**:
   - Vulnerability severity rating
   - Exploitation proof of concept
   - Remediation recommendations
   - Retest verification
   - Executive summary

### Automated Security Testing

Continuous testing includes:

1. **CI/CD Integration**:
   - Pipeline security checks
   - Automated vulnerability scanning
   - Dependency analysis
   - Secret detection
   - Configuration validation

2. **Code Analysis**:
   - Static code analysis
   - Code quality checks
   - Custom rule development
   - Vulnerability pattern detection
   - Security anti-patterns

3. **Infrastructure Testing**:
   - Configuration compliance checking
   - Cloud security posture assessment
   - Container security scanning
   - Infrastructure as Code validation
   - Network security verification

## Incident Response

Structured processes ensure effective response to security incidents and minimize their impact.

### Incident Response Plan

The incident response framework includes:

1. **Response Phases**:
   - Preparation
   - Detection and analysis
   - Containment
   - Eradication
   - Recovery
   - Post-incident activity

2. **Response Team**:
   - Security operations
   - Technical specialists
   - Management representatives
   - Legal counsel
   - Communications personnel
   - External expertise

3. **Incident Classification**:
   - Severity levels
   - Impact assessment
   - Response prioritization
   - Escalation criteria
   - Notification requirements

4. **Response Procedures**:
   - Initial assessment
   - Evidence collection
   - Containment strategy
   - Investigation process
   - Communication protocols
   - Recovery operations

### Breach Management

Data breach handling includes:

1. **Breach Identification**:
   - Data exposure detection
   - Unauthorized access identification
   - Exfiltration detection
   - Breach scope determination
   - Impact assessment

2. **Containment and Mitigation**:
   - Access termination
   - System isolation
   - Vulnerability remediation
   - Credential rotation
   - Recovery plan execution

3. **Notification Process**:
   - Legal requirements determination
   - Regulatory reporting
   - Customer notification
   - Partner communication
   - Public disclosure

4. **Post-breach Activities**:
   - Forensic investigation
   - Root cause analysis
   - Control improvement
   - Monitoring enhancement
   - Documentation update

### Incident Playbooks

Pre-defined response plans include:

1. **Malware Response**:
   - Identification and isolation
   - Malware analysis
   - System cleaning
   - Recovery procedures
   - Re-infection prevention

2. **Account Compromise**:
   - Access termination
   - Credential reset
   - Activity investigation
   - Damage assessment
   - Account recovery

3. **Data Breach**:
   - Containment actions
   - Exposure assessment
   - Notification process
   - Regulatory compliance
   - Evidence preservation

4. **Denial of Service**:
   - Attack characterization
   - Traffic filtering
   - Service restoration
   - Architecture hardening
   - Post-attack analysis

5. **API Abuse**:
   - Attack pattern identification
   - Rate limiting implementation
   - IP blocking
   - Authentication review
   - Monitoring enhancement

### Incident Drills

Readiness is maintained through:

1. **Tabletop Exercises**:
   - Scenario-based discussions
   - Role-playing
   - Decision-making practice
   - Response evaluation
   - Plan refinement

2. **Technical Drills**:
   - Simulated attacks
   - Response procedure testing
   - Tool verification
   - Recovery testing
   - Communication testing

3. **Full-scale Exercises**:
   - Realistic scenario execution
   - Cross-functional participation
   - External coordination
   - Complete process validation
   - Comprehensive assessment

## Future Enhancements

The security model continues to evolve with planned enhancements and emerging technology adoption.

### Security Roadmap

Upcoming security improvements include:

1. **Zero Trust Implementation**:
   - Complete network redesign
   - Identity-centric security
   - Continuous verification
   - Least privilege access
   - Micro-segmentation

2. **AI Security Enhancement**:
   - Machine learning for threat detection
   - Behavioral analysis
   - Anomaly identification
   - Automated response
   - Predictive security

3. **Cloud Security Evolution**:
   - Multi-cloud security strategy
   - Cloud-native security controls
   - Serverless security
   - Container security enhancement
   - Cloud workload protection

4. **Privacy Enhancement**:
   - Advanced anonymization
   - Privacy-enhancing technologies
   - Data sovereignty solutions
   - Consent management improvements
   - Privacy rights automation

### Emerging Technology Assessment

Evaluation of new security technologies includes:

1. **Quantum Computing Impact**:
   - Post-quantum cryptography
   - Algorithm migration
   - Key exchange protocols
   - Quantum threat assessment
   - Quantum-resistant standards

2. **Blockchain Security**:
   - Distributed identity solutions
   - Immutable audit logging
   - Smart contract security
   - Token-based authorization
   - Decentralized security models

3. **Edge Computing Security**:
   - Distributed security controls
   - Local security enforcement
   - Edge-specific protection
   - Disconnected operation security
   - Edge device management

4. **DevSecOps Evolution**:
   - Security as code
   - Automated compliance verification
   - Continuous security validation
   - Security telemetry integration
   - Developer security empowerment

## Appendix

### Cryptographic Standards

Approved cryptographic algorithms include:

1. **Symmetric Encryption**:
   - AES-256 (GCM/CBC modes)
   - ChaCha20-Poly1305

2. **Asymmetric Encryption**:
   - RSA (3072-bit minimum)
   - ECC (P-256, P-384, P-521)

3. **Hashing Algorithms**:
   - SHA-256, SHA-384, SHA-512
   - BLAKE2

4. **Key Exchange**:
   - ECDHE
   - DH (3072-bit minimum)

5. **Digital Signatures**:
   - RSA-PSS
   - ECDSA
   - Ed25519

### Security Responsibilities

Security roles and responsibilities:

1. **Security Team**:
   - Security architecture
   - Policy development
   - Control implementation
   - Vulnerability management
   - Incident response

2. **Development Team**:
   - Secure coding
   - Security testing
   - Vulnerability remediation
   - Security feature implementation
   - Security requirements adherence

3. **Operations Team**:
   - Secure configuration
   - Patch management
   - Monitoring
   - Incident detection
   - Security tool operation

4. **Management**:
   - Risk acceptance
   - Resource allocation
   - Policy approval
   - Compliance oversight
   - Security program direction

### Security Tools

Key security tools deployed include:

1. **Vulnerability Management**:
   - Qualys
   - Tenable
   - Rapid7

2. **SIEM Solution**:
   - Splunk
   - Azure Sentinel
   - Elastic Security

3. **Application Security**:
   - Checkmarx
   - SonarQube
   - OWASP ZAP

4. **Container Security**:
   - Aqua Security
   - Twistlock
   - Docker Bench

5. **Cloud Security**:
   - Cloud Security Posture Management
   - Cloud Workload Protection
   - Cloud Access Security Broker

### Reference Documents

Related security documentation:

1. **Policy Documents**:
   - Information Security Policy
   - Data Protection Policy
   - Acceptable Use Policy
   - Incident Response Policy
   - Access Control Policy

2. **Process Documents**:
   - Vulnerability Management Procedure
   - Incident Response Procedure
   - Change Management Process
   - Access Review Process
   - Data Handling Procedure

3. **Technical Standards**:
   - Password Requirements
   - Encryption Standards
   - Network Security Standards
   - Cloud Security Standards
   - Application Security Standards

4. **Compliance Documents**:
   - Regulatory Compliance Matrix
   - Control Framework Mapping
   - Audit Evidence Catalog
   - Risk Assessment Methodology
   - Compliance Monitoring Approach

---

© 2023-2025 TuneMantra. All rights reserved.# TuneMantra Security Model

## Overview

This document outlines the security model implemented in the TuneMantra platform. It covers authentication, authorization, data protection, and other security considerations.

## Authentication and Authorization

TuneMantra implements a robust authentication and authorization system:

- **JWT-based authentication**: Secure token-based authentication with appropriate expiration and refresh mechanisms
- **Role-based access control**: Granular permissions based on user roles
- **Multi-factor authentication**: Optional 2FA for sensitive operations
- **Password policies**: Strong password requirements and regular rotation

## Data Protection

Data protection measures include:

- **Encryption at rest**: All sensitive data is encrypted in the database
- **Encryption in transit**: All API communication uses TLS
- **Data masking**: Sensitive data is masked in logs and non-essential views
- **Secure key management**: Cryptographic keys are securely stored and rotated

## API Security

API security measures include:

- **Input validation**: All API inputs are validated using Zod schemas
- **Rate limiting**: Protection against brute force attacks
- **CSRF protection**: Cross-site request forgery prevention
- **API key management**: Secure handling of API keys for external services

## Blockchain Security

Blockchain-specific security measures include:

- **Secure wallet management**: Proper handling of private keys
- **Transaction validation**: Multiple validation layers for blockchain transactions
- **Smart contract security**: Audited smart contracts with security best practices
- **Cryptographic signature verification**: Secure verification of rights ownership

## Infrastructure Security

Infrastructure security measures include:

- **Network segmentation**: Proper separation of network components
- **Intrusion detection**: Monitoring for unauthorized access attempts
- **DDOS protection**: Mitigation measures for distributed denial of service attacks
- **Regular security scans**: Automated vulnerability scanning

## Compliance

TuneMantra complies with relevant security standards:

- **GDPR compliance**: Data protection measures in line with EU regulations
- **SOC 2 principles**: Security, availability, processing integrity, confidentiality, and privacy
- **Regular audits**: Third-party security audits

## Security Procedures

Detailed procedures for security operations can be found in the [Security Procedures](operations/security-procedures.md) document.

---

## documentation/technical/security/security-overview.md

# Security Implementation Documentation

## Overview

The TuneMantra platform implements a comprehensive security strategy to protect user data, intellectual property, and financial information. This document outlines the security measures implemented across the application stack.

## Authentication and Authorization

### Authentication Mechanisms

1. **Session-based Authentication**
   - Uses Express-session with PostgreSQL session store
   - Sessions are persistent across server restarts
   - Session cookies are HttpOnly to prevent JavaScript access
   - Session expiration is enforced (30 days by default)

2. **Password Security**
   - Password hashing using scrypt (cryptographically secure key derivation function)
   - Salt generation for each password to prevent rainbow table attacks
   - Support for BCrypt format for legacy compatibility
   - Secure password comparison to prevent timing attacks

3. **API Key Authentication**
   - Unique API keys for programmatic access
   - Keys are scoped to specific permissions
   - Keys can be rotated and revoked by users
   - Key expiration can be set for time-limited access

### Authorization Systems

1. **Role-Based Access Control (RBAC)**
   - User roles include: admin, label, artist_manager, artist, team_member
   - Each role has predefined permissions
   - Routes are protected based on role requirements

2. **Permission System**
   - Fine-grained permissions beyond role-based access
   - Custom permission templates can be created and assigned
   - Permissions are stored as JSON and validated on requests

3. **Multi-tenant Isolation**
   - Users can only access their own resources
   - Label owners can access their artists' resources
   - Artist managers can access their managed artists' resources

4. **Middleware Protection**
   - `requireAuth` middleware ensures authentication
   - Role-specific middlewares (e.g., `requireAdmin`)
   - Resource ownership validation middleware

## Data Security

### Database Security

1. **Connection Security**
   - PostgreSQL connection over SSL/TLS
   - Connection pooling for secure reuse
   - Environment variable-based configuration

2. **Query Security**
   - Parameterized queries to prevent SQL injection
   - Type-safe queries using Drizzle ORM
   - Input validation before database operations

3. **Sensitive Data Storage**
   - Passwords are hashed, never stored in plaintext
   - Payment details are encrypted or tokenized
   - API credentials are stored securely

### API Security

1. **Input Validation**
   - Zod schema validation for all inputs
   - Validation middleware for routes
   - File upload validation for size and type

2. **Output Sanitization**
   - Sensitive fields are removed from responses
   - Data is filtered based on user permissions
   - XSS prevention in API responses

3. **HTTP Security Headers**
   - Content-Security-Policy
   - X-Content-Type-Options
   - X-Frame-Options
   - Referrer-Policy
   - Implemented using Helmet.js

## Network Security

1. **HTTPS Enforcement**
   - All production traffic uses HTTPS
   - HSTS headers for secure connection enforcement
   - Secure cookie settings in production

2. **Rate Limiting**
   - API rate limiting to prevent brute force and DoS attacks
   - IP-based and user-based rate limits
   - Increasing backoff for repeated failures

3. **CORS Policy**
   - Restrictive CORS policy for API endpoints
   - Allows only trusted origins in production
   - Credentials allowed only from trusted origins

## Audit and Logging

1. **Activity Logging**
   - User login/logout events
   - Critical data modifications
   - API key usage tracking
   - Admin actions logging

2. **Audit Trails**
   - `subLabelAuditLogs` table tracks sub-label changes
   - Captures who made changes and what was changed
   - Stores previous and new values for comparison

3. **Error Logging**
   - Structured error logging
   - Stack traces in development only
   - Client-safe error messages in production

## Vulnerability Prevention

1. **Dependency Security**
   - Regular updates of dependencies
   - Security vulnerability scanning
   - Minimal dependency approach

2. **XSS Prevention**
   - Content security policy configuration
   - Input sanitization and validation
   - React's built-in XSS protection
   - XSS filtering library for user content

3. **CSRF Protection**
   - CSRF token validation for state-changing operations
   - SameSite cookie settings
   - Origin verification

4. **Injection Prevention**
   - SQL injection prevention through parameterized queries
   - NoSQL injection prevention in JSON operations
   - Command injection prevention in system calls

## File Upload Security

1. **File Validation**
   - File type validation based on content (MIME) type
   - Size limits for different file types
   - Maximum file count per user

2. **Storage Security**
   - Files stored outside the web root
   - Randomized filenames to prevent guessing
   - Validation before serving files

3. **Content Scanning**
   - Malware scanning for uploaded files
   - Audio file validation for music tracks
   - Image safety verification

## Financial Security

1. **Payment Processing**
   - Integration with secure payment providers
   - PCI compliance considerations
   - Tokenization of payment methods

2. **Royalty Calculations**
   - Audit trails for all royalty calculations
   - Transparent split payments with verification
   - Multi-step approval for large payments

3. **Withdrawal Security**
   - Verification steps for withdrawal requests
   - Limits and thresholds to prevent fraud
   - Notification of withdrawal events

## Infrastructure Security

1. **Deployment Security**
   - Secure environment variable management
   - Production vs. development configuration
   - Database migration safety

2. **Server Configuration**
   - Restrictive file permissions
   - Principle of least privilege
   - Regular security updates

3. **Monitoring**
   - Error rate monitoring
   - Authentication failure monitoring
   - Unusual traffic patterns detection

## Security Disclosure Policy

TuneMantra has an established security disclosure policy:

1. **Vulnerability Reporting**
   - Secure channel for reporting vulnerabilities
   - Responsible disclosure timeline
   - Recognition for security researchers

2. **Incident Response**
   - Documented incident response plan
   - User notification procedures
   - Post-incident analysis process

3. **Regular Security Reviews**
   - Periodic security audits
   - Penetration testing
   - Code review for security issues

## Implementation Examples

### Password Hashing Implementation

```typescript
// Hash a password for secure storage
export async function hashPassword(password: string): Promise<string> {
  // Generate a random salt
  const salt = randomBytes(16).toString('hex');
  
  // Hash the password with the salt using scrypt
  const hash = await scryptAsync(password, salt, 64);
  
  // Return the hash and salt combined as a single string
  return `${hash.toString('hex')}.${salt}`;
}

// Compare a supplied password with a stored hashed password
async function comparePasswords(supplied: string, stored: string): Promise<boolean> {
  // Handle multiple password formats
  
  // Format: "hashed.salt" (scrypt)
  if (stored.includes('.')) {
    const [hashedPassword, salt] = stored.split('.');
    const suppliedHash = await scryptAsync(supplied, salt, 64);
    return timingSafeEqual(
      Buffer.from(hashedPassword, 'hex'),
      suppliedHash
    );
  }
  
  // Format: "salt:hashed" (legacy)
  if (stored.includes(':')) {
    const [salt, hashedPassword] = stored.split(':');
    const suppliedHash = await scryptAsync(supplied, salt, 64);
    return timingSafeEqual(
      Buffer.from(hashedPassword, 'hex'),
      suppliedHash
    );
  }
  
  // Format: "$2b$..." (bcrypt)
  if (stored.startsWith('$2b$')) {
    return bcrypt.compare(supplied, stored);
  }
  
  // Unknown format
  return false;
}
```

### Authentication Middleware

```typescript
// Authentication middleware for protected routes
export const requireAuth = (req: Request, res: Response, next: NextFunction) => {
  // Check if user is authenticated via session
  if (!req.isAuthenticated() || !req.user) {
    return res.status(401).json({
      error: {
        message: 'Authentication required',
        code: 'AUTH_REQUIRED'
      }
    });
  }

  // Perform safety checks on the user object
  if (!req.user.id) {
    return res.status(401).json({
      error: {
        message: 'Invalid user session',
        code: 'INVALID_SESSION'
      }
    });
  }

  // Set userId for convenience in route handlers
  req.userId = req.user.id;

  // Enforce access restrictions based on account status
  if (req.user.status === 'suspended') {
    return res.status(403).json({
      error: {
        message: 'Your account has been suspended',
        code: 'ACCOUNT_SUSPENDED'
      }
    });
  }

  // Check if payment approval is pending
  if (req.user.status === 'pending_approval') {
    return res.status(402).json({
      error: {
        message: 'Your account is pending payment approval',
        code: 'PAYMENT_REQUIRED'
      }
    });
  }

  // Account is valid, proceed to the next middleware
  next();
};
```

### API Rate Limiting Configuration

```typescript
// Configure rate limiting
const apiLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // limit each IP to 100 requests per windowMs
  standardHeaders: true, // Return rate limit info in the `RateLimit-*` headers
  legacyHeaders: false, // Disable the `X-RateLimit-*` headers
  message: {
    error: {
      message: 'Too many requests, please try again later',
      code: 'RATE_LIMIT_EXCEEDED'
    }
  }
});

// Higher limits for authenticated users
const authenticatedLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 300, // higher limit for authenticated users
  standardHeaders: true,
  legacyHeaders: false,
  // Skip rate limiting for certain IPs or special users
  skip: (req, res) => req.user?.role === 'admin',
  message: {
    error: {
      message: 'Too many requests, please try again later',
      code: 'RATE_LIMIT_EXCEEDED'
    }
  }
});

// Apply rate limiting to routes
app.use('/api/', apiLimiter);
app.use('/api/auth/', authLimiter);
app.use('/api/users/', authenticatedLimiter);
```

## Security Best Practices for Developers

1. **Authentication**
   - Always use the provided authentication middlewares
   - Never store sensitive credentials in code or logs
   - Implement proper session invalidation on logout

2. **Data Protection**
   - Always validate user input using Zod schemas
   - Use parameterized queries for database access
   - Follow the principle of least privilege for data access

3. **Error Handling**
   - Use structured error handling
   - Do not expose sensitive information in error messages
   - Log security-relevant errors appropriately

4. **Frontend Security**
   - Implement proper authentication state management
   - Sanitize user-generated content before rendering
   - Use HTTPS for all API requests

5. **API Development**
   - Apply proper authentication checks to all endpoints
   - Implement rate limiting for public endpoints
   - Validate ownership of resources in all operations

---

## documentation/technical/security-model.md

# TuneMantra Security Model

*Version: 1.0.0 (March 27, 2025)*

## Table of Contents

- [Introduction](#introduction)
- [Security Architecture](#security-architecture)
- [Identity and Access Management](#identity-and-access-management)
- [Data Protection](#data-protection)
- [Network Security](#network-security)
- [Application Security](#application-security)
- [API Security](#api-security)
- [Infrastructure Security](#infrastructure-security)
- [Compliance Framework](#compliance-framework)
- [Security Operations](#security-operations)
- [Threat Modeling](#threat-modeling)
- [Security Testing](#security-testing)
- [Incident Response](#incident-response)
- [Future Enhancements](#future-enhancements)
- [Appendix](#appendix)

## Introduction

This document describes the comprehensive security model implemented in the TuneMantra platform. It covers all aspects of security from architecture to operations, detailing the controls, processes, and technologies used to protect the platform, its users, and their data.

### Purpose and Scope

This document:

- Defines the security architecture of the TuneMantra platform
- Details security controls implemented across all system layers
- Describes security procedures for operations and incident response
- Outlines compliance mechanisms for regulatory requirements
- Serves as a reference for security audits and assessments

### Security Principles

TuneMantra's security model is built on these core principles:

1. **Defense in Depth**: Multiple layers of security controls
2. **Least Privilege**: Minimal access rights for every user and component
3. **Secure by Design**: Security built into the architecture from the beginning
4. **Zero Trust**: Verification of all access requests regardless of source
5. **Data-Centric Security**: Protection focused on securing the data itself
6. **Privacy by Design**: Privacy controls built into all processes
7. **Continuous Improvement**: Ongoing enhancement of security measures

### Critical Assets Protection

The security model prioritizes protection of these critical assets:

1. **User Authentication Credentials**: Account access information
2. **Financial Data**: Royalty, payment, and banking information
3. **Intellectual Property**: Music content and associated rights
4. **Personal Information**: User and artist data
5. **Business Logic**: Proprietary algorithms and processes
6. **Configuration Data**: System settings and environment information
7. **Access Controls**: Permission and authorization information

## Security Architecture

The security architecture provides a structured approach to protecting all aspects of the platform through layered defenses.

### High-Level Security Architecture

The security architecture consists of these core layers:

1. **Perimeter Security**: Edge protection and external boundary controls
2. **Network Security**: Protection of communication channels
3. **Host Security**: Operating system and infrastructure protection
4. **Application Security**: Protection of application components
5. **Data Security**: Protection of data at rest, in use, and in transit
6. **Identity Security**: Authentication and authorization controls

### Security Domains

Security is implemented across these domains:

1. **User Domain**: End-user devices and access points
2. **Service Domain**: Application services and APIs
3. **Data Domain**: Storage systems and databases
4. **Management Domain**: Administrative interfaces and tools
5. **Integration Domain**: External system connections
6. **Monitoring Domain**: Security monitoring and alerting

### Trust Boundaries

The system defines these trust boundaries:

1. **External Boundary**: Separates external users from the system
2. **Service Boundary**: Isolates each microservice
3. **Data Boundary**: Controls access to stored information
4. **Administrative Boundary**: Restricts management functions
5. **Tenant Boundary**: Separates different organizations
6. **Integration Boundary**: Controls external system interactions

### Security Controls Classification

Security controls are categorized as:

1. **Preventative Controls**: Block security incidents before they occur
2. **Detective Controls**: Identify security incidents as they happen
3. **Corrective Controls**: Mitigate the impact of security incidents
4. **Deterrent Controls**: Discourage potential attackers
5. **Recovery Controls**: Restore system function after incidents
6. **Compensating Controls**: Provide alternatives when primary controls aren't feasible

## Identity and Access Management

The identity and access management system provides comprehensive controls for authentication, authorization, and account management.

### Authentication System

The multi-layered authentication system includes:

1. **Primary Authentication**:
   - Password-based (with strong complexity requirements)
   - Social authentication (with identity verification)
   - Single sign-on (supporting SAML 2.0 and OpenID Connect)

2. **Multi-factor Authentication**:
   - Time-based one-time passwords (TOTP)
   - Push notifications to verified mobile devices
   - SMS verification (with fallbacks)
   - WebAuthn/FIDO2 support for hardware keys

3. **Authentication Policies**:
   - Risk-based authentication requirements
   - Location-based access controls
   - Device fingerprinting
   - Failed attempt limiting
   - Session timeout controls

4. **Session Management**:
   - Secure session token generation
   - Anti-hijacking measures
   - Concurrent session controls
   - Inactivity timeouts
   - Forced re-authentication for sensitive operations

### Authorization Framework

The fine-grained authorization system implements:

1. **Role-Based Access Control (RBAC)**:
   - Hierarchical role structure
   - Role inheritance
   - Separation of duties
   - Job-function alignment
   - Principle of least privilege

2. **Attribute-Based Access Control (ABAC)**:
   - Context-aware permissions
   - Dynamic access decisions
   - Environmental conditions
   - Time-based restrictions
   - Attribute combination logic

3. **Resource-Based Controls**:
   - Resource-level permissions
   - Content-specific access
   - Ownership-based controls
   - Organization boundary enforcement
   - Classification-based restrictions

4. **Policy Engine**:
   - Centralized policy definition
   - Real-time policy evaluation
   - Policy version control
   - Conflict resolution
   - Policy simulation and testing

### Identity Lifecycle Management

The system manages the complete identity lifecycle:

1. **Provisioning**:
   - Self-registration with verification
   - Administrative creation
   - Identity federation
   - Just-in-time provisioning
   - Bulk user creation

2. **Account Maintenance**:
   - Self-service profile management
   - Password reset mechanisms
   - Contact information verification
   - Recovery options management
   - Forced update for compliance

3. **Access Certification**:
   - Periodic access review
   - Manager attestation
   - Risk-based certification
   - Automated revocation
   - Exception handling

4. **Deprovisioning**:
   - Immediate access termination
   - Scheduled account removal
   - Data preservation options
   - Access history maintenance
   - Reactivation capabilities

### Directory Services

The user directory infrastructure provides:

1. **Centralized User Repository**:
   - Comprehensive user attributes
   - Extensible schema
   - High-availability design
   - Backup and recovery
   - Historical record preservation

2. **Organization Structure**:
   - Multi-level hierarchy support
   - Cross-organization relationships
   - Attribute inheritance
   - Organizational unit management
   - Dynamic group membership

3. **External Directory Integration**:
   - Active Directory/LDAP connectivity
   - Identity federation
   - Just-in-time provisioning
   - Attribute mapping
   - Authentication delegation

### Privileged Access Management

Special controls for administrative access include:

1. **Privileged Account Controls**:
   - Just-in-time elevation
   - Limited duration access
   - Approval workflows
   - Session recording
   - Enhanced monitoring

2. **Administrative Separation**:
   - Segregation of administrative roles
   - Multi-person approval requirements
   - Function-specific privileges
   - Emergency access procedures
   - Administrative audit trails

## Data Protection

Comprehensive data protection measures safeguard information throughout its lifecycle.

### Data Classification

The data classification framework includes:

1. **Sensitivity Levels**:
   - Public: Information without restrictions
   - Internal: Business information with limited distribution
   - Confidential: Sensitive business data requiring protection
   - Restricted: Highly sensitive data with stringent controls

2. **Classification Process**:
   - Automated classification
   - User-applied labels
   - Policy-based classification
   - Inheritance from containers
   - Regular classification review

3. **Handling Requirements**:
   - Classification-specific controls
   - Required protection measures
   - Sharing restrictions
   - Retention requirements
   - Disposal procedures

### Encryption Framework

Data encryption is implemented through:

1. **Encryption at Rest**:
   - Database-level encryption
   - Filesystem encryption
   - Object storage encryption
   - Hardware security module integration
   - Key rotation mechanisms

2. **Encryption in Transit**:
   - TLS 1.3 enforcement
   - Certificate management
   - Modern cipher requirements
   - Perfect forward secrecy
   - HSTS implementation

3. **End-to-End Encryption**:
   - Sensitive communications protection
   - Client-side encryption
   - Key management services
   - Secure key exchange
   - Key recovery mechanisms

4. **Key Management**:
   - Hardware security modules
   - Key lifecycle management
   - Segregation of duties
   - Key backup and recovery
   - Certificate authority management

### Data Loss Prevention

Data leakage is prevented through:

1. **Content Inspection**:
   - Pattern matching
   - Fingerprinting
   - Machine learning classification
   - Contextual analysis
   - Metadata examination

2. **Control Points**:
   - API gateway inspection
   - Email monitoring
   - Endpoint controls
   - Cloud application monitoring
   - Network monitoring

3. **Prevention Actions**:
   - Blocking unauthorized transfers
   - Quarantine capabilities
   - Automated encryption
   - User notification
   - Administrator alerting

### Privacy Controls

Privacy protection includes:

1. **Personal Data Handling**:
   - Minimization of collection
   - Purpose limitation
   - Consent management
   - Data subject rights support
   - Special category handling

2. **Anonymization/Pseudonymization**:
   - Irreversible anonymization techniques
   - Pseudonymization for processing
   - Re-identification prevention
   - Aggregation methods
   - Synthetic data generation

3. **Cross-border Controls**:
   - Geographic data restrictions
   - Adequacy determination
   - Transfer impact assessment
   - Standard contractual clauses
   - Binding corporate rules

### Secure Data Lifecycle

Data is protected throughout its lifecycle through:

1. **Secure Creation**:
   - Classification at creation
   - Automatic protection application
   - Creator attribution
   - Lineage tracking
   - Initial access control

2. **Secure Storage**:
   - Appropriate security controls
   - Redundancy for availability
   - Backup integration
   - Tamper protection
   - Secure deletion capability

3. **Secure Processing**:
   - Memory protection
   - Processing isolation
   - Temporary data protection
   - Access monitoring
   - Security in compute

4. **Secure Archiving**:
   - Long-term integrity
   - Accessibility preservation
   - Classification maintenance
   - Retrieval controls
   - Compliance preservation

5. **Secure Deletion**:
   - Complete removal
   - Verification process
   - Hardware destruction where needed
   - Certificate of destruction
   - Deletion audit trail

## Network Security

Multiple layers of network protection safeguard communications and prevent unauthorized access.

### Network Architecture

The secure network design includes:

1. **Network Segmentation**:
   - Separate security zones
   - Microsegmentation
   - Virtual network isolation
   - Purpose-specific subnets
   - Cross-zone traffic controls

2. **Defense in Depth**:
   - Multiple security layers
   - Overlapping protection
   - Independent control mechanisms
   - Diverse security technologies
   - Redundant protection paths

3. **Security Zones**:
   - Internet-facing DMZ
   - Application services zone
   - Database zone
   - Management zone
   - Internal services zone

### Perimeter Protection

Edge security includes:

1. **DDoS Protection**:
   - Volumetric attack mitigation
   - Application layer protection
   - Traffic scrubbing
   - Rate limiting
   - Resource preservation

2. **Web Application Firewall**:
   - OWASP protection
   - Custom rule sets
   - Anomaly detection
   - Bot protection
   - API abuse prevention

3. **Network Firewall**:
   - Stateful packet inspection
   - Next-generation capabilities
   - Traffic filtering
   - Protocol validation
   - Virtual private networking

### Traffic Management

Network traffic control includes:

1. **Load Balancing**:
   - Traffic distribution
   - Health checking
   - SSL termination
   - Application-aware routing
   - Rate limiting

2. **API Gateway**:
   - Request validation
   - Traffic management
   - Authentication enforcement
   - Rate limiting
   - Request/response transformation

3. **Content Delivery Network**:
   - Edge caching
   - DDoS protection
   - Geographic distribution
   - SSL offloading
   - Edge security

### Internal Network Security

Internal protection includes:

1. **Internal Firewalls**:
   - Zone separation
   - Lateral movement prevention
   - Microsegmentation
   - Service isolation
   - Traffic monitoring

2. **Network Access Control**:
   - Device authentication
   - Health validation
   - Policy enforcement
   - Device quarantine
   - Guest network isolation

3. **Zero Trust Network Access**:
   - Identity-based authentication
   - Device validation
   - Continuous verification
   - Least privilege access
   - Session monitoring

### Cloud Network Security

Cloud-specific controls include:

1. **Virtual Network Security**:
   - Software-defined networking
   - Private connectivity
   - Virtual network peering
   - Service endpoints
   - Private link services

2. **Cloud Access Security**:
   - Cloud service protection
   - Identity-aware access
   - Service-specific controls
   - Multi-cloud security
   - Cloud security posture management

## Application Security

Comprehensive application security measures protect the platform from design through implementation.

### Secure Development Lifecycle

Security is integrated into development through:

1. **Security Requirements**:
   - Threat modeling
   - Security user stories
   - Compliance requirements
   - Business risk assessment
   - Technical risk assessment

2. **Secure Design**:
   - Security architecture review
   - Design pattern selection
   - Attack surface analysis
   - Trust boundary identification
   - Authentication and authorization design

3. **Secure Implementation**:
   - Secure coding standards
   - Code security analysis
   - Dependency scanning
   - Manual code review
   - Security unit testing

4. **Security Testing**:
   - Dynamic application security testing
   - Static application security testing
   - Interactive application security testing
   - Penetration testing
   - Fuzz testing

5. **Security Deployment**:
   - Secure configuration
   - Secret management
   - Hardening standards
   - Vulnerability scanning
   - Deployment verification

### Web Application Security

Web protection includes:

1. **Input Validation**:
   - Parameter validation
   - Content type verification
   - Schema validation
   - Sanitization
   - Canonicalization

2. **Output Encoding**:
   - Context-aware encoding
   - XSS prevention
   - Header security
   - Content Security Policy
   - Safe rendering patterns

3. **Session Security**:
   - Secure session management
   - Anti-hijacking measures
   - Token protection
   - Cookie security
   - CSRF protection

4. **Authentication Security**:
   - Secure credential handling
   - Brute force protection
   - Multi-factor options
   - Account recovery security
   - Authentication feedback

5. **Client-side Security**:
   - Secure JavaScript practices
   - Browser security headers
   - Subresource Integrity
   - Safe dependency management
   - Frontend vulnerability scanning

### API Security

API protection includes:

1. **API Authentication**:
   - OAuth 2.0 implementation
   - API key management
   - Token validation
   - Certificate-based authentication
   - Mutual TLS

2. **API Authorization**:
   - Scope-based permissions
   - Fine-grained access control
   - Token inspection
   - Role-based permissions
   - Context-aware authorization

3. **Request Validation**:
   - Schema validation
   - Parameter checking
   - Rate limiting
   - Size constraints
   - Content validation

4. **Response Security**:
   - Data minimization
   - Appropriate status codes
   - Error handling security
   - Response filtering
   - Information leakage prevention

5. **API Gateway Protection**:
   - Traffic management
   - Request inspection
   - Bot detection
   - API abuse prevention
   - Anomaly detection

### Security Features

Security functionality includes:

1. **Secure File Handling**:
   - File type validation
   - Virus scanning
   - Content verification
   - Metadata stripping
   - Safe storage

2. **Cryptography**:
   - Modern algorithm selection
   - Secure implementation
   - Library validation
   - Key management
   - Crypto agility

3. **Error Handling**:
   - Security-conscious errors
   - Information disclosure prevention
   - Graceful failure
   - Appropriate logging
   - User feedback security

4. **Audit Logging**:
   - Comprehensive event capture
   - Tamper-evident logging
   - Secure transmission
   - Standardized format
   - Retention management

### Dependency Management

Third-party component security includes:

1. **Dependency Scanning**:
   - Vulnerability detection
   - License compliance
   - Version management
   - Transitive dependency analysis
   - Dependency health monitoring

2. **Supply Chain Security**:
   - Vendor security assessment
   - Provenance verification
   - Build integrity validation
   - Artifact signing
   - Bill of materials maintenance

3. **Update Management**:
   - Vulnerability patching
   - Dependency lifecycle management
   - Deprecation handling
   - Breaking change assessment
   - Automatic update pipelines

## API Security

Specialized controls protect the platform's API infrastructure, which serves as the primary interface for integrations.

### API Gateway Security

The API gateway provides:

1. **Traffic Control**:
   - Request rate limiting
   - Quota management
   - Traffic shaping
   - Circuit breaking
   - Load shedding

2. **Request Validation**:
   - Schema validation
   - Parameter sanitization
   - Content type verification
   - Size limitation
   - Header validation

3. **Authentication Enforcement**:
   - Credential validation
   - Token verification
   - Certificate validation
   - API key management
   - Multi-factor coordination

4. **Request Processing**:
   - Request transformation
   - Sensitive data filtering
   - Header normalization
   - Canonical request formatting
   - Protocol conversion

5. **Monitoring and Analytics**:
   - Usage tracking
   - Anomaly detection
   - Error rate monitoring
   - Performance measurement
   - Availability tracking

### OAuth 2.0 Implementation

The OAuth 2.0 framework includes:

1. **Grant Types**:
   - Authorization code with PKCE
   - Client credentials
   - Resource owner password (limited cases)
   - Refresh token
   - Device authorization

2. **Token Security**:
   - JWT signing and encryption
   - Short-lived access tokens
   - Audience validation
   - Token binding
   - Scope restriction

3. **Authorization Server**:
   - Secure client registration
   - Token issuance security
   - Token introspection
   - Token revocation
   - Authorization code security

4. **OpenID Connect**:
   - Identity token issuance
   - Claims management
   - UserInfo endpoint
   - Subject identifier management
   - Session management

### API Versioning and Lifecycle

API evolution is managed through:

1. **Version Control**:
   - Semantic versioning
   - Version compatibility
   - Deprecation policy
   - Version sunset planning
   - Migration support

2. **Documentation**:
   - OpenAPI specification
   - Security requirements
   - Authentication documentation
   - Example secure usage
   - Error response documentation

3. **Change Management**:
   - Breaking change identification
   - Backward compatibility
   - Security enhancement introduction
   - Notification process
   - Transition period

### API Access Control

API-specific access controls include:

1. **API Permissions**:
   - Operation-level permissions
   - Resource-based access
   - Scope-based authorization
   - Content filtering
   - Field-level security

2. **Application Registration**:
   - Developer onboarding
   - Application verification
   - Purpose limitation
   - Usage monitoring
   - Terms enforcement

3. **Partner-specific Controls**:
   - Partner authentication
   - Custom rate limits
   - Enhanced capabilities
   - Specialized endpoints
   - Partner monitoring

### API Threat Protection

API-specific threat mitigation includes:

1. **Attack Detection**:
   - Injection attack identification
   - Parameter tampering
   - Protocol abuse
   - Resource exhaustion attempts
   - Business logic abuse

2. **Bot Management**:
   - Bot identification
   - Good bot allowlisting
   - Bad bot blocking
   - CAPTCHA integration
   - Behavioral analysis

3. **Anomaly Detection**:
   - Unusual request patterns
   - Abnormal data access
   - Geographic anomalies
   - Timing analysis
   - Volume monitoring

## Infrastructure Security

Comprehensive security controls protect the underlying infrastructure hosting the platform.

### Cloud Security

Cloud infrastructure protection includes:

1. **Identity and Access Management**:
   - Cloud IAM configuration
   - Role-based access
   - Just-in-time privileges
   - Service account management
   - Cross-cloud identity federation

2. **Resource Protection**:
   - Secure configuration
   - Cloud security posture management
   - Infrastructure as Code security
   - Resource tagging and inventory
   - Compliance validation

3. **Network Security**:
   - Virtual network segmentation
   - Cloud firewall configuration
   - Private connectivity
   - Service endpoints
   - DDoS protection

4. **Data Protection**:
   - Storage encryption
   - Key management
   - Secure access methods
   - Backup security
   - Deletion verification

5. **Monitoring and Logging**:
   - Cloud audit logging
   - Resource monitoring
   - Activity tracking
   - Threat detection
   - Security information and event management

### Containerization Security

Container protection includes:

1. **Image Security**:
   - Base image security
   - Vulnerability scanning
   - Image signing
   - Image registry security
   - Minimal image design

2. **Container Runtime Security**:
   - Runtime protection
   - Immutable containers
   - Privileged container prevention
   - Resource limitations
   - Capability restrictions

3. **Orchestration Security**:
   - Kubernetes security configuration
   - Network policy enforcement
   - Pod security standards
   - Secret management
   - Admission control

4. **Container Monitoring**:
   - Runtime monitoring
   - Behavioral analysis
   - Anomaly detection
   - Compliance verification
   - Vulnerability management

### Infrastructure as Code Security

IaC security includes:

1. **Secure Development**:
   - Code security scanning
   - Policy as code
   - Security testing
   - Version control
   - Peer review

2. **Deployment Security**:
   - Pipeline security controls
   - Approval workflows
   - Drift detection
   - Change validation
   - Rollback capability

3. **Configuration Management**:
   - Secure default configurations
   - Configuration validation
   - Compliance verification
   - Secrets management
   - Immutable infrastructure

### Server Security

Host-level security includes:

1. **Operating System Hardening**:
   - Minimal installation
   - Security configuration
   - Unnecessary service removal
   - Kernel hardening
   - File system security

2. **Endpoint Protection**:
   - Anti-malware
   - Host-based firewall
   - File integrity monitoring
   - Application control
   - Exploit prevention

3. **Patch Management**:
   - Vulnerability scanning
   - Critical patch application
   - Patch testing
   - Update automation
   - Compliance reporting

4. **Access Control**:
   - Privileged access management
   - SSH hardening
   - MFA for server access
   - Bastion host architecture
   - Just-in-time access

## Compliance Framework

The platform maintains compliance with relevant regulations and standards through a comprehensive framework.

### Regulatory Compliance

The platform addresses these key regulations:

1. **Data Protection**:
   - GDPR (General Data Protection Regulation)
   - CCPA/CPRA (California Consumer Privacy Act)
   - LGPD (Brazil General Data Protection Law)
   - Global privacy regulations

2. **Financial Compliance**:
   - PCI DSS (Payment Card Industry Data Security Standard)
   - SOX (Sarbanes-Oxley Act)
   - Regional financial regulations

3. **Industry-specific**:
   - DMCA (Digital Millennium Copyright Act)
   - Copyright directives
   - Music licensing regulations
   - Digital rights management requirements

### Standards Adherence

The platform follows these security standards:

1. **ISO Standards**:
   - ISO/IEC 27001 (Information Security Management)
   - ISO/IEC 27017 (Cloud Security)
   - ISO/IEC 27018 (Cloud Privacy)
   - ISO/IEC 27701 (Privacy Information Management)

2. **Industry Standards**:
   - NIST Cybersecurity Framework
   - NIST 800-53 security controls
   - CIS Controls
   - OWASP Application Security Verification Standard

3. **Cloud Security**:
   - Cloud Security Alliance STAR
   - Cloud Controls Matrix
   - Well-Architected frameworks

### Compliance Controls

Compliance is maintained through:

1. **Policy Framework**:
   - Information security policies
   - Data protection policies
   - Acceptable use policies
   - Risk management policies
   - Compliance policies

2. **Control Implementation**:
   - Technical controls
   - Administrative controls
   - Physical controls
   - Compensating controls
   - Detective controls

3. **Assessment Program**:
   - Internal audits
   - External assessments
   - Vulnerability management
   - Penetration testing
   - Compliance monitoring

4. **Documentation**:
   - Control documentation
   - Evidence collection
   - Audit trail maintenance
   - Compliance reporting
   - Policy attestation

### Privacy Program

The privacy framework includes:

1. **Privacy Governance**:
   - Privacy office
   - Data protection officer
   - Privacy policies
   - Privacy impact assessment
   - Privacy by design

2. **Data Subject Rights**:
   - Access request handling
   - Correction mechanisms
   - Deletion capabilities
   - Portability support
   - Consent management

3. **Cross-border Data Transfers**:
   - Transfer impact assessment
   - Adequacy mechanisms
   - Standard contractual clauses
   - Binding corporate rules
   - Certification frameworks

4. **Privacy Controls**:
   - Data minimization
   - Purpose limitation
   - Storage limitation
   - Data accuracy measures
   - De-identification techniques

## Security Operations

Operational security processes ensure ongoing protection of the platform and rapid response to security events.

### Security Monitoring

Continuous monitoring includes:

1. **Security Information and Event Management**:
   - Log collection
   - Event correlation
   - Anomaly detection
   - Alert generation
   - Incident triggering

2. **Threat Detection**:
   - Signature-based detection
   - Behavioral analysis
   - Machine learning models
   - Threat intelligence integration
   - User and entity behavior analytics

3. **Monitoring Coverage**:
   - Network traffic
   - System logs
   - Application logs
   - Authentication events
   - Cloud resource activity
   - Database activity

4. **Alert Management**:
   - Alert prioritization
   - False positive reduction
   - Alert escalation
   - Notification routing
   - Response tracking

### Vulnerability Management

Ongoing vulnerability handling includes:

1. **Vulnerability Scanning**:
   - Network scanning
   - Web application scanning
   - Container scanning
   - Cloud configuration scanning
   - Code scanning

2. **Patch Management**:
   - Vulnerability assessment
   - Patch prioritization
   - Testing process
   - Deployment automation
   - Verification

3. **Risk Assessment**:
   - Vulnerability scoring
   - Business impact analysis
   - Exploitation likelihood
   - Remediation planning
   - Acceptance criteria

4. **Remediation Process**:
   - Fix development
   - Implementation planning
   - Change management
   - Verification testing
   - Risk reassessment

### Security Awareness

Security culture is fostered through:

1. **Training Program**:
   - Onboarding security training
   - Role-specific training
   - Developer security training
   - Compliance training
   - Refresher courses

2. **Awareness Campaigns**:
   - Phishing simulations
   - Security newsletters
   - Awareness events
   - Security champions
   - Executive communications

3. **Policy Communication**:
   - Policy distribution
   - Acceptable use acknowledgment
   - Policy updates notification
   - Compliance reminders
   - Consequence awareness

### Third-party Risk Management

External risk is managed through:

1. **Vendor Assessment**:
   - Security questionnaires
   - Control validation
   - Compliance verification
   - Service level agreements
   - Right to audit

2. **Continuous Monitoring**:
   - Vendor security ratings
   - Threat intelligence monitoring
   - Breach notification handling
   - Performance measurement
   - Compliance maintenance

3. **Integration Security**:
   - Connection security
   - Data exchange protection
   - Authentication and authorization
   - Monitoring and logging
   - Change management

## Threat Modeling

Systematic threat modeling identifies and addresses security risks throughout the platform.

### Threat Modeling Methodology

The threat modeling process includes:

1. **System Decomposition**:
   - Component identification
   - Data flow mapping
   - Trust boundary identification
   - Entry point analysis
   - Privilege levels

2. **Threat Identification**:
   - STRIDE categorization
   - Attack tree analysis
   - Attack vector identification
   - Threat library utilization
   - Attack surface analysis

3. **Risk Assessment**:
   - Impact evaluation
   - Likelihood determination
   - Risk scoring
   - Risk prioritization
   - Acceptance criteria

4. **Mitigation Planning**:
   - Control identification
   - Design adjustments
   - Implementation recommendations
   - Verification methods
   - Residual risk assessment

### Common Threats

Key threats addressed include:

1. **Authentication Threats**:
   - Credential theft
   - Brute force attacks
   - Session hijacking
   - Authentication bypass
   - Multi-factor compromise

2. **Authorization Threats**:
   - Privilege escalation
   - Insecure direct object references
   - Missing function-level access control
   - Horizontal privilege escalation
   - JWT attacks

3. **Data Protection Threats**:
   - Data exfiltration
   - Unauthorized access
   - Data tampering
   - Cryptographic weaknesses
   - Key management failures

4. **API Threats**:
   - API abuse
   - Parameter tampering
   - Schema validation bypass
   - Race conditions
   - Business logic abuse

5. **Infrastructure Threats**:
   - Service misconfiguration
   - Container escape
   - Insecure defaults
   - Unnecessary services
   - Component vulnerabilities

### Threat Modeling by Component

Threat models are developed for:

1. **Authentication System**:
   - Login process
   - MFA implementation
   - Password reset
   - Session management
   - API authentication

2. **Payment Processing**:
   - Payment capture
   - Payment distribution
   - Financial data storage
   - Payment provider integration
   - Reconciliation process

3. **Content Distribution**:
   - Content upload
   - Metadata processing
   - Platform delivery
   - Content protection
   - Takedown processes

4. **Administrative Functions**:
   - User management
   - System configuration
   - Access control management
   - Report generation
   - Audit functions

## Security Testing

Comprehensive testing verifies the effectiveness of security controls and identifies vulnerabilities.

### Testing Methodology

The security testing program includes:

1. **Testing Types**:
   - Static application security testing (SAST)
   - Dynamic application security testing (DAST)
   - Interactive application security testing (IAST)
   - Software composition analysis (SCA)
   - Penetration testing
   - Red team exercises

2. **Testing Frequency**:
   - Continuous integration testing
   - Pre-release testing
   - Periodic scheduled testing
   - Post-incident testing
   - Change-triggered testing

3. **Testing Scope**:
   - Authentication and authorization
   - Data protection
   - API security
   - Infrastructure security
   - Network security
   - Application security

4. **Testing Process**:
   - Preparation and planning
   - Test execution
   - Result analysis
   - Vulnerability validation
   - Remediation tracking

### Penetration Testing

External security validation includes:

1. **Testing Approach**:
   - Black box testing
   - Gray box testing
   - White box testing
   - Red team simulation
   - Purple team exercises

2. **Testing Areas**:
   - Web application testing
   - API security testing
   - Network infrastructure testing
   - Cloud configuration testing
   - Social engineering testing

3. **Testing Methodology**:
   - OWASP testing guide
   - NIST penetration testing framework
   - PTES (Penetration Testing Execution Standard)
   - Custom test scenarios
   - Industry-specific testing

4. **Reporting and Remediation**:
   - Vulnerability severity rating
   - Exploitation proof of concept
   - Remediation recommendations
   - Retest verification
   - Executive summary

### Automated Security Testing

Continuous testing includes:

1. **CI/CD Integration**:
   - Pipeline security checks
   - Automated vulnerability scanning
   - Dependency analysis
   - Secret detection
   - Configuration validation

2. **Code Analysis**:
   - Static code analysis
   - Code quality checks
   - Custom rule development
   - Vulnerability pattern detection
   - Security anti-patterns

3. **Infrastructure Testing**:
   - Configuration compliance checking
   - Cloud security posture assessment
   - Container security scanning
   - Infrastructure as Code validation
   - Network security verification

## Incident Response

Structured processes ensure effective response to security incidents and minimize their impact.

### Incident Response Plan

The incident response framework includes:

1. **Response Phases**:
   - Preparation
   - Detection and analysis
   - Containment
   - Eradication
   - Recovery
   - Post-incident activity

2. **Response Team**:
   - Security operations
   - Technical specialists
   - Management representatives
   - Legal counsel
   - Communications personnel
   - External expertise

3. **Incident Classification**:
   - Severity levels
   - Impact assessment
   - Response prioritization
   - Escalation criteria
   - Notification requirements

4. **Response Procedures**:
   - Initial assessment
   - Evidence collection
   - Containment strategy
   - Investigation process
   - Communication protocols
   - Recovery operations

### Breach Management

Data breach handling includes:

1. **Breach Identification**:
   - Data exposure detection
   - Unauthorized access identification
   - Exfiltration detection
   - Breach scope determination
   - Impact assessment

2. **Containment and Mitigation**:
   - Access termination
   - System isolation
   - Vulnerability remediation
   - Credential rotation
   - Recovery plan execution

3. **Notification Process**:
   - Legal requirements determination
   - Regulatory reporting
   - Customer notification
   - Partner communication
   - Public disclosure

4. **Post-breach Activities**:
   - Forensic investigation
   - Root cause analysis
   - Control improvement
   - Monitoring enhancement
   - Documentation update

### Incident Playbooks

Pre-defined response plans include:

1. **Malware Response**:
   - Identification and isolation
   - Malware analysis
   - System cleaning
   - Recovery procedures
   - Re-infection prevention

2. **Account Compromise**:
   - Access termination
   - Credential reset
   - Activity investigation
   - Damage assessment
   - Account recovery

3. **Data Breach**:
   - Containment actions
   - Exposure assessment
   - Notification process
   - Regulatory compliance
   - Evidence preservation

4. **Denial of Service**:
   - Attack characterization
   - Traffic filtering
   - Service restoration
   - Architecture hardening
   - Post-attack analysis

5. **API Abuse**:
   - Attack pattern identification
   - Rate limiting implementation
   - IP blocking
   - Authentication review
   - Monitoring enhancement

### Incident Drills

Readiness is maintained through:

1. **Tabletop Exercises**:
   - Scenario-based discussions
   - Role-playing
   - Decision-making practice
   - Response evaluation
   - Plan refinement

2. **Technical Drills**:
   - Simulated attacks
   - Response procedure testing
   - Tool verification
   - Recovery testing
   - Communication testing

3. **Full-scale Exercises**:
   - Realistic scenario execution
   - Cross-functional participation
   - External coordination
   - Complete process validation
   - Comprehensive assessment

## Future Enhancements

The security model continues to evolve with planned enhancements and emerging technology adoption.

### Security Roadmap

Upcoming security improvements include:

1. **Zero Trust Implementation**:
   - Complete network redesign
   - Identity-centric security
   - Continuous verification
   - Least privilege access
   - Micro-segmentation

2. **AI Security Enhancement**:
   - Machine learning for threat detection
   - Behavioral analysis
   - Anomaly identification
   - Automated response
   - Predictive security

3. **Cloud Security Evolution**:
   - Multi-cloud security strategy
   - Cloud-native security controls
   - Serverless security
   - Container security enhancement
   - Cloud workload protection

4. **Privacy Enhancement**:
   - Advanced anonymization
   - Privacy-enhancing technologies
   - Data sovereignty solutions
   - Consent management improvements
   - Privacy rights automation

### Emerging Technology Assessment

Evaluation of new security technologies includes:

1. **Quantum Computing Impact**:
   - Post-quantum cryptography
   - Algorithm migration
   - Key exchange protocols
   - Quantum threat assessment
   - Quantum-resistant standards

2. **Blockchain Security**:
   - Distributed identity solutions
   - Immutable audit logging
   - Smart contract security
   - Token-based authorization
   - Decentralized security models

3. **Edge Computing Security**:
   - Distributed security controls
   - Local security enforcement
   - Edge-specific protection
   - Disconnected operation security
   - Edge device management

4. **DevSecOps Evolution**:
   - Security as code
   - Automated compliance verification
   - Continuous security validation
   - Security telemetry integration
   - Developer security empowerment

## Appendix

### Cryptographic Standards

Approved cryptographic algorithms include:

1. **Symmetric Encryption**:
   - AES-256 (GCM/CBC modes)
   - ChaCha20-Poly1305

2. **Asymmetric Encryption**:
   - RSA (3072-bit minimum)
   - ECC (P-256, P-384, P-521)

3. **Hashing Algorithms**:
   - SHA-256, SHA-384, SHA-512
   - BLAKE2

4. **Key Exchange**:
   - ECDHE
   - DH (3072-bit minimum)

5. **Digital Signatures**:
   - RSA-PSS
   - ECDSA
   - Ed25519

### Security Responsibilities

Security roles and responsibilities:

1. **Security Team**:
   - Security architecture
   - Policy development
   - Control implementation
   - Vulnerability management
   - Incident response

2. **Development Team**:
   - Secure coding
   - Security testing
   - Vulnerability remediation
   - Security feature implementation
   - Security requirements adherence

3. **Operations Team**:
   - Secure configuration
   - Patch management
   - Monitoring
   - Incident detection
   - Security tool operation

4. **Management**:
   - Risk acceptance
   - Resource allocation
   - Policy approval
   - Compliance oversight
   - Security program direction

### Security Tools

Key security tools deployed include:

1. **Vulnerability Management**:
   - Qualys
   - Tenable
   - Rapid7

2. **SIEM Solution**:
   - Splunk
   - Azure Sentinel
   - Elastic Security

3. **Application Security**:
   - Checkmarx
   - SonarQube
   - OWASP ZAP

4. **Container Security**:
   - Aqua Security
   - Twistlock
   - Docker Bench

5. **Cloud Security**:
   - Cloud Security Posture Management
   - Cloud Workload Protection
   - Cloud Access Security Broker

### Reference Documents

Related security documentation:

1. **Policy Documents**:
   - Information Security Policy
   - Data Protection Policy
   - Acceptable Use Policy
   - Incident Response Policy
   - Access Control Policy

2. **Process Documents**:
   - Vulnerability Management Procedure
   - Incident Response Procedure
   - Change Management Process
   - Access Review Process
   - Data Handling Procedure

3. **Technical Standards**:
   - Password Requirements
   - Encryption Standards
   - Network Security Standards
   - Cloud Security Standards
   - Application Security Standards

4. **Compliance Documents**:
   - Regulatory Compliance Matrix
   - Control Framework Mapping
   - Audit Evidence Catalog
   - Risk Assessment Methodology
   - Compliance Monitoring Approach

---

© 2023-2025 TuneMantra. All rights reserved.# TuneMantra Security Model

## Overview

This document outlines the security model implemented in the TuneMantra platform. It covers authentication, authorization, data protection, and other security considerations.

## Authentication and Authorization

TuneMantra implements a robust authentication and authorization system:

- **JWT-based authentication**: Secure token-based authentication with appropriate expiration and refresh mechanisms
- **Role-based access control**: Granular permissions based on user roles
- **Multi-factor authentication**: Optional 2FA for sensitive operations
- **Password policies**: Strong password requirements and regular rotation

## Data Protection

Data protection measures include:

- **Encryption at rest**: All sensitive data is encrypted in the database
- **Encryption in transit**: All API communication uses TLS
- **Data masking**: Sensitive data is masked in logs and non-essential views
- **Secure key management**: Cryptographic keys are securely stored and rotated

## API Security

API security measures include:

- **Input validation**: All API inputs are validated using Zod schemas
- **Rate limiting**: Protection against brute force attacks
- **CSRF protection**: Cross-site request forgery prevention
- **API key management**: Secure handling of API keys for external services

## Blockchain Security

Blockchain-specific security measures include:

- **Secure wallet management**: Proper handling of private keys
- **Transaction validation**: Multiple validation layers for blockchain transactions
- **Smart contract security**: Audited smart contracts with security best practices
- **Cryptographic signature verification**: Secure verification of rights ownership

## Infrastructure Security

Infrastructure security measures include:

- **Network segmentation**: Proper separation of network components
- **Intrusion detection**: Monitoring for unauthorized access attempts
- **DDOS protection**: Mitigation measures for distributed denial of service attacks
- **Regular security scans**: Automated vulnerability scanning

## Compliance

TuneMantra complies with relevant security standards:

- **GDPR compliance**: Data protection measures in line with EU regulations
- **SOC 2 principles**: Security, availability, processing integrity, confidentiality, and privacy
- **Regular audits**: Third-party security audits

## Security Procedures

Detailed procedures for security operations can be found in the [Security Procedures](operations/security-procedures.md) document.

---

## documentation/technical/security.md

# Security Implementation Documentation

## Overview

The TuneMantra platform implements a comprehensive security strategy to protect user data, intellectual property, and financial information. This document outlines the security measures implemented across the application stack.

## Authentication and Authorization

### Authentication Mechanisms

1. **Session-based Authentication**
   - Uses Express-session with PostgreSQL session store
   - Sessions are persistent across server restarts
   - Session cookies are HttpOnly to prevent JavaScript access
   - Session expiration is enforced (30 days by default)

2. **Password Security**
   - Password hashing using scrypt (cryptographically secure key derivation function)
   - Salt generation for each password to prevent rainbow table attacks
   - Support for BCrypt format for legacy compatibility
   - Secure password comparison to prevent timing attacks

3. **API Key Authentication**
   - Unique API keys for programmatic access
   - Keys are scoped to specific permissions
   - Keys can be rotated and revoked by users
   - Key expiration can be set for time-limited access

### Authorization Systems

1. **Role-Based Access Control (RBAC)**
   - User roles include: admin, label, artist_manager, artist, team_member
   - Each role has predefined permissions
   - Routes are protected based on role requirements

2. **Permission System**
   - Fine-grained permissions beyond role-based access
   - Custom permission templates can be created and assigned
   - Permissions are stored as JSON and validated on requests

3. **Multi-tenant Isolation**
   - Users can only access their own resources
   - Label owners can access their artists' resources
   - Artist managers can access their managed artists' resources

4. **Middleware Protection**
   - `requireAuth` middleware ensures authentication
   - Role-specific middlewares (e.g., `requireAdmin`)
   - Resource ownership validation middleware

## Data Security

### Database Security

1. **Connection Security**
   - PostgreSQL connection over SSL/TLS
   - Connection pooling for secure reuse
   - Environment variable-based configuration

2. **Query Security**
   - Parameterized queries to prevent SQL injection
   - Type-safe queries using Drizzle ORM
   - Input validation before database operations

3. **Sensitive Data Storage**
   - Passwords are hashed, never stored in plaintext
   - Payment details are encrypted or tokenized
   - API credentials are stored securely

### API Security

1. **Input Validation**
   - Zod schema validation for all inputs
   - Validation middleware for routes
   - File upload validation for size and type

2. **Output Sanitization**
   - Sensitive fields are removed from responses
   - Data is filtered based on user permissions
   - XSS prevention in API responses

3. **HTTP Security Headers**
   - Content-Security-Policy
   - X-Content-Type-Options
   - X-Frame-Options
   - Referrer-Policy
   - Implemented using Helmet.js

## Network Security

1. **HTTPS Enforcement**
   - All production traffic uses HTTPS
   - HSTS headers for secure connection enforcement
   - Secure cookie settings in production

2. **Rate Limiting**
   - API rate limiting to prevent brute force and DoS attacks
   - IP-based and user-based rate limits
   - Increasing backoff for repeated failures

3. **CORS Policy**
   - Restrictive CORS policy for API endpoints
   - Allows only trusted origins in production
   - Credentials allowed only from trusted origins

## Audit and Logging

1. **Activity Logging**
   - User login/logout events
   - Critical data modifications
   - API key usage tracking
   - Admin actions logging

2. **Audit Trails**
   - `subLabelAuditLogs` table tracks sub-label changes
   - Captures who made changes and what was changed
   - Stores previous and new values for comparison

3. **Error Logging**
   - Structured error logging
   - Stack traces in development only
   - Client-safe error messages in production

## Vulnerability Prevention

1. **Dependency Security**
   - Regular updates of dependencies
   - Security vulnerability scanning
   - Minimal dependency approach

2. **XSS Prevention**
   - Content security policy configuration
   - Input sanitization and validation
   - React's built-in XSS protection
   - XSS filtering library for user content

3. **CSRF Protection**
   - CSRF token validation for state-changing operations
   - SameSite cookie settings
   - Origin verification

4. **Injection Prevention**
   - SQL injection prevention through parameterized queries
   - NoSQL injection prevention in JSON operations
   - Command injection prevention in system calls

## File Upload Security

1. **File Validation**
   - File type validation based on content (MIME) type
   - Size limits for different file types
   - Maximum file count per user

2. **Storage Security**
   - Files stored outside the web root
   - Randomized filenames to prevent guessing
   - Validation before serving files

3. **Content Scanning**
   - Malware scanning for uploaded files
   - Audio file validation for music tracks
   - Image safety verification

## Financial Security

1. **Payment Processing**
   - Integration with secure payment providers
   - PCI compliance considerations
   - Tokenization of payment methods

2. **Royalty Calculations**
   - Audit trails for all royalty calculations
   - Transparent split payments with verification
   - Multi-step approval for large payments

3. **Withdrawal Security**
   - Verification steps for withdrawal requests
   - Limits and thresholds to prevent fraud
   - Notification of withdrawal events

## Infrastructure Security

1. **Deployment Security**
   - Secure environment variable management
   - Production vs. development configuration
   - Database migration safety

2. **Server Configuration**
   - Restrictive file permissions
   - Principle of least privilege
   - Regular security updates

3. **Monitoring**
   - Error rate monitoring
   - Authentication failure monitoring
   - Unusual traffic patterns detection

## Security Disclosure Policy

TuneMantra has an established security disclosure policy:

1. **Vulnerability Reporting**
   - Secure channel for reporting vulnerabilities
   - Responsible disclosure timeline
   - Recognition for security researchers

2. **Incident Response**
   - Documented incident response plan
   - User notification procedures
   - Post-incident analysis process

3. **Regular Security Reviews**
   - Periodic security audits
   - Penetration testing
   - Code review for security issues

## Implementation Examples

### Password Hashing Implementation

```typescript
// Hash a password for secure storage
export async function hashPassword(password: string): Promise<string> {
  // Generate a random salt
  const salt = randomBytes(16).toString('hex');
  
  // Hash the password with the salt using scrypt
  const hash = await scryptAsync(password, salt, 64);
  
  // Return the hash and salt combined as a single string
  return `${hash.toString('hex')}.${salt}`;
}

// Compare a supplied password with a stored hashed password
async function comparePasswords(supplied: string, stored: string): Promise<boolean> {
  // Handle multiple password formats
  
  // Format: "hashed.salt" (scrypt)
  if (stored.includes('.')) {
    const [hashedPassword, salt] = stored.split('.');
    const suppliedHash = await scryptAsync(supplied, salt, 64);
    return timingSafeEqual(
      Buffer.from(hashedPassword, 'hex'),
      suppliedHash
    );
  }
  
  // Format: "salt:hashed" (legacy)
  if (stored.includes(':')) {
    const [salt, hashedPassword] = stored.split(':');
    const suppliedHash = await scryptAsync(supplied, salt, 64);
    return timingSafeEqual(
      Buffer.from(hashedPassword, 'hex'),
      suppliedHash
    );
  }
  
  // Format: "$2b$..." (bcrypt)
  if (stored.startsWith('$2b$')) {
    return bcrypt.compare(supplied, stored);
  }
  
  // Unknown format
  return false;
}
```

### Authentication Middleware

```typescript
// Authentication middleware for protected routes
export const requireAuth = (req: Request, res: Response, next: NextFunction) => {
  // Check if user is authenticated via session
  if (!req.isAuthenticated() || !req.user) {
    return res.status(401).json({
      error: {
        message: 'Authentication required',
        code: 'AUTH_REQUIRED'
      }
    });
  }

  // Perform safety checks on the user object
  if (!req.user.id) {
    return res.status(401).json({
      error: {
        message: 'Invalid user session',
        code: 'INVALID_SESSION'
      }
    });
  }

  // Set userId for convenience in route handlers
  req.userId = req.user.id;

  // Enforce access restrictions based on account status
  if (req.user.status === 'suspended') {
    return res.status(403).json({
      error: {
        message: 'Your account has been suspended',
        code: 'ACCOUNT_SUSPENDED'
      }
    });
  }

  // Check if payment approval is pending
  if (req.user.status === 'pending_approval') {
    return res.status(402).json({
      error: {
        message: 'Your account is pending payment approval',
        code: 'PAYMENT_REQUIRED'
      }
    });
  }

  // Account is valid, proceed to the next middleware
  next();
};
```

### API Rate Limiting Configuration

```typescript
// Configure rate limiting
const apiLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // limit each IP to 100 requests per windowMs
  standardHeaders: true, // Return rate limit info in the `RateLimit-*` headers
  legacyHeaders: false, // Disable the `X-RateLimit-*` headers
  message: {
    error: {
      message: 'Too many requests, please try again later',
      code: 'RATE_LIMIT_EXCEEDED'
    }
  }
});

// Higher limits for authenticated users
const authenticatedLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 300, // higher limit for authenticated users
  standardHeaders: true,
  legacyHeaders: false,
  // Skip rate limiting for certain IPs or special users
  skip: (req, res) => req.user?.role === 'admin',
  message: {
    error: {
      message: 'Too many requests, please try again later',
      code: 'RATE_LIMIT_EXCEEDED'
    }
  }
});

// Apply rate limiting to routes
app.use('/api/', apiLimiter);
app.use('/api/auth/', authLimiter);
app.use('/api/users/', authenticatedLimiter);
```

## Security Best Practices for Developers

1. **Authentication**
   - Always use the provided authentication middlewares
   - Never store sensitive credentials in code or logs
   - Implement proper session invalidation on logout

2. **Data Protection**
   - Always validate user input using Zod schemas
   - Use parameterized queries for database access
   - Follow the principle of least privilege for data access

3. **Error Handling**
   - Use structured error handling
   - Do not expose sensitive information in error messages
   - Log security-relevant errors appropriately

4. **Frontend Security**
   - Implement proper authentication state management
   - Sanitize user-generated content before rendering
   - Use HTTPS for all API requests

5. **API Development**
   - Apply proper authentication checks to all endpoints
   - Implement rate limiting for public endpoints
   - Validate ownership of resources in all operations

---

## documentation/testing/README.md

# TuneMantra Testing Documentation

This directory contains testing documentation for the TuneMantra platform, including test plans, testing approaches, and testing guides.

## Contents

- [Testing Approach](testing-approach.md) - Overall strategy for testing TuneMantra
- [Testing Guide](testing-guide.md) - Instructions for testing integrated features
- [Test Plan](test-plan.md) - Comprehensive test plan for the platform


---

## documentation/testing/test-plan.md

# TuneMantra Test Plan

## Overview

This test plan outlines the approach for verifying the integrated functionality of the TuneMantra music distribution platform. The focus is on validating the core capabilities, particularly the blockchain integration, rights management, and royalty calculation features.

## Test Objectives

1. Verify blockchain connectivity and multi-network support
2. Validate rights management functionality including territorial rights
3. Test royalty calculation accuracy and processing
4. Ensure proper integration between components

## Test Environment

### Prerequisites

- PostgreSQL database
- Node.js environment
- Blockchain provider APIs (Ethereum, Polygon, Mumbai)

### Configuration

- Environment variables for database connection
- Environment variables for blockchain RPC endpoints
- Feature flags for enabling/disabling specific networks

## Test Scope

### In Scope

- Blockchain connector service
- Rights management service
- Royalty calculation
- Database operations for core functions

### Out of Scope

- User interface testing
- Load/performance testing
- Security penetration testing

## Test Strategy

### Unit Testing

Each core service will be tested individually to verify its basic functionality:

- **Blockchain Connector**: Test network support and NFT operations
- **Rights Management**: Test rights registration, conflict detection
- **Royalty Calculation**: Test calculation accuracy and financial operations

### Integration Testing

Test interactions between services:

- Rights registration → Blockchain verification
- Rights management → Royalty calculation
- Blockchain operations → Database persistence

## Test Cases

### Blockchain Connector Tests

1. **Network Support**
   - Verify supported networks can be retrieved
   - Verify each network's configuration is valid

2. **NFT Minting**
   - Verify NFT can be minted for a track
   - Verify NFT metadata is properly created
   - Verify NFT details can be retrieved

### Rights Management Tests

1. **Rights Registration**
   - Verify standard rights can be registered
   - Verify territorial rights can be registered
   - Verify rights with split percentages work correctly

2. **Conflict Detection**
   - Verify conflicts are detected when total percentage exceeds 100%
   - Verify conflicts are handled properly

3. **Rights Verification**
   - Verify rights ownership can be checked
   - Verify territorial restrictions are enforced

### Royalty Calculation Tests

1. **Calculation**
   - Verify royalty amounts are calculated correctly
   - Verify splits between multiple rights holders

2. **Processing**
   - Verify royalties can be marked as processed
   - Verify royalties can be marked as paid

## Test Execution

### Running Tests

Three main test scripts have been created:

1. `scripts/test-blockchain-connector.ts`: Tests blockchain operations
2. `scripts/test-rights-management.ts`: Tests rights management
3. `scripts/test-royalty-calculation.ts`: Tests royalty calculations

A combined script `scripts/run-all-tests.ts` runs all tests in sequence.

### Test Data

The tests use a minimal set of test data created on-the-fly if it doesn't exist:
- Test users
- Test tracks
- Test releases
- Test distribution records

## Success Criteria

### Pass Criteria

- All test cases execute without errors
- Core functionality works as expected
- Data integrity is maintained

### Fail Criteria

- Critical functions fail to execute
- Database errors occur
- Inconsistent behavior is observed

## Risk Management

### Identified Risks

1. **Blockchain Provider Availability**
   - Mitigation: Use fallback providers, implement retries
   
2. **Database Performance**
   - Mitigation: Optimize queries, limit test data size

3. **Incomplete Test Coverage**
   - Mitigation: Regularly review and expand test cases

## Reporting

Test results will be captured in the console output and can be redirected to log files for analysis.

### Key Metrics

- Number of tests passed/failed
- Error types and frequency
- Transaction times for blockchain operations

## Follow-up Actions

After test execution:

1. Fix any identified issues
2. Document workarounds for known limitations
3. Update tests to cover new functionality

## Conclusion

This test plan provides a structured approach to verify the core functionality of TuneMantra. By following this plan, we can ensure that the platform's key features work as expected and integrate properly with each other.

---

## documentation/testing/testing-approach.md

# TuneMantra Testing Approach

This document outlines our testing approach for the TuneMantra platform, focusing on verification of core functionalities across both simulation-based testing and database integration.

## Testing Strategy

We've implemented a comprehensive testing strategy that combines:

1. **Simulation-Based Testing**: Core functionality tests that don't require database access
2. **Database-Integrated Tests**: Tests that interact with the actual database
3. **Database Verification**: Scripts to verify data integrity and consistency

This multi-tiered approach ensures we can verify business logic, functionality, and data integrity throughout the platform.

## Simulation Test Scripts

We've created three simulation test scripts that run independently of database connections:

### 1. Blockchain Simulator (`scripts/blockchain-simulator.ts`)

This script simulates the blockchain connector functionality, including:
- Multi-network support (Mumbai, Rinkeby)
- NFT minting operations 
- NFT metadata verification
- Token retrieval and details

The simulation accurately represents the behavior of the actual blockchain connector and helps validate the business logic before attempting actual blockchain transactions.

### 2. Rights Management Simulator (`scripts/rights-management-simulator.ts`)

This script simulates the rights management service functionality, including:
- Rights registration process
- Conflict detection (territorial, time-based and percentage-based)
- Ownership verification
- Blockchain verification of rights
- Rights retrieval by asset and user

The simulation implements the full conflict detection algorithms to ensure the rights management logic works correctly.

### 3. Royalty Calculation Simulator (`scripts/royalty-calculation-simulator.ts`)

This script simulates the royalty calculation service functionality, including:
- Platform-specific royalty rate calculations
- Territory-based royalty splitting
- Percentage-based ownership splits
- Fee calculations 
- Revenue aggregation
- Statistical breakdowns by platform and territory

## Database-Integrated Test Scripts

These scripts interact with the actual database to validate functionality:

- `scripts/test-blockchain-connector.ts`: Tests blockchain connector functionality with database storage
- `scripts/test-rights-management.ts`: Tests rights management service with database persistence
- `scripts/test-royalty-calculation.ts`: Tests royalty calculation service with database connectivity
- `scripts/setup-missing-tables.ts`: Utility script to create necessary database tables

## Database Utility and Verification Tools

We've added database utility and verification tools to ensure proper data handling:

- `scripts/db-utils.ts`: Utility functions for common database operations
- `scripts/verify-database.ts`: Script to verify data integrity and table contents

The new database utilities provide consistent methods for:
- Checking if tables exist
- Counting records and validating data
- Performing CRUD operations with proper error handling
- Transaction support for complex operations
- Connection management

## Running the Tests

### Full Test Suite

To run the complete test suite including simulation tests, database tests, and verification:

```bash
npx tsx scripts/run-all-tests.ts
```

The `run-all-tests.ts` script now runs all tests in sequence, with proper handling of database connections.

### Individual Tests

You can also run individual test scripts:

```bash
# Run just the blockchain database test
npx tsx scripts/test-blockchain-connector.ts

# Run just the database verification
npx tsx scripts/verify-database.ts

# Setup database tables
npx tsx scripts/setup-missing-tables.ts
```

## Test Results

Our test suite confirms that both the core business logic and database integration of the TuneMantra platform are working correctly. The tests verify:

1. **Blockchain Operations**:
   - Multi-network support
   - NFT minting and metadata management
   - Token retrieval and ownership verification
   - Database storage of blockchain transactions

2. **Rights Management**:
   - Proper handling of ownership registration
   - Accurate conflict detection across territories
   - Correct percentage-based ownership verification
   - Blockchain verification of rights claims
   - Database persistence of rights records

3. **Royalty Calculations**:
   - Accurate per-stream revenue calculations
   - Correct platform fee deductions
   - Precise splitting of royalties based on ownership percentages
   - Proper territorial revenue attribution
   - Comprehensive reporting capabilities

4. **Data Integrity**:
   - Verification of record counts across tables
   - Validation of data consistency
   - Confirmation of proper relationships between records

## Current Status

The tests confirm:
- 19 user records in the system
- 42 track records
- 12 user wallet entries
- 1 blockchain NFT record (created through testing)
- Properly created rights management tables (currently empty)

## Next Steps

1. Add test data for rights management to fully validate rights and royalty functionality
2. Implement remaining features identified from branch comparison
3. Conduct comprehensive end-to-end testing with frontend components
4. Deploy platform with complete testing results and metrics

---

## documentation/testing/testing-guide.md

# TuneMantra Testing Guide

This guide provides instructions on how to test the integrated features of the TuneMantra music distribution platform.

## Prerequisites

Before running the tests, ensure that:

1. The PostgreSQL database is set up and accessible
2. Environment variables are properly configured (especially blockchain provider URLs)
3. Node.js and npm are installed

## Available Test Scripts

We've created several test scripts to validate different components of the system:

1. **Blockchain Connector Tests**: `scripts/test-blockchain-connector.ts`
   - Tests multi-network support
   - Tests NFT minting functionality

2. **Rights Management Tests**: `scripts/test-rights-management.ts`
   - Tests rights registration
   - Tests conflict detection
   - Tests rights verification

3. **Royalty Calculation Tests**: `scripts/test-royalty-calculation.ts`
   - Tests royalty calculation functionality
   - Tests royalty processing

4. **Run All Tests**: `scripts/run-all-tests.ts`
   - Runs all tests in sequence

## Running the Tests

### Running Individual Tests

You can run any test script individually using:

```bash
npx tsx scripts/test-blockchain-connector.ts
```

Replace the script name with the test you want to run.

### Running All Tests

To run all tests in sequence:

```bash
npx tsx scripts/run-all-tests.ts
```

## Interpreting Test Results

Each test will output detailed information about the operations being performed and their results.

### Success Indicators

- **Blockchain Tests**: Look for successful network connections and NFT minting
- **Rights Management Tests**: Look for successful rights registration and accurate conflict detection
- **Royalty Tests**: Look for correct calculation amounts and processing status changes

### Common Issues and Troubleshooting

1. **Database Connection Errors**
   - Ensure the PostgreSQL database is running
   - Check database credentials in environment variables

2. **Blockchain Connection Errors**
   - Verify the RPC URLs in environment variables
   - Check if the blockchain provider services are available

3. **Missing Tables**
   - Some tests auto-create required tables if they don't exist
   - If you encounter errors about missing tables, check the database schema

## Environment Configuration

For optimal testing, ensure these environment variables are set:

```
# Database
DATABASE_URL=postgresql://username:password@localhost:5432/tunemantra

# Blockchain
ETHEREUM_RPC_URL=https://mainnet.infura.io/v3/your-api-key
POLYGON_RPC_URL=https://polygon-rpc.com
MUMBAI_RPC_URL=https://rpc-mumbai.maticvigil.com

# Feature Flags
ETHEREUM_ACTIVE=false
POLYGON_ACTIVE=false
MUMBAI_ACTIVE=true
DEFAULT_BLOCKCHAIN_NETWORK=mumbai
```

## Test Data

The test scripts will automatically create minimal test data if none exists, including:
- Test users
- Test tracks
- Test releases
- Test distribution records

You can manually seed more comprehensive test data if needed for more thorough testing.

## Extending the Tests

To add new tests:

1. Create a new test script in the `scripts` directory
2. Follow the pattern of existing tests
3. Add the new script to the `TEST_SCRIPTS` array in `run-all-tests.ts`

---

## documentation/user/README.md

# TuneMantra User Documentation

This section contains comprehensive documentation for users of the TuneMantra platform.

## Getting Started

- [Getting Started Guide](getting-started.md) - Introduction to the platform
- [Account Setup](account-settings-guide.md) - Setting up your account

## Role-Based Guides

- [Artist Guide](artist-guide.md) - Documentation for artists using the platform
- [Label Guide](label-guide.md) - Documentation for labels and publishers
- [Admin Guide](administration-guide.md) - Documentation for platform administrators

## Feature Guides

- [Rights Management Guide](rights-management-guide.md) - Managing rights for your content
- [Distribution Guide](distribution-guide.md) - Distributing your content
- [Royalty Management Guide](royalty-management-guide.md) - Managing royalties and payments
- [Analytics Guide](analytics-guide.md) - Using the analytics dashboard
- [Reporting Guide](reporting-guide.md) - Generating and understanding reports

## Technical Guides

- [Audio Fingerprinting Guide](audio-fingerprinting-guide.md) - Understanding audio fingerprinting
- [Blockchain Features Guide](blockchain-features-guide.md) - Using blockchain features

## Resources

- [FAQs](resources/faqs.md) - Frequently asked questions
- [Troubleshooting](resources/troubleshooting.md) - Common issues and solutions
- [Templates](resources/templates.md) - Useful templates for creating content

---

## documentation/user/account-settings-guide.md

# Account Settings Guide for TuneMantra

<div align="center">
  <img src="../diagrams/settings-guide-header.svg" alt="TuneMantra Account Settings Guide" width="800"/>
</div>

## Introduction

Welcome to TuneMantra's comprehensive Account Settings Guide. This document provides detailed instructions on how to configure and manage your account settings within the TuneMantra platform. Properly configured account settings are essential for security, efficiency, and ensuring the platform is tailored to your specific needs. Whether you're an individual artist, a label manager, or a rights administrator, this guide will help you optimize your TuneMantra experience through proper account configuration.

## Table of Contents

- [Account Management](#account-management)
- [Profile Settings](#profile-settings)
- [Security Settings](#security-settings)
- [Team Management](#team-management)
- [Notification Preferences](#notification-preferences)
- [Integration Settings](#integration-settings)
- [Billing and Subscription](#billing-and-subscription)
- [Legal and Compliance](#legal-and-compliance)
- [Display and Accessibility](#display-and-accessibility)
- [API Access](#api-access)
- [FAQ](#frequently-asked-questions)

## Account Management

### Account Dashboard

Central location for managing all account-related settings:

<div align="center">
  <img src="../screenshots/account-dashboard.png" alt="Account Dashboard" width="700"/>
</div>

1. **Dashboard Overview**
   - Account summary and status
   - Quick settings access
   - Recent account activity
   - Verification status
   - Account health indicators
   - Support access

2. **Account Types**
   - Individual artist accounts
   - Label accounts
   - Publisher accounts
   - Distributor accounts
   - Administrator accounts
   - Multi-entity accounts

3. **Account Verification**
   - Identity verification process
   - Business verification requirements
   - Verification status tracking
   - Required documentation
   - Additional verification levels
   - Verification benefits

4. **Account Navigation**
   - Settings categories
   - Quick access favorites
   - Settings search
   - Recent settings
   - Guided setup paths
   - Mobile settings navigation

### Account Details

Manage basic information about your account:

1. **Basic Information**
   - Account name
   - Account type
   - Registration date
   - Account ID/Reference number
   - Parent account (if applicable)
   - Account status

2. **Contact Information**
   - Primary contact details
   - Secondary contact options
   - Support contact designation
   - Business address
   - Support preferences
   - Time zone settings

3. **Language and Region**
   - Interface language preference
   - Regional format settings
   - Currency preferences
   - Time zone configuration
   - Tax jurisdiction
   - Compliance region

4. **Account Preferences**
   - Default views and pages
   - Email communication preferences
   - Privacy settings
   - Data usage preferences
   - Marketing preferences
   - Default filters

### Multi-Account Management

For users with multiple entities or roles:

1. **Account Switching**
   - Account list and selection
   - Quick-switch functionality
   - Permission-aware switching
   - Account-specific bookmarks
   - Visual account indicators
   - Default account setting

2. **Role Management**
   - Multiple role configuration
   - Role-specific permissions
   - Context-aware role switching
   - Role combination handling
   - Role conflict resolution
   - Role documentation

3. **Cross-Account Features**
   - Unified notifications
   - Cross-account search
   - Aggregated dashboards
   - Combined reporting
   - Shared asset management
   - Consolidated history

4. **Entity Relationships**
   - Parent-child relationships
   - Partnership configurations
   - Entity mergers and acquisitions
   - Group affiliations
   - Distribution relationships
   - Rights holder connections

## Profile Settings

### Personal Profile

Manage your individual user profile:

<div align="center">
  <img src="../screenshots/profile-settings.png" alt="Profile Settings" width="700"/>
</div>

1. **Profile Information**
   - Name and credentials
   - Professional title
   - Biography/About section
   - Profile image
   - Professional links
   - Skills and expertise

2. **Communication Details**
   - Contact email
   - Phone number
   - Messaging preferences
   - Alternative contact methods
   - Social profiles
   - Public contact settings

3. **Professional Information**
   - Company affiliation
   - Industry role
   - Experience level
   - Specializations
   - Professional achievements
   - Industry certifications

4. **Privacy Controls**
   - Profile visibility settings
   - Information sharing preferences
   - Contact permission settings
   - Third-party visibility
   - Public profile options
   - Activity visibility

### Organization Profile

Configure details for your label, publisher, or company:

1. **Organization Details**
   - Legal entity name
   - Trading name (if different)
   - Company registration details
   - Year established
   - Organization size
   - Industry classification

2. **Brand Assets**
   - Company logo (various formats)
   - Brand color scheme
   - Branded elements
   - Style guide integration
   - Watermark settings
   - Brand usage settings

3. **Organization Structure**
   - Departments and divisions
   - Leadership structure
   - Team organization
   - Subsidiary relationships
   - Partner connections
   - Distribution hierarchy

4. **Public Presence**
   - Website and social media
   - Press kit materials
   - Company description
   - Mission statement
   - Notable achievements
   - Flagship artists/releases

### Artist Profiles

Manage artist identity and branding:

1. **Artist Information**
   - Artist/band name
   - Genre classifications
   - Formation date
   - Member information
   - Origin/location
   - Label affiliations

2. **Artist Images**
   - Profile photos
   - Press photos
   - Album artwork
   - Logo and branding
   - Press kit visuals
   - Social media assets

3. **Biography and Description**
   - Short and long biography
   - Artist statement
   - Career highlights
   - Influences and style
   - Awards and recognition
   - Press quotes

4. **Artist Links**
   - Website URL
   - Social media profiles
   - Streaming platform links
   - Video channel links
   - Booking contact
   - Press contact

## Security Settings

### Account Security

Protect your account with robust security measures:

<div align="center">
  <img src="../screenshots/security-settings.png" alt="Security Settings" width="700"/>
</div>

1. **Password Management**
   - Password strength requirements
   - Password change process
   - Password history policy
   - Password expiration settings
   - Password recovery options
   - Password security tips

2. **Multi-Factor Authentication**
   - MFA setup process
   - Supported authentication methods
   - Backup verification options
   - Device management
   - Session verification settings
   - Recovery code management

3. **Login Settings**
   - Session duration configuration
   - Device trust settings
   - Login notification preferences
   - Geographic access restrictions
   - IP address restrictions
   - Suspicious activity detection

4. **Account Recovery**
   - Recovery email configuration
   - Recovery phone setup
   - Trusted contacts designation
   - Security questions
   - Recovery documentation
   - Recovery process overview

### Access Control

Manage who can access your account and what they can do:

1. **Permission Levels**
   - Role-based access control
   - Custom permission sets
   - Permission inheritance
   - Permission templates
   - Temporary permissions
   - Emergency access protocol

2. **User Access Management**
   - User invitation process
   - Access request handling
   - User deprovisioning
   - Access recertification
   - Dormant account handling
   - Access logging and review

3. **Resource Permissions**
   - Catalog access permissions
   - Financial information access
   - Analytics view permissions
   - Report access controls
   - Asset permission management
   - Settings modification rights

4. **Third-Party Access**
   - API access management
   - Vendor access controls
   - Partner permission settings
   - Integration permission scopes
   - External user management
   - Service account controls

### Security Monitoring

Track and protect account security:

1. **Activity Logs**
   - Login history
   - Setting changes log
   - Permission modifications
   - Security event recording
   - Data access tracking
   - Export and sharing logs

2. **Security Notifications**
   - Unusual activity alerts
   - New device login notices
   - Permission change alerts
   - Password update confirmations
   - Security setting modifications
   - Recovery activity notices

3. **Vulnerability Management**
   - Security assessment tools
   - Vulnerability scanning
   - Security recommendation engine
   - Risk scoring
   - Remediation guidance
   - Security posture dashboard

4. **Compliance Monitoring**
   - Security policy adherence
   - Regulatory compliance checks
   - Security certification status
   - Audit preparedness tools
   - Compliance reporting
   - Policy violation alerts

## Team Management

### Team Structure

Organize your team for effective collaboration:

<div align="center">
  <img src="../screenshots/team-management.png" alt="Team Management" width="700"/>
</div>

1. **Team Creation**
   - Team setup process
   - Team naming and description
   - Team type selection
   - Team purpose definition
   - Team visibility settings
   - Team hierarchy placement

2. **Team Membership**
   - Member invitation process
   - Role assignment within team
   - Membership approval workflow
   - External collaborator inclusion
   - Membership duration control
   - Bulk member management

3. **Team Hierarchy**
   - Parent-child team relationships
   - Cross-functional team connections
   - Reporting relationships
   - Resource inheritance
   - Visibility inheritance
   - Permission cascading

4. **Team Settings**
   - Notification preferences
   - Meeting configurations
   - Resource allocation
   - Default workspace settings
   - Team branding options
   - Collaboration tool preferences

### Role Management

Define and assign user roles within your organization:

1. **Role Definitions**
   - Standard role templates
   - Custom role creation
   - Role description and documentation
   - Permission bundle assignment
   - Role scope definition
   - Role hierarchy placement

2. **Role Assignment**
   - User-role matching
   - Multiple role handling
   - Temporary role assignment
   - Role transition management
   - Role conflict prevention
   - Role assignment approval

3. **Role Hierarchy**
   - Supervisory relationships
   - Delegation chains
   - Approval hierarchies
   - Escalation paths
   - Override authority
   - Authority limitations

4. **Role Governance**
   - Role review processes
   - Separation of duties enforcement
   - Least privilege principles
   - Role consolidation analysis
   - Role usage monitoring
   - Role-based access certification

### Collaboration Settings

Configure how your team works together:

1. **Communication Tools**
   - Internal messaging configuration
   - Commenting preferences
   - Notification routing
   - @mention capabilities
   - Communication history
   - Thread management

2. **Workflow Configuration**
   - Approval process setup
   - Task assignment rules
   - Workflow templates
   - Stage gate configuration
   - Deadline management
   - Escalation procedures

3. **Shared Resources**
   - Document sharing settings
   - Collaborative editing
   - Resource locking protocols
   - Version control settings
   - Contribution tracking
   - Review and approval flows

4. **Activity Tracking**
   - Team activity dashboard
   - Individual contribution metrics
   - Project progress visualization
   - Milestone tracking
   - Deadline monitoring
   - Performance analytics

## Notification Preferences

### Notification Settings

Control how and when you receive alerts:

<div align="center">
  <img src="../screenshots/notification-settings.png" alt="Notification Settings" width="700"/>
</div>

1. **Notification Types**
   - System notifications
   - Security alerts
   - Content updates
   - Financial notifications
   - Team communications
   - Deadline reminders
   - Performance alerts

2. **Delivery Channels**
   - Email notifications
   - In-app notifications
   - Mobile push notifications
   - SMS alerts
   - Desktop notifications
   - Webhook deliveries

3. **Notification Frequency**
   - Real-time alerts
   - Digest configuration (daily, weekly)
   - Quiet hours setting
   - Batching preferences
   - Priority-based delivery
   - Frequency limitations

4. **Content Controls**
   - Notification detail level
   - Preview content settings
   - Sensitive information handling
   - Language preferences
   - Formatting options
   - Rich media inclusion

### Alert Prioritization

Organize notifications by importance:

1. **Priority Levels**
   - Critical alerts
   - High priority notifications
   - Standard notifications
   - Informational updates
   - Background activity
   - Custom priority categories

2. **Priority Rules**
   - Automatic prioritization criteria
   - Manual priority assignment
   - Context-based priority adjustment
   - Time-sensitive escalation
   - Value-based prioritization
   - Role-specific priority settings

3. **Alert Handling**
   - Acknowledgment requirements
   - Response tracking
   - Escalation paths
   - Delegation options
   - Alert aging policies
   - Alert resolution tracking

4. **Notification Analytics**
   - Volume tracking
   - Response time analysis
   - Effectiveness metrics
   - Action conversion rates
   - User engagement patterns
   - Notification optimization

### Subscription Management

Control ongoing updates and communications:

1. **Content Subscriptions**
   - Release updates
   - Performance reports
   - Industry news
   - Platform updates
   - Educational content
   - Event notifications

2. **Subscription Levels**
   - Full content delivery
   - Summary-only options
   - Threshold-based alerts
   - Exception notifications
   - Milestone updates
   - Custom subscription rules

3. **Subscription Management**
   - Topic-based subscription
   - Entity-level following
   - Subscription bundling
   - Temporary subscription pausing
   - Subscription recommendations
   - One-click unsubscribe

4. **Communication Preferences**
   - Preferred notification time
   - Communication frequency caps
   - Channel preferences by type
   - Content format preferences
   - Language and locale settings
   - Accessibility requirements

## Integration Settings

### Platform Connections

Connect TuneMantra with external services:

<div align="center">
  <img src="../screenshots/integration-settings.png" alt="Integration Settings" width="700"/>
</div>

1. **Streaming Platforms**
   - Spotify integration
   - Apple Music connection
   - Amazon Music linking
   - YouTube Music setup
   - Tidal integration
   - Custom DSP connections

2. **Social Media**
   - Facebook integration
   - Instagram connection
   - Twitter linking
   - TikTok integration
   - YouTube channel connection
   - LinkedIn organization linking

3. **Financial Services**
   - Banking connections
   - Payment processor integration
   - Accounting software linking
   - Invoicing system connection
   - Tax preparation service
   - Payroll system integration

4. **Creative Tools**
   - Digital audio workstation integration
   - Design software connection
   - Video editing platform linking
   - Content management systems
   - Asset management platforms
   - Creative collaboration tools

### API Configuration

Manage programmatic access to your account:

1. **API Key Management**
   - API key generation
   - Key rotation policies
   - Permission scoping
   - Usage limits configuration
   - IP restriction settings
   - Key revocation procedures

2. **Webhook Configuration**
   - Webhook endpoint registration
   - Event subscription
   - Webhook security settings
   - Delivery retry policies
   - Webhook monitoring
   - Testing and validation tools

3. **OAuth Applications**
   - OAuth client registration
   - Redirect URL configuration
   - Scope definition
   - Token lifetime settings
   - Refresh token policies
   - Application verification

4. **API Usage Monitoring**
   - Request volume tracking
   - Rate limit monitoring
   - Error tracking
   - Performance analytics
   - Usage pattern analysis
   - Cost allocation

### Data Exchange Settings

Configure how data flows between systems:

1. **Import Configuration**
   - Data source connections
   - Import schedule setup
   - Data mapping configuration
   - Validation rule definition
   - Error handling preferences
   - Notification settings

2. **Export Settings**
   - Export format preferences
   - Scheduled export configuration
   - Destination configuration
   - Post-processing options
   - Export scope definition
   - Security and encryption

3. **Synchronization Options**
   - Bi-directional sync configuration
   - Conflict resolution rules
   - Frequency settings
   - Field-level sync mapping
   - Historical sync options
   - Trigger-based sync

4. **Integration Monitoring**
   - Connection status dashboard
   - Data flow visualization
   - Error and exception tracking
   - Performance metrics
   - Throughput analytics
   - Integration health scoring

## Billing and Subscription

### Subscription Management

Manage your TuneMantra plan and features:

<div align="center">
  <img src="../screenshots/subscription-settings.png" alt="Subscription Settings" width="700"/>
</div>

1. **Plan Information**
   - Current plan details
   - Feature entitlements
   - Usage allocations
   - Plan comparison
   - Upgrade/downgrade options
   - Special offers

2. **Subscription Changes**
   - Plan upgrade process
   - Downgrade procedure
   - Add-on feature selection
   - User seat management
   - Storage capacity adjustment
   - Feature activation/deactivation

3. **Renewal Settings**
   - Auto-renewal configuration
   - Renewal notification preferences
   - Renewal date information
   - Term length options
   - Early renewal incentives
   - Renewal authorization

4. **Usage Monitoring**
   - Resource usage tracking
   - Limit proximity alerts
   - Historical usage patterns
   - Projected usage forecasting
   - Usage optimization suggestions
   - Overage handling preferences

### Payment Methods

Manage how you pay for services:

1. **Payment Options**
   - Credit/debit card management
   - Bank account connection
   - PayPal integration
   - Wire transfer setup
   - Digital payment methods
   - Currency selection

2. **Billing Contact**
   - Primary billing contact
   - Alternate contacts
   - Billing email preferences
   - Billing address management
   - Tax identification information
   - Billing notification settings

3. **Auto-Payment Configuration**
   - Automatic payment setup
   - Payment retry settings
   - Payment failure handling
   - Backup payment method
   - Threshold-based charging
   - Prepayment options

4. **Payment Security**
   - Card storage security
   - PCI compliance information
   - Tokenization explanation
   - Authorization policies
   - Payment verification methods
   - Fraud prevention measures

### Billing History

Access and manage past transactions:

1. **Invoice Access**
   - Complete invoice history
   - Invoice detail view
   - Invoice search and filtering
   - Invoice download options
   - Tax document access
   - Statement view options

2. **Payment Records**
   - Payment transaction history
   - Payment receipt access
   - Payment method used
   - Transaction ID reference
   - Payment status tracking
   - Refund and credit history

3. **Billing Analytics**
   - Spending trend analysis
   - Service usage correlation
   - Cost center allocation
   - Budget comparison
   - Forecast projection
   - Cost optimization suggestions

4. **Billing Preferences**
   - Invoice delivery method
   - Invoice format options
   - Billing cycle selection
   - Currency display preference
   - Tax handling options
   - Custom field requirements

## Legal and Compliance

### Terms and Agreements

Manage legal documents and contracts:

<div align="center">
  <img src="../screenshots/legal-settings.png" alt="Legal Settings" width="700"/>
</div>

1. **Terms Acceptance**
   - Terms of service status
   - Privacy policy acknowledgment
   - User agreement tracking
   - Amendment acceptance history
   - Special terms documentation
   - Pending agreement alerts

2. **Contract Management**
   - Artist agreements
   - Distribution contracts
   - Service level agreements
   - Partner contracts
   - Vendor agreements
   - Employee/contractor documents

3. **Rights Documentation**
   - Copyright registration
   - Trademark documentation
   - Patent information
   - License agreements
   - Assignment documentation
   - Rights clearance records

4. **Policy Acknowledgments**
   - Acceptable use policy
   - Code of conduct
   - Anti-harassment policy
   - Information security policy
   - Data handling guidelines
   - Conflict of interest policy

### Privacy Settings

Control how your data is used and shared:

1. **Data Usage Preferences**
   - Analytics participation
   - Feature improvement data
   - Marketing data usage
   - Personalization settings
   - Third-party data sharing
   - Research participation

2. **Data Subject Rights**
   - Access request process
   - Data portability options
   - Right to be forgotten
   - Processing limitation
   - Objection handling
   - Automated decision exclusion

3. **Consent Management**
   - Consent tracking dashboard
   - Granular consent settings
   - Consent withdrawal options
   - Re-consent workflows
   - Purpose specification
   - Consent receipt access

4. **Privacy Controls**
   - Profile visibility settings
   - Activity tracking limitations
   - Communication restrictions
   - Search engine visibility
   - Metadata privacy options
   - Anonymity preferences

### Compliance Records

Maintain documentation for regulatory compliance:

1. **Compliance Documentation**
   - Regulatory certification status
   - Compliance audit history
   - Standard adherence evidence
   - Policy implementation records
   - Training completion tracking
   - Remediation history

2. **Tax Information**
   - Tax identification documents
   - Withholding certificates
   - Tax treaty documentation
   - VAT/GST registration
   - Tax exemption evidence
   - International tax compliance

3. **Industry Compliance**
   - Music industry standards compliance
   - Royalty compliance documentation
   - Rights management certification
   - Metadata standard adherence
   - Platform-specific compliance
   - Geographic restriction compliance

4. **Data Protection Records**
   - GDPR compliance documentation
   - CCPA compliance evidence
   - Data processing records
   - Impact assessment history
   - Breach notification records
   - Cross-border transfer documentation

## Display and Accessibility

### Visual Preferences

Customize how TuneMantra looks for you:

<div align="center">
  <img src="../screenshots/display-settings.png" alt="Display Settings" width="700"/>
</div>

1. **Theme Options**
   - Light/dark mode selection
   - Color scheme customization
   - Contrast adjustment
   - Font size preferences
   - Layout density options
   - Custom branding application

2. **Dashboard Customization**
   - Widget arrangement
   - Default dashboard selection
   - Metric visibility toggles
   - Visualization preferences
   - Information density setting
   - Dashboard rotation options

3. **Layout Configuration**
   - Navigation panel position
   - Workspace layout selection
   - Panel expansion defaults
   - Split-screen configuration
   - Multi-monitor optimization
   - Mobile layout preferences

4. **Visual Accessibility**
   - High contrast mode
   - Screen reader optimization
   - Motion reduction settings
   - Focus indicator enhancement
   - Color blindness accommodation
   - Text scaling options

### Language and Localization

Configure regional and language settings:

1. **Language Selection**
   - Interface language
   - Content language preference
   - Translation quality feedback
   - Missing translation reporting
   - Language fallback order
   - Bi-lingual display options

2. **Regional Formats**
   - Date format preference
   - Time format selection
   - Number formatting
   - Currency display options
   - Measurement unit selection
   - Calendar type preference

3. **Localization Settings**
   - Time zone configuration
   - First day of week selection
   - Holiday calendar integration
   - Working hours definition
   - Regional compliance adaptation
   - Geographic customization

4. **Translation Management**
   - User-contributed translations
   - Glossary customization
   - Industry-specific terminology
   - Machine translation preferences
   - Translation memory utilization
   - Automated translation settings

### Accessibility Configuration

Make TuneMantra work for all users:

1. **Input Preferences**
   - Keyboard shortcut customization
   - Voice control settings
   - Alternative input device support
   - Pointer precision adjustment
   - Touch interaction customization
   - Gesture configuration

2. **Perception Assistance**
   - Screen reader optimization
   - Audio description enabling
   - Captioning preferences
   - Text-to-speech settings
   - Visual notification alternatives
   - Tactile feedback options

3. **Cognitive Support**
   - Simplified interface option
   - Step-by-step guidance
   - Reading level adjustment
   - Attention focus tools
   - Memory assistance features
   - Distraction reduction settings

4. **Mobility Accommodations**
   - Target size enlargement
   - Dwell clicking options
   - Pointer stabilization
   - Sticky keys configuration
   - Timing adjustment
   - Action cancellation safety

## API Access

### API Management

Control programmatic access to your data:

<div align="center">
  <img src="../screenshots/api-settings.png" alt="API Settings" width="700"/>
</div>

1. **API Credentials**
   - API key generation process
   - Secret management
   - Authentication token setup
   - Credential expiration policies
   - Emergency revocation procedure
   - Credential rotation practices

2. **Access Scopes**
   - Available permission scopes
   - Scope combination rules
   - Least privilege application
   - Temporary scope elevation
   - Scope limitation by environment
   - Custom scope definition

3. **Rate Limiting**
   - Request quota configuration
   - Rate tier selection
   - Burst allowance settings
   - Throttling behavior preferences
   - Quota increase request process
   - Usage notification thresholds

4. **API Monitoring**
   - Usage dashboard
   - Performance metrics
   - Error tracking
   - Latency monitoring
   - Availability statistics
   - Usage pattern visualization

### Developer Tools

Resources for integrating with TuneMantra:

1. **Development Resources**
   - API documentation access
   - SDK availability
   - Code examples library
   - Postman collection
   - Test environment access
   - Version migration guides

2. **Testing and Sandbox**
   - Sandbox environment setup
   - Test data generation
   - Request validation tools
   - Mock response configuration
   - Performance testing utilities
   - Integration testing frameworks

3. **Application Registration**
   - OAuth client registration
   - Application verification process
   - Redirect URL management
   - Application listing control
   - User consent customization
   - Application icon and branding

4. **Developer Support**
   - Developer forum access
   - Support ticket priority
   - Feature request submission
   - Beta program enrollment
   - Developer newsletter subscription
   - Technical consultation booking

### Webhook Configuration

Set up automated notifications for events:

1. **Endpoint Management**
   - Webhook URL registration
   - Endpoint verification process
   - Security configuration
   - Health monitoring setup
   - Load balancing options
   - Endpoint rotation policies

2. **Event Subscription**
   - Available event types
   - Event filtering criteria
   - Subscription bundling
   - Event sampling options
   - Version selection
   - Custom payload configuration

3. **Delivery Settings**
   - Retry policy configuration
   - Delivery timeout settings
   - Concurrent delivery limits
   - Delivery ordering preferences
   - Batch vs. individual delivery
   - Delivery acknowledgment requirements

4. **Webhook Security**
   - Signature verification setup
   - IP restriction configuration
   - Rate protection measures
   - Payload encryption options
   - Mutual TLS configuration
   - Secret rotation management

## Frequently Asked Questions

### Account Questions

**Q: How do I change the primary email address on my account?**  
A: Changing your primary email requires verification of both old and new addresses:
1. Navigate to Account Settings > Profile > Contact Information
2. Click "Change" next to your current email address
3. Enter your new email address and your current password
4. A verification code will be sent to your new email address
5. Enter the verification code to complete the change
6. A confirmation will be sent to both old and new email addresses

For security reasons, you'll continue to receive important security notifications at both addresses for 30 days after the change. If you no longer have access to your old email, please contact support with verification documentation.

**Q: Can I have multiple users with different permission levels for my label account?**  
A: Yes, TuneMantra supports sophisticated team management:
1. Go to Account Settings > Team Management > Team Members
2. Click "Add Team Member" and enter their email address
3. Select one of our predefined roles (Admin, Finance, A&R, Marketing, etc.) or create a custom role
4. Customize specific permissions if needed
5. Set access limitations by catalog, territory, or function if required
6. Review and confirm the invitation

The new user will receive an email invitation to join your team. You can add up to 5 team members with the Standard plan, 15 with the Professional plan, and unlimited with the Enterprise plan. Each team member can have their own login credentials while accessing your shared account resources based on their permissions.

**Q: How do I add or remove seats from my subscription?**  
A: Adjusting your subscription seats is simple:
1. Go to Account Settings > Billing & Subscription > Subscription Management
2. Click "Modify Subscription" and select "Adjust Seats"
3. Use the controls to increase or decrease your seat count
4. Review the prorated cost adjustment
5. Confirm your changes

For seat increases, you'll be charged immediately for the prorated amount through your billing period. For seat decreases, the change will take effect at your next renewal date unless you select "Apply Immediately," which will provide an account credit for unused time. Note that you cannot reduce seats below the number of active users; you'll need to remove users first.

### Security Questions

**Q: How do I enable two-factor authentication for my account?**  
A: To enhance your account security with 2FA:
1. Go to Account Settings > Security > Multi-Factor Authentication
2. Click "Enable 2FA" and select your preferred method:
   - Authenticator App (recommended)
   - SMS Text Messages
   - Email Codes
3. Follow the setup instructions for your chosen method
4. Save your backup recovery codes in a secure location
5. Verify the setup by completing a test login

Once enabled, you'll need both your password and a verification code when logging in from new devices or after 30 days on trusted devices. We strongly recommend using an authenticator app like Google Authenticator, Microsoft Authenticator, or Authy for the most secure experience, as SMS can be vulnerable to interception.

**Q: What should I do if I suspect unauthorized access to my account?**  
A: If you believe your account has been compromised:
1. Immediately go to Account Settings > Security > Emergency Actions
2. Click "Secure My Account" to initiate our security protocol:
   - This immediately logs out all active sessions
   - Temporarily suspends API access
   - Prompts an immediate password reset
   - Enables additional monitoring
2. Complete the password reset process with a strong, unique password
3. Review recent account activity in the Security Audit Log
4. Check for any unauthorized changes to payment methods, contact info, or team members
5. Enable two-factor authentication if not already active
6. Contact support for additional security review

For added protection, consider reviewing authorized applications and integrations and revoking any you don't recognize or need.

**Q: Can I restrict account access to specific IP addresses?**  
A: Yes, IP restrictions are available on Professional and Enterprise plans:
1. Go to Account Settings > Security > Access Controls
2. Select "IP Restrictions" from the security options
3. Choose your restriction mode:
   - Allowlist Mode (only specified IPs can access)
   - Denylist Mode (specified IPs are blocked)
4. Add IP addresses or CIDR ranges to your list
5. Set an emergency override contact in case of legitimate access issues
6. Enable email notifications for blocked access attempts
7. Save your configuration

Remember that IP restrictions apply to all access methods including the web interface, API access, and mobile applications. We recommend testing your configuration carefully and keeping at least one emergency contact who can disable restrictions if legitimate access is blocked. IP restrictions work alongside other security measures like 2FA for layered protection.

### Billing Questions

**Q: How do I update my payment method or billing information?**  
A: To update your payment information:
1. Navigate to Account Settings > Billing & Subscription > Payment Methods
2. To add a new method:
   - Click "Add Payment Method"
   - Enter the required details
   - Set as default if desired
3. To update an existing method:
   - Select the payment method
   - Click "Edit" or "Update"
   - Make your changes
4. To update billing information:
   - Go to the "Billing Information" tab
   - Edit company name, address, tax ID, etc.
   - Save your changes

Changes to your payment method take effect immediately. If you're removing your only payment method, you'll need to add a new one first. For subscription payments, the default payment method will be used for your next billing cycle.

**Q: What happens if I exceed my plan's usage limits?**  
A: TuneMantra handles usage overages in the following ways:
1. Notification: You'll receive alerts at 80% and 95% of your limits
2. Grace Buffer: Most limits include a 10% buffer before overage charges apply
3. Overage Handling (varies by feature):
   - Storage: Automatic charging at your plan's overage rate
   - API Calls: Rate limiting once threshold is reached
   - Distributions: Queuing of new requests until next cycle
   - Team Seats: Required upgrade before adding more users
4. Billing: Any overages appear as line items on your next invoice

You can monitor your current usage in Account Settings > Billing & Subscription > Usage Dashboard. To avoid overages, consider upgrading your plan if you consistently approach your limits. Enterprise customers can configure custom overage handling, including hard caps with no additional charges.

**Q: How do I get a copy of my invoices for accounting purposes?**  
A: All billing documentation is easily accessible:
1. Go to Account Settings > Billing & Subscription > Billing History
2. Find the invoice you need in the list
3. Click "Download" to get a PDF copy
4. For additional formats:
   - Use the "Export" button
   - Select format (PDF, CSV, or JSON)
   - Choose download or email delivery
5. For legal/tax documentation:
   - Select the "Tax Documents" tab
   - Download annual statements, VAT receipts, etc.

For automated delivery, you can configure invoice email settings or set up a webhook notification for new invoices. Enterprise customers can also arrange for automated delivery to accounting systems via SFTP or API integration.

### Integration Questions

**Q: How do I connect my Spotify for Artists account with TuneMantra?**  
A: To integrate Spotify for Artists data:
1. Go to Account Settings > Integrations > Streaming Platforms
2. Locate Spotify in the platform list and click "Connect"
3. Click "Authorize with Spotify"
4. Log in to your Spotify for Artists account when prompted
5. Review the requested permissions and click "Authorize"
6. Complete any additional verification steps requested by Spotify
7. Return to TuneMantra to confirm successful connection

Once connected, your Spotify streaming data will begin syncing to TuneMantra within 24-48 hours. Historical data for up to 36 months may be imported depending on your subscription level. You can verify the connection status and last sync time in the integration dashboard. For troubleshooting or disconnection, return to the same settings page.

**Q: Can I use the TuneMantra API to build my own custom reports or applications?**  
A: Yes, our comprehensive API enables custom integrations:
1. Go to Account Settings > API Access > API Keys
2. Click "Generate New API Key"
3. Name your key based on its purpose (e.g., "Custom Reporting Tool")
4. Select the specific scopes (permissions) required
5. Set any optional restrictions (IP limits, rate limits, expiration)
6. Create and securely store your new API credentials

Once you have your credentials, visit our Developer Portal (developers.tunemantra.com) for documentation, code examples, and SDKs in popular languages. All plans include API access, but quotas and available endpoints vary by subscription level. Remember that API keys grant access to your account, so handle them securely and rotate them periodically.

**Q: How do I set up automated data exports to my own systems?**  
A: TuneMantra offers several data export automation options:
1. Scheduled Reports:
   - Configure in Reporting > Scheduled Reports
   - Set delivery to SFTP, cloud storage, or email
   - Define frequency, format, and content

2. Webhook Notifications:
   - Configure in Account Settings > API Access > Webhooks
   - Receive real-time data on specified events
   - Process data in your own systems

3. Direct Database Connection (Enterprise only):
   - Request secure read-replica access
   - Connect your BI tools directly
   - Set up ETL processes

4. Custom API Integration:
   - Use our REST API with your authentication
   - Implement polling or event-based synchronization
   - Develop against our sandbox environment

The most popular approach is scheduled exports to a cloud storage provider (S3, GCS, Azure Blob) combined with webhook notifications for real-time updates. Enterprise customers can request customized integration solutions through their account manager.

---

## Support Resources

If you need additional assistance with account settings:

- **Knowledge Base**: Visit [help.tunemantra.com/account-settings](https://help.tunemantra.com/account-settings) for detailed tutorials
- **Video Guides**: Access step-by-step video guides in the Settings Learning Center
- **Live Support**: Chat with our support team via the in-app chat feature
- **Security Resources**: Review security best practices at [security.tunemantra.com](https://security.tunemantra.com)
- **Account Manager**: Enterprise customers can contact their dedicated account manager

---

**Document Information:**
- Version: 2.0
- Last Updated: March 25, 2025
- Contact: documentation@tunemantra.com

---

## documentation/user/administration-guide.md

# TuneMantra Administration Guide

*Version: 1.0.0 (March 27, 2025)*

## Table of Contents

- [Introduction](#introduction)
- [Administrator Roles](#administrator-roles)
- [System Administration](#system-administration)
  - [User Management](#user-management)
  - [Organization Management](#organization-management)
  - [Platform Configuration](#platform-configuration)
  - [Security Settings](#security-settings)
  - [System Monitoring](#system-monitoring)
- [Content Administration](#content-administration)
  - [Catalog Management](#catalog-management)
  - [Distribution Management](#distribution-management)
  - [Rights Management](#rights-management)
  - [Royalty Settings](#royalty-settings)
- [Financial Administration](#financial-administration)
  - [Payment Management](#payment-management)
  - [Revenue Processing](#revenue-processing)
  - [Tax Settings](#tax-settings)
  - [Financial Reports](#financial-reports)
- [Analytics and Reporting](#analytics-and-reporting)
  - [Dashboard Configuration](#dashboard-configuration)
  - [Report Generation](#report-generation)
  - [Data Export](#data-export)
  - [Custom Metrics](#custom-metrics)
- [Platform Maintenance](#platform-maintenance)
  - [Scheduled Maintenance](#scheduled-maintenance)
  - [Backup and Recovery](#backup-and-recovery)
  - [Performance Tuning](#performance-tuning)
  - [Issue Troubleshooting](#issue-troubleshooting)
- [Appendix](#appendix)
  - [Admin API Reference](#admin-api-reference)
  - [Configuration Reference](#configuration-reference)
  - [Error Codes](#error-codes)
  - [Glossary](#glossary)

## Introduction

The TuneMantra Administration Guide provides comprehensive information for platform administrators to effectively manage and maintain the TuneMantra system. This guide covers all aspects of administration, from user management to system configuration and maintenance procedures.

### Purpose of This Guide

This document serves as the primary reference for administrators, enabling them to:

1. Configure and maintain the TuneMantra platform
2. Manage users, organizations, and their permissions
3. Oversee content, distribution, and rights management
4. Configure financial settings and payment processes
5. Generate reports and analyze platform data
6. Troubleshoot issues and perform system maintenance

### Target Audience

This guide is intended for:

- **System Administrators**: Responsible for platform configuration, maintenance, and security
- **Content Administrators**: Managing catalog, distribution, and rights
- **Financial Administrators**: Overseeing royalty calculations, payments, and financial reporting
- **Organization Administrators**: Managing users and settings within an organization

### Prerequisites

Administrators should have:

- Access to an administrator account with appropriate permissions
- Understanding of digital music distribution processes
- Familiarity with rights management and royalty calculations
- Basic knowledge of database concepts and web technologies
- Understanding of security best practices

## Administrator Roles

TuneMantra supports multiple administrator roles with different responsibilities and permission levels.

### Super Administrator

Super Administrators have unrestricted access to all platform functions and settings.

**Responsibilities:**
- System-wide configuration
- Managing all organizations
- Creating and managing other administrator accounts
- Security policy enforcement
- System maintenance and updates

**Access Level:** Complete access to all features and data

### System Administrator

System Administrators manage platform-wide settings and configurations.

**Responsibilities:**
- Platform configuration
- System monitoring
- Performance optimization
- Backup and recovery
- API management

**Access Level:** Full access to system settings, limited access to organization data

### Organization Administrator

Organization Administrators manage settings and users for their specific organization.

**Responsibilities:**
- Managing organization users
- Configuring organization settings
- Overseeing content and distribution
- Managing rights and royalties
- Financial reporting for the organization

**Access Level:** Full access to organization data, no access to other organizations

### Content Administrator

Content Administrators focus on catalog and distribution management.

**Responsibilities:**
- Managing music catalog
- Configuring distribution settings
- Overseeing DSP relationships
- Content quality control
- Metadata management

**Access Level:** Full access to content features, limited access to financial features

### Financial Administrator

Financial Administrators handle royalty calculations and payments.

**Responsibilities:**
- Configuring royalty rules
- Processing payments
- Managing tax settings
- Financial reporting
- Revenue reconciliation

**Access Level:** Full access to financial features, limited access to content features

## System Administration

### User Management

The User Management section allows administrators to create, modify, and manage user accounts.

#### Creating Users

To create a new user:

1. Navigate to **Administration → User Management → Users**
2. Click the **Add User** button
3. Fill in the required information:
   - First Name
   - Last Name
   - Email Address
   - Role (Admin, User, etc.)
   - Organization
4. Set initial password or enable "Send invitation email"
5. Click **Create User**

The system will create the user account and send an email invitation if selected.

#### User Roles and Permissions

User roles define the actions a user can perform in the system. To manage roles:

1. Navigate to **Administration → User Management → Roles**
2. View existing roles or click **Add Role** to create a new role
3. Configure permissions for the role:
   - Content Management permissions
   - Distribution permissions
   - Analytics permissions
   - Administration permissions
4. Save the role configuration

To assign a role to a user:

1. Navigate to **Administration → User Management → Users**
2. Find the user and click **Edit**
3. Select the appropriate role from the Role dropdown
4. Click **Save**

#### User Authentication Settings

Configure authentication settings for the platform:

1. Navigate to **Administration → System Settings → Authentication**
2. Configure the following settings:
   - Password policy (minimum length, complexity requirements)
   - Multi-factor authentication requirements
   - Session timeout period
   - Failed login attempt limits
   - Password expiration policy
3. Click **Save Settings**

#### User Activity and Audit Logs

Review user activity and security events:

1. Navigate to **Administration → Audit & Logs → User Activity**
2. Set the date range and filter criteria
3. View login attempts, actions performed, and resource access
4. Export the log data if needed for compliance or investigation

### Organization Management

#### Creating Organizations

To create a new organization:

1. Navigate to **Administration → Organization Management → Organizations**
2. Click the **Add Organization** button
3. Fill in the organization details:
   - Name
   - Legal Name
   - Organization Type (Label, Distributor, etc.)
   - Contact Information
   - Billing Information
4. Configure organization settings:
   - Default distribution territories
   - Default royalty rules
   - Organization-specific features
5. Click **Create Organization**

#### Organization Hierarchy

Manage parent-child relationships between organizations:

1. Navigate to **Administration → Organization Management → Organizations**
2. Select an organization and click **Edit**
3. In the **Organization Hierarchy** section:
   - To create a sub-organization, click **Add Sub-Organization**
   - To change parent organization, select a different organization from the **Parent Organization** dropdown
4. Click **Save**

#### Organization Settings

Configure organization-specific settings:

1. Navigate to **Administration → Organization Management → Organizations**
2. Select an organization and click **Edit**
3. Configure the following settings:
   - Organization profile information
   - Default payout methods
   - DSP platform preferences
   - Notification settings
   - Custom fields
4. Click **Save**

#### Organization Users

Manage users associated with an organization:

1. Navigate to **Administration → Organization Management → Organizations**
2. Select an organization and click **View Users**
3. Review the list of users associated with the organization
4. To add a user:
   - Click **Add User to Organization**
   - Select an existing user or create a new one
   - Assign organization-specific roles
   - Click **Add**
5. To remove a user, click the **Remove** button next to their name

### Platform Configuration

#### System Settings

Configure global platform settings:

1. Navigate to **Administration → System Settings → General**
2. Configure the following settings:
   - Platform name and branding
   - Default language and timezone
   - Date and number formats
   - Notification preferences
   - Feature toggles
3. Click **Save Settings**

#### External Integrations

Configure connections to external services:

1. Navigate to **Administration → System Settings → Integrations**
2. Set up integrations with:
   - Payment processors
   - Email service providers
   - Storage services
   - Analytics platforms
   - API partners
3. For each integration, provide:
   - API keys
   - Endpoint URLs
   - Authentication credentials
   - Configuration parameters
4. Test the connection and click **Save**

#### Localization

Configure language and regional settings:

1. Navigate to **Administration → System Settings → Localization**
2. Manage supported languages:
   - Enable or disable languages
   - Set the default language
   - Import language translations
3. Configure regional settings:
   - Currency formats
   - Date and time formats
   - Number formats
   - Timezone defaults
4. Click **Save Settings**

#### Email Templates

Customize notification and communication templates:

1. Navigate to **Administration → Communication → Email Templates**
2. Select a template to edit:
   - User invitation
   - Password reset
   - Payment notification
   - Release status update
   - Distribution alert
3. Customize the template:
   - Edit the subject line
   - Modify the email content
   - Adjust formatting
   - Add variables and conditional logic
4. Preview the template and click **Save**

### Security Settings

#### Access Control

Manage IP restrictions and network security:

1. Navigate to **Administration → Security → Access Control**
2. Configure IP restrictions:
   - Add allowed IP addresses or ranges
   - Block specific IP addresses
   - Set country-based restrictions
3. Configure session settings:
   - Set session timeout periods
   - Enable concurrent session limitations
   - Configure idle session management
4. Click **Save Settings**

#### API Security

Manage API access and security:

1. Navigate to **Administration → Security → API Settings**
2. Configure API security settings:
   - Rate limiting
   - Token expiration
   - Allowed scope permissions
   - IP restrictions for API access
3. Manage API clients:
   - Create new API clients
   - Revoke access for existing clients
   - Set client-specific permissions
4. Click **Save Settings**

#### Data Protection

Configure data protection and privacy settings:

1. Navigate to **Administration → Security → Data Protection**
2. Configure data retention policies:
   - Set retention periods for different data types
   - Configure automatic data deletion
   - Set up data archiving rules
3. Configure data encryption settings:
   - Manage encryption keys
   - Set field-level encryption
   - Configure transport security
4. Configure privacy settings:
   - Data anonymization rules
   - Personal data handling
   - Consent management
5. Click **Save Settings**

#### Security Auditing

Review security events and configuration:

1. Navigate to **Administration → Security → Audit**
2. Review security events:
   - Authentication attempts
   - Permission changes
   - Security setting modifications
   - API access events
3. Run security compliance reports:
   - Permission matrix
   - Security configuration
   - Vulnerability assessment
   - Compliance status
4. Export reports for compliance documentation

### System Monitoring

#### Performance Monitoring

Monitor system performance metrics:

1. Navigate to **Administration → Monitoring → Performance**
2. View real-time performance metrics:
   - System response time
   - Database performance
   - API response times
   - Resource utilization
3. Configure performance alerts:
   - Set threshold values
   - Configure notification recipients
   - Schedule performance reports
4. View historical performance trends

#### Error Monitoring

Track and analyze system errors:

1. Navigate to **Administration → Monitoring → Errors**
2. View error logs by:
   - Severity level
   - Component
   - Time period
   - Error type
3. Analyze error patterns and trends
4. Configure error alerts and notifications

#### User Activity

Monitor user interactions with the system:

1. Navigate to **Administration → Monitoring → User Activity**
2. View user actions:
   - Login history
   - Feature usage
   - Content modifications
   - Administrative actions
3. Create activity reports by:
   - User
   - Organization
   - Action type
   - Time period
4. Export activity data for analysis

#### System Health

Monitor overall system health:

1. Navigate to **Administration → Monitoring → System Health**
2. View the status of system components:
   - Application services
   - Database health
   - Integration status
   - Queue processing
   - Scheduled task execution
3. Configure health check settings:
   - Check frequency
   - Alert thresholds
   - Notification recipients
4. View historical health status data

## Content Administration

### Catalog Management

#### Release Approval

Review and approve new releases:

1. Navigate to **Content → Catalog → Pending Releases**
2. View the list of releases awaiting approval
3. For each release:
   - Review metadata completeness
   - Check audio quality
   - Verify artwork compliance
   - Validate rights information
4. Approve or reject the release:
   - For approval, click **Approve** and set the distribution date
   - For rejection, click **Reject** and provide a reason
5. The system will notify the submitter of the decision

#### Metadata Standards

Configure metadata validation rules:

1. Navigate to **Administration → Content → Metadata Standards**
2. Configure validation rules for:
   - Artist names
   - Release titles
   - Genre classifications
   - Language codes
   - Parental advisory flags
   - Release dates
3. Set required and optional fields
4. Configure format validation rules
5. Click **Save Settings**

#### Asset Management

Manage audio files, images, and other assets:

1. Navigate to **Content → Assets**
2. View assets by type:
   - Audio files
   - Artwork
   - Documents
   - Video files
3. Manage storage settings:
   - Storage quotas
   - Retention policies
   - Archive settings
   - Compression settings
4. Configure asset processing:
   - Audio transcoding profiles
   - Image processing rules
   - Quality checks
   - Automatic validation

#### Batch Operations

Perform operations on multiple catalog items:

1. Navigate to **Content → Catalog → Batch Operations**
2. Select the operation type:
   - Metadata update
   - Rights update
   - Distribution update
   - Status change
3. Apply filters to select the target items
4. Configure the operation parameters
5. Preview the changes
6. Click **Execute** to run the batch operation

### Distribution Management

#### Platform Configuration

Configure distribution service providers:

1. Navigate to **Administration → Distribution → Platforms**
2. For each platform (Spotify, Apple Music, etc.):
   - Configure API credentials
   - Set delivery specifications
   - Configure metadata mappings
   - Set territory availability
3. Test the platform connection
4. Enable or disable the platform
5. Click **Save Settings**

#### Distribution Rules

Configure content distribution rules:

1. Navigate to **Administration → Distribution → Rules**
2. Create rules based on:
   - Content type
   - Genre
   - Territory
   - Organization
   - Release date
3. For each rule, configure:
   - Target platforms
   - Delivery timing
   - Special handling instructions
   - Metadata transformations
4. Set rule priority and save

#### Delivery Monitoring

Monitor content delivery status:

1. Navigate to **Distribution → Delivery Status**
2. View deliveries by:
   - Status (Pending, In Progress, Completed, Failed)
   - Platform
   - Date range
   - Content type
3. For each delivery:
   - View detailed delivery status
   - See platform-specific feedback
   - Check error messages
   - View delivery history
4. Take action on failed deliveries:
   - Retry the delivery
   - Edit content and resubmit
   - Cancel the delivery

#### Takedown Management

Process and manage content takedowns:

1. Navigate to **Distribution → Takedowns**
2. View takedown requests by:
   - Status
   - Reason
   - Requester
   - Content type
3. Process takedown requests:
   - Review the request details
   - Verify the takedown reason
   - Check rights information
   - Approve or reject the request
4. Monitor takedown execution:
   - View takedown status by platform
   - Check for platform-specific issues
   - Receive completion notifications

### Rights Management

#### Rights Configuration

Configure rights management settings:

1. Navigate to **Administration → Rights → Configuration**
2. Configure rights types:
   - Recording rights
   - Composition rights
   - Publishing rights
   - Performance rights
3. Set up territory-specific rules
4. Configure rights validation rules
5. Define rights conflict resolution procedures
6. Click **Save Settings**

#### Ownership Management

Manage rights holder information:

1. Navigate to **Rights → Ownership**
2. View rights by:
   - Content
   - Rights holder
   - Rights type
   - Territory
3. Manage rights holders:
   - Add new rights holders
   - Edit existing rights holder information
   - Configure payment information
   - Set default split percentages
4. Resolve ownership conflicts:
   - View conflicting claims
   - Review supporting documentation
   - Make ownership determinations
   - Document resolution decisions

#### Rights Verification

Verify and validate rights information:

1. Navigate to **Rights → Verification**
2. View rights requiring verification
3. For each item:
   - Review ownership documentation
   - Check against external databases
   - Verify split percentages
   - Confirm territory rights
4. Approve or flag for further investigation
5. Document verification decisions

#### Rights Reporting

Generate rights-related reports:

1. Navigate to **Rights → Reports**
2. Select the report type:
   - Ownership summary
   - Rights conflicts
   - Unregistered works
   - Territory coverage
   - Split analysis
3. Configure report parameters:
   - Date range
   - Content scope
   - Rights types
   - Territories
4. Generate and export the report

### Royalty Settings

#### Royalty Rules

Configure royalty calculation rules:

1. Navigate to **Administration → Royalties → Rules**
2. Create royalty rules based on:
   - Content type
   - Platform
   - Territory
   - Rights type
   - Time period
3. For each rule, configure:
   - Rate structure (percentage, per-unit, minimum)
   - Tiered rates
   - Minimum guarantees
   - Fee deductions
   - Currency settings
4. Set rule priority and save

#### Split Templates

Create templates for common royalty splits:

1. Navigate to **Administration → Royalties → Split Templates**
2. Create templates for different scenarios:
   - Standard artist agreement
   - Label distribution
   - Publishing splits
   - Special project splits
3. For each template, define:
   - Role-based percentages
   - Default recipients
   - Territory variations
   - Override rules
4. Save the template for future use

#### Calculation Settings

Configure royalty calculation parameters:

1. Navigate to **Administration → Royalties → Calculation Settings**
2. Configure calculation frequency:
   - Daily processing
   - Monthly calculations
   - Quarterly reporting
3. Set processing parameters:
   - Batch size
   - Processing priority
   - Error handling
   - Notification settings
4. Configure rounding and precision rules
5. Set currency conversion settings
6. Click **Save Settings**

#### Statements Configuration

Configure royalty statement settings:

1. Navigate to **Administration → Royalties → Statements**
2. Configure statement generation:
   - Statement frequency
   - Statement format
   - Delivery method
   - Notification settings
3. Customize statement templates:
   - Header and footer
   - Summary sections
   - Detail level
   - Grouping options
4. Configure statement approvals:
   - Approval workflow
   - Required reviewers
   - Threshold-based rules
5. Click **Save Settings**

## Financial Administration

### Payment Management

#### Payment Methods

Configure available payment methods:

1. Navigate to **Administration → Payments → Methods**
2. Configure each payment method:
   - Bank transfer
   - PayPal
   - ACH
   - Check
   - Digital wallet
3. For each method, set:
   - Processing fees
   - Minimum payment amounts
   - Currency restrictions
   - Processing timeframes
   - Required information
4. Enable or disable payment methods
5. Click **Save Settings**

#### Payment Schedules

Configure payment frequency and timing:

1. Navigate to **Administration → Payments → Schedules**
2. Create payment schedules:
   - Monthly payments
   - Quarterly payments
   - Custom schedules
3. For each schedule, configure:
   - Payment date calculation
   - Minimum payment thresholds
   - Currency conversion timing
   - Payment approval workflow
4. Assign schedules to organizations or rights holders
5. Click **Save Settings**

#### Payment Processing

Process and monitor payments:

1. Navigate to **Payments → Processing**
2. View pending payments:
   - Filter by recipient, amount, date, or status
   - View payment details
   - Check payment history
3. Process payments:
   - Select payments to process
   - Verify payment details
   - Submit for processing
   - Monitor processing status
4. Handle exceptions:
   - Review failed payments
   - Correct payment information
   - Resubmit or cancel payments
   - Communicate with recipients

#### Payment Reconciliation

Reconcile payment records:

1. Navigate to **Payments → Reconciliation**
2. Select the time period to reconcile
3. Review payment statuses:
   - Compare processed vs. confirmed payments
   - Identify discrepancies
   - Match payment records with bank statements
4. Mark payments as reconciled
5. Generate reconciliation reports
6. Document unresolved items

### Revenue Processing

#### Revenue Import

Import and process revenue data:

1. Navigate to **Finance → Revenue → Import**
2. Select the revenue source:
   - Platform reports (Spotify, Apple Music, etc.)
   - Distributor statements
   - Direct sources
3. Upload the revenue file or configure API import
4. Map data fields:
   - Content identifiers
   - Revenue amounts
   - Currency
   - Period
   - Territory
5. Validate and process the import
6. Review import results and handle exceptions

#### Revenue Validation

Validate imported revenue data:

1. Navigate to **Finance → Revenue → Validation**
2. View validation results:
   - Unmatched content
   - Invalid amounts
   - Missing data
   - Duplicate entries
3. Resolve validation issues:
   - Match content manually
   - Correct data errors
   - Mark records for investigation
   - Exclude invalid records
4. Approve validated revenue for royalty processing

#### Revenue Adjustments

Create and manage revenue adjustments:

1. Navigate to **Finance → Revenue → Adjustments**
2. Create a new adjustment:
   - Select content and period
   - Specify adjustment reason
   - Enter adjustment amount
   - Provide supporting documentation
3. Submit for approval:
   - Route to appropriate approvers
   - Track approval status
   - Implement approved adjustments
4. View adjustment history and impact on royalties

#### Revenue Reports

Generate revenue reports:

1. Navigate to **Finance → Revenue → Reports**
2. Select the report type:
   - Platform summary
   - Content performance
   - Territory analysis
   - Trend analysis
   - Comparison reports
3. Configure report parameters:
   - Date range
   - Content scope
   - Grouping options
   - Comparison baselines
4. Generate and export the report

### Tax Settings

#### Tax Rates

Configure tax rates and rules:

1. Navigate to **Administration → Finance → Tax Rates**
2. Configure tax rates by:
   - Territory
   - Content type
   - Service type
   - Organization type
3. For each configuration, set:
   - Rate percentage
   - Exemption rules
   - Calculation method
   - Effective dates
4. Import tax rate updates
5. Click **Save Settings**

#### Withholding Tax

Configure withholding tax settings:

1. Navigate to **Administration → Finance → Withholding Tax**
2. Configure withholding rules by:
   - Recipient country
   - Payment type
   - Tax treaty status
3. For each configuration, set:
   - Withholding rate
   - Documentation requirements
   - Reporting procedures
   - Submission deadlines
4. Update tax forms and requirements
5. Click **Save Settings**

#### Tax Documents

Manage tax documentation:

1. Navigate to **Finance → Tax → Documents**
2. View tax documents by:
   - Document type
   - Recipient
   - Status
   - Expiration date
3. Process incoming documents:
   - Validate information
   - Store securely
   - Link to recipient profiles
   - Set expiration reminders
4. Generate tax reports:
   - 1099 forms
   - Withholding certificates
   - VAT reports
   - Compliance documentation

#### Tax Compliance

Monitor tax compliance:

1. Navigate to **Finance → Tax → Compliance**
2. Review compliance status:
   - Missing documentation
   - Expiring forms
   - Rate changes
   - Reporting deadlines
3. Generate compliance reports:
   - Documentation status
   - Withholding summary
   - Filing requirements
   - Jurisdiction summary
4. Address compliance issues:
   - Send document requests
   - Update tax settings
   - Schedule filings
   - Document compliance actions

### Financial Reports

#### Standard Reports

Access and generate standard financial reports:

1. Navigate to **Finance → Reports → Standard**
2. Select the report type:
   - Revenue summary
   - Royalty distribution
   - Payment status
   - Tax withholding
   - Currency exchange
3. Configure report parameters:
   - Date range
   - Organization scope
   - Grouping options
   - Comparison periods
4. Generate and export the report

#### Custom Reports

Create and manage custom financial reports:

1. Navigate to **Finance → Reports → Custom**
2. Create a new report:
   - Select data sources
   - Configure calculation formulas
   - Define filters and parameters
   - Design the report layout
3. Save the report template
4. Run the report with specific parameters
5. Schedule automatic report generation

#### Financial Dashboards

Configure financial dashboards:

1. Navigate to **Finance → Dashboards**
2. Configure dashboard components:
   - Revenue trends
   - Payment status
   - Outstanding balances
   - Top performers
   - Royalty distribution
3. Set refresh frequency and data range
4. Configure visibility and access permissions
5. Save dashboard configuration

#### Audit Reports

Generate financial audit reports:

1. Navigate to **Finance → Reports → Audit**
2. Select the audit report type:
   - Calculation verification
   - Payment reconciliation
   - Adjustment history
   - User action log
   - Configuration changes
3. Configure report parameters:
   - Date range
   - Scope
   - Detail level
   - Grouping options
4. Generate and export the report

## Analytics and Reporting

### Dashboard Configuration

#### System Dashboards

Configure system-level dashboards:

1. Navigate to **Administration → Analytics → System Dashboards**
2. Configure dashboard components:
   - System health
   - User activity
   - Content status
   - Processing queues
   - Error trends
3. Set data refresh intervals
4. Configure alert thresholds
5. Save dashboard configuration

#### User Dashboards

Configure user-facing dashboards:

1. Navigate to **Administration → Analytics → User Dashboards**
2. Configure default dashboards for roles:
   - Administrator dashboard
   - Label manager dashboard
   - Artist dashboard
   - Financial dashboard
3. Configure available components:
   - Performance metrics
   - Content status
   - Financial summaries
   - Distribution status
4. Set customization permissions
5. Save dashboard configurations

#### Custom Metrics

Create and manage custom metrics:

1. Navigate to **Administration → Analytics → Custom Metrics**
2. Create a new metric:
   - Define data sources
   - Configure calculation formula
   - Set dimension mappings
   - Define visualization options
3. Test the metric with sample data
4. Add the metric to available dashboard components
5. Save the metric configuration

#### Alert Configuration

Configure analytics alerts:

1. Navigate to **Administration → Analytics → Alerts**
2. Create alert rules based on:
   - Metric values
   - Trend patterns
   - Threshold crossings
   - Comparative analysis
3. Configure alert actions:
   - Email notifications
   - Dashboard indicators
   - System notifications
   - Workflow triggers
4. Set alert frequency and conditions
5. Save alert configuration

### Report Generation

#### Standard Reports

Manage standard report templates:

1. Navigate to **Administration → Analytics → Standard Reports**
2. Configure standard report templates:
   - Content performance
   - User activity
   - Distribution status
   - Financial summaries
3. For each template, set:
   - Default parameters
   - Layout and formatting
   - Export options
   - Scheduling options
4. Save the report templates

#### Custom Reports

Configure custom report creation:

1. Navigate to **Administration → Analytics → Custom Reports**
2. Configure custom report builder:
   - Available data sources
   - Report components
   - Calculation functions
   - Visualization options
3. Set permissions for report creation
4. Configure approval workflows for shared reports
5. Save configuration settings

#### Scheduled Reports

Manage report scheduling:

1. Navigate to **Administration → Analytics → Scheduled Reports**
2. Configure scheduling options:
   - Frequency options
   - Delivery methods
   - Format options
   - Recipient management
3. Set default scheduling parameters
4. Configure storage and retention policies
5. Monitor scheduling system status

#### Report Access Control

Manage report access permissions:

1. Navigate to **Administration → Analytics → Report Access**
2. Configure access rules based on:
   - User role
   - Organization
   - Report type
   - Data sensitivity
3. Set default visibility settings
4. Configure sharing and distribution options
5. Implement data filtering for sensitive information
6. Save access control configuration

### Data Export

#### Export Formats

Configure data export formats:

1. Navigate to **Administration → Analytics → Export Formats**
2. Configure supported formats:
   - CSV
   - Excel
   - PDF
   - JSON
   - XML
3. For each format, set:
   - Default options
   - Formatting rules
   - Header and footer content
   - File naming conventions
4. Save format configuration

#### Bulk Export

Configure bulk data export settings:

1. Navigate to **Administration → Analytics → Bulk Export**
2. Configure bulk export options:
   - Maximum data size
   - Processing priority
   - Compression options
   - Notification settings
3. Set up storage and retention policies
4. Configure delivery options:
   - Download links
   - Secure file transfer
   - Email attachments
   - Cloud storage integration
5. Save bulk export configuration

#### Data Feeds

Configure automated data feeds:

1. Navigate to **Administration → Analytics → Data Feeds**
2. Create data feed configurations:
   - Define data sources
   - Configure output format
   - Set update frequency
   - Specify delivery method
3. Configure security settings:
   - Authentication
   - Encryption
   - Access control
   - IP restrictions
4. Set up monitoring and notifications
5. Save feed configuration

#### Export Logs

Review and manage data exports:

1. Navigate to **Analytics → Export Logs**
2. View export history:
   - Filter by user, date, format, or status
   - View export details
   - Track delivery status
   - Monitor usage patterns
3. Manage active exports:
   - Cancel in-progress exports
   - Retry failed exports
   - Update delivery options
   - Extend download availability
4. Generate export activity reports

### Custom Metrics

#### Metric Designer

Configure the custom metric designer:

1. Navigate to **Administration → Analytics → Metric Designer**
2. Configure available data sources:
   - Platform data
   - Revenue data
   - Content metadata
   - User activity
   - System performance
3. Set up calculation functions:
   - Mathematical operations
   - Statistical functions
   - Time-based aggregations
   - Conditional logic
4. Configure visualization options:
   - Chart types
   - Formatting rules
   - Color schemes
   - Labeling options
5. Save configuration

#### Metric Validation

Set up metric validation rules:

1. Navigate to **Administration → Analytics → Metric Validation**
2. Configure validation rules:
   - Data range checks
   - Consistency verification
   - Reference comparisons
   - Trend reasonableness
3. Set up validation workflows:
   - Automated checks
   - Manual verification steps
   - Approval requirements
   - Documentation standards
4. Configure exception handling
5. Save validation configuration

#### Metric Catalog

Manage the metric catalog:

1. Navigate to **Administration → Analytics → Metric Catalog**
2. Configure catalog organization:
   - Category structure
   - Tagging system
   - Search functionality
   - Related metrics
3. Set up metric documentation:
   - Description templates
   - Calculation explanation
   - Usage guidelines
   - Version history
4. Configure access permissions
5. Save catalog configuration

#### Metric Usage Monitoring

Monitor metric usage:

1. Navigate to **Analytics → Metric Usage**
2. View usage statistics:
   - Frequency of use
   - User adoption
   - Performance impact
   - Error frequency
3. Configure usage alerts:
   - Performance degradation
   - Excessive usage
   - Low adoption
   - Error patterns
4. Generate usage reports

## Platform Maintenance

### Scheduled Maintenance

#### Maintenance Windows

Configure maintenance scheduling:

1. Navigate to **Administration → Maintenance → Scheduling**
2. Configure maintenance windows:
   - Recurring windows
   - Blackout periods
   - Notice requirements
   - Duration limits
3. Set up user notifications:
   - Announcement timing
   - Notification methods
   - Audience targeting
   - Message templates
4. Configure impact assessments
5. Save scheduling configuration

#### Maintenance Tasks

Manage scheduled maintenance tasks:

1. Navigate to **Administration → Maintenance → Tasks**
2. Configure standard maintenance tasks:
   - Database optimization
   - Cache clearing
   - Storage cleanup
   - Index rebuilding
   - Log rotation
3. Set task scheduling:
   - Frequency
   - Dependencies
   - Resource limitations
   - Failure handling
4. Configure monitoring and reporting
5. Save task configuration

#### Deployment Management

Configure system update procedures:

1. Navigate to **Administration → Maintenance → Deployment**
2. Configure deployment workflows:
   - Testing requirements
   - Approval process
   - Rollback procedures
   - Documentation standards
3. Set up deployment windows
4. Configure version control
5. Set up deployment notifications
6. Save deployment configuration

#### Maintenance Logs

Manage maintenance activity records:

1. Navigate to **Administration → Maintenance → Logs**
2. Configure log retention:
   - Storage duration
   - Detail level
   - Archiving rules
   - Security controls
3. Set up log analysis:
   - Success metrics
   - Issue identification
   - Pattern detection
   - Trend analysis
4. Configure reporting
5. Save log configuration

### Backup and Recovery

#### Backup Configuration

Configure data backup settings:

1. Navigate to **Administration → Maintenance → Backup Configuration**
2. Configure backup types:
   - Full backups
   - Incremental backups
   - Differential backups
   - Transaction log backups
3. Set backup scheduling:
   - Frequency
   - Timing
   - Resource limitations
   - Dependencies
4. Configure storage options:
   - Local storage
   - Cloud storage
   - Redundant copies
   - Encryption
5. Save backup configuration

#### Recovery Procedures

Define data recovery procedures:

1. Navigate to **Administration → Maintenance → Recovery Procedures**
2. Configure recovery options:
   - Point-in-time recovery
   - Selective restoration
   - Emergency procedures
   - Testing protocols
3. Set up recovery environments:
   - Staging environment
   - Validation procedures
   - Access controls
   - Documentation requirements
4. Define escalation procedures
5. Save recovery configuration

#### Data Retention

Configure data retention policies:

1. Navigate to **Administration → Maintenance → Data Retention**
2. Configure retention policies by data type:
   - User data
   - Transaction records
   - Content files
   - Analytics data
   - System logs
3. Set retention periods:
   - Legal requirements
   - Business needs
   - Storage constraints
   - Privacy regulations
4. Configure archiving workflows
5. Define deletion procedures
6. Save retention configuration

#### Disaster Recovery

Configure disaster recovery planning:

1. Navigate to **Administration → Maintenance → Disaster Recovery**
2. Define recovery scenarios:
   - Data corruption
   - System failure
   - Facility outage
   - Security breach
3. Configure recovery plans:
   - Response procedures
   - Resource requirements
   - Communication protocols
   - Testing schedules
4. Set recovery objectives:
   - Recovery time objectives (RTO)
   - Recovery point objectives (RPO)
   - Service level agreements
   - Success criteria
5. Save disaster recovery configuration

### Performance Tuning

#### Database Optimization

Configure database performance settings:

1. Navigate to **Administration → Maintenance → Database Optimization**
2. Configure optimization tasks:
   - Index maintenance
   - Statistics updates
   - Query optimization
   - Table partitioning
   - Storage allocation
3. Set task scheduling:
   - Frequency
   - Resource limitations
   - Dependency management
   - Priority settings
4. Configure monitoring and alerting
5. Save optimization configuration

#### Caching Configuration

Manage system caching:

1. Navigate to **Administration → Maintenance → Caching**
2. Configure cache settings:
   - Memory allocation
   - Expiration policies
   - Invalidation rules
   - Cache layers
3. Define cacheable content:
   - Static content
   - Query results
   - API responses
   - User-specific data
4. Configure cache monitoring
5. Set up manual cache management
6. Save caching configuration

#### Resource Allocation

Configure system resource management:

1. Navigate to **Administration → Maintenance → Resources**
2. Configure resource allocation:
   - CPU allocation
   - Memory limits
   - Storage quotas
   - Network bandwidth
   - Connection pools
3. Set resource priorities:
   - Critical services
   - Background tasks
   - User interactions
   - Reporting processes
4. Configure scaling policies
5. Set up resource monitoring
6. Save resource configuration

#### Performance Monitoring

Configure performance monitoring:

1. Navigate to **Administration → Maintenance → Performance Monitoring**
2. Configure monitoring metrics:
   - Response times
   - Throughput
   - Error rates
   - Resource utilization
   - Queue lengths
3. Set alert thresholds:
   - Warning levels
   - Critical levels
   - Trend-based alerts
   - Combined conditions
4. Configure dashboards and reporting
5. Set up historical analysis
6. Save monitoring configuration

### Issue Troubleshooting

#### Error Tracking

Configure error monitoring and tracking:

1. Navigate to **Administration → Maintenance → Error Tracking**
2. Configure error collection:
   - Error types
   - Severity classification
   - Contextual information
   - Sampling rates
3. Set up notification rules:
   - Recipients by error type
   - Escalation procedures
   - Aggregation rules
   - Frequency controls
4. Configure error analysis:
   - Pattern detection
   - Root cause analysis
   - Impact assessment
   - Resolution tracking
5. Save error tracking configuration

#### Diagnostic Tools

Configure system diagnostic capabilities:

1. Navigate to **Administration → Maintenance → Diagnostics**
2. Configure diagnostic tools:
   - Log analysis
   - Query profiling
   - Process monitoring
   - Network diagnostics
   - Memory analysis
3. Set access permissions:
   - Tool availability by role
   - Usage limitations
   - Result visibility
   - Execution authorization
4. Configure diagnostic workflows
5. Save diagnostic configuration

#### Issue Management

Configure issue tracking and resolution:

1. Navigate to **Administration → Maintenance → Issue Management**
2. Configure issue tracking:
   - Issue categorization
   - Priority assignment
   - Status workflow
   - Assignment rules
   - SLA tracking
3. Set up communication templates:
   - Status updates
   - Resolution notices
   - Escalation messages
   - Investigation requests
4. Configure reporting and analytics
5. Save issue management configuration

#### Support Configuration

Configure support processes:

1. Navigate to **Administration → Maintenance → Support**
2. Configure support channels:
   - In-app support
   - Email support
   - Knowledge base
   - Ticket system
   - Live chat
3. Set support availability:
   - Hours of operation
   - Response time targets
   - Escalation paths
   - Special handling rules
4. Configure support documentation
5. Set up satisfaction measurement
6. Save support configuration

## Appendix

### Admin API Reference

The Admin API allows programmatic access to administrative functions.

#### Authentication

All Admin API requests require authentication using an administrator API key.

```
Authorization: Bearer YOUR_ADMIN_API_KEY
```

#### Common API Endpoints

- **Users**: `/api/admin/users`
- **Organizations**: `/api/admin/organizations`
- **System Settings**: `/api/admin/settings`
- **Maintenance**: `/api/admin/maintenance`
- **Analytics**: `/api/admin/analytics`

For detailed API documentation, see the [Admin API Reference](../developer/api-reference.md).

### Configuration Reference

#### System Configuration Files

Important configuration files:

- **Main Configuration**: `/config/system.yaml`
- **Security Settings**: `/config/security.yaml`
- **Database Configuration**: `/config/database.yaml`
- **API Configuration**: `/config/api.yaml`
- **Logging Configuration**: `/config/logging.yaml`

#### Environment Variables

Key environment variables:

- `TM_DATABASE_URL`: Database connection string
- `TM_REDIS_URL`: Redis connection string
- `TM_SECRET_KEY`: Application encryption key
- `TM_ENVIRONMENT`: Application environment (production, staging, development)
- `TM_LOG_LEVEL`: Logging level (debug, info, warn, error)

### Error Codes

#### System Error Codes

- **1xxx**: Authentication and authorization errors
- **2xxx**: Data validation errors
- **3xxx**: Processing errors
- **4xxx**: External integration errors
- **5xxx**: System errors

#### Common Error Codes

- **1001**: Authentication failed
- **1002**: Authorization failed
- **2001**: Invalid data format
- **2002**: Missing required field
- **3001**: Processing timeout
- **3002**: Resource limit exceeded
- **4001**: External service unavailable
- **5001**: Internal server error

### Glossary

- **DSP**: Digital Service Provider (Spotify, Apple Music, etc.)
- **ISRC**: International Standard Recording Code
- **UPC**: Universal Product Code
- **Royalty**: Payment for the use of intellectual property
- **Rights Holder**: Entity that owns rights to content
- **Split**: Percentage of royalties allocated to each rights holder
- **Takedown**: Removal of content from distribution platforms
- **Metadata**: Descriptive information about content
- **Reconciliation**: Process of matching and validating financial records

---

© 2023-2025 TuneMantra. All rights reserved.

---

## documentation/user/analytics-guide.md

# Analytics Guide for TuneMantra

<div align="center">
  <img src="../diagrams/analytics-guide-header.svg" alt="TuneMantra Analytics Guide" width="800"/>
</div>

## Introduction

Welcome to TuneMantra's comprehensive Analytics Guide. This document provides detailed instructions on how to leverage TuneMantra's powerful analytics capabilities to gain insights into your music's performance, audience demographics, and revenue trends. Whether you're an artist, label manager, or rights holder, this guide will help you make data-driven decisions to grow your music career and business.

## Table of Contents

- [Analytics Dashboard Overview](#analytics-dashboard-overview)
- [Performance Metrics](#performance-metrics)
- [Audience Insights](#audience-insights)
- [Revenue Analytics](#revenue-analytics)
- [Catalog Analysis](#catalog-analysis)
- [Playlist & Discovery Analysis](#playlist--discovery-analysis)
- [Marketing Impact Analysis](#marketing-impact-analysis)
- [Comparative Analytics](#comparative-analytics)
- [Custom Reporting](#custom-reporting)
- [Data Export & Integration](#data-export--integration)
- [Best Practices](#best-practices)
- [FAQ](#frequently-asked-questions)

## Analytics Dashboard Overview

The TuneMantra Analytics Dashboard provides a comprehensive view of your music's performance across all platforms in a single unified interface.

<div align="center">
  <img src="../screenshots/analytics-dashboard.png" alt="Analytics Dashboard" width="700"/>
</div>

### Key Dashboard Components

1. **Global Performance Summary**
   - Total streams, downloads, and revenue
   - Period-over-period growth metrics
   - Top performing tracks and releases
   - Geographic distribution heat map

2. **Quick Filters**
   - Time period selection (Today, 7 days, 30 days, Custom)
   - Platform filters (All, Spotify, Apple Music, etc.)
   - Content type (Singles, EPs, Albums, etc.)
   - Territory selection

3. **Performance Trend Charts**
   - Streams and engagement over time
   - Revenue trajectory
   - Audience growth visualization
   - Platform comparison charts

4. **Key Performance Indicators (KPIs)**
   - Stream-to-follower ratio
   - Average revenue per stream
   - Playlist inclusion rate
   - Content engagement score

### Navigation and Customization

Access and customize your analytics experience:

1. **Analytics Navigation**
   - Use the left navigation panel to access different analytics sections
   - Breadcrumb navigation for multi-level drill-downs
   - Quick-jump menu for frequently accessed sections
   - Search functionality for specific metrics or reports

2. **Dashboard Customization**
   - Select **Customize View** to modify dashboard layout
   - Add, remove, or resize analytics widgets
   - Change visualization types for specific metrics
   - Save multiple custom dashboard configurations

3. **Alert Configuration**
   - Set performance thresholds for notifications
   - Configure email or in-app alerts
   - Schedule regular analytics reports
   - Create custom alert triggers

## Performance Metrics

### Streaming Analytics

Detailed metrics for streaming performance across all platforms:

<div align="center">
  <img src="../screenshots/streaming-analytics.png" alt="Streaming Analytics Interface" width="700"/>
</div>

1. **Stream Count Analysis**
   - Total streams across all platforms
   - Platform-by-platform breakdown
   - Historical streaming trends
   - Peak streaming periods

2. **Stream Source Analysis**
   - Playlist-generated streams
   - Direct artist page streams
   - Search-driven streams
   - Algorithm-recommended streams
   - Library/collection streams

3. **Stream Geography**
   - Country and region-level streaming data
   - City-level hotspots for top territories
   - Global streaming heat map
   - Territory growth comparison

4. **Advanced Stream Metrics**
   - Stream completion rate (% of full track plays)
   - Repeat listener percentage
   - Time-of-day streaming patterns
   - Day-of-week performance analysis

### Engagement Metrics

Understand how listeners interact with your content:

1. **Content Engagement**
   - Save/add-to-library rate
   - Playlist add rate
   - Share rate
   - Skip rate (where available)
   - Comment and reaction metrics

2. **Profile Engagement**
   - Artist page visits
   - Follow/unfollow metrics
   - Biography views
   - Related artist clicks
   - Photo gallery views

3. **Social Engagement**
   - Cross-platform social media metrics
   - Social sharing analysis
   - Commenting activity
   - User-generated content tracking
   - Social follower correlation

4. **Combined Engagement Score**
   - Proprietary engagement calculation
   - Benchmarking against similar artists
   - Engagement trend analysis
   - Actionable improvement suggestions

### Video Performance

Comprehensive metrics for music videos and visual content:

1. **Video Views Analysis**
   - Total video views across platforms
   - Platform-specific performance
   - View completion rate
   - Average watch time

2. **Video Engagement**
   - Like/dislike ratio
   - Comment activity
   - Share rate
   - Subscriber conversion
   - Click-through rate on calls-to-action

3. **Audience Retention**
   - Second-by-second view retention
   - Drop-off point identification
   - Re-watch analytics
   - Average view count per unique viewer

4. **Video Feature Utilization**
   - Youtube Shorts performance
   - TikTok integration metrics
   - Instagram Reels analytics
   - Platform-specific video feature usage

## Audience Insights

### Demographic Analysis

Detailed understanding of your listener demographics:

<div align="center">
  <img src="../screenshots/audience-demographics.png" alt="Audience Demographics" width="700"/>
</div>

1. **Age Distribution**
   - Age group breakdown
   - Age trends over time
   - Age comparison by platform
   - Age-specific engagement metrics

2. **Gender Analysis**
   - Gender distribution
   - Gender trends over time
   - Gender comparison by platform
   - Gender-specific engagement patterns

3. **Location Demographics**
   - Country and region analysis
   - Urban vs. rural listener split
   - City-level hotspots
   - Language preferences

4. **Advanced Demographics**
   - Listener occupation insights (where available)
   - Income level estimation
   - Education level analysis
   - Lifestyle segment categorization

### Listening Behavior

Analyze how your audience consumes your music:

1. **Listening Patterns**
   - Time of day listening distribution
   - Day of week patterns
   - Seasonal listening trends
   - Session duration analysis

2. **Device Analytics**
   - Device type breakdown (mobile, desktop, smart speaker, etc.)
   - Operating system distribution
   - App vs. web player usage
   - Premium vs. free tier usage

3. **Listening Context**
   - Playlist context analysis
   - Personal vs. shared listening sessions
   - Background vs. active listening
   - Listening sequence analysis (tracks before/after)

4. **Content Preferences**
   - Genre affinity
   - Tempo and mood preferences
   - Feature artist impact
   - Production style preferences

### Audience Growth

Track your audience expansion and engagement:

1. **Follower Growth**
   - Total follower count across platforms
   - Follower growth rate
   - Platform-specific follower trends
   - Follower retention rate

2. **Audience Loyalty**
   - First-time vs. returning listener ratio
   - Listener retention cohort analysis
   - Super-fan identification
   - Listening frequency distribution

3. **Audience Acquisition**
   - New listener sources
   - Conversion points analysis
   - Referral tracking
   - Acquisition cost estimation (with campaign data)

4. **Audience Comparison**
   - Similar artist audience overlap
   - Genre audience comparison
   - Competitive audience analysis
   - Market penetration metrics

## Revenue Analytics

### Revenue Overview

Comprehensive view of your music's financial performance:

<div align="center">
  <img src="../screenshots/revenue-analytics.png" alt="Revenue Analytics Dashboard" width="700"/>
</div>

1. **Total Revenue**
   - Overall revenue across all sources
   - Platform-by-platform revenue breakdown
   - Revenue trends over time
   - Revenue forecasting

2. **Revenue Sources**
   - Streaming revenue
   - Download sales
   - Physical sales (if applicable)
   - Sync licensing
   - Performance royalties
   - Other revenue streams

3. **Revenue Geography**
   - Territory-based revenue analysis
   - Top earning markets
   - Revenue growth by territory
   - Currency impact analysis

4. **Catalog Value Analysis**
   - Catalog valuation metrics
   - Revenue per track/release
   - Longevity and sustainability metrics
   - Catalog growth projections

### Royalty Analysis

Detailed breakdown of royalty earnings:

1. **Royalty Types**
   - Mechanical royalties
   - Performance royalties
   - Neighboring rights
   - Sync licensing
   - Public performance

2. **Royalty Timeline**
   - Historical royalty earnings
   - Royalty payment scheduling
   - Royalty trend analysis
   - Payment reconciliation

3. **Split Analysis**
   - Split payment visualization
   - Collaborator payment tracking
   - Split evolution over time
   - Payment distribution metrics

4. **Royalty Efficiency**
   - Collection rate analysis
   - Unclaimed royalty identification
   - Collection society performance
   - Administrative cost analysis

### Monetization Optimization

Tools to maximize your revenue potential:

1. **Revenue Opportunity Analysis**
   - Underperforming market identification
   - Monetization gap detection
   - Licensing opportunity suggestions
   - Revenue optimization recommendations

2. **Pricing Analytics**
   - Price point effectiveness
   - Promotional impact analysis
   - Bundle performance metrics
   - Price elasticity estimation

3. **Monetization Strategy**
   - Platform prioritization recommendations
   - Release strategy optimization
   - Merchandise integration analysis
   - Fan monetization pathways

4. **Revenue Benchmarking**
   - Industry comparison metrics
   - Genre-specific revenue benchmarks
   - Similar artist comparison
   - Market share analysis

## Catalog Analysis

### Catalog Performance

Deep analysis of your music catalog's performance:

<div align="center">
  <img src="../screenshots/catalog-analysis.png" alt="Catalog Analysis Interface" width="700"/>
</div>

1. **Catalog Overview**
   - Complete catalog visualization
   - Track and release performance matrix
   - Performance distribution analysis
   - Catalog growth tracking

2. **Catalog Performance Layers**
   - Top 20% performing content
   - Mid-tier content analysis
   - Long-tail content performance
   - Underperforming content identification

3. **Content Type Analysis**
   - Singles vs. EP vs. album performance
   - Original vs. remix performance
   - Feature track impact analysis
   - Live recording performance

4. **Catalog Age Analysis**
   - New release performance curve
   - Catalog longevity metrics
   - Seasonal performance patterns
   - Resurgence detection (viral moments)

### Track-Level Analytics

Detailed metrics for individual track performance:

1. **Track Performance Detail**
   - Track-specific streaming data
   - Track engagement metrics
   - Track revenue analysis
   - Historical performance trending

2. **Track Comparison**
   - Side-by-side track comparison
   - Performance ranking within catalog
   - Relative growth metrics
   - Feature impact analysis

3. **Track Context Analysis**
   - Playlist performance by track
   - Listening context distribution
   - Skip and completion rates
   - Add-to-library conversion

4. **Track Technical Analysis**
   - Audio feature correlation with performance
   - Duration impact analysis
   - Intro length effectiveness
   - Sound profile optimization data

### Release Analytics

Analyze performance at the release level:

1. **Release Performance Metrics**
   - Release-level streaming totals
   - Release engagement data
   - Cross-track listening patterns
   - Complete vs. partial consumption

2. **Release Strategy Analysis**
   - Release timing effectiveness
   - Pre-release campaign impact
   - Release frequency optimization
   - Track sequencing analysis

3. **Release Comparison**
   - Historical release performance
   - Release-over-release growth
   - Performance distribution within releases
   - Release strategy effectiveness

4. **Release Lifecycle Analysis**
   - First week performance
   - 30/60/90 day performance curves
   - Long-term sustainability metrics
   - Promotional impact points

## Playlist & Discovery Analysis

### Playlist Analytics

Comprehensive metrics for playlist performance:

<div align="center">
  <img src="../screenshots/playlist-analytics.png" alt="Playlist Analytics" width="700"/>
</div>

1. **Playlist Overview**
   - Total active playlists
   - Playlist adds/removes timeline
   - Playlist categorization
   - Playlist size and follower distribution

2. **Playlist Types**
   - Editorial playlist performance
   - Algorithmic playlist inclusion
   - User-generated playlist data
   - Branded playlist analytics

3. **Playlist Impact**
   - Stream attribution by playlist
   - Follower acquisition from playlists
   - Discovery percentage via playlists
   - Playlist-driven revenue

4. **Playlist Opportunity**
   - Playlist match recommendations
   - Similar artist playlist targets
   - Pitch optimization suggestions
   - Playlist tracking alerts

### Discovery & Algorithm Analytics

Understand how listeners discover your music:

1. **Discovery Sources**
   - First-touch attribution analysis
   - Platform recommendation engines
   - Search-driven discovery
   - Social media referrals
   - Direct link access

2. **Algorithm Performance**
   - "Recommended for you" inclusion rate
   - Auto-playlist performance
   - Next-up/auto-play metrics
   - Algorithm affinity score

3. **Recommendation Analysis**
   - Similar artists connections
   - "Fans also like" metrics
   - Genre classification impact
   - Mood and context assignments

4. **Search Analytics**
   - Search volume for artist/tracks
   - Search click-through rate
   - Search term variants
   - Search ranking position

### Platform-Specific Performance

Analyze performance across different streaming services:

1. **Platform Comparison**
   - Side-by-side platform metrics
   - Platform-specific growth rates
   - Audience differences by platform
   - Revenue efficiency by platform

2. **Platform Optimization**
   - Platform-specific feature utilization
   - Profile completeness scoring
   - Platform engagement optimization
   - Platform-specific content opportunities

3. **Platform Feature Impact**
   - Spotify Canvas effectiveness
   - Apple Music Spatial Audio performance
   - Amazon Music HD metrics
   - YouTube Content ID impact

4. **Platform Strategy Recommendations**
   - Platform-specific optimization tactics
   - Feature utilization suggestions
   - Content strategy by platform
   - Platform prioritization guidance

## Marketing Impact Analysis

### Campaign Performance

Measure the effectiveness of your marketing efforts:

<div align="center">
  <img src="../screenshots/marketing-analytics.png" alt="Marketing Impact Analysis" width="700"/>
</div>

1. **Campaign Overview**
   - Campaign performance dashboard
   - Campaign ROI metrics
   - Multi-channel campaign visualization
   - Campaign timeline analysis

2. **Campaign Types**
   - Release campaign impact
   - Tour/event promotion effectiveness
   - Content marketing performance
   - Paid advertising results

3. **Channel Performance**
   - Social media marketing metrics
   - Email marketing effectiveness
   - Influencer campaign results
   - Paid advertising performance

4. **Campaign Attribution**
   - Multi-touch attribution modeling
   - Conversion path analysis
   - Attribution weighting
   - Incremental lift measurement

### Social Media Analytics

Track performance across social platforms:

1. **Social Media Overview**
   - Cross-platform social media metrics
   - Follower growth across channels
   - Engagement rate comparison
   - Content performance analysis

2. **Platform-Specific Analytics**
   - Instagram performance metrics
   - TikTok effectiveness analysis
   - Twitter engagement data
   - YouTube channel analytics

3. **Content Type Analysis**
   - Video vs. image vs. text performance
   - Live content effectiveness
   - Story/ephemeral content metrics
   - User-generated content impact

4. **Social Media ROI**
   - Conversion tracking from social
   - Social media attribution
   - Follower value calculation
   - Platform efficiency comparison

### Fan Engagement Metrics

Measure and optimize fan relationships:

1. **Fan Journey Analysis**
   - Fan journey visualization
   - Touchpoint effectiveness
   - Conversion funnel analysis
   - Fan lifecycle stage distribution

2. **Engagement Depth**
   - Casual to super-fan progression metrics
   - Engagement frequency distribution
   - Monetary value by engagement tier
   - Engagement longevity analysis

3. **Community Analytics**
   - Community growth metrics
   - Discussion and interaction analysis
   - User-generated content volume
   - Community health indicators

4. **Direct-to-Fan Performance**
   - Email marketing performance
   - Fan club/membership metrics
   - Direct purchase analysis
   - Exclusive content engagement

## Comparative Analytics

### Benchmark Comparison

Compare your performance against relevant benchmarks:

<div align="center">
  <img src="../screenshots/benchmark-comparison.png" alt="Benchmark Comparison Analytics" width="700"/>
</div>

1. **Industry Benchmarks**
   - Performance vs. industry averages
   - Growth rate comparison
   - Engagement benchmark comparison
   - Monetization efficiency benchmarks

2. **Genre Benchmarks**
   - Genre-specific performance comparison
   - Sub-genre analysis
   - Genre trend alignment
   - Cross-genre performance

3. **Similar Artist Comparison**
   - Similar sized artist comparison
   - Growth trajectory benchmarking
   - Catalog performance comparison
   - Platform strategy comparison

4. **Historical Benchmarking**
   - Self-comparison over time
   - Growth rate sustainability
   - Seasonal performance normalization
   - Career stage progression metrics

### Competitive Analysis

Understand your position relative to competitors:

1. **Market Share Analysis**
   - Genre market share calculation
   - Share of voice metrics
   - Playlist share comparison
   - Audience overlap analysis

2. **Competitive Growth Comparison**
   - Relative growth rate analysis
   - New release impact comparison
   - Catalog expansion effectiveness
   - Market penetration metrics

3. **Competitive Strategy Insights**
   - Release strategy comparison
   - Content type effectiveness
   - Platform prioritization analysis
   - Marketing approach effectiveness

4. **Competitive Opportunity Identification**
   - Gap analysis and opportunity mapping
   - Underserved audience segments
   - Content opportunity identification
   - Channel optimization suggestions

### Trend Analysis

Track and leverage industry and platform trends:

1. **Industry Trend Alignment**
   - Genre trend correlation
   - Production style alignment
   - Release strategy timeliness
   - Marketing approach relevance

2. **Platform Trend Analysis**
   - Platform growth trends
   - Feature adoption timing
   - Algorithm change impact
   - User behavior shifts

3. **Content Trend Analysis**
   - Track length optimization
   - Genre fusion effectiveness
   - Collaboration strategy impact
   - Production style relevance

4. **Emerging Opportunity Detection**
   - Rising platform identification
   - Emerging genre monitoring
   - New audience segment growth
   - Innovative content format tracking

## Custom Reporting

### Report Builder

Create tailored reports for your specific needs:

<div align="center">
  <img src="../screenshots/custom-report-builder.png" alt="Custom Report Builder Interface" width="700"/>
</div>

1. **Report Creation Interface**
   - Drag-and-drop report builder
   - Metric selection and configuration
   - Visualization type options
   - Filter and segmentation tools

2. **Report Templates**
   - Pre-built report templates
   - Industry-specific report layouts
   - Role-optimized reporting views
   - Goal-specific report configurations

3. **Advanced Reporting Options**
   - Multi-dimension analysis
   - Correlation reporting
   - Time-series comparison
   - Conditional formatting

4. **Report Library Management**
   - Saved report organization
   - Report versioning
   - Sharing and permissions
   - Report scheduling

### Data Visualization

Powerful tools to visualize your analytics data:

1. **Visualization Types**
   - Line, bar, and area charts
   - Scatter plots and heat maps
   - Pie and donut charts
   - Tables and pivot tables
   - Geographical maps

2. **Interactive Visualizations**
   - Drill-down capabilities
   - Interactive filtering
   - Hover and click interactions
   - Animation and timeline controls

3. **Advanced Visualization**
   - Multi-metric visualizations
   - Correlation matrices
   - Network and relationship graphs
   - Funnel and pathway visualizations

4. **Visualization Customization**
   - Color scheme selection
   - Label and annotation options
   - Axis and scale configuration
   - Threshold and goal line settings

### Scheduled Reporting

Automate your analytics workflow:

1. **Report Scheduling**
   - Set up regular report delivery
   - Configure delivery frequency
   - Select delivery format (PDF, Excel, etc.)
   - Define recipient lists

2. **Alert Configuration**
   - Set performance thresholds
   - Configure alert conditions
   - Select notification methods
   - Set alert priority levels

3. **Delivery Options**
   - Email delivery
   - In-app notifications
   - API-based integrations
   - Webhook triggers

4. **Report Tracking**
   - Delivery confirmation
   - Report view tracking
   - User interaction analytics
   - Report effectiveness metrics

## Data Export & Integration

### Data Export Options

Access and utilize your data outside the platform:

<div align="center">
  <img src="../screenshots/data-export-tools.png" alt="Data Export Options" width="700"/>
</div>

1. **File Formats**
   - CSV and Excel exports
   - PDF reports
   - JSON data feeds
   - Raw data access

2. **Export Granularity**
   - Summary exports
   - Detailed record exports
   - Time-series data exports
   - Multi-dimensional data tables

3. **Export Automation**
   - Scheduled exports
   - Trigger-based exports
   - API-driven export requests
   - Automated delivery to storage

4. **Data Export Security**
   - Encrypted exports
   - Access-controlled delivery
   - Audit trail for exports
   - Permissioned data access

### API Integration

Connect TuneMantra analytics with your existing tools:

1. **API Access**
   - RESTful API documentation
   - Authentication and authorization
   - Rate limits and quotas
   - Endpoint reference

2. **Data Endpoints**
   - Performance metrics API
   - Revenue data endpoints
   - Audience analytics access
   - Catalog performance data

3. **Integration Patterns**
   - Real-time data streaming
   - Webhook notifications
   - Batch data synchronization
   - Query-based data access

4. **Developer Resources**
   - SDK availability
   - Code examples
   - Integration tutorials
   - Technical support

### Third-Party Integrations

Connect with your existing tools and platforms:

1. **Analytics Platforms**
   - Google Analytics integration
   - Tableau connection
   - Power BI integration
   - Custom analytics platform connections

2. **Business Tools**
   - CRM integration (Salesforce, etc.)
   - Marketing platform connections
   - Social media analytics integration
   - Accounting system connections

3. **Music Industry Tools**
   - Distribution platform connections
   - Label management system integration
   - Publishing administration connections
   - Tour management platform integration

4. **Custom Integration Services**
   - Custom integration development
   - Data transformation services
   - Integration monitoring and support
   - Legacy system connections

## Best Practices

### Analytics Strategy

Maximize the value of your analytics data:

1. **Goal-Based Analytics**
   - Define clear measurement objectives
   - Align metrics with business goals
   - Set measurable targets
   - Create analytics scorecards

2. **Analytics Cadence**
   - Daily monitoring recommendations
   - Weekly analysis schedule
   - Monthly deep-dive assessments
   - Quarterly strategic reviews

3. **Analytics Ownership**
   - Define analytics stakeholders
   - Establish review responsibilities
   - Set action owners
   - Create feedback loops

4. **Analytics Evolution**
   - Regular metric evaluation
   - Analytics maturity assessment
   - New metric introduction process
   - Analytics capability advancement

### Data-Driven Decision Making

Transform analytics into actionable insights:

1. **Insight Identification Process**
   - Data exploration techniques
   - Pattern recognition methods
   - Anomaly detection practices
   - Correlation discovery

2. **Decision Framework**
   - Hypothesis development
   - A/B testing methodology
   - Data validation processes
   - Decision documentation

3. **Implementation Planning**
   - Insight prioritization
   - Action planning
   - Resource allocation
   - Timeline development

4. **Results Measurement**
   - Before/after analysis
   - Impact assessment
   - ROI calculation
   - Learning documentation

### Analytics Interpretation

Accurately understand and communicate your data:

1. **Context Consideration**
   - Seasonal adjustment techniques
   - Industry event normalization
   - Platform change accounting
   - Benchmark contextualization

2. **Correlation vs. Causation**
   - Multi-factor analysis methods
   - Control variable identification
   - Causation validation techniques
   - Alternative explanation assessment

3. **Statistical Significance**
   - Sample size considerations
   - Confidence interval understanding
   - Variance and outlier management
   - Trend validation methods

4. **Storytelling with Data**
   - Narrative development techniques
   - Visualization best practices
   - Executive summary creation
   - Audience-specific presentations

## Frequently Asked Questions

### General Analytics Questions

**Q: Why do my streaming numbers differ between TuneMantra and my DSP dashboards?**  
A: Slight differences are normal due to several factors: (1) Data timing differences - TuneMantra may aggregate data at different intervals than DSPs; (2) Counting methodologies - platforms may have different definitions of a "stream"; (3) Processing delays - some platforms have longer reporting cycles. For financial reconciliation, the final monthly statements should be considered authoritative.

**Q: How far back does historical data go in TuneMantra Analytics?**  
A: TuneMantra Analytics maintains complete historical data from the moment your content is distributed through our platform. For content distributed before joining TuneMantra, we can import historical data from most major platforms during onboarding, typically up to 3 years of historical performance.

**Q: How often is analytics data updated?**  
A: Most streaming and performance data is updated daily, typically refreshing between 2-4 AM UTC. Revenue data is updated as it's reported by platforms, which varies by platform but is typically every 30-45 days. Real-time estimates are provided for revenue based on stream counts and historical averages.

### Technical Questions

**Q: Can I access raw data for custom analysis?**  
A: Yes, TuneMantra provides several options for accessing raw data: (1) The Report Builder allows detailed data export in CSV/Excel format; (2) The Analytics API provides programmatic access for custom integrations; (3) For enterprise clients, direct database connections can be established. Contact your account manager for specific requirements.

**Q: What attribution models are used for tracking marketing impact?**  
A: TuneMantra uses a multi-touch attribution model that assigns appropriate credit to various marketing touchpoints. By default, we use a position-based model that gives 40% credit to first touch, 40% to last touch, and 20% distributed among middle interactions. Enterprise users can configure custom attribution models in the Marketing Analytics settings.

**Q: How accurate is the demographic data?**  
A: Demographic data comes from several sources: (1) Platform-provided anonymous aggregate data; (2) TuneMantra audience panel data; (3) Third-party data partnerships. The accuracy varies by platform and region, with typically 90%+ confidence for major territories and platforms. All demographic data is presented as statistically significant samples, not individual listener tracking.

### Analytics Interpretation

**Q: What metrics should I focus on to measure my music's success?**  
A: The most important metrics depend on your specific goals:
- For growth focus: Track listener growth rate, new listener acquisition, and geographic expansion
- For engagement focus: Monitor save rate, completion rate, and repeat listener percentage
- For revenue focus: Analyze revenue per stream, platform revenue efficiency, and catalog value
We recommend creating a custom dashboard with your top 5-7 KPIs aligned with your current strategic objectives.

**Q: How can I identify which part of my catalog to focus on promoting?**  
A: Use the Catalog Analysis section to identify: (1) High-performing tracks with growth potential - look for tracks with strong completion rates and save rates; (2) Tracks resonating with specific audience segments - use the audience affinity analysis; (3) Tracks with playlist potential - review the playlist match score. The Opportunity Analysis tool automatically highlights tracks that merit additional promotional support.

**Q: How do I interpret sudden changes in streaming numbers?**  
A: Investigate sudden changes using these analytics tools: (1) The Source Analysis will show if changes came from playlists, algorithms, or direct traffic; (2) The Platform Breakdown will reveal if changes are platform-specific; (3) The Geography View will show if changes are region-specific. Major spikes often correlate with playlist additions, algorithm changes, or social media events - all identifiable in the respective analytics sections.

---

## Support Resources

If you need additional assistance with analytics:

- **Knowledge Base**: Visit [help.tunemantra.com/analytics](https://help.tunemantra.com/analytics) for detailed tutorials
- **Video Tutorials**: Access step-by-step video guides in the Learning Center
- **Analytics Support**: Contact our dedicated analytics team at analytics@tunemantra.com
- **Data Consultations**: Enterprise users can schedule one-on-one consultations with our data analysts

---

**Document Information:**
- Version: 2.0
- Last Updated: March 25, 2025
- Contact: documentation@tunemantra.com

---

## documentation/user/artist-guide.md

# Artist Guide for TuneMantra

<div align="center">
  <img src="../diagrams/artist-guide-header.svg" alt="TuneMantra Artist Guide" width="800"/>
</div>

## Introduction

Welcome to TuneMantra's comprehensive guide for Artists. This document provides detailed instructions, best practices, and expert tips for maximizing your success on the TuneMantra platform. Whether you're an independent artist or signed to a label, this guide will help you navigate the platform's features and optimize your music distribution, rights management, and revenue generation.

## Table of Contents

- [Dashboard Overview](#dashboard-overview)
- [Profile Management](#profile-management)
- [Music Management](#music-management)
- [Release Creation](#release-creation)
- [Distribution](#distribution)
- [Rights & Royalties](#rights--royalties)
- [Analytics & Insights](#analytics--insights)
- [Financial Management](#financial-management)
- [Marketing Tools](#marketing-tools)
- [Collaboration Features](#collaboration-features)
- [Advanced Features](#advanced-features)
- [Best Practices](#best-practices)
- [FAQ](#frequently-asked-questions)

## Dashboard Overview

Your artist dashboard is the command center for managing all aspects of your music career on TuneMantra.

<div align="center">
  <img src="../screenshots/artist-dashboard.png" alt="Artist Dashboard" width="700"/>
</div>

### Key Dashboard Elements

1. **Performance Summary**
   - Quick overview of streams, followers, and revenue metrics
   - Most popular tracks and territories
   - Recent release activity
   - Upcoming release schedule

2. **Navigation Menu**
   - Music: Manage your tracks and releases
   - Distribution: Control where your music is delivered
   - Rights: Manage ownership and rights information
   - Analytics: View detailed performance metrics
   - Finance: Track revenue and manage payments
   - Marketing: Access promotional tools and campaigns
   - Settings: Configure your account preferences

3. **Activity Feed**
   - Real-time streaming and engagement updates
   - Important notifications and alerts
   - Messages from your team or label
   - New fan interactions

4. **Quick Actions**
   - Create New Release
   - Check Analytics
   - Withdraw Earnings
   - Run Marketing Campaign
   - Contact Support

### Dashboard Customization

You can customize your dashboard to focus on what matters most to you:

1. Click the **Customize** button in the top-right corner
2. Drag and drop widgets to rearrange them
3. Add or remove widgets from the widget gallery
4. Configure widget settings and display options
5. Save your custom layout for future sessions

## Profile Management

### Setting Up Your Artist Profile

A complete, professional artist profile enhances your visibility and credibility on the platform.

1. **Basic Information**
   - Artist Name: Your official artist name
   - Biography: Craft a compelling artist bio (500-1000 characters recommended)
   - Profile Picture: Upload a high-quality headshot (minimum 1000x1000px, PNG format)
   - Banner Image: Upload a banner for your profile page (1800x400px recommended)
   - Artist Type: Solo Artist, Band, Duo, Group, etc.
   - Primary Genre: Select your main musical genre
   - Secondary Genres: Select up to 3 additional genres

2. **Contact & Social Information**
   - Official Website URL
   - Social Media Links (Instagram, TikTok, Twitter, Facebook, YouTube, etc.)
   - Booking Email (for performance inquiries)
   - Management Contact (optional)

3. **Additional Details**
   - Location: Country and city
   - Career Stage: Emerging, Established, etc.
   - Formation Year: When you began your music career
   - Influences: Artists who inspire your sound
   - Band Members: For groups, include member names and roles

### Profile Verification

Get the official verified badge to establish authenticity:

1. **Verification Requirements**
   - Complete profile with all required fields
   - At least one released track
   - Linked and active social media accounts
   - Minimum follower requirements (platform-specific)

2. **Verification Process**
   - Submit verification request from Settings
   - Provide requested identification documents
   - Complete verification questionnaire
   - Allow 3-5 business days for review

3. **Maintaining Verification**
   - Regular account activity
   - Adherence to platform guidelines
   - Timely updates to profile information

## Music Management

### Managing Your Catalog

Efficiently organize and manage your music catalog:

1. **Viewing Your Catalog**
   - Navigate to **Music > My Catalog**
   - Filter by release type, date, or status
   - Search by track or release title
   - Sort by performance metrics

2. **Track Management**
   <div align="center">
     <img src="../screenshots/track-management-artist.png" alt="Track Management Interface" width="700"/>
   </div>

   - View track details and metadata
   - Check streaming performance
   - Manage track rights and splits
   - Update track information
   - Download audio files and artwork

3. **Release Management**
   - Group related tracks as albums, EPs, or singles
   - View release status and availability
   - Check release-level analytics
   - Download release assets

### Audio Quality Guidelines

Ensure your music sounds its best across all platforms:

1. **Recommended Audio Specifications**
   - Format: Uncompressed WAV
   - Bit Depth: 16-bit or 24-bit
   - Sample Rate: 44.1kHz or higher
   - Channels: Stereo
   - Dynamic Range: -14 LUFS for optimal streaming loudness

2. **Pre-Upload Audio Checklist**
   - Check for clipping or distortion
   - Verify consistent volume across tracks
   - Ensure clean beginnings and endings
   - Confirm correct metadata embedding
   - Test on multiple speaker systems

3. **Audio Quality Verification**
   - Use the platform's audio quality analyzer
   - Review automatic analysis results
   - Address any flagged issues
   - Perform manual quality check with headphones

## Release Creation

### Creating a New Release

Step-by-step guide to creating professional music releases:

1. **Initiate a New Release**
   - Navigate to **Music > Create New Release**
   - Select release type:
     - Single (1-3 tracks)
     - EP (4-6 tracks)
     - Album (7+ tracks)
     - Remix EP

2. **Basic Release Information**
   - Release Title
   - Primary Artist(s)
   - Featured Artists
   - Release Date (minimum 7 days from submission)
   - Label (select "Independent" if self-releasing)
   - Primary Genre and Subgenre
   - Language
   - Parental Advisory (if applicable)

3. **Release Artwork**
   - Upload square cover artwork (minimum 3000x3000px, RGB JPG format)
   - Ensure artwork meets platform requirements:
     - No text except artist name and title
     - No website URLs or social media handles
     - No explicit imagery
     - No third-party logos or QR codes

4. **Adding Tracks**
   - Upload audio files (WAV format recommended)
   - Complete track information for each song:
     - Track Title
     - Track Version (if applicable)
     - Track Number
     - Duration (auto-detected)
     - ISRC Code (request one if needed)
     - Explicit Content Flag
     - Lyrics (optional but recommended)
     - Language
     - Mood and Theme Tags (helps with playlist placement)

5. **Credits and Rights**
   - Songwriter(s) / Composer(s)
   - Producer(s)
   - Release Copyright Information
     - Year
     - Copyright Holder
   - Recording Copyright Information
     - Year
     - Copyright Holder
   - UPC/EAN Code (automatically generated if not provided)

6. **Additional Options**
   - Pre-save Date (to build anticipation before release)
   - Release Description (for DSPs and marketing)
   - Similar Artists (for algorithm recommendations)
   - Territories to Exclude (if any)

### Release Timeline Planning

Strategically plan your release schedule for maximum impact:

1. **Optimal Release Planning**
   - Schedule releases for Friday (global new music day)
   - Plan 3-4 weeks in advance for pre-save campaigns
   - Coordinate with marketing activities and live events
   - Consider seasonal factors and competitive releases

2. **Pre-Release Strategy**
   - Set up pre-save campaigns
   - Prepare promotional materials
   - Schedule social media announcements
   - Plan first-week engagement activities

3. **Release Calendar**
   - View and manage upcoming releases
   - Set reminders for key promotional dates
   - Adjust release dates if needed (up to 72 hours before scheduled release)
   - Coordinate multiple releases for optimal spacing

## Distribution

### Distribution Management

Control where and how your music reaches audiences:

1. **Platform Selection**
   <div align="center">
     <img src="../screenshots/distribution-platforms-artist.png" alt="Distribution Platform Selection" width="700"/>
   </div>

   - Choose from available distribution platforms:
     - Major streaming services (Spotify, Apple Music, Amazon Music, etc.)
     - Download stores (iTunes, Amazon, etc.)
     - Video platforms (YouTube Music, TikTok, etc.)
     - Regional services (NetEase, Boomplay, etc.)
     - Specialized platforms (Beatport, Traxsource, etc.)

2. **Distribution Settings**
   - Global Distribution (all available platforms)
   - Custom Distribution (select specific platforms)
   - Territory Settings (distribute to specific regions)
   - Exclusive Releases (platform-specific)
   - Release Timing (immediate or scheduled)

3. **Distribution Verification**
   - Preview how your release will appear on platforms
   - Check metadata formatting across services
   - Verify audio playback quality
   - Submit for distribution with confidence

### Distribution Status Tracking

Monitor your music's journey to platforms in real-time:

1. **Status Dashboard**
   - Track the processing status of all releases
   - View platform-by-platform delivery confirmation
   - Receive notifications when music goes live
   - Monitor for any distribution issues

2. **Link Collection**
   - Automatically collect links as your music goes live
   - Copy links for social media promotion
   - Generate smart links for multi-platform promotion
   - Monitor link performance and clicks

3. **Post-Release Updates**
   - Update release metadata if needed
   - Request artwork changes
   - Submit takedown requests if necessary
   - Schedule catalog refreshes

## Rights & Royalties

### Royalty Management

Understand and optimize your earnings:

1. **Royalty Dashboard**
   <div align="center">
     <img src="../screenshots/royalty-dashboard-artist.png" alt="Royalty Dashboard" width="700"/>
   </div>

   - Real-time earnings overview
   - Platform-by-platform revenue breakdown
   - Historical earnings comparison
   - Projected future earnings

2. **Revenue Sources**
   - Streaming royalties
   - Download sales
   - Sync licensing
   - Performance royalties
   - Mechanical royalties

3. **Payment History**
   - Track all previous payments
   - Download payment receipts
   - Verify payment accuracy
   - Set up payment notifications

### Split Management

Fairly distribute earnings among collaborators:

1. **Creating Split Sheets**
   - Add collaborators by email or username
   - Assign precise percentage splits
   - Define role-based splits (writer, producer, performer)
   - Send agreements for electronic signature

2. **Managing Splits**
   - View all tracks with active splits
   - Update splits when needed (with collaborator approval)
   - Export split documentation for legal purposes
   - Set up automated payments based on splits

3. **Split Templates**
   - Create reusable split templates for regular collaborators
   - Apply templates to new releases
   - Modify templates as relationships evolve
   - Share templates with your creative team

### Rights Registration

Protect your creative work and ensure proper attribution:

1. **Copyright Registration**
   - Register your works with copyright offices (links to external services)
   - Store copyright registration numbers
   - Upload supporting documentation
   - Set copyright claim alerts

2. **Performance Rights Organization (PRO) Registration**
   - Link your PRO account (ASCAP, BMI, SESAC, etc.)
   - Register works with connected PROs
   - Track registration status
   - Receive notifications for PRO-related actions

3. **Publishing Administration**
   - Connect with publishing administrators
   - Track publishing royalties
   - Review publishing data
   - Identify unclaimed royalties

## Analytics & Insights

### Performance Analytics

Gain valuable insights into your music's performance:

1. **Stream Analytics**
   - Total streams across all platforms
   - Platform-by-platform breakdown
   - Daily, weekly, monthly, and yearly trends
   - Stream source analysis (playlists, direct, algorithmic)

2. **Audience Analytics**
   <div align="center">
     <img src="../screenshots/audience-analytics.png" alt="Audience Analytics Dashboard" width="700"/>
   </div>

   - Demographic breakdowns (age, gender)
   - Geographic distribution of listeners
   - Listening device and platform preferences
   - Fan engagement metrics

3. **Track and Release Comparison**
   - Compare performance across your catalog
   - Identify your strongest markets
   - Analyze release strategy effectiveness
   - Track career growth metrics

### Advanced Insights

Leverage data for strategic career decisions:

1. **Playlist Analytics**
   - Track all playlist placements
   - Measure playlist impact on streams
   - Identify high-performing playlists
   - Monitor playlist adds and removals

2. **Marketing Effectiveness**
   - Track promotional campaign results
   - Measure marketing ROI
   - A/B test promotion strategies
   - Optimize marketing spending

3. **Trending Analysis**
   - Identify rising markets for your music
   - Spot genre trend alignments
   - Compare with industry benchmarks
   - Receive growth opportunity alerts

### Reporting Features

Create and export customized reports for your team:

1. **Report Types**
   - Performance summaries
   - Financial reports
   - Catalog analysis
   - Fan engagement reports

2. **Report Customization**
   - Select specific metrics
   - Choose date ranges
   - Customize visualizations
   - Save report templates

3. **Sharing and Export**
   - Export to various formats (PDF, Excel, CSV)
   - Schedule automated reports
   - Share reports with team members
   - Embed reports in external tools

## Financial Management

### Revenue Tracking

Monitor and manage your earnings efficiently:

1. **Revenue Dashboard**
   - Comprehensive earnings overview
   - Revenue breakdowns by source
   - Historical revenue comparisons
   - Currency conversion for global earnings

2. **Payment Methods**
   - Add and manage payment methods
   - Set default payment preferences
   - Configure payment thresholds
   - Update payment information

3. **Tax Management**
   - Submit tax information
   - Generate year-end tax summaries
   - Download tax forms
   - Manage withholding settings

### Withdrawals

Access your earnings when you need them:

1. **Initiating Withdrawals**
   - Request payment of available balance
   - Select withdrawal amount
   - Choose payment method
   - Set up recurring withdrawals

2. **Withdrawal Status**
   - Track pending withdrawals
   - View estimated arrival dates
   - Receive payment notifications
   - Resolve any payment issues

3. **Financial Calendar**
   - Payment schedule overview
   - Upcoming payment dates
   - Historical payment timeline
   - Revenue forecast periods

### Financial Planning

Tools to help manage your music career finances:

1. **Revenue Forecasting**
   - Project future earnings based on current trends
   - Scenario planning for new releases
   - Seasonal revenue projections
   - Goal setting and tracking

2. **Expense Tracking**
   - Log music-related expenses
   - Categorize expenses for tax purposes
   - Link receipts to expense entries
   - Generate expense reports

3. **Budget Tools**
   - Create release budgets
   - Track marketing spending
   - Plan reinvestment of earnings
   - Set financial goals

## Marketing Tools

### Promotional Features

Built-in tools to promote your music effectively:

1. **Pre-Save Campaigns**
   - Create custom pre-save pages
   - Track pre-save conversions
   - Collect fan email addresses
   - Automate release-day notifications

2. **Smart Links**
   <div align="center">
     <img src="../screenshots/smart-links.png" alt="Smart Links Creation Interface" width="700"/>
   </div>

   - Generate links for all platforms
   - Customize link landing pages
   - Track link performance
   - A/B test different designs

3. **Social Media Tools**
   - Create shareable content
   - Schedule social posts
   - Generate platform-specific assets
   - Track social engagement

### Audience Building

Grow and engage with your fan base:

1. **Fan Capture**
   - Email collection tools
   - Fan data management
   - Segmentation and targeting
   - Audience insights

2. **Engagement Features**
   - Direct messaging capabilities
   - Exclusive content distribution
   - Fan polls and feedback collection
   - Superfan identification

3. **Email Marketing**
   - Build email campaigns
   - Design email templates
   - Schedule automated messages
   - Track open and click rates

### Playlisting Strategy

Maximize your playlist potential:

1. **Playlist Pitching**
   - Create compelling playlist pitches
   - Submit to platform editorial teams
   - Track pitch status and results
   - Analyze successful pitch patterns

2. **Playlist Tracking**
   - Monitor all playlist inclusions
   - Track playlist performance impact
   - Receive alerts for new additions
   - Identify high-value playlists

3. **Curator Relationships**
   - Discover relevant playlist curators
   - Track curator preferences
   - Build personalized outreach
   - Maintain curator relationships

## Collaboration Features

### Team Management

Coordinate with your professional team:

1. **Team Roles**
   - Add team members with specific roles:
     - Manager
     - Producer
     - Engineer
     - Designer
     - Marketing
     - Administrative
   - Set appropriate permissions for each role
   - Track team member activities
   - Manage access credentials

2. **Collaboration Tools**
   - Shared calendar for release planning
   - Task assignment and tracking
   - Internal messaging system
   - Document sharing and collaboration

3. **Notifications and Updates**
   - Customize notification preferences
   - Set up team alerts for key events
   - Create activity digests
   - Schedule regular updates

### Creator Collaboration

Work efficiently with other artists and creators:

1. **Collaboration Management**
   <div align="center">
     <img src="../screenshots/collaboration-dashboard.png" alt="Collaboration Dashboard" width="700"/>
   </div>

   - Track all collaborative projects
   - Manage collaboration invitations
   - Set clear collaboration terms
   - Document contribution agreements

2. **File Sharing**
   - Share works-in-progress securely
   - Version control for project files
   - Feedback and annotation tools
   - Finalize tracks for release

3. **Split Creation**
   - Document contribution percentages
   - Create formal split agreements
   - Obtain electronic signatures
   - Store collaboration contracts

## Advanced Features

### AI-Powered Tools

Leverage artificial intelligence to enhance your music career:

1. **AI Metadata Enhancement**
   - Automatic genre classification
   - Mood and theme detection
   - Similar artist recommendations
   - SEO optimization suggestions

2. **Audience Matching**
   - Identify potential fans based on listening patterns
   - Find similar audiences to your current listeners
   - Discover untapped geographic markets
   - Target promotion to high-potential listeners

3. **Performance Prediction**
   - Track potential based on early indicators
   - Compare with similar release patterns
   - Identify probable growth trajectories
   - Receive performance alerts and suggestions

### API Integration

Connect TuneMantra with your existing workflow:

1. **Available Integrations**
   - Digital Audio Workstations (DAWs)
   - Social media management tools
   - Accounting software
   - Website content management

2. **Custom API Access**
   - Generate API credentials
   - Access documentation and SDKs
   - Set usage limits and permissions
   - Monitor API usage

3. **Data Synchronization**
   - Schedule automated data exchanges
   - Configure webhooks for real-time updates
   - Map data fields between systems
   - Troubleshoot integration issues

### Career Development Resources

Resources to support your growth as an artist:

1. **Educational Content**
   - Industry guides and tutorials
   - Best practice documentation
   - Video masterclasses
   - Expert webinars

2. **Networking Opportunities**
   - Industry directory
   - Collaboration matching
   - Virtual events and meetups
   - Mentorship connections

3. **Career Planning Tools**
   - Goal setting and tracking
   - Career milestone planning
   - Progress visualization
   - Professional development resources

## Best Practices

### Release Strategy

Optimize your release approach for maximum impact:

1. **Release Cadence**
   - Maintain consistent release schedule (recommended: at least quarterly)
   - Balance singles vs. full projects based on your genre
   - Consider "waterfall" release strategy (singles leading to EP/album)
   - Plan release dates around industry events and seasonal factors

2. **Content Preparation**
   - Finalize all assets at least 4 weeks before release
   - Prepare a comprehensive release checklist
   - Create a content calendar for supporting materials
   - Plan post-release engagement activities

3. **Quality Control**
   - Always review distribution preview before submitting
   - Listen to final masters on multiple devices
   - Double-check all metadata for accuracy
   - Verify all collaborator information and splits before release

### Marketing Effectiveness

Market your music efficiently and effectively:

1. **Targeted Promotion**
   - Focus on your proven core audience first
   - Expand to similar demographics strategically
   - Allocate budget based on market response data
   - Test new promotion channels with limited investment

2. **Content Strategy**
   - Create a consistent visual identity
   - Maintain regular content schedule between releases
   - Repurpose content across platforms
   - Balance promotional vs. engagement content

3. **Analytics-Driven Decisions**
   - Review performance data before planning new releases
   - Analyze successful marketing campaigns for patterns
   - Test marketing messages with sample audiences
   - Adjust strategies based on concrete performance data

### Financial Management

Maintain healthy music business finances:

1. **Revenue Optimization**
   - Register all works with appropriate PROs
   - Ensure complete metadata for all releases
   - Review statements regularly for discrepancies
   - Appeal any identified payment errors promptly

2. **Reinvestment Strategy**
   - Allocate percentage of earnings to future music production
   - Budget for marketing based on project scale
   - Maintain emergency funds for unexpected opportunities
   - Track ROI on all music investments

3. **Tax Efficiency**
   - Maintain organized financial records year-round
   - Track all deductible music business expenses
   - Consider appropriate business structure
   - Work with a music industry financial professional

## Frequently Asked Questions

### Distribution

**Q: How long does it take for my music to appear on streaming platforms?**  
A: After submission, your music typically takes 2-5 business days to be processed and delivered to platforms. Then platforms have their own ingestion times, usually 1-3 additional days. For optimal results, we recommend scheduling releases at least 2 weeks in advance.

**Q: Can I change my release date after submitting?**  
A: Yes, you can modify your release date through the Distribution Management interface up until 72 hours before the scheduled release. After that, changes may not be possible for technical reasons.

**Q: What happens if there's an error with my release?**  
A: If we detect any issues with your submission, you'll receive a notification with details about the problem and steps to resolve it. Common issues include incorrect metadata, low-quality audio files, or artwork that doesn't meet requirements.

### Rights & Royalties

**Q: How often are royalties calculated and paid?**  
A: Royalties are calculated monthly as we receive reports from platforms. Payments are processed once your balance reaches your selected payment threshold (default: $50) or on your configured payment schedule.

**Q: How do I handle a collaboration where I need to split royalties?**  
A: Use the Split Management tool to invite collaborators by email, set percentage splits, and have all parties electronically sign the agreement. Once established, royalties will be automatically divided according to the agreed percentages.

**Q: Can I transfer my existing catalog to TuneMantra?**  
A: Yes, you can transfer your existing catalog by using our Catalog Transfer tool. You'll need to provide proof of rights ownership and information about your current distributor. Our team will guide you through the process to ensure a smooth transition.

### Analytics & Marketing

**Q: Why do my streaming numbers differ between TuneMantra and the streaming platform's own dashboard?**  
A: Slight differences are normal due to reporting delays, data processing times, and different counting methodologies. TuneMantra consolidates data from all platforms, which may be updated at different intervals. For the most accurate historical data, always refer to TuneMantra's finalized monthly statements.

**Q: How can I increase my chances of getting on editorial playlists?**  
A: Submit your music at least 4 weeks before release through our Playlist Pitching tool. Include compelling artist and track information, noteworthy achievements, and a clear description of why your track fits specific playlists. Our data shows that consistent quality releases, growing engagement metrics, and a strong artist profile significantly improve playlist consideration.

**Q: How do I track the effectiveness of my marketing efforts?**  
A: Use our Campaign Tracking feature to create unique links and campaign tags for each marketing initiative. This allows you to directly attribute streams, followers, and revenue to specific marketing activities in your Analytics dashboard, helping you identify your most effective promotion channels.

---

## Support Resources

If you need additional assistance with your artist account on TuneMantra:

- **Knowledge Base**: Visit [help.tunemantra.com](https://help.tunemantra.com) for detailed tutorials and guides
- **Video Tutorials**: Access step-by-step video guides in the Learning Center
- **Artist Support**: Contact our dedicated artist support team at artists@tunemantra.com
- **Community Forums**: Connect with other artists and share experiences at [community.tunemantra.com](https://community.tunemantra.com)
- **Office Hours**: Join our weekly virtual office hours for live Q&A with our team

---

**Document Information:**
- Version: 2.0
- Last Updated: March 25, 2025
- Contact: documentation@tunemantra.com

---

## documentation/user/audio-fingerprinting-guide.md

# Audio Fingerprinting User Guide

## What is Audio Fingerprinting?

Audio fingerprinting is a technology that identifies unique characteristics in audio files, similar to how a human fingerprint identifies a person. In TuneMantra, we use audio fingerprinting to:

1. **Verify originality** of your content
2. **Identify potential copyright issues** before distribution
3. **Validate metadata** accuracy
4. **Detect samples** from other works that may require clearance

## Why is Audio Fingerprinting Important?

Distributing music with copyright issues can lead to:

- Takedown notices
- Lost revenue
- Legal complications
- Damaged reputation

Our audio fingerprinting tool helps you identify these issues **before** your music is distributed, saving you time, money, and potential legal headaches.

## Using the Audio Fingerprinting Tool

### Step 1: Upload Your Audio

1. Navigate to the Upload page
2. Select your audio file(s) by clicking "Browse" or dragging files into the upload area
3. The system will first validate the file format and specifications
4. Once validation passes, proceed to the Metadata tab

### Step 2: Run the Fingerprinting Validation

In the Metadata tab, you'll see the "Copyright Validation" card with the Audio Fingerprinting tool.

1. Click the "Start Fingerprinting Validation" button
2. The system will analyze your audio for:
   - Matches in commercial music databases
   - Metadata accuracy
   - Potential samples

3. This process takes a few moments to complete

### Step 3: Review the Results

After analysis is complete, review each section of the results:

#### Copyright Detection

This section shows if your track matches existing content in commercial databases:

- **Green badge (Passed)**: No matches found - your content appears to be original
- **Red badge (Issues Found)**: Potential copyright matches detected

If matches are found, you'll see details including:
- Track title and artist
- Confidence level of the match
- Source of the match
- Potential copyright issues

#### Metadata Validation

Verifies if your provided metadata matches what was detected in the audio:

- **Green badge (Passed)**: Your metadata is consistent with the audio content
- **Red badge (Issues Found)**: Discrepancies detected between your metadata and what was found in the audio

Any issues will be clearly listed for you to address.

#### Sample Detection

Identifies potential samples from other works:

- **Green badge (No Samples)**: No samples detected
- **Red badge (Samples Found)**: Potential samples detected, with details including:
  - Original track and artist
  - Timestamp where the sample appears
  - Confidence level

## What to Do If Issues Are Found

### Copyright Matches

If your track has a high-confidence match:

1. **Verify originality**: Confirm your track doesn't improperly use copyrighted material
2. **Check for covers**: If this is a cover song, ensure you have the proper licenses
3. **Document ownership**: If it's your original work that's already in the database, be prepared to provide proof of ownership

### Metadata Discrepancies

If metadata issues are detected:

1. **Check your metadata**: Verify that your titles, artist names, and other details are accurate
2. **Update if needed**: Correct any errors in the metadata fields
3. **Add explanation**: If there's a legitimate reason for the discrepancy, note it in the additional info field

### Sample Detection

If samples are detected:

1. **Verify samples**: Confirm whether you're using samples from other works
2. **Ensure clearance**: Make sure you have proper clearance for any samples
3. **Document licenses**: Keep records of any sample clearances you've obtained

## Best Practices

1. **Run fingerprinting early**: Check for issues before completing the full distribution process
2. **Address all issues**: Resolve any identified problems before distribution
3. **Keep documentation**: Maintain records of sample clearances and rights
4. **Be thorough with metadata**: Provide complete and accurate information

## Limitations

Please note that our audio fingerprinting system:

1. May not detect **all** potential copyright issues
2. Works best with released commercial music
3. Has varying detection rates based on audio quality and length
4. Should be used as a tool, not a guarantee of copyright clearance

## Getting Help

If you have questions about audio fingerprinting results or need assistance:

1. Check our [Copyright FAQ](copyright-faq.md) for common questions
2. Contact our support team for specific issues
3. Consider consulting a music rights specialist for complex copyright situations

---

*Note: The audio fingerprinting service requires an internet connection and may be unavailable if our service provider is down. You can proceed with uploads during service outages, but we strongly recommend running fingerprinting validation when the service becomes available.*

---

## documentation/user/distribution-guide.md

# Distribution Guide for TuneMantra

<div align="center">
  <img src="../diagrams/distribution-guide-header.svg" alt="TuneMantra Distribution Guide" width="800"/>
</div>

## Introduction

Welcome to TuneMantra's comprehensive Distribution Guide. This document provides detailed instructions, workflows, and best practices for distributing music across various platforms through the TuneMantra system. Whether you're an independent artist or a label manager, this guide will help you efficiently deliver your music to global audiences while maintaining complete control over your content.

## Table of Contents

- [Distribution Fundamentals](#distribution-fundamentals)
- [Distribution Workflow](#distribution-workflow)
- [Platform Management](#platform-management)
- [Release Delivery](#release-delivery)
- [Distribution Monitoring](#distribution-monitoring)
- [Troubleshooting](#troubleshooting)
- [Advanced Distribution Features](#advanced-distribution-features)
- [Best Practices](#best-practices)
- [FAQ](#frequently-asked-questions)

## Distribution Fundamentals

### Understanding Music Distribution

Music distribution is the process of delivering your music to streaming platforms, download stores, and other digital service providers (DSPs). TuneMantra provides an end-to-end solution for this process.

<div align="center">
  <img src="../screenshots/distribution-overview.png" alt="Distribution Overview" width="700"/>
</div>

### Key Distribution Concepts

1. **Digital Service Providers (DSPs)**
   - Streaming platforms (Spotify, Apple Music, Amazon Music, etc.)
   - Download stores (iTunes, Amazon MP3, etc.)
   - Video platforms (YouTube Music, TikTok, etc.)
   - Regional services (NetEase, Boomplay, etc.)
   - Specialized platforms (Beatport, Traxsource, etc.)

2. **Distribution Timeline**
   - Submission: You upload and provide metadata
   - Processing: TuneMantra validates and prepares your content
   - Delivery: Content is delivered to selected platforms
   - Ingestion: Platforms process and review your content
   - Live: Content becomes available to listeners

3. **Distribution Models**
   - Standard Distribution: Content delivered to major platforms
   - Premium Distribution: Priority delivery with enhanced services
   - Custom Distribution: Tailored services for specific needs
   - Direct Distribution: Platform-specific special arrangements

4. **Release Types**
   - Singles (1-3 tracks)
   - EPs (4-6 tracks)
   - Albums (7+ tracks)
   - Compilations
   - Remix packages

## Distribution Workflow

### Step 1: Prepare Your Release

Before submitting for distribution, ensure you have:

1. **Audio Files**
   - High-quality WAV files (minimum 16-bit/44.1kHz)
   - Properly mastered for digital distribution (-14 LUFS recommended)
   - Free of defects, noise, and clipping
   - Silences trimmed appropriately

2. **Artwork**
   - Square format (minimum 3000x3000px)
   - RGB color mode (JPG or PNG format)
   - Professional quality and relevant to release
   - Compliant with platform guidelines:
     - No explicit imagery
     - No text beyond artist name and title
     - No URLs, QR codes, or social media handles
     - No third-party logos or unauthorized branding

3. **Metadata**
   - Accurate and consistent artist name(s)
   - Release title and track titles
   - Correct release date
   - Appropriate genre classifications
   - Language information
   - Credits for all contributors
   - ISRC codes for each track (TuneMantra can generate these if needed)
   - UPC/EAN code for the release (TuneMantra can generate this if needed)

4. **Rights Information**
   - Verified ownership rights
   - Sample clearances (if applicable)
   - Split sheets for royalty allocation
   - Publishing information

### Step 2: Create a New Distribution

<div align="center">
  <img src="../screenshots/new-distribution.png" alt="Create New Distribution Interface" width="700"/>
</div>

1. Navigate to **Distribution > Create New Distribution**

2. Select release type and fill in basic information:
   - Release Title
   - Primary Artist
   - Featured Artists (if applicable)
   - Release Date (minimum 7 days in advance recommended)
   - Genre and Subgenre
   - Language
   - Parental Advisory (if applicable)

3. Upload cover artwork and verify compliance

4. Add tracks:
   - Upload audio files
   - Enter track details (title, artists, ISRC, etc.)
   - Add lyrics (optional but recommended)
   - Set track order

5. Complete additional metadata:
   - Copyright information
   - Recording ownership
   - Additional contributors
   - Release description
   - Mood and theme tags (helps with playlist consideration)

### Step 3: Select Distribution Platforms

Choose where your music will be distributed:

1. **Platform Selection Options**
   - All Platforms (recommended for maximum reach)
   - Custom Selection (choose specific platforms)
   - Territory-Specific Selection (distribute to platforms in specific regions)

2. **Platform Categories**
   - Major Streaming (Spotify, Apple Music, Amazon Music, etc.)
   - Video Platforms (YouTube Music, TikTok, Instagram Music, etc.)
   - Download Stores (iTunes, Amazon MP3, etc.)
   - Regional Platforms (NetEase, Boomplay, JioSaavn, etc.)
   - Specialized Platforms (Beatport, Traxsource, Bandcamp, etc.)

3. **Platform-Specific Settings**
   - Pre-save options
   - Exclusive content settings
   - Territory restrictions
   - Custom release dates per platform (if needed)
   - Pricing tier selection (for download stores)

### Step 4: Review and Submit

<div align="center">
  <img src="../screenshots/distribution-review.png" alt="Distribution Review Screen" width="700"/>
</div>

1. **Final Review Checklist**
   - Verify all metadata for accuracy
   - Preview how release will appear on platforms
   - Confirm audio quality and artwork compliance
   - Review platform selections and settings
   - Check release date and pre-save configuration

2. **Quality Control Verification**
   - Automated system checks for potential issues
   - Manual verification options
   - Issue resolution if problems are detected

3. **Submit for Distribution**
   - Confirm submission
   - Review estimated delivery timeline
   - Set up distribution notifications

## Platform Management

### Supported Distribution Platforms

TuneMantra distributes to over 150+ global platforms, including:

1. **Major Streaming Services**
   - Spotify
   - Apple Music
   - Amazon Music
   - Deezer
   - Tidal
   - Pandora
   - YouTube Music

2. **Video Platforms**
   - TikTok
   - Instagram/Facebook
   - YouTube Content ID
   - Snapchat
   - Triller

3. **Download Stores**
   - iTunes
   - Amazon MP3
   - Google Play
   - Bandcamp

4. **Regional Services**
   - NetEase (China)
   - QQ Music (China)
   - JioSaavn (India)
   - Boomplay (Africa)
   - Anghami (Middle East)
   - Yandex (Russia)

5. **Specialized Platforms**
   - Beatport
   - Traxsource
   - Juno Download
   - Audiomack
   - SoundCloud

### Platform Requirements

Different platforms have unique requirements that TuneMantra helps you navigate:

1. **Content Guidelines**
   - Explicit content policies
   - Artwork requirements
   - Audio quality standards
   - Metadata formatting rules

2. **Release Timeline Considerations**
   - Standard ingestion times
   - Platform-specific delays
   - Priority delivery options
   - Pre-release considerations

3. **Pricing Tiers**
   - Standard pricing
   - Premium pricing
   - Free/pay-what-you-want options
   - Promotional pricing

### Platform-Specific Features

Maximize your distribution with platform-specific optimization:

1. **Spotify**
   - Canvas video support
   - Songwriter pages linking
   - Spotify for Artists verification
   - Playlist pitch eligibility

2. **Apple Music**
   - Lyrics integration
   - Spatial Audio support
   - Apple Digital Masters certification
   - Pre-add campaign setup

3. **Amazon Music**
   - HD audio delivery
   - Amazon Originals eligibility
   - Alexa voice integration

4. **YouTube Music**
   - Topic channel creation
   - Content ID protection
   - Automatic video generation
   - Shorts soundtrack integration

## Release Delivery

### Distribution Processing

Once submitted, your distribution goes through these stages:

1. **Validation Stage**
   - Metadata verification
   - Audio quality checking
   - Rights verification
   - Artwork compliance check

2. **Processing Stage**
   - File conversion for platform specifications
   - Metadata formatting for each platform
   - Package preparation
   - Delivery queue assignment

3. **Delivery Stage**
   - Platform batch delivery
   - API-based direct delivery
   - Feed-based delivery
   - Partner network distribution

4. **Verification Stage**
   - Delivery confirmation tracking
   - Platform ingestion monitoring
   - Link collection
   - Live status verification

### Distribution Timeline

<div align="center">
  <img src="../screenshots/distribution-timeline.png" alt="Distribution Timeline" width="700"/>
</div>

Typical distribution timeline from submission to availability:

1. **Processing Time**
   - Initial validation: 1-24 hours
   - Processing and preparation: 1-3 days
   - Priority processing available for urgent releases

2. **Platform Delivery Time**
   - Major platforms: 1-7 days
   - Regional platforms: 3-14 days
   - Specialized platforms: 3-21 days
   - Video platforms: 5-14 days

3. **Total Timeline Expectations**
   - Minimum time to all platforms: 7-10 days
   - Average time to all platforms: 14-21 days
   - Recommended submission: At least 3 weeks before release date

### Priority Distribution

Expedite your distribution with premium services:

1. **Expedited Processing**
   - Front-of-queue validation
   - Accelerated processing
   - Priority delivery to platforms

2. **Rush Distribution**
   - Emergency processing for time-sensitive releases
   - Direct platform coordination
   - 24/7 monitoring and troubleshooting

3. **Eligibility Requirements**
   - Account standing considerations
   - Release importance factors
   - Additional fee structure

## Distribution Monitoring

### Distribution Dashboard

Track your distribution status in real-time:

<div align="center">
  <img src="../screenshots/distribution-dashboard.png" alt="Distribution Dashboard" width="700"/>
</div>

1. **Status Overview**
   - Overall distribution progress
   - Platform-by-platform status
   - Timeline visualization
   - Issue highlighting

2. **Platform Status Indicators**
   - Queued: Awaiting delivery
   - Delivered: Sent to platform
   - Processing: Being processed by platform
   - Live: Available to listeners
   - Error: Issue requiring attention

3. **Timeline Tracking**
   - Submission timestamp
   - Processing milestones
   - Delivery confirmation
   - Live confirmation
   - Historical status changes

### Link Collection

Access and manage links to your distributed content:

1. **Link Dashboard**
   - Automatic link collection as content goes live
   - Platform-organized link library
   - Copy functionality for easy sharing
   - Link verification tools

2. **Smart Link Generation**
   - Create unified landing pages for all platforms
   - Customizable smart link appearance
   - Analytics integration for click tracking
   - Social media optimization

3. **Link Management**
   - Link organization by release
   - Bulk export options
   - Link sharing tools
   - Link verification and testing

### Distribution Analytics

Measure the effectiveness of your distribution:

1. **Delivery Performance**
   - Platform delivery success rates
   - Average delivery times
   - Platform comparison metrics
   - Historical performance trends

2. **Territory Coverage**
   - Global availability map
   - Territory-specific delivery status
   - Regional accessibility verification
   - Geographic distribution gaps

3. **Issue Analytics**
   - Common error patterns
   - Platform-specific issue frequency
   - Resolution time metrics
   - Preventative recommendations

## Troubleshooting

### Common Distribution Issues

Solutions for frequently encountered distribution problems:

1. **Metadata Rejections**
   - Issue: Platform rejects release due to metadata issues
   - Solution: Review error details, correct metadata issues, and resubmit the specific information
   - Prevention: Follow metadata best practices and use the metadata validator before submission

2. **Artwork Rejections**
   - Issue: Platforms reject artwork for non-compliance
   - Solution: Create new compliant artwork and resubmit
   - Prevention: Review platform-specific artwork guidelines before submission

3. **Audio Quality Issues**
   - Issue: Audio files flagged for quality concerns
   - Solution: Address specific quality issues (clipping, noise, etc.) and resubmit improved files
   - Prevention: Use the audio analyzer tool before submission to identify potential issues

4. **Rights Conflicts**
   - Issue: Content flagged for potential rights conflicts
   - Solution: Provide documentation proving rights ownership or resolve conflicts with other rights holders
   - Prevention: Clear all samples and ensure all collaborators have signed proper agreements

### Platform-Specific Issues

Solutions for issues with specific platforms:

1. **Spotify**
   - Issue: Artist profile linking problems
   - Solution: Verify artist name consistency and request profile merging if needed
   - Prevention: Use exact same artist name spelling across all releases

2. **Apple Music**
   - Issue: Delayed appearance in catalog
   - Solution: Check delivery status and allow additional processing time
   - Prevention: Submit well in advance of release date

3. **YouTube Content ID**
   - Issue: Incorrect content claiming
   - Solution: Report incorrect claims and provide ownership documentation
   - Prevention: Ensure all rights are properly documented before distribution

4. **Regional Platforms**
   - Issue: Metadata language compatibility
   - Solution: Provide translations or alternate metadata when requested
   - Prevention: Include international character support in metadata when relevant

### Error Resolution Process

Step-by-step guide for resolving distribution errors:

1. **Error Identification**
   - Review error notifications
   - Check distribution dashboard for details
   - Understand the specific issue and requirements

2. **Correction Submission**
   - Update the specific content or metadata
   - Provide additional documentation if required
   - Submit corrections through the resolution center

3. **Verification Process**
   - Track correction status
   - Confirm resolution with platform
   - Verify final availability

4. **Escalation Procedures**
   - When to contact support
   - Required information for support tickets
   - Escalation timeframes and expectations

## Advanced Distribution Features

### Scheduled Releases

Plan your release strategy in advance:

1. **Release Calendar**
   <div align="center">
     <img src="../screenshots/release-calendar.png" alt="Release Calendar" width="700"/>
   </div>

   - Schedule releases up to 12 months in advance
   - Visualize release timeline
   - Coordinate multiple releases
   - Avoid scheduling conflicts

2. **Pre-save/Pre-order Configuration**
   - Set up pre-save campaigns
   - Configure pre-order availability
   - Track pre-release performance
   - Automate release-day notifications

3. **Staggered Release Strategy**
   - Platform-specific release dates
   - Territory-based release timing
   - Exclusive window configuration
   - Sequential platform rollout

### Territorial Distribution Control

Target specific geographic markets:

1. **Territory Selection**
   - Include/exclude specific territories
   - Region-based platform selection
   - Territory groups (e.g., North America, EU, LATAM, etc.)
   - Country-specific customization

2. **Localized Metadata**
   - Language-specific metadata
   - Regional genre classification
   - Local market optimization
   - Territorial copyright information

3. **Regional Pricing Control**
   - Territory-specific pricing tiers
   - Currency configuration
   - Regional promotional pricing
   - Market-appropriate price points

### Content Protection

Safeguard your music during distribution:

1. **Fingerprinting Technology**
   - Automatic content fingerprinting
   - Cross-platform identification
   - Unauthorized use detection
   - Takedown automation

2. **Rights Management Integration**
   - Ownership documentation
   - Rights verification
   - Conflict resolution tools
   - Chain of title tracking

3. **Anti-Piracy Measures**
   - Watermarking technology
   - Web monitoring
   - Automated takedown notices
   - Infringement reporting

### Catalog Management

Maintain and optimize your distributed music:

1. **Catalog Overview**
   - Complete catalog visualization
   - Status monitoring across platforms
   - Availability verification
   - Performance metrics

2. **Catalog Updates**
   - Metadata refreshes
   - Artwork updates
   - Audio quality improvements
   - Platform-specific optimization

3. **Catalog Analytics**
   - Comprehensive performance data
   - Catalog health metrics
   - Gap analysis
   - Optimization recommendations

## Best Practices

### Distribution Optimization

Maximize the effectiveness of your distribution:

1. **Release Planning**
   - Schedule releases for Friday (global new music day)
   - Submit at least 3 weeks before intended release date
   - Coordinate with marketing campaigns
   - Consider seasonal factors and competitive releases

2. **Metadata Excellence**
   - Use consistent artist names across all releases
   - Provide complete and accurate credits
   - Include detailed genre classifications
   - Add mood and theme tags for algorithmic recommendation

3. **Quality Assurance**
   - Review all content before submission
   - Validate metadata for accuracy
   - Ensure audio meets platform standards
   - Verify artwork compliance across all platforms

### Strategic Distribution

Optimize your reach and impact:

1. **Platform Prioritization**
   - Identify key platforms for your genre
   - Consider audience demographics by platform
   - Balance broad reach with targeted focus
   - Leverage platform-specific features for key services

2. **Release Timing**
   - Coordinate with promotional activities
   - Consider platform-specific editorial calendars
   - Avoid major industry release dates for better visibility
   - Time releases for seasonal relevance when applicable

3. **Distribution Package Selection**
   - Match distribution services to release importance
   - Utilize priority distribution for strategic releases
   - Balance standard and premium services for portfolio optimization
   - Consider specialized distribution for genre-specific platforms

### Distribution Analytics Utilization

Leverage distribution data for continual improvement:

1. **Performance Monitoring**
   - Track platform delivery performance
   - Analyze territory coverage effectiveness
   - Monitor issue frequency and resolution time
   - Compare current performance against historical baselines

2. **Optimization Cycle**
   - Identify recurring distribution issues
   - Implement targeted improvements
   - Test changes with subsequent releases
   - Document successful strategies for future releases

3. **Platform Relationship Development**
   - Maintain consistent release schedule
   - Respond promptly to platform issues
   - Build editorial relationships
   - Develop platform-specific optimization strategies

## Frequently Asked Questions

### Submission & Timing

**Q: How far in advance should I submit my release?**  
A: We recommend submitting your release at least 3-4 weeks before your intended release date. This allows sufficient time for processing, delivery to all platforms, and platform ingestion. For important releases with marketing campaigns, consider submitting 6-8 weeks in advance.

**Q: Can I change my release date after submission?**  
A: Yes, you can modify your release date through the Distribution Management interface up until 7 days before the scheduled release. After that, changes may not be possible for technical reasons. Date changes may affect editorial playlist consideration.

**Q: What's the fastest possible distribution timeline?**  
A: With Priority Distribution, we can typically deliver to major platforms within 3-5 days. However, platform ingestion times vary and cannot be guaranteed. For truly urgent releases, contact support to discuss Rush Distribution options.

### Platforms & Delivery

**Q: Why is my release available on some platforms but not others?**  
A: Different platforms have varying ingestion times. Major platforms like Spotify and Apple Music typically process content within 1-7 days, while smaller or regional platforms may take 7-21 days. Check the Distribution Dashboard for platform-specific status information.

**Q: Can I select different release dates for different platforms?**  
A: Yes, with Advanced Distribution control, you can set platform-specific release dates. This allows for exclusive windows, staggered releases, or territory-based rollouts. Configure these options in the Platform Settings section during distribution setup.

**Q: How do I get my music on editorial playlists?**  
A: Editorial playlist consideration starts with timely distribution (at least 3-4 weeks before release). Use the Playlist Pitching tool in the Marketing section to create compelling pitches for editorial teams. Complete all metadata thoroughly and include engaging release notes to improve your chances.

### Troubleshooting & Updates

**Q: My release was rejected by a platform. What should I do?**  
A: Check the Distribution Dashboard for specific error details. Most rejections relate to metadata, artwork, or audio quality issues. The error message will indicate the specific problem and required corrections. Make the necessary changes and resubmit through the Resolution Center.

**Q: Can I update my release metadata or artwork after distribution?**  
A: Yes, you can update certain elements after distribution through the Catalog Management section. Metadata updates typically take 1-2 weeks to propagate across all platforms. Artwork changes are possible but may take longer and require redelivery to some platforms.

**Q: How do I remove my music from a specific platform?**  
A: In the Distribution Dashboard, locate the release and select "Manage Availability." You can then select specific platforms for takedown. Takedown requests typically process within 3-7 days, although complete removal may take up to 2-3 weeks on some platforms.

---

## Support Resources

If you need additional assistance with distribution:

- **Knowledge Base**: Visit [help.tunemantra.com/distribution](https://help.tunemantra.com/distribution) for detailed tutorials and guides
- **Video Tutorials**: Access step-by-step video guides in the Learning Center
- **Distribution Support**: Contact our dedicated distribution team at distribution@tunemantra.com
- **Live Chat Support**: Available during business hours for immediate assistance with distribution issues

---

**Document Information:**
- Version: 2.0
- Last Updated: March 25, 2025
- Contact: documentation@tunemantra.com

---

## documentation/user/getting-started.md

# TuneMantra Getting Started Guide

*Version: 1.0.0 (March 27, 2025)*

## Table of Contents

- [Introduction](#introduction)
- [Creating Your Account](#creating-your-account)
- [Setting Up Your Organization](#setting-up-your-organization)
- [Navigating the Platform](#navigating-the-platform)
- [Uploading Your First Release](#uploading-your-first-release)
- [Managing Distribution](#managing-distribution)
- [Tracking Performance](#tracking-performance)
- [Understanding Royalties](#understanding-royalties)
- [Getting Support](#getting-support)
- [Advanced Features](#advanced-features)

## Introduction

Welcome to TuneMantra! This guide will help you get started with our music distribution and rights management platform. TuneMantra provides a comprehensive solution for distributing your music to global streaming platforms, managing rights, tracking performance, and collecting royalties.

### What is TuneMantra?

TuneMantra is a complete music distribution and rights management platform that helps artists, labels, and rights holders:

- Distribute music to 150+ streaming services and digital stores
- Track performance and audience engagement across platforms
- Collect and manage royalties with transparent reporting
- Control rights and ownership information
- Analyze data to inform business decisions

### How This Guide Will Help

This guide will walk you through:

- Setting up your account and organization profile
- Navigating the platform's key features
- Uploading and managing your first release
- Understanding basic analytics and royalty reports
- Finding additional resources and support

## Creating Your Account

### Registration Process

To create your TuneMantra account:

1. Visit [tunemantra.com](https://www.tunemantra.com) and click **Sign Up**
2. Enter your email address and create a password
3. Verify your email by clicking the link sent to your inbox
4. Complete your personal profile with:
   - Full name
   - Contact information
   - Timezone and language preferences

### Account Security

We recommend these security best practices:

1. **Strong Password**: Use a unique, complex password with at least 12 characters
2. **Two-Factor Authentication**: Enable 2FA in your account settings
3. **Recovery Options**: Add a phone number or backup email for account recovery
4. **Regular Verification**: Review your account details periodically

## Setting Up Your Organization

### Organization Types

TuneMantra supports different organization structures:

- **Artist**: Individual musicians or bands
- **Label**: Music labels and distribution companies
- **Publisher**: Music publishing companies
- **Distributor**: Distribution services
- **Management**: Artist management companies

### Creating Your Organization

To set up your organization:

1. Go to **Settings** > **Organization** after logging in
2. Click **Create Organization**
3. Select your organization type
4. Complete the profile with:
   - Organization name
   - Business information
   - Logo and branding elements
   - Contact details
   - Tax information

### Team Management

To add team members to your organization:

1. Navigate to **Settings** > **Team Members**
2. Click **Invite Team Member**
3. Enter their email address
4. Assign appropriate roles and permissions:
   - **Admin**: Full access to all features
   - **Manager**: Access to most features except billing and organization settings
   - **Staff**: Limited access to assigned areas
   - **Finance**: Access to financial reports and royalty information
   - **Artist**: Access to their own content and performance data

## Navigating the Platform

### Dashboard Overview

The TuneMantra dashboard provides a quick overview of:

- Recent releases and their status
- Performance highlights and trends
- Upcoming royalty payments
- Important notifications and alerts
- Quick access to common actions

### Main Navigation Areas

The platform is organized into these main sections:

1. **Catalog**: Manage your music releases, tracks, and assets
2. **Distribution**: Control where and how your music is available
3. **Analytics**: Track performance across platforms
4. **Royalties**: View earnings and payment information
5. **Rights**: Manage ownership and licensing information
6. **Settings**: Configure your account and organization

### User Interface Elements

Key interface components include:

1. **Primary Navigation**: Main sections of the platform (left sidebar)
2. **Secondary Navigation**: Subsections within each main area (top tabs)
3. **Action Bar**: Common actions for the current view (top right)
4. **Content Area**: Main information display (center)
5. **Detail Panel**: Additional information about selected items (right sidebar)
6. **Notification Center**: System alerts and updates (bell icon)
7. **User Menu**: Account and profile options (profile picture)

### Accessibility Features

TuneMantra includes these accessibility features:

- Keyboard navigation support
- Screen reader compatibility
- Adjustable text sizes
- High contrast mode
- Customizable notification preferences

## Uploading Your First Release

### Preparing Your Content

Before uploading, ensure you have:

1. **Audio Files**:
   - High-quality WAV files (16-bit/44.1kHz minimum)
   - Properly named files
   - Consistent volume levels

2. **Artwork**:
   - Square image (3000x3000 pixels recommended)
   - RGB color mode
   - No explicit content or unauthorized brand logos

3. **Metadata**:
   - Release title
   - Track titles and order
   - Artist information
   - Genre and subgenre
   - Release date (at least 10 days in the future)
   - ISRC codes (if available)
   - UPC/EAN code (if available)

4. **Rights Information**:
   - Songwriter/composer details
   - Publishing information
   - Ownership splits (if applicable)

### Upload Process

To upload your release:

1. Go to **Catalog** > **Releases**
2. Click **New Release**
3. Select release type:
   - Single (1-2 tracks)
   - EP (3-6 tracks)
   - Album (7+ tracks)

4. Complete the release information form:
   - Basic information
   - Artist details
   - Release date and availability
   - Territories

5. Upload artwork by dragging and dropping or using the file selector

6. Add tracks:
   - Upload audio files by dragging and dropping or using the file selector
   - Enter track metadata for each song
   - Set track order
   - Add songwriter/composer information

7. Configure rights and revenue splits (if applicable)

8. Review all information for accuracy

9. Click **Submit for Distribution**

### Release Status Tracking

After submission, your release will move through these stages:

1. **Draft**: Initial creation, not yet submitted
2. **Submitted**: Sent for review
3. **In Review**: Being checked by our team
4. **Approved**: Accepted and queued for delivery
5. **Delivered**: Sent to platforms
6. **Live**: Available on streaming services
7. **Rejected**: Returned for corrections (with specific feedback)

Track status in real-time in the **Catalog** > **Releases** section.

## Managing Distribution

### Platform Selection

Control where your music is distributed:

1. Go to **Distribution** > **Platforms**
2. Select from 150+ available services
3. Options include:
   - **Global Streaming**: Spotify, Apple Music, Amazon Music, etc.
   - **Video Platforms**: YouTube Music, TikTok, etc.
   - **Regional Services**: JioSaavn, QQ Music, etc.
   - **Download Stores**: iTunes, Amazon MP3, etc.
   - **Specialized Services**: Beatport, Bandcamp, etc.

4. Configure default selections for new releases

### Territory Management

Control geographic availability:

1. Navigate to **Distribution** > **Territories**
2. Choose from availability options:
   - Worldwide (all territories)
   - Selected regions (continents or groups)
   - Specific countries
   - Exclusion-based (everywhere except selected areas)

3. Set territory-specific release dates if needed

### Release Timing

Schedule and control timing:

1. Set your **Standard Release Schedule** in preferences
   - Default: Friday global release day
   - Custom scheduling available

2. For specific releases, adjust timing in the release editor:
   - Pre-save/pre-add campaigns
   - Pre-order periods
   - Staggered release strategy

### Takedowns and Updates

To modify or remove content:

1. Go to **Catalog** > **Releases**
2. Select the release to modify
3. Choose from:
   - **Update Metadata**: Edit information without removal
   - **Update Audio**: Replace track files (may require redelivery)
   - **Update Artwork**: Replace cover image
   - **Territory Change**: Modify availability regions
   - **Takedown Request**: Remove from all or specific platforms

4. Follow the guided workflow to complete your request

## Tracking Performance

### Analytics Dashboard

The main analytics view provides:

1. Go to **Analytics** > **Overview**
2. View performance summaries:
   - Total streams and downloads
   - Revenue estimates
   - Trend indicators
   - Platform breakdown
   - Geographic distribution

3. Filter by:
   - Time period
   - Release or track
   - Platform
   - Territory

### Streaming Performance

Track detailed streaming data:

1. Navigate to **Analytics** > **Streaming**
2. View metrics including:
   - Stream counts by platform
   - Listener demographics
   - Skip rates
   - Playlist inclusions
   - Growth trends
   - Comparative benchmarks

### Audience Insights

Understand your listeners:

1. Go to **Analytics** > **Audience**
2. Explore demographic information:
   - Age groups
   - Gender distribution
   - Geographic location
   - Listening habits
   - Device usage
   - Discovery methods

### Social Media Performance

Track social engagement:

1. Navigate to **Analytics** > **Social**
2. View metrics from connected platforms:
   - Follower growth
   - Engagement rates
   - Content performance
   - Mention tracking
   - Sentiment analysis

### Custom Reports

Create personalized analytics views:

1. Go to **Analytics** > **Reports**
2. Click **Create Custom Report**
3. Select metrics, dimensions, and filters
4. Save report for future use
5. Set up automated delivery to your email

## Understanding Royalties

### Royalty Dashboard

View your earnings overview:

1. Navigate to **Royalties** > **Dashboard**
2. See summaries of:
   - Current period earnings
   - Historical earnings
   - Upcoming payments
   - Revenue by source
   - Top earning content

### Detailed Statements

Access comprehensive royalty information:

1. Go to **Royalties** > **Statements**
2. Select reporting period
3. View detailed breakdown:
   - Platform-specific earnings
   - Track-level performance
   - Territory distribution
   - Revenue type categories

4. Download statements in multiple formats:
   - PDF for official records
   - Excel for further analysis
   - CSV for data import

### Payment Information

Manage your payment settings:

1. Navigate to **Royalties** > **Payments**
2. Configure payment methods:
   - Bank transfer (ACH/SEPA/Wire)
   - PayPal
   - Other available options

3. View payment history
4. Track pending payments

### Split Management

For content with multiple rights holders:

1. Go to **Rights** > **Splits**
2. Create and manage revenue allocation:
   - Add collaborators by email
   - Set percentage splits
   - Configure split categories (recording, composition)
   - Send agreements for electronic signature

## Getting Support

### Help Center

Access comprehensive support resources:

1. Click the **Help** icon in the navigation menu
2. Browse categorized help articles
3. Search for specific topics
4. View video tutorials and guides

### Support Tickets

Get personalized assistance:

1. Navigate to **Help** > **Support**
2. Click **New Support Request**
3. Select issue category
4. Describe your question or problem
5. Attach screenshots or files if helpful
6. Submit and track your request status

### Live Chat

For immediate help:

1. Click the chat icon in the bottom right corner
2. Connect with our support team during business hours
3. Access AI-assisted support 24/7

### Community Forum

Connect with other users:

1. Go to **Help** > **Community**
2. Browse discussion categories
3. Search for related topics
4. Create new discussions
5. Share experiences and best practices

## Advanced Features

### Release Planning

Use our planning tools:

1. Navigate to **Catalog** > **Planning**
2. Create release calendars
3. Set promotional milestones
4. Coordinate multiple releases
5. Receive timeline recommendations

### Promotional Tools

Enhance your marketing:

1. Go to **Marketing** > **Promotion**
2. Access features like:
   - Pre-save campaigns
   - Release links
   - Social media content creator
   - Email announcement templates
   - QR code generation

### Rights Management

Manage complex ownership scenarios:

1. Navigate to **Rights** > **Management**
2. Register and track:
   - Sound recording rights
   - Composition rights
   - Publishing information
   - Licensing agreements
   - Territory-specific arrangements

### API Integration

For advanced users and organizations:

1. Go to **Settings** > **Developer**
2. Access API documentation
3. Generate API keys
4. Set up webhooks for automated workflows
5. Integrate with your existing systems

---

Congratulations! You're now ready to start using TuneMantra to distribute and manage your music. If you need any additional help, remember that our support team is available to assist you.

For more detailed information about specific features, check out our specialized guides in the Help Center.

---

© 2023-2025 TuneMantra. All rights reserved.

---

## documentation/user/label-guide.md

# Music Label Guide for TuneMantra

<div align="center">
  <img src="../diagrams/label-guide-header.svg" alt="TuneMantra Label Guide" width="800"/>
</div>

## Introduction

Welcome to TuneMantra's comprehensive guide for Music Labels. This document provides detailed instructions, best practices, and tips for maximizing your label's success on the TuneMantra platform. Whether you're an established label or just starting out, this guide will help you navigate the platform's features and optimize your music distribution, rights management, and revenue generation.

## Table of Contents

- [Dashboard Overview](#dashboard-overview)
- [Label Management](#label-management)
- [Artist & Roster Management](#artist--roster-management)
- [Release Management](#release-management)
- [Distribution](#distribution)
- [Rights & Royalty Management](#rights--royalty-management)
- [Analytics & Reporting](#analytics--reporting)
- [Financial Management](#financial-management)
- [Promotion & Marketing](#promotion--marketing)
- [Advanced Features](#advanced-features)
- [Best Practices](#best-practices)
- [FAQ](#frequently-asked-questions)

## Dashboard Overview

The Label Dashboard is your command center for managing all aspects of your label operations on TuneMantra.

<div align="center">
  <img src="../screenshots/label-dashboard.png" alt="Label Dashboard" width="700"/>
</div>

### Key Dashboard Elements

1. **Performance Summary**
   - Quick overview of streams, revenue, and growth metrics
   - Top performing releases and territories
   - Recent distribution activity
   - Pending tasks and approvals

2. **Navigation Menu**
   - Artists & Roster: Manage your roster of artists
   - Releases: Manage your catalog of music
   - Distribution: Control where your music is distributed
   - Rights: Manage ownership and rights information
   - Analytics: View detailed performance metrics
   - Finance: Track revenue and manage payments
   - Settings: Configure your label account

3. **Activity Feed**
   - Real-time updates on releases, distributions, and analytics
   - Important notifications and alerts
   - Recent communications

4. **Quick Actions**
   - Create New Release
   - Add Artist
   - Schedule Distribution
   - Generate Reports
   - Invite Team Members

### Dashboard Customization

You can customize your dashboard layout to focus on the metrics and information most important to your label:

1. Click the **Customize** button in the top-right corner
2. Drag and drop widgets to rearrange them
3. Add or remove widgets from the widget library
4. Configure widget settings and display options
5. Save your custom layout

## Label Management

### Setting Up Your Label Profile

A complete label profile enhances your visibility and credibility on the platform.

1. **Basic Information**
   - Label Name: Your official label name
   - Founded Date: When your label was established
   - Label Logo: Upload a high-resolution label logo (minimum 1000x1000px, PNG format with transparency)
   - Banner Image: Upload a banner image for your label page (1800x400px recommended)
   - Label Bio: Write a compelling description of your label, its history, and musical focus

2. **Contact Information**
   - Official Website URL
   - Social Media Links (Twitter, Instagram, Facebook, YouTube, etc.)
   - Public Contact Email (for artist submissions)
   - Address Information (optional, not publicly displayed)

3. **Legal Information**
   - Company Registration Details
   - Tax Information
   - Copyright Information

### Label Branding

Maintain consistent branding across your label's presence on TuneMantra:

1. **Brand Assets**
   - Upload your brand color palette
   - Define typography guidelines
   - Add additional logos and marks

2. **Artist Pages Customization**
   - Apply label branding to artist pages
   - Customize artist page layouts
   - Set up consistent visual elements

3. **Release Artwork Guidelines**
   - Define templates for release artwork
   - Set up artwork approval workflows
   - Maintain visual consistency

### Team Management

Efficiently manage your label's team with role-based access controls:

1. **Adding Team Members**
   - Navigate to **Settings > Team Management**
   - Click **Add Team Member**
   - Enter email address and select appropriate role
   - Define access permissions

2. **Available Roles**
   | Role | Description | Primary Permissions |
   |------|-------------|---------------------|
   | **Admin** | Full access to all label functions | All permissions |
   | **Manager** | Day-to-day label management | Manage artists, releases, distribution |
   | **A&R** | Artist and repertoire management | Manage artists, releases, content |
   | **Finance** | Financial operations | View/manage royalties, payments, financial reports |
   | **Marketing** | Promotional activities | Access to analytics, promotional tools |
   | **Distribution** | Distribution management | Manage distribution, store delivery |
   | **Analytics** | Performance tracking | View analytics and reports |
   | **Artist** | Limited artist account | Manage own content only |

3. **Custom Roles**
   - Create custom roles with specific permission sets
   - Configure granular permissions for each area of the platform
   - Set up approval workflows for specific actions

## Artist & Roster Management

### Adding Artists to Your Roster

Build and manage your label's artist roster:

1. **Adding a New Artist**
   - Navigate to **Artists > Add New Artist**
   - Enter artist details:
     - Name (official artist name)
     - Bio (compelling artist description)
     - Profile Image (minimum 1000x1000px, PNG format)
     - Banner Image (1800x400px recommended)
     - Social Media Links
     - Apple Music/Spotify Artist Links (if existing)

2. **Artist Onboarding**
   - Send invitation to artist email
   - Configure artist access level
   - Set up artist contract details
   - Define revenue share agreement

3. **Artist Profile Verification**
   - Submit verification request
   - Provide required documentation
   - Track verification status

### Artist Contracts & Agreements

Manage legal relationships with your artists:

1. **Contract Management**
   - Upload contract documents
   - Define key contract terms:
     - Duration/Term
     - Territory
     - Revenue Splits
     - Exclusivity
     - Obligations
   - Set up contract renewal notifications

2. **Revenue Share Configuration**
   - Define base royalty percentages
   - Configure platform-specific splits
   - Set up advanced split arrangements
   - Configure payment schedules

3. **Rights Management**
   - Define ownership rights
   - Set publishing splits
   - Configure master ownership
   - Manage licensing rights

### Artist Communication

Maintain strong relationships with your roster:

1. **Communication Tools**
   - Internal messaging system
   - Comment threads on releases
   - Shared calendars for key dates
   - File sharing for assets

2. **Artist Portal**
   - Customizable artist dashboard
   - Performance metrics visibility
   - Royalty and payment tracking
   - Release status updates

## Release Management

### Creating a New Release

Efficiently prepare and manage music releases:

1. **Initiate a New Release**
   - Navigate to **Releases > Create New Release**
   - Select release type:
     - Single (1-3 tracks)
     - EP (4-6 tracks)
     - Album (7+ tracks)
     - Compilation
     - Remix Package

2. **Basic Release Information**
   - Release Title
   - Primary Artist(s)
   - Featured Artists
   - Release Date
   - Record Label
   - Genre (primary and secondary)
   - Language
   - Parental Advisory (if applicable)

3. **Release Artwork**
   - Upload cover artwork (minimum 3000x3000px, RGB JPG format)
   - Ensure artwork meets all platform requirements:
     - No text except artist name and title
     - No website URLs or social media handles
     - No explicit imagery
     - No third-party logos or unauthorized branding

4. **Track Management**
   <div align="center">
     <img src="../screenshots/track-management.png" alt="Track Management Interface" width="700"/>
   </div>

   - Add tracks to the release
   - For each track, provide:
     - Track Title
     - Track Version (if applicable)
     - Track Number and Volume Number
     - Duration
     - Primary Artist(s)
     - Featured Artist(s)
     - Songwriter(s) / Composer(s)
     - Producer(s)
     - ISRC Code (or request a new one)
     - Audio File (WAV format, 16-bit or higher, 44.1kHz+)
     - Explicit Content Flag

5. **Additional Metadata**
   - Release Copyright Information
     - Year
     - Copyright Holder
   - Recording Copyright Information
     - Year
     - Copyright Holder
   - Original Release Date (for reissues)
   - UPC/EAN Code (or request a new one)
   - Pre-order Date (if applicable)
   - Pre-save Date (if applicable)

6. **Advanced Information**
   - Mood Tags (select up to 5)
   - Theme Tags (select up to 5)
   - Similar Artists (for recommendation algorithms)
   - Credits and Liner Notes
   - Territories to Exclude (if any)
   - Release Notes for DSPs

### Release Approval Workflow

Ensure quality control with structured approval processes:

1. **Internal Review**
   - Audio quality check
   - Metadata accuracy verification
   - Artwork compliance check
   - Rights and splits verification

2. **Approval Chain**
   - Configurable multi-step approval workflow
   - Role-based approval requirements
   - Automated notifications for pending approvals
   - Comment thread for review feedback

3. **Release Revisions**
   - Track changes to release details
   - Version comparison
   - Revision history
   - Approval status tracking

### Release Calendar

Plan and visualize your label's release schedule:

1. **Calendar View**
   - Month, quarter, and year views
   - Color-coded by release type and status
   - Drag-and-drop rescheduling
   - Conflict detection

2. **Release Planning**
   - Strategic date selection tool
   - Competitive release analyzer
   - Optimal release day recommendations
   - Marketing timeline integration

## Distribution

### Distribution Management

Control how and where your music is delivered:

1. **Platform Selection**
   <div align="center">
     <img src="../screenshots/distribution-platforms.png" alt="Distribution Platform Selection" width="700"/>
   </div>

   - Select platforms for distribution:
     - Major streaming services (Spotify, Apple Music, Amazon Music, etc.)
     - Download stores (iTunes, Amazon, etc.)
     - Video platforms (YouTube Music, TikTok, etc.)
     - Regional services (NetEase, Boomplay, etc.)
     - Specialized platforms (Beatport, Traxsource, etc.)

2. **Distribution Timing**
   - Immediate distribution
   - Scheduled future distribution
   - Coordinated global release
   - Phased territory rollout
   - Pre-order/pre-save configuration

3. **Distribution Settings**
   - Platform-specific pricing
   - Territory exclusions
   - Promotional settings
   - Feature opt-ins (Canvas, Storylines, etc.)

### Delivery Management

Track the delivery status of your releases:

1. **Delivery Dashboard**
   - Real-time delivery status
   - Platform-by-platform tracking
   - Error monitoring and alerting
   - Takedown status

2. **Catalog Management**
   - Complete catalog overview
   - Availability by platform and territory
   - Link collection
   - Availability timeline

3. **Content Refresh**
   - Update metadata across platforms
   - Artwork updates
   - Audio replacement (quality upgrades)
   - Credit updates

### Specialized Distribution Options

Optimize distribution for specific scenarios:

1. **DJ Service Distribution**
   - Specialized delivery to DJ platforms
   - Extended mix handling
   - Stem delivery options
   - DJ-friendly metadata

2. **Sampling and Stems**
   - Stem delivery management
   - Sample clearance tracking
   - Remix authorization
   - Licensing controls

3. **Territorial Strategies**
   - Region-specific release strategies
   - Local platform prioritization
   - Language-specific metadata
   - Regional pricing strategies

## Rights & Royalty Management

### Rights Registration

Maintain accurate rights information for your catalog:

1. **Rights Entry**
   - Register track-level rights
     - Composition ownership
     - Recording ownership
     - Publishing information
   - Define ownership percentages
   - Associate rights holders
   - Document rights transfers

2. **Chain of Title Tracking**
   - Document ownership history
   - Upload supporting documentation
   - Track rights transfers
   - Maintain audit trail

3. **Verification Process**
   - Rights conflict detection
   - Ownership verification
   - External database cross-reference
   - Resolution workflow

### Royalty Configuration

Set up how revenue is tracked and distributed:

1. **Royalty Models**
   - Configure label-wide royalty rules
   - Set up artist-specific arrangements
   - Define special royalty scenarios
   - Configure recoupment rules

2. **Split Management**
   <div align="center">
     <img src="../screenshots/royalty-splits.png" alt="Royalty Split Management" width="700"/>
   </div>

   - Track-level revenue splits
   - Role-based split templates
   - Multi-level split hierarchies
   - Split sheet generation and export

3. **Advanced Royalty Rules**
   - Minimum guarantees
   - Escalators and tiers
   - Territory-specific rates
   - Platform-specific adjustments

### Payment Management

Handle royalty calculations and payments:

1. **Statement Generation**
   - Automatic statement creation
   - Configurable statement periods
   - Multi-format exports
   - Detailed transaction view

2. **Payment Processing**
   - Batch payment creation
   - Multiple payment methods
   - Payment verification
   - Transaction history

3. **Tax Management**
   - Tax form collection
   - Withholding calculation
   - Tax reporting
   - International tax compliance

## Analytics & Reporting

### Performance Analytics

Gain insights into your catalog's performance:

1. **Catalog Overview**
   - Streaming performance
   - Revenue trends
   - Catalog growth
   - Market share analysis

2. **Release Performance**
   <div align="center">
     <img src="../screenshots/release-analytics.png" alt="Release Analytics Dashboard" width="700"/>
   </div>

   - Track-by-track analysis
   - Release comparison
   - Performance relative to catalog
   - Release milestone tracking

3. **Artist Performance**
   - Artist growth metrics
   - Audience demographics
   - Platform affinities
   - Comparative analysis

### Advanced Analytics

Leverage data for strategic decision-making:

1. **Market Analysis**
   - Territory performance
   - Platform comparison
   - Genre trends
   - Audience behavior

2. **Predictive Analytics**
   - Performance projections
   - Trend forecasting
   - Audience growth modeling
   - Revenue forecasting

3. **Comparative Benchmarking**
   - Industry benchmarks
   - Genre benchmarks
   - Similar artist comparison
   - Historical performance

### Reporting

Create and distribute actionable reports:

1. **Standard Reports**
   - Monthly label performance
   - Artist performance
   - Release analytics
   - Financial summary

2. **Custom Reports**
   - Report builder interface
   - Visualization options
   - Filtering and segmentation
   - Scheduled report delivery

3. **Data Export Options**
   - Multiple file formats (CSV, Excel, PDF)
   - API access for data integration
   - Automated exports
   - Raw data access

## Financial Management

### Revenue Tracking

Monitor all revenue streams in one place:

1. **Revenue Dashboard**
   - Overall revenue summary
   - Platform-by-platform breakdown
   - Territory analysis
   - Format-based segmentation

2. **Revenue Timeline**
   - Historical performance
   - Seasonal patterns
   - Growth trends
   - Forecasted revenue

3. **Revenue Sources**
   - Streaming revenue
   - Download sales
   - Physical sales
   - Licensing and sync
   - Additional revenue streams

### Payment Management

Handle incoming and outgoing payments:

1. **Label Payments**
   - Payment processing status
   - Platform payment tracking
   - Payment reconciliation
   - Payment discrepancy management

2. **Artist and Rightsholder Payments**
   - Payment scheduling
   - Batch payment processing
   - Payment confirmation
   - Statement generation

3. **Banking Integration**
   - Secure bank connections
   - Currency management
   - Payment methods
   - Transaction history

### Financial Reporting

Generate comprehensive financial reports:

1. **Accounting Reports**
   - Profit and loss statements
   - Revenue by period
   - Territory-based reporting
   - Currency consolidated reports

2. **Tax Documentation**
   - Tax report generation
   - Form preparation
   - Withholding documentation
   - International tax compliance

3. **Audit Support**
   - Transaction history
   - Royalty calculation audit trail
   - Payment documentation
   - Financial record export

## Promotion & Marketing

### Promotional Tools

Leverage platform tools to promote your releases:

1. **Playlist Pitching**
   - Platform-specific pitch creation
   - Pitch deadline management
   - Pitch tracking and results
   - Playlist inclusion monitoring

2. **Pre-Save Campaigns**
   - Multi-platform pre-save setup
   - Custom landing page creation
   - Pre-save analytics
   - Fan data collection

3. **Social Media Integration**
   - Coordinated posting tools
   - Asset management
   - Performance tracking
   - Audience engagement metrics

### Marketing Analytics

Measure the effectiveness of your promotional efforts:

1. **Campaign Tracking**
   - Campaign setup and tagging
   - Performance monitoring
   - Conversion metrics
   - ROI calculation

2. **Audience Insights**
   - Demographic analysis
   - Geographic distribution
   - Platform preferences
   - Engagement patterns

3. **Promotional Impact Analysis**
   - Release performance correlation
   - Stream attribution
   - Comparative campaign analysis
   - Optimization recommendations

### Release Optimization

Fine-tune your release strategy for maximum impact:

1. **Release Timing Tools**
   - Optimal release date analysis
   - Competitive release calendar
   - Platform-specific timing
   - Regional considerations

2. **Metadata Optimization**
   - Search optimization suggestions
   - Genre classification analysis
   - Tag recommendation
   - Platform-specific metadata guidance

3. **Visual Asset Optimization**
   - Artwork performance analysis
   - A/B testing tools
   - Platform-specific visual guidelines
   - Visual trend analysis

## Advanced Features

### Catalog Acquisition Tools

Manage the acquisition and integration of external catalogs:

1. **Catalog Valuation**
   - Performance-based valuation
   - Revenue projection
   - Catalog analysis
   - Comparative benchmarking

2. **Catalog Migration**
   - Rights transfer management
   - Re-delivery coordination
   - Historical data import
   - Split reconfiguration

3. **Catalog Enhancement**
   - Metadata enrichment
   - Asset quality improvement
   - Rights verification and cleanup
   - Performance optimization

### API Integration

Extend platform functionality with API access:

1. **API Access Management**
   - API key generation
   - Permission configuration
   - Usage monitoring
   - Rate limiting

2. **Data Synchronization**
   - External system integration
   - Automated data exchange
   - Webhook configuration
   - Custom data workflows

3. **Custom Applications**
   - Development documentation
   - Sample code and SDKs
   - Testing environment
   - Integration support

### Advanced Rights Management

Implement sophisticated rights handling for complex scenarios:

1. **Multi-Territorial Rights**
   - Territory-specific ownership
   - Regional rights management
   - Conflict detection
   - Harmonized distribution

2. **Time-Based Rights**
   - Rights reversion tracking
   - Scheduled ownership changes
   - Term-limited agreements
   - Historical rights documentation

3. **Sub-Licensing**
   - License management
   - License term tracking
   - Revenue flow configuration
   - License renewal management

## Best Practices

### Distribution Optimization

Maximize the effectiveness of your distributions:

1. **Release Scheduling**
   - Schedule releases for Friday release days (global standard)
   - Plan at least 3-4 weeks in advance for optimal playlist consideration
   - Avoid holiday periods unless strategically planned
   - Consider territory-specific release timing for global artists

2. **Metadata Excellence**
   - Use consistent artist names across all releases
   - Include complete and accurate songwriter/producer credits
   - Apply comprehensive and relevant genre tags
   - Craft compelling, error-free descriptions

3. **Quality Assurance**
   - Submit high-quality WAV files (minimum 16-bit/44.1kHz)
   - Ensure proper mastering for streaming platforms
   - Verify all metadata accuracy before submission
   - Double-check all ownership splits and rights information

### Rights Management Excellence

Ensure proper rights management for legal compliance and accurate royalties:

1. **Documentation Practices**
   - Maintain signed agreements for all releases
   - Document all rights transfers and assignments
   - Store supporting evidence for ownership claims
   - Keep historical rights information accessible

2. **Split Management**
   - Verify all splits total exactly 100%
   - Obtain written confirmation of splits from all parties
   - Document the basis for split calculations
   - Regularly review split assignments for accuracy

3. **Conflict Prevention**
   - Establish clear ownership guidelines upfront
   - Document all creative contribution expectations
   - Address ownership questions before release
   - Implement a formal dispute resolution process

### Financial Management

Maintain strong financial operations for your label:

1. **Revenue Verification**
   - Regularly reconcile platform reports with received payments
   - Audit platform statements for inconsistencies
   - Track and follow up on payment discrepancies
   - Maintain organized financial documentation

2. **Transparent Royalty Processing**
   - Process royalty calculations promptly after revenue receipt
   - Provide detailed statements to all rights holders
   - Document all recoupment applications
   - Maintain accessible calculation audit trails

3. **Tax Compliance**
   - Collect appropriate tax documentation from all payees
   - Apply correct withholding based on territory requirements
   - Maintain accurate financial records for tax reporting
   - Consult with music industry tax professionals regularly

## Frequently Asked Questions

### Distribution

**Q: How far in advance should I schedule my release?**  
A: For optimal playlist consideration and marketing preparation, schedule your release at least 3-4 weeks in advance. For major releases with substantial marketing campaigns, 6-8 weeks is recommended.

**Q: Can I change my release date after scheduling?**  
A: Yes, you can adjust your release date through the Distribution Management interface up until the point of delivery. Keep in mind that last-minute changes may impact playlist considerations and pre-save campaigns.

**Q: How do I track where my release is available?**  
A: The Catalog Management section provides real-time tracking of availability across all platforms. You can view links, streaming status, and delivery confirmations in one centralized dashboard.

### Rights Management

**Q: How do I handle a disputed ownership claim?**  
A: Navigate to the Rights Management section, locate the disputed content, and use the Dispute Resolution workflow. Upload supporting documentation, document the competing claims, and follow the structured resolution process.

**Q: Can I register my catalog with collection societies through TuneMantra?**  
A: Yes, TuneMantra offers direct integration with major collection societies. Navigate to Rights Management > External Registration to configure automated work registration with supported societies.

**Q: How do I transfer rights for an acquired catalog?**  
A: Use the Catalog Acquisition tools under Advanced Features. The system provides a structured workflow for documenting the rights transfer, updating ownership records, and ensuring proper royalty flow.

### Financial Management

**Q: How often are royalty statements generated?**  
A: By default, statements are generated monthly, but you can configure quarterly or custom periods in Financial Settings. Statements are typically available 15-20 days after the close of the period, allowing for platform data consolidation.

**Q: Can I set minimum payment thresholds for artists?**  
A: Yes, navigate to Financial Settings > Payment Rules to configure minimum payment thresholds by artist, payment method, or territory. The system will automatically hold payments until thresholds are reached.

**Q: How are currency conversions handled?**  
A: TuneMantra uses daily exchange rates for all currency conversions. You can configure a preferred currency for reporting and payouts in Financial Settings. The exchange rates used for all conversions are documented in each statement for transparency.

---

## Support Resources

If you need additional assistance with your label operations on TuneMantra:

- **Knowledge Base**: Visit [help.tunemantra.com](https://help.tunemantra.com) for detailed tutorials and guides
- **Video Tutorials**: Access step-by-step video guides in the Learning Center
- **Support Team**: Contact our dedicated label support team at labels@tunemantra.com
- **Training Sessions**: Schedule a personalized training session with our label success team

---

**Document Information:**
- Version: 2.0
- Last Updated: March 25, 2025
- Contact: documentation@tunemantra.com

---

## documentation/user/reporting-guide.md

# Reporting Guide for TuneMantra

<div align="center">
  <img src="../diagrams/reporting-guide-header.svg" alt="TuneMantra Reporting Guide" width="800"/>
</div>

## Introduction

Welcome to TuneMantra's comprehensive Reporting Guide. This document provides detailed instructions on how to generate, customize, and utilize reports within the TuneMantra platform. Powerful reporting capabilities are essential for making data-driven decisions about your music career or business. Whether you're an artist looking for performance insights or a label executive needing detailed financial analysis, this guide will help you leverage TuneMantra's reporting tools to gain valuable insights from your data.

## Table of Contents

- [Reporting Fundamentals](#reporting-fundamentals)
- [Report Dashboard](#report-dashboard)
- [Standard Reports](#standard-reports)
- [Custom Report Builder](#custom-report-builder)
- [Data Visualization](#data-visualization)
- [Report Scheduling](#report-scheduling)
- [Export & Sharing](#export--sharing)
- [Advanced Reporting](#advanced-reporting)
- [Integrations](#integrations)
- [Best Practices](#best-practices)
- [FAQ](#frequently-asked-questions)

## Reporting Fundamentals

### Understanding TuneMantra Reporting

Reports provide structured insights into your music data:

<div align="center">
  <img src="../screenshots/reporting-overview.png" alt="Reporting Overview" width="700"/>
</div>

1. **Report Types**
   - Performance Reports: Track and release performance metrics
   - Financial Reports: Revenue and royalty information
   - Audience Reports: Listener demographics and behavior
   - Distribution Reports: Delivery status and availability
   - Rights Reports: Ownership and rights management status
   - Comparative Reports: Benchmarking and trend analysis
   - Custom Reports: User-defined combinations of data

2. **Data Sources**
   - Streaming platform data
   - Download and sales information
   - Rights and ownership records
   - Royalty and payment data
   - User activity and engagement metrics
   - Demographic and geographic information
   - Historical performance trends

3. **Report Components**
   - Headers and identifying information
   - Time period specifications
   - Filtering parameters
   - Data tables and summaries
   - Visualizations and charts
   - Footnotes and explanations
   - Actions and drill-down options

4. **Report Benefits**
   - Data-driven decision making
   - Performance tracking and optimization
   - Financial planning and forecasting
   - Audience targeting and expansion
   - Catalog management and prioritization
   - Rights compliance and verification
   - Resource allocation optimization

### Reporting Architecture

How TuneMantra's reporting system is structured:

1. **Data Layer**
   - Consolidated data warehouse
   - Real-time and historical data
   - Data normalization and processing
   - Custom metrics and calculations
   - Data quality assurance

2. **Processing Layer**
   - Query execution engine
   - Aggregation and transformation
   - Filtering and segmentation
   - Calculation and formula processing
   - Caching mechanisms

3. **Presentation Layer**
   - Report templates and formats
   - Visualization rendering
   - Interactive components
   - Export formatting
   - Responsive display adaptation

4. **Distribution Layer**
   - Report scheduling
   - Delivery methods
   - Sharing and permissions
   - Notification system
   - Integration endpoints

## Report Dashboard

### Dashboard Overview

Central command center for accessing and managing reports:

<div align="center">
  <img src="../screenshots/report-dashboard.png" alt="Report Dashboard" width="700"/>
</div>

1. **Main Components**
   - Report Library (saved and recent reports)
   - Report Templates (standard report access)
   - Custom Report Builder access
   - Scheduled Reports management
   - Favorite Reports section
   - Report Search functionality

2. **Report Organization**
   - Category-based organization
   - Tag-based filtering
   - Creation date sorting
   - Frequency of use tracking
   - Custom folders and collections
   - Archiving options

3. **Quick Actions**
   - Generate New Report
   - Schedule Delivery
   - Edit Existing Report
   - Duplicate Report
   - Share Report
   - Export Report
   - Delete Report

4. **Dashboard Customization**
   - Layout preferences
   - Default report views
   - Favorites management
   - Widget arrangement
   - Color scheme selection
   - Display density options

### Navigation and Filters

Efficiently find and access reports:

1. **Report Navigation**
   - Hierarchical category navigation
   - Quick access favorites
   - Recent reports list
   - Search functionality
   - Advanced filtering options
   - Breadcrumb navigation

2. **Filter Options**
   - Report type filters
   - Date range selection
   - Data source filtering
   - Owner/creator filtering
   - Status filtering (draft, final, archived)
   - Tag-based filtering

3. **Saved Filters**
   - Create and name filter combinations
   - Apply saved filters with one click
   - Share filters with team members
   - Set default filters for categories
   - Schedule using saved filters
   - Filter management interface

4. **Filter Creation**
   - Simple filter builder
   - Condition-based filtering
   - Multiple filter combination
   - Advanced filter logic (AND/OR operations)
   - Exclusion filtering
   - Filter previewing

## Standard Reports

### Performance Reports

Track the performance of your music across platforms:

<div align="center">
  <img src="../screenshots/performance-report.png" alt="Performance Report Example" width="700"/>
</div>

1. **Catalog Overview Report**
   - Complete catalog performance summary
   - Track and release metrics comparison
   - Trend analysis over time
   - Top performers identification
   - Underperforming content alerts
   - Catalog health indicators

2. **Release Performance Report**
   - Release-specific performance metrics
   - Track-by-track breakdown
   - Platform comparison
   - Release lifecycle analysis
   - Comparative performance vs. previous releases
   - Release goal tracking

3. **Streaming Performance Report**
   - Streaming counts by platform
   - Stream source analysis
   - Playlist performance impact
   - Stream geography breakdown
   - Listener behavior metrics
   - Streaming trend visualization

4. **Listener Engagement Report**
   - Save/add-to-library rates
   - Completion rates
   - Skip analysis
   - Repeat listener percentage
   - Share and social engagement
   - User-generated content metrics

### Financial Reports

Monitor the financial aspects of your music business:

1. **Revenue Summary Report**
   - Overall revenue overview
   - Revenue by source breakdown
   - Time-period comparison
   - Revenue trend analysis
   - Forecast projections
   - Goal attainment tracking

2. **Royalty Statement Report**
   - Detailed royalty calculations
   - Platform-specific royalty breakdown
   - Split payment allocations
   - Withholding and adjustments
   - Payment status tracking
   - Historical comparison

3. **Payment History Report**
   - Complete payment transaction log
   - Payment method analysis
   - Recipient breakdown
   - Payment timeliness metrics
   - Fee and conversion impact
   - Reconciliation status

4. **Financial Forecast Report**
   - Projected earnings based on trends
   - Scenario-based projections
   - Seasonal impact modeling
   - New release impact estimation
   - Cash flow prediction
   - Risk assessment indicators

### Audience Reports

Understand who is listening to your music:

1. **Demographic Analysis Report**
   - Age distribution breakdown
   - Gender analysis
   - Geographic distribution
   - Language preferences
   - Device and platform usage
   - Time-of-day listening patterns

2. **Geographic Performance Report**
   - Country and region breakdown
   - City-level hotspots
   - Territory growth identification
   - Geographic trend analysis
   - Market penetration metrics
   - Territory-specific recommendations

3. **Listener Behavior Report**
   - Listening session analysis
   - Playlist context understanding
   - Skip and repeat patterns
   - Cross-catalog exploration
   - Platform-specific behavior
   - Listener journey mapping

4. **Audience Growth Report**
   - New listener acquisition
   - Listener retention analysis
   - Audience loyalty metrics
   - Super-fan identification
   - Audience expansion opportunities
   - Audience segment performance

### Distribution Reports

Track your music availability across platforms:

1. **Distribution Status Report**
   - Overall distribution coverage
   - Platform-by-platform status
   - Territory availability matrix
   - Distribution timeline tracking
   - Error and issue summary
   - Action items and recommendations

2. **Platform Performance Report**
   - Comparative platform analysis
   - Platform-specific metrics
   - Feature utilization by platform
   - Platform audience characteristics
   - Revenue efficiency by platform
   - Platform growth trends

3. **Distribution Timeline Report**
   - Upcoming release schedule
   - Historical release tracking
   - Timeline visualization
   - Milestone achievement tracking
   - Delay analysis and prevention
   - Strategic timing recommendations

4. **Takedown and Update Report**
   - Content removal tracking
   - Metadata update status
   - Asset replacement monitoring
   - Compliance issue resolution
   - Platform response metrics
   - Historical change log

## Custom Report Builder

### Report Creation

Build custom reports tailored to your specific needs:

<div align="center">
  <img src="../screenshots/custom-report-builder.png" alt="Custom Report Builder" width="700"/>
</div>

1. **Report Definition**
   - Report title and description
   - Category and tag assignment
   - Time period configuration
   - Default filter settings
   - Parameter definition
   - Access permissions

2. **Data Selection**
   - Data source selection
   - Field inclusion/exclusion
   - Metric and dimension selection
   - Calculated field creation
   - Data transformation options
   - Sample data preview

3. **Filtering and Segmentation**
   - Filter condition creation
   - Segment definition
   - Comparison setup
   - Parameter implementation
   - Advanced filtering logic
   - Filter preview and testing

4. **Layout and Structure**
   - Section organization
   - Column arrangement
   - Grouping and sorting
   - Summary and subtotal configuration
   - Conditional formatting
   - Header and footer design

### Advanced Customization

Take your custom reports to the next level:

1. **Calculated Metrics**
   - Formula builder interface
   - Function library access
   - Conditional calculations
   - Aggregation methods
   - Unit and formatting options
   - Calculation validation

2. **Conditional Logic**
   - If-then-else conditions
   - Case statements
   - Threshold-based formatting
   - Exception highlighting
   - Alert condition definition
   - Logic testing and validation

3. **Dynamic Parameters**
   - Parameter definition
   - Default value configuration
   - Parameter input controls
   - Parameter validation rules
   - Cascading parameters
   - Parameter-based filtering

4. **Report Templates**
   - Template creation from existing reports
   - Template library management
   - Template parameter configuration
   - Template customization
   - Template sharing and permissions
   - Version control for templates

### Report Testing and Validation

Ensure your custom reports are accurate and efficient:

1. **Preview and Testing**
   - Live data preview
   - Sample data testing
   - Performance optimization
   - Error checking
   - Mobile device preview
   - User experience evaluation

2. **Data Validation**
   - Cross-reference checking
   - Totals validation
   - Sample verification
   - Edge case testing
   - Historical comparison
   - Manual verification process

3. **Performance Optimization**
   - Query efficiency analysis
   - Index utilization
   - Calculation optimization
   - Cache configuration
   - Load time measurement
   - Resource usage monitoring

4. **User Acceptance Testing**
   - Stakeholder review process
   - Feedback collection
   - Usability assessment
   - Functional requirement verification
   - Final approval workflow
   - Release and documentation

## Data Visualization

### Chart Types

Visualize your data with the appropriate chart types:

<div align="center">
  <img src="../screenshots/data-visualization-options.png" alt="Data Visualization Options" width="700"/>
</div>

1. **Time Series Visualizations**
   - Line charts for trends
   - Area charts for cumulative values
   - Candlestick charts for ranges
   - Timeline charts for events
   - Combo charts for multiple metrics
   - Animated time series

2. **Comparison Visualizations**
   - Bar charts (vertical and horizontal)
   - Column charts for category comparison
   - Stacked bars for part-to-whole
   - Grouped bars for multi-variable
   - Bullet charts for target comparison
   - Waterfall charts for sequential impact

3. **Distribution Visualizations**
   - Pie and donut charts for composition
   - Treemaps for hierarchical data
   - Heat maps for matrix data
   - Scatter plots for correlation
   - Bubble charts for three variables
   - Histogram for frequency distribution

4. **Geographic Visualizations**
   - Maps with color-coding
   - Bubble maps for quantity
   - Heat maps for intensity
   - Flow maps for movement
   - Choropleth maps for regional comparison
   - Custom territory mapping

### Visualization Customization

Tailor visualizations to communicate effectively:

1. **Design Elements**
   - Color scheme selection
   - Font and typography options
   - Size and proportion adjustment
   - Grid and axis configuration
   - Legend positioning and format
   - Chart title and label customization

2. **Interactive Features**
   - Hover tooltips
   - Click-through actions
   - Drill-down capabilities
   - Filtering interactions
   - Zoom and pan options
   - Selection and highlighting

3. **Advanced Visualization**
   - Multi-chart dashboards
   - Coordinated views
   - Small multiples
   - Animation and transitions
   - Annotation layers
   - Custom visual elements

4. **Mobile Optimization**
   - Responsive design
   - Touch-friendly interactions
   - Simplified views for small screens
   - Portrait/landscape adaptations
   - Performance optimization
   - Offline viewing options

### Data Storytelling

Use visualizations to tell compelling stories with your data:

1. **Narrative Structures**
   - Sequential revelation
   - Comparison and contrast
   - Cause and effect relationships
   - Problem-solution framework
   - What-if scenarios
   - Trend to insight flow

2. **Annotation and Context**
   - Explanatory text elements
   - Highlight critical points
   - Trend line annotations
   - Reference lines and regions
   - Historical context markers
   - Predictive elements

3. **Guided Analysis**
   - Guided walkthrough sequences
   - Progressive disclosure
   - Focus attention techniques
   - Interactive storytelling
   - Narrative bookmarks
   - Presentation mode

4. **Conclusion and Call to Action**
   - Insight summary
   - Recommendation highlighting
   - Next steps guidance
   - Decision support elements
   - Action item generation
   - Follow-up tracking

## Report Scheduling

### Schedule Configuration

Automate report generation and delivery:

<div align="center">
  <img src="../screenshots/report-scheduling.png" alt="Report Scheduling Interface" width="700"/>
</div>

1. **Scheduling Options**
   - One-time delivery
   - Recurring schedules (daily, weekly, monthly)
   - Custom schedule creation
   - Event-based triggers
   - Conditional scheduling
   - Time zone configuration

2. **Report Parameters**
   - Dynamic date ranges
   - Relative time periods
   - Parameter value selection
   - Multiple parameter versions
   - Parameter sequencing
   - Default override options

3. **Delivery Configuration**
   - Recipient management
   - Delivery method selection
   - Format specification
   - Custom delivery message
   - Attachment options
   - Delivery priority setting

4. **Schedule Management**
   - Schedule calendar view
   - Schedule conflict detection
   - Pause and resume capabilities
   - Schedule modification
   - History and audit trail
   - Error handling and notifications

### Delivery Methods

Choose how your reports are distributed:

1. **Email Delivery**
   - HTML email formatting
   - PDF attachment options
   - Embedded visualization
   - Recipient group management
   - Email template customization
   - Delivery confirmation

2. **Portal Access**
   - Secure portal publishing
   - Access control configuration
   - Notification of availability
   - Interactive report access
   - Version history
   - Comment and collaboration features

3. **File Export**
   - Network location delivery
   - Cloud storage integration
   - FTP/SFTP delivery
   - File naming conventions
   - Folder organization
   - Archiving policies

4. **Integration Delivery**
   - API-based delivery
   - Webhook notifications
   - Third-party system integration
   - Database writing
   - Data feed generation
   - Composite delivery workflows

### Alert Configuration

Set up notifications based on report results:

1. **Alert Conditions**
   - Threshold-based alerts
   - Trend-based triggers
   - Anomaly detection
   - Goal achievement notification
   - Comparative alerts
   - Complex condition builders

2. **Alert Actions**
   - Email notifications
   - SMS alerts
   - In-app notifications
   - Workflow triggers
   - External system notifications
   - Escalation sequences

3. **Alert Management**
   - Alert history tracking
   - Snooze functionality
   - Alert grouping and consolidation
   - Priority management
   - Resolution tracking
   - Effectiveness analysis

4. **Alert Customization**
   - Message template creation
   - Alert categorization
   - Severity levels
   - Visual indicators
   - Supporting data inclusion
   - Action recommendation inclusion

## Export & Sharing

### Export Options

Extract report data in various formats:

<div align="center">
  <img src="../screenshots/export-options.png" alt="Export Options Interface" width="700"/>
</div>

1. **File Formats**
   - PDF (presentation quality)
   - Excel (analytical functionality)
   - CSV (raw data access)
   - JSON (programmatic use)
   - HTML (web viewing)
   - PowerPoint (presentation slides)

2. **Export Customization**
   - Page setup and orientation
   - Header and footer configuration
   - Branding elements inclusion
   - Chart quality settings
   - Data range selection
   - Filtered vs. complete export

3. **Batch Export**
   - Multiple report export
   - Combined report packages
   - Report set definitions
   - Scheduled batch exports
   - Package organization
   - Delivery options

4. **Export Security**
   - Password protection
   - Data masking options
   - Permission-based field exclusion
   - Watermarking
   - Expiration configuration
   - Access tracking

### Report Sharing

Share reports with team members and stakeholders:

1. **Sharing Controls**
   - Recipient selection
   - Permission level assignment
   - View vs. edit access
   - Time-limited sharing
   - Password protection
   - Revocation capabilities

2. **Collaboration Features**
   - Commenting functionality
   - Shared annotations
   - Edit suggestions
   - Version comparison
   - Approval workflows
   - Activity tracking

3. **External Sharing**
   - Public link generation
   - Embedded report options
   - Client portal integration
   - Access tracking
   - Anonymous vs. authenticated access
   - External user management

4. **Team Workspaces**
   - Shared report libraries
   - Team dashboards
   - Collaborative filtering
   - Role-based visibility
   - Notification configuration
   - Activity feed and updates

### Embedding Reports

Integrate reports into other applications and sites:

1. **Embedding Methods**
   - iFrame integration
   - JavaScript embedding
   - API-based rendering
   - Single sign-on integration
   - White-labeled embedding
   - Mobile app integration

2. **Interactive Options**
   - Filter pass-through
   - Parameter input
   - Drill-down preservation
   - Action binding
   - Context-sensitive display
   - Responsive sizing

3. **Embedded Security**
   - Domain restrictions
   - Token-based authentication
   - Session management
   - Data access controls
   - Feature restrictions
   - Usage monitoring

4. **Integration Scenarios**
   - Website integration
   - Portal embedding
   - Application integration
   - Mobile app embedding
   - Kiosk mode display
   - Digital signage implementation

## Advanced Reporting

### Cross-Source Analysis

Combine data from multiple sources for comprehensive insights:

<div align="center">
  <img src="../screenshots/cross-source-analysis.png" alt="Cross-Source Analysis" width="700"/>
</div>

1. **Data Source Integration**
   - Multiple platform consolidation
   - External data source connection
   - Data mapping and reconciliation
   - Common key identification
   - Refresh synchronization
   - Metadata alignment

2. **Joined Analysis**
   - Relationship definition
   - Join type selection
   - Multi-point connections
   - Dimension conformity
   - Metric normalization
   - Composite key management

3. **Unified Metrics**
   - Cross-source calculation creation
   - Normalization techniques
   - Common denominator establishment
   - Conversion factor application
   - Aggregation consistency
   - Unified dimension hierarchy

4. **Cross-Source Visualization**
   - Side-by-side comparison
   - Blended visualization
   - Source identification
   - Quality indicators
   - Synchronized filtering
   - Source-specific formatting

### Predictive Reporting

Use historical data to forecast future performance:

1. **Trend Analysis**
   - Historical pattern identification
   - Seasonality detection
   - Growth rate calculation
   - Trend line projection
   - Confidence interval display
   - Anomaly identification

2. **Forecasting Models**
   - Linear projection
   - Exponential smoothing
   - Moving average models
   - ARIMA modeling
   - Machine learning prediction
   - Multi-factor forecasting

3. **Scenario Modeling**
   - What-if analysis tools
   - Parameter adjustment
   - Multiple scenario comparison
   - Best/worst case projections
   - Sensitivity analysis
   - Impact visualization

4. **Predictive Insights**
   - Opportunity identification
   - Risk assessment
   - Resource allocation guidance
   - Strategic recommendation
   - Optimization suggestion
   - Leading indicator tracking

### Advanced Filtering

Implement sophisticated data filtering techniques:

1. **Complex Filter Logic**
   - Multi-condition filters
   - Nested condition groups
   - Boolean operators (AND, OR, NOT)
   - Parameter-driven filters
   - Exclusion filtering
   - Regular expression matching

2. **Dynamic Filtering**
   - User input controls
   - Session-based filtering
   - Context-aware filters
   - Relative date ranges
   - Cascading filter dependencies
   - Filter state persistence

3. **Advanced Selection Methods**
   - Top/bottom N filtering
   - Percentage-based selection
   - Statistical outlier isolation
   - Pattern-based filtering
   - Comparative filtering
   - Relative performance filtering

4. **Filter Management**
   - Filter library creation
   - Filter template sharing
   - Filter impact analysis
   - Filter documentation
   - Filter dependency tracking
   - Filter optimization

## Integrations

### External Systems

Connect TuneMantra reporting with other tools and platforms:

<div align="center">
  <img src="../screenshots/report-integrations.png" alt="Reporting System Integrations" width="700"/>
</div>

1. **Business Intelligence Tools**
   - Tableau integration
   - Power BI connection
   - Google Data Studio linking
   - Looker integration
   - Domo connection
   - Custom BI tool APIs

2. **Financial Systems**
   - Accounting software integration
   - ERP system connection
   - Payment processor linking
   - Tax preparation software
   - Financial planning tools
   - Banking system integration

3. **CRM Integration**
   - Salesforce connection
   - HubSpot integration
   - Custom CRM linking
   - Contact enrichment
   - Activity synchronization
   - Opportunity tracking

4. **Productivity Tools**
   - Microsoft Office integration
   - Google Workspace connection
   - Project management tools
   - Team collaboration platforms
   - Email system integration
   - Calendar synchronization

### API Access

Access reporting functionality programmatically:

1. **API Capabilities**
   - Report generation
   - Data extraction
   - Parameter setting
   - Scheduling control
   - Delivery management
   - User administration

2. **Authentication and Security**
   - API key management
   - OAuth implementation
   - Permission scoping
   - Rate limiting
   - Request logging
   - Security best practices

3. **Implementation Examples**
   - Custom application integration
   - Automated workflows
   - Mobile app connection
   - Third-party tool linking
   - Custom dashboards
   - Embedded analytics

4. **Developer Resources**
   - API documentation
   - SDK availability
   - Code examples
   - Testing environment
   - Version control
   - Support channels

### Data Export Options

Extract raw data for external analysis:

1. **Bulk Data Export**
   - Complete dataset extraction
   - Incremental data export
   - Historical data archiving
   - Structured data formats
   - Compression options
   - Metadata inclusion

2. **Scheduled Data Feeds**
   - Automated data delivery
   - Format specification
   - Destination configuration
   - Frequency setting
   - Notification options
   - Error handling

3. **Real-Time Data Access**
   - Streaming data API
   - Webhook implementation
   - Event-based triggers
   - Data sampling options
   - Latency management
   - Volume control

4. **Custom Data Pipelines**
   - ETL process integration
   - Data warehouse connection
   - Data lake feeding
   - Transformation specification
   - Pipeline monitoring
   - Error recovery

## Best Practices

### Report Design

Create effective, user-friendly reports:

1. **Design Principles**
   - Focus on key insights
   - Progressive disclosure approach
   - Consistent layout and formatting
   - Clear visual hierarchy
   - Intuitive navigation
   - Appropriate level of detail

2. **Visual Best Practices**
   - Purposeful use of color
   - Minimizing chart junk
   - Proper axis scaling
   - Clear labeling
   - Accessibility considerations
   - Print-friendly options

3. **Performance Considerations**
   - Data volume management
   - Calculation efficiency
   - Filter optimization
   - Caching implementation
   - Load time optimization
   - Mobile performance tuning

4. **User Experience**
   - Audience-appropriate complexity
   - Consistent terminology
   - Helpful documentation
   - Intuitive interactions
   - Error prevention
   - Feedback mechanisms

### Data Interpretation

Extract meaningful insights from your reports:

1. **Analysis Approaches**
   - Comparative analysis techniques
   - Trend identification methods
   - Correlation discovery
   - Anomaly investigation
   - Root cause analysis
   - Opportunity identification

2. **Common Pitfalls**
   - Correlation vs. causation confusion
   - Selection bias awareness
   - Time period sensitivity
   - Seasonality adjustment
   - Small sample size caution
   - Outlier influence consideration

3. **Context Consideration**
   - Industry benchmarking
   - Historical performance context
   - External factor awareness
   - Competitive landscape
   - Market condition correlation
   - Strategic alignment

4. **Action Orientation**
   - Insight to action translation
   - Priority determination
   - Resource allocation guidance
   - Risk assessment incorporation
   - Opportunity sizing
   - Implementation planning

### Report Management

Maintain an effective reporting ecosystem:

1. **Report Governance**
   - Report inventory management
   - Ownership and stewardship
   - Standardization policies
   - Quality assurance processes
   - Retirement procedures
   - Documentation requirements

2. **Report Lifecycle**
   - Development workflow
   - Testing and validation
   - Release management
   - Maintenance scheduling
   - Performance monitoring
   - Version control

3. **User Adoption**
   - Training program development
   - Self-service enablement
   - Support resource creation
   - User feedback collection
   - Usage monitoring
   - Continuous improvement

4. **Report Optimization**
   - Usage analysis
   - Value assessment
   - Consolidation opportunities
   - Enhancement prioritization
   - Performance tuning
   - User satisfaction measurement

## Frequently Asked Questions

### General Reporting Questions

**Q: How do I determine which report type is best for my specific needs?**  
A: Consider the following factors when choosing a report type:
1. Purpose: What decisions or actions will this report inform?
2. Audience: Who will consume this information and what is their analytical skill level?
3. Timeframe: Do you need point-in-time data or trends over time?
4. Comparison: Are you comparing performance across dimensions?
5. Detail Level: Do you need summary metrics or detailed transaction data?

Our Report Selection Wizard (available in the Report Dashboard) can guide you through these considerations and recommend the most appropriate report type. You can also schedule a consultation with our reporting specialists for personalized guidance.

**Q: How frequently is the data in reports updated?**  
A: Data refresh schedules vary by data source:
- Streaming data: Updated daily with 24-48 hour lag from platforms
- Financial data: Updated as statements are processed (typically monthly)
- Audience data: Refreshed weekly for most platforms
- Rights data: Updated in real-time as changes occur
- Custom metrics: Calculated during report generation

You can view the data freshness for any report in the report header, which displays the last data update timestamp. For critical time-sensitive analysis, you can trigger a manual data refresh from the report actions menu.

**Q: Can I combine data from multiple sources in a single report?**  
A: Yes, TuneMantra offers several methods for multi-source reporting:
1. The Custom Report Builder allows joining data across compatible sources
2. Cross-source templates are available for common multi-source needs
3. Data Blend functionality lets you combine results from separate queries
4. The Data Integration layer pre-combines certain compatible data sources

When building cross-source reports, pay attention to the "Relationship" panel to ensure proper data mapping between sources. Our Cross-Source Analysis Guide provides detailed instructions for complex multi-source reporting needs.

### Technical Questions

**Q: What are the export limits for reports?**  
A: Export limits vary by format and subscription level:
- PDF exports: Up to 500 pages per report
- Excel exports: Up to 1 million rows
- CSV exports: Up to 5 million rows
- Scheduled exports: Up to 20 reports per schedule
- API data extraction: Rate limits based on your subscription tier

For extremely large data extracts, we recommend using the Data Export API with pagination, or scheduling segmented reports. Enterprise users can request temporary limit increases for special reporting needs by contacting support.

**Q: How can I automate the distribution of reports to my team?**  
A: TuneMantra offers comprehensive report automation options:
1. Email Scheduling: Configure reports to be delivered via email on a recurring schedule
2. Shared Folders: Set up auto-updating reports in team workspaces
3. API Integration: Use our reporting API to pull reports into other systems
4. Webhook Triggers: Configure event-based report generation
5. Portal Subscriptions: Let team members subscribe to report updates

The most popular approach is to use the Schedule Manager (Reports > Schedules) to create a delivery schedule, select recipients, and configure delivery options including format preferences and message customization.

**Q: How do I troubleshoot a slow-running report?**  
A: If you encounter performance issues, try these troubleshooting steps:
1. Check data volume: Reports with large date ranges or high granularity will be slower
2. Examine filters: Add filters to reduce the dataset being processed
3. Review calculations: Complex calculated fields can impact performance
4. Consider aggregation: Pre-aggregate data when detailed records aren't necessary
5. Check visualizations: Some visualization types are more resource-intensive
6. Inspect parameters: Certain parameter selections may expand the data scope

For persistent performance issues, the Performance Analyzer tool (available in the report editor) can identify specific bottlenecks. The system will also provide optimization suggestions for improving report efficiency.

### Report Design

**Q: What's the best way to visualize trend data over time?**  
A: For time-based trend visualization, consider these options:
1. Line charts: Best for continuous data showing precise changes over time
2. Area charts: Effective for showing cumulative values or part-to-whole changes
3. Column charts: Good for discrete time periods with precise value comparison
4. Candlestick charts: Ideal for showing range data (high/low/open/close)
5. Heatmaps: Excellent for showing intensity patterns across time and categories

For most music industry metrics, line charts with appropriate annotation are the most effective. When comparing multiple trends, limit to 3-5 lines with distinct colors and include a clear legend. Use interactive tooltips to provide precise values at specific points in time.

**Q: How can I create reports that are optimized for both desktop and mobile viewing?**  
A: To create truly responsive reports:
1. Use the "Responsive Design" toggle in the report builder
2. Select mobile-friendly visualizations (simpler charts work better)
3. Configure "Mobile Layout" separately from desktop layout
4. Use "Progressive Disclosure" to hide details until requested
5. Test your report using the Mobile Preview function
6. Set up alternative views for different device types

The "Mobile First" templates in the template gallery are specifically designed with responsive principles in mind. For critical mobile reports, consider creating a dedicated mobile version rather than adapting a desktop report.

**Q: What's the best approach for comparing performance across different time periods?**  
A: Effective period-over-period comparison can be achieved several ways:
1. Dual-axis time charts: Plot current and previous period on the same timeline
2. Percent change calculation: Create calculated fields showing relative change
3. Small multiples: Display multiple time periods as separate mini-charts
4. Normalized comparison: Index values to a common starting point (100%)
5. Moving averages: Smooth out fluctuations to highlight true trends

The Period Comparison template provides a pre-built framework for this analysis. For seasonal businesses, year-over-year comparison often provides the most meaningful insights rather than sequential period comparison.

---

## Support Resources

If you need additional assistance with reporting:

- **Knowledge Base**: Visit [help.tunemantra.com/reporting](https://help.tunemantra.com/reporting) for detailed tutorials
- **Video Guides**: Access step-by-step video guides in the Reporting Learning Center
- **Report Library**: Explore sample reports in the Template Gallery for inspiration
- **Data Dictionary**: Reference the comprehensive field descriptions in the Data Dictionary
- **Community Forums**: Connect with other users to share report designs and tips

---

**Document Information:**
- Version: 2.0
- Last Updated: March 25, 2025
- Contact: documentation@tunemantra.com

---

## documentation/user/rights-management-guide.md

# Rights Management Guide for TuneMantra

<div align="center">
  <img src="../diagrams/rights-guide-header.svg" alt="TuneMantra Rights Management Guide" width="800"/>
</div>

## Introduction

Welcome to TuneMantra's comprehensive Rights Management Guide. This document provides detailed instructions, workflows, and best practices for managing music rights and ownership within the TuneMantra platform. Understanding and properly managing rights is critical to music business success, ensuring you receive appropriate credit and compensation for your work while avoiding legal complications. This guide will help artists, labels, publishers, and rights holders effectively manage their intellectual property.

## Table of Contents

- [Rights Management Fundamentals](#rights-management-fundamentals)
- [Rights Dashboard](#rights-dashboard)
- [Ownership Documentation](#ownership-documentation)
- [Split Management](#split-management)
- [Rights Registration](#rights-registration)
- [Conflict Resolution](#conflict-resolution)
- [Publishing Administration](#publishing-administration)
- [Advanced Rights Management](#advanced-rights-management)
- [Legal Protection](#legal-protection)
- [Best Practices](#best-practices)
- [FAQ](#frequently-asked-questions)

## Rights Management Fundamentals

### Understanding Music Rights

Music rights are complex with multiple layers of copyright and ownership:

<div align="center">
  <img src="../screenshots/rights-overview.png" alt="Rights Overview" width="700"/>
</div>

1. **Copyright Basics**
   - Sound Recording Copyright (Master Rights)
   - Musical Composition Copyright (Publishing Rights)
   - Copyright duration and jurisdiction variations
   - Rights transfer and licensing principles

2. **Types of Rights**
   - Mechanical Rights: Reproduction of music in physical/digital formats
   - Performance Rights: Public performance/broadcast of music
   - Synchronization Rights: Use of music in video/film
   - Print Rights: Sheet music and lyric reproduction
   - Digital Rights: Streaming, downloads, and interactive usage

3. **Rights Holders**
   - Songwriters and Composers
   - Performers and Recording Artists
   - Music Publishers
   - Record Labels
   - Administrators and Distributors

4. **Rights Flow**
   - Creation to registration process
   - Exploitation chain
   - Revenue collection pathways
   - Rights reversion conditions

### Rights Management in TuneMantra

How TuneMantra's rights management system helps track and monetize your rights:

1. **Platform Capabilities**
   - Centralized rights documentation
   - Split tracking and management
   - Registration with collection societies
   - Conflict detection and resolution
   - Rights-based revenue allocation

2. **Integration with Distribution**
   - Rights metadata delivery to platforms
   - Ownership verification for distribution
   - Territory-specific rights management
   - Platform-specific rights handling

3. **Rights Protection**
   - Unauthorized use monitoring
   - Fingerprinting and content identification
   - Takedown request management
   - Dispute resolution processes

4. **Analytics Integration**
   - Rights-based performance tracking
   - Rights-based revenue analytics
   - Ownership share performance metrics
   - Collection efficiency monitoring

## Rights Dashboard

### Dashboard Overview

Central command center for managing your rights portfolio:

<div align="center">
  <img src="../screenshots/rights-dashboard.png" alt="Rights Dashboard" width="700"/>
</div>

1. **Main Components**
   - Rights Portfolio Summary
   - Ownership Status Indicators
   - Registration Status Tracking
   - Rights Alerts and Notifications
   - Action Items Queue

2. **Quick Views**
   - My Owned Works
   - Works Pending Registration
   - Split Agreements Requiring Action
   - Royalty Status by Work
   - Rights Conflicts

3. **Rights Calendar**
   - Registration Deadlines
   - Renewal Dates
   - Contract Term Milestones
   - Rights Reversion Dates
   - Action Item Due Dates

4. **Performance Metrics**
   - Registration Completion Rate
   - Rights Documentation Completeness
   - Collection Society Coverage
   - Rights Conflict Resolution Rate

### Navigation and Customization

Efficiently access rights management features:

1. **Rights Navigation**
   - Catalog-based navigation
   - Project-based organization
   - Collaborator grouping
   - Status-based filtering

2. **Dashboard Customization**
   - Widget arrangement
   - Metric selection
   - Alert threshold configuration
   - Custom views creation

3. **Right-Click Actions**
   - Quick actions menu
   - Bulk operations
   - Context-specific tools
   - Shortcut access

## Ownership Documentation

### Documentation Center

Maintain comprehensive evidence of ownership rights:

<div align="center">
  <img src="../screenshots/rights-documentation.png" alt="Rights Documentation Center" width="700"/>
</div>

1. **Document Types**
   - Copyright Registrations
   - Split Agreements
   - Songwriter Contracts
   - Producer Agreements
   - Collaboration Contracts
   - Sample Clearances
   - License Documentation

2. **Document Management**
   - Document Upload and Organization
   - Version Control
   - Document Templates
   - Optical Character Recognition (OCR)
   - Electronic Signature Integration

3. **Chain of Title**
   - Documentation Timeline
   - Rights Transfer History
   - Ownership Audit Trail
   - Historical Rights Documentation

4. **Rights Validation**
   - Document Verification Process
   - Completeness Checking
   - Conflicting Claims Detection
   - Documentation Gap Identification

### Work Registration

Register and document your creative works:

1. **Basic Work Information**
   - Title and Alternative Titles
   - Creation Date
   - First Publication Date
   - Work Type and Category
   - Language and Translations

2. **Composition Details**
   - Genre and Style
   - Tempo and Key
   - Duration
   - Arrangement Details
   - Derivative Work Information

3. **Recording Details**
   - Recording Date and Location
   - Producer Information
   - Studio Credits
   - Master Owner
   - Original/Derivative Status

4. **Identifier Registration**
   - ISWC (International Standard Musical Work Code)
   - ISRC (International Standard Recording Code)
   - IPI (Interested Parties Information)
   - IPN (International Performer Number)
   - Custom Work IDs

### Collaboration Documentation

Track and formalize creative partnerships:

1. **Collaborator Management**
   - Collaborator Database
   - Role Assignment
   - Contact Information
   - Society Affiliations
   - Split History

2. **Collaboration Agreements**
   - Agreement Templates
   - Custom Agreement Creation
   - Agreement Negotiation
   - Electronic Signature Process
   - Agreement Storage

3. **Collaboration Workflow**
   - Invitation System
   - Role Definition
   - Contribution Tracking
   - Approval Process
   - Finalization Protocol

4. **Collaboration Analytics**
   - Collaboration History
   - Partnership Performance
   - Split Evolution Over Time
   - Collaborator Network Visualization

## Split Management

### Split Definition

Configure revenue sharing for your works:

<div align="center">
  <img src="../screenshots/split-management.png" alt="Split Management Interface" width="700"/>
</div>

1. **Split Types**
   - Writer's Share (Publishing)
   - Publisher's Share (Publishing)
   - Master Recording Ownership
   - Producer Points
   - Performance Royalties
   - Mechanical Royalties

2. **Split Entry Interface**
   - Percentage Allocation
   - Role-Based Splits
   - Territory-Specific Splits
   - Split Templates
   - Visual Split Editor

3. **Special Split Arrangements**
   - Advance Recoupment Rules
   - Escalating Percentage Splits
   - Time-Based Split Changes
   - Minimum Guarantee Provisions
   - Administrative Fee Handling

4. **Split Validation**
   - Total Percentage Verification
   - Conflict Detection
   - Gap Identification
   - Approval Status Tracking
   - Historical Comparison

### Split Sheets

Create and manage formal split documentation:

1. **Split Sheet Creation**
   - New Split Sheet Generation
   - Template Selection
   - Manual Entry Options
   - Bulk Creation Tools
   - Import from External Sources

2. **Split Sheet Components**
   - Work Identification
   - Party Information
   - Role Designation
   - Percentage Allocation
   - Payment Information
   - Terms and Conditions
   - Signature Fields

3. **Approval Process**
   - Invitation to Collaborators
   - Review and Comment
   - Change Request Handling
   - Electronic Signature
   - Finalization and Locking

4. **Split Sheet Management**
   - Version Control
   - History Tracking
   - Document Storage
   - Export Options
   - Distribution to Parties

### Split Templates

Streamline split creation for repeated collaborations:

1. **Template Management**
   - Template Creation
   - Team Templates
   - Project Templates
   - Role-Based Templates
   - Template Library

2. **Template Application**
   - Quick Apply to New Works
   - Bulk Application
   - Template Modification
   - Adjustment for Specific Works
   - Template Version Control

3. **Advanced Template Features**
   - Conditional Rules
   - Variable Participant Structure
   - Role-Based Automation
   - Project-Specific Adaptation
   - Default Overrides

4. **Template Sharing**
   - Team Template Sharing
   - Template Export/Import
   - Collaboration on Templates
   - Template Recommendations
   - Industry Standard Templates

## Rights Registration

### Collection Society Registration

Register works with performing rights organizations and collection societies:

<div align="center">
  <img src="../screenshots/society-registration.png" alt="Collection Society Registration" width="700"/>
</div>

1. **Society Connections**
   - ASCAP, BMI, SESAC (US)
   - PRS, PPL (UK)
   - SOCAN (Canada)
   - GEMA (Germany)
   - SACEM (France)
   - APRA AMCOS (Australia/NZ)
   - And 100+ global societies

2. **Registration Process**
   - Society Account Linking
   - Work Information Preparation
   - Registration Submission
   - Status Tracking
   - Registration Confirmation

3. **Bulk Registration**
   - Catalog Registration
   - Registration Batch Processing
   - Template-Based Registration
   - Error Handling and Correction
   - Submission Scheduling

4. **Registration Verification**
   - Confirmation Tracking
   - Work Status Monitoring
   - Database Lookup
   - Discrepancy Resolution
   - Registration Audit

### Publishing Administration

Connect with and manage publishing administrators:

1. **Administrator Connections**
   - Administrator Setup
   - Contract Configuration
   - Term Management
   - Territory Assignment
   - Communication Channel

2. **Work Delivery**
   - Administrator-Specific Formats
   - Metadata Requirements
   - Asset Delivery
   - Schedule Management
   - Delivery Confirmation

3. **Administration Tracking**
   - Registration Status
   - Royalty Collection Tracking
   - Statement Reconciliation
   - Issue Resolution
   - Performance Metrics

4. **Administrator Comparison**
   - Service Comparison Tools
   - Performance Analytics
   - Territory Coverage Analysis
   - Collection Efficiency Metrics
   - Contract Term Evaluation

### Copyright Registration

Direct copyright registration with government offices:

1. **Copyright Office Connections**
   - US Copyright Office
   - UK Intellectual Property Office
   - Canadian Intellectual Property Office
   - Other National Copyright Offices

2. **Registration Preparation**
   - Form Selection
   - Work Classification
   - Claimant Information
   - Deposit Material Preparation
   - Fee Calculation

3. **Submission Process**
   - Electronic Filing
   - Document Upload
   - Payment Processing
   - Confirmation Receipt
   - Registration Tracking

4. **Registration Management**
   - Status Monitoring
   - Certificate Storage
   - Amendment Handling
   - Renewal Management
   - Supplementary Registration

## Conflict Resolution

### Conflict Detection

Identify and address rights ownership conflicts:

<div align="center">
  <img src="../screenshots/conflict-detection.png" alt="Conflict Detection Interface" width="700"/>
</div>

1. **Conflict Types**
   - Split Total Discrepancies
   - Overlapping Ownership Claims
   - Contradictory Registration Data
   - Chain of Title Gaps
   - Registration Mismatches

2. **Automated Detection**
   - System Validation Checks
   - Registration Data Comparison
   - Split Agreement Analysis
   - External Database Cross-Reference
   - Ongoing Monitoring

3. **Conflict Notification**
   - Alert Prioritization
   - Stakeholder Notification
   - Documentation Requests
   - Resolution Timeframes
   - Escalation Protocols

4. **Conflict Documentation**
   - Issue Documentation
   - Supporting Evidence Collection
   - Claim Validation
   - Version Comparison
   - Historical Context Preservation

### Resolution Workflow

Systematic process for resolving rights conflicts:

1. **Initial Assessment**
   - Conflict Classification
   - Severity Evaluation
   - Stakeholder Identification
   - Financial Impact Analysis
   - Resolution Priority

2. **Resolution Options**
   - Direct Negotiation
   - Mediated Resolution
   - Split Adjustment
   - Documentation Update
   - Registration Correction

3. **Resolution Process**
   - Communication Facilitation
   - Evidence Presentation
   - Proposal Development
   - Agreement Documentation
   - Implementation Planning

4. **Resolution Implementation**
   - Split Updates
   - Registration Corrections
   - Documentation Updates
   - Payment Adjustments
   - Stakeholder Notification

### Dispute Management

Handle more serious rights disagreements:

1. **Dispute Escalation**
   - Escalation Criteria
   - Mediation Initiation
   - Legal Consultation
   - Third-Party Involvement
   - Authority Referral

2. **Dispute Documentation**
   - Case File Creation
   - Evidence Organization
   - Claim Timeline
   - Communication Record
   - Resolution Attempts

3. **Resolution Tracking**
   - Case Status Monitoring
   - Action Item Tracking
   - Timeline Management
   - Milestone Documentation
   - Resolution Confirmation

4. **Post-Resolution Activities**
   - Implementation Verification
   - Documentation Update
   - System Correction
   - Stakeholder Notification
   - Preventative Measures

## Publishing Administration

### Publisher Management

Manage publishing entities and relationships:

<div align="center">
  <img src="../screenshots/publisher-management.png" alt="Publisher Management Interface" width="700"/>
</div>

1. **Publisher Setup**
   - Publisher Profile Creation
   - Sub-Publisher Management
   - Administrator Connections
   - Territory Assignment
   - Catalog Organization

2. **Publisher Share Management**
   - Share Definition and Allocation
   - Territory-Specific Shares
   - Administrative Fee Configuration
   - Term-Based Share Changes
   - Collection Authorization

3. **Publisher Affiliations**
   - Society Registration
   - IPI Number Management
   - Publisher Codes
   - Affiliation Documentation
   - Territory Coverage

4. **Publisher Analytics**
   - Catalog Performance by Publisher
   - Collection Efficiency
   - Territory Performance
   - Administrative Cost Analysis
   - Publisher Comparison

### Sub-Publishing

Manage international publishing relationships:

1. **Sub-Publisher Network**
   - Sub-Publisher Database
   - Territory Assignment
   - Term Management
   - Rate Negotiation
   - Performance Monitoring

2. **Sub-Publishing Agreements**
   - Agreement Templates
   - Custom Agreement Creation
   - Term Configuration
   - Rate Structure Definition
   - Delivery Requirements

3. **Sub-Publishing Delivery**
   - Catalog Delivery
   - Metadata Formatting
   - Asset Preparation
   - Delivery Scheduling
   - Confirmation Tracking

4. **Sub-Publishing Analytics**
   - Territory Performance
   - Sub-Publisher Comparison
   - Collection Efficiency
   - Statement Reconciliation
   - Term Renewal Analysis

### Catalog Valuation

Understand and maximize the value of your rights portfolio:

1. **Valuation Analysis**
   - Income-Based Valuation
   - Comparative Market Analysis
   - Catalog Earnings Projection
   - Growth Trend Analysis
   - Risk Assessment

2. **Valuation Factors**
   - Historical Performance
   - Future Revenue Potential
   - Usage Trends
   - Territory Penetration
   - Marketplace Demand

3. **Catalog Health Metrics**
   - Age Distribution Analysis
   - Hit Ratio Calculation
   - Diversification Assessment
   - Stability Measurement
   - Growth Indicators

4. **Strategic Recommendations**
   - Catalog Enhancement Opportunities
   - Exploitation Recommendations
   - Investment Prioritization
   - Divestment Considerations
   - Acquisition Targeting

## Advanced Rights Management

### Territorial Rights Management

Manage rights across different geographic territories:

<div align="center">
  <img src="../screenshots/territorial-rights.png" alt="Territorial Rights Management" width="700"/>
</div>

1. **Territory Configuration**
   - Global Territory Setup
   - Region Definition
   - Country-Level Management
   - Territory Grouping
   - Market-Specific Settings

2. **Territory-Specific Rights**
   - Ownership by Territory
   - Term Variation by Region
   - Territory-Specific Restrictions
   - Exploitation Rights by Market
   - Collection Authority Assignment

3. **International Registration**
   - Multi-Society Registration
   - Territory-Specific Formatting
   - Translation Management
   - Regional Identifier Handling
   - International Compliance

4. **Territorial Performance**
   - Territory-Based Collection Analysis
   - Registration Efficiency by Region
   - Market Penetration Metrics
   - Regional Revenue Comparison
   - Exploitation Opportunity Identification

### Time-Based Rights Management

Handle rights that change over time:

1. **Term Definition**
   - Initial Term Setting
   - Renewal Configuration
   - Expiration Management
   - Reversion Conditions
   - Perpetuity Handling

2. **Rights Timeline**
   - Chronological Rights Visualization
   - Term Milestone Tracking
   - Ownership Transition Management
   - Historical Rights Documentation
   - Future Rights Projection

3. **Time-Based Triggers**
   - Term Expiration Alerts
   - Renewal Notifications
   - Reversion Action Items
   - Option Deadline Reminders
   - Grace Period Management

4. **Contract Timeline Integration**
   - Contract Term Synchronization
   - Amendment Incorporation
   - Term Extension Processing
   - Early Termination Handling
   - Post-Term Obligation Tracking

### Rights Transfer Management

Facilitate the buying, selling, and transferring of rights:

1. **Transfer Documentation**
   - Transfer Agreement Templates
   - Custom Transfer Creation
   - Asset Schedule Management
   - Transfer Terms Definition
   - Effective Date Configuration

2. **Transfer Process**
   - Rights Audit Pre-Transfer
   - Ownership Verification
   - Transfer Execution
   - Documentation Update
   - Registration Modification

3. **Post-Transfer Activities**
   - Society Notification
   - Administrator Updates
   - Platform Registration Changes
   - Payment Redirection
   - Historical Documentation Preservation

4. **Transfer Analytics**
   - Transfer Value Analysis
   - Transaction History
   - Portfolio Evolution
   - Acquisition Performance
   - Divestment Impact

## Legal Protection

### Infringement Monitoring

Monitor and address unauthorized use of your content:

<div align="center">
  <img src="../screenshots/infringement-monitoring.png" alt="Infringement Monitoring" width="700"/>
</div>

1. **Monitoring Tools**
   - Audio Fingerprinting
   - Digital Fingerprint Matching
   - Web Crawling
   - Social Media Monitoring
   - User-Generated Content Scanning

2. **Detection Process**
   - Automated Scanning
   - Match Verification
   - Unauthorized Use Classification
   - Impact Assessment
   - Action Recommendation

3. **Response Options**
   - Automated Content Claiming
   - Monetization Enablement
   - Takedown Request
   - Cease and Desist Notification
   - Legal Action Initiation

4. **Resolution Tracking**
   - Case Status Monitoring
   - Action Effectiveness Measurement
   - Resolution Documentation
   - Financial Recovery Tracking
   - Repeat Infringer Management

### Takedown Management

Remove unauthorized content from platforms:

1. **Takedown Preparation**
   - Rights Verification
   - Infringement Documentation
   - Takedown Notice Creation
   - Platform Research
   - Contact Information Gathering

2. **Takedown Submission**
   - Platform-Specific Formatting
   - DMCA Notice Delivery
   - Direct Platform Communication
   - Submission Tracking
   - Follow-Up Scheduling

3. **Response Handling**
   - Counter-Notice Processing
   - Evidence Provision
   - Escalation Procedures
   - Legal Consultation
   - Resolution Documentation

4. **Takedown Analytics**
   - Success Rate Tracking
   - Platform Response Time
   - Repeat Infringement Patterns
   - Financial Impact Assessment
   - Protection Strategy Optimization

### Legal Documentation

Maintain legal documentation for rights protection:

1. **Legal Document Library**
   - Contract Templates
   - Agreement Boilerplate
   - Legal Correspondence Templates
   - Notice Formats
   - Standard Terms and Conditions

2. **Document Creation**
   - Custom Document Generation
   - Clause Library Utilization
   - Legal Review Workflow
   - Approval Process
   - Execution Preparation

3. **Legal Document Management**
   - Version Control
   - Access Permission Management
   - Secure Storage
   - Searchable Indexing
   - Retention Policy Compliance

4. **Legal Analytics**
   - Agreement Effectiveness Analysis
   - Clause Performance Evaluation
   - Term Standardization Assessment
   - Risk Exposure Measurement
   - Protection Strategy Optimization

## Best Practices

### Rights Documentation

Establish robust ownership documentation:

1. **Documentation Standards**
   - Complete Chain of Title
   - Written Agreements for All Collaborations
   - Clear Role and Contribution Definition
   - Explicit Territory and Term Specification
   - Consistent Identifier Usage

2. **Preventative Practices**
   - Pre-Collaboration Agreement Execution
   - Regular Rights Audit
   - Gap Identification and Resolution
   - Redundant Documentation Storage
   - Digital and Physical Backup

3. **Documentation Workflow**
   - Standard Operating Procedures
   - Responsibility Assignment
   - Review and Approval Process
   - Implementation Verification
   - Periodic Reassessment

4. **Documentation Tools**
   - Template Utilization
   - Electronic Signature Implementation
   - Secure Document Storage
   - Accessible Repository Organization
   - Search and Retrieval Optimization

### Rights Registration

Maximize protection through registration:

1. **Registration Strategy**
   - Prioritize High-Value Works
   - Comprehensive Society Coverage
   - Global Registration Approach
   - Timeliness Focus
   - Registration Quality Emphasis

2. **Registration Workflow**
   - Standard Registration Process
   - Deadline-Driven Scheduling
   - Registration Batching
   - Quality Control Checkpoints
   - Confirmation Verification

3. **Registration Maintenance**
   - Regular Status Verification
   - Update Implementation
   - Renewal Management
   - Gap Identification
   - Correction Processing

4. **Registration Optimization**
   - Metadata Standardization
   - Format Consistency
   - Identifier Management
   - Translation Quality
   - Detail Completeness

### Rights Monetization

Maximize revenue from your rights portfolio:

1. **Collection Strategy**
   - Society Coverage Optimization
   - Direct Licensing Exploration
   - Sync Licensing Program
   - Secondary Usage Tracking
   - Unclaimed Revenue Capture

2. **Revenue Leakage Prevention**
   - Registration Completeness Verification
   - Payment Pathway Validation
   - Statement Reconciliation
   - Collection Gap Identification
   - Discrepancy Resolution

3. **Monetization Enhancement**
   - Catalog Promotion Strategy
   - Licensing Opportunity Development
   - Rate Negotiation Approach
   - Catalog Bundling Options
   - New Market Exploration

4. **Value Maximization**
   - Catalog Analysis and Segmentation
   - High-Value Work Identification
   - Strategic Investment Planning
   - Performance Tracking
   - Value-Building Activities

## Frequently Asked Questions

### Rights Basics

**Q: What's the difference between master rights and publishing rights?**  
A: Master rights (sound recording copyright) cover the specific recorded version of a song and are typically owned by the recording artist or their label. Publishing rights (composition copyright) cover the underlying musical composition (melody, lyrics, structure) and are typically owned by songwriters and their publishers. Both generate different revenue streams and require separate management within TuneMantra.

**Q: How do I determine who owns what percentage of a song?**  
A: Ownership percentages should be agreed upon by all contributors before or during the creation process. TuneMantra's Split Management tools allow you to document these agreements. Generally, percentages are based on:
- Contribution significance to the final work
- Prior agreements between collaborators
- Industry standards for specific roles (e.g., producer points)
- Written contracts specifying ownership division

The most important principle is having clear written documentation of all splits that totals exactly 100%.

**Q: Why do I need to register my works with collection societies if I'm already distributing through TuneMantra?**  
A: Distribution platforms only collect certain types of royalties (primarily streaming and download revenue). Collection societies collect performance royalties when your music is:
- Played on radio, TV, or in public venues
- Used in films, commercials, or other media
- Performed live
- Streamed on certain platforms that pay performance royalties separately

Without society registration, you're likely missing significant revenue streams that distribution alone doesn't capture.

### Platform-Specific Questions

**Q: How do I handle rights for a song that uses samples?**  
A: For sampled content, TuneMantra provides specialized documentation tools:
1. Use the Sample Documentation section to record all samples used
2. Upload sample clearance documentation for each sample
3. Configure "sample split" percentages to allocate ownership to original creators
4. Link the sample source works in your rights documentation
5. Ensure all sample permissions are properly documented before distribution

Uncleared samples can result in takedowns, legal issues, and financial penalties, so always secure and document proper clearance.

**Q: Can TuneMantra help resolve a rights dispute with another creator?**  
A: Yes, TuneMantra offers several conflict resolution tools:
1. Conflict Documentation: Upload evidence supporting your ownership claim
2. Mediation Interface: Communicate with other parties in a structured environment
3. Split Proposal Tools: Suggest and negotiate resolution splits
4. Resolution Templates: Use standard industry resolution approaches
5. Agreement Generation: Create and execute formal resolution documentation

For disputes requiring legal intervention, TuneMantra can provide case documentation and specialized support, though external legal counsel may be necessary for court proceedings.

**Q: How do I transfer rights to another party using TuneMantra?**  
A: To transfer rights:
1. Navigate to Rights Management > Transfer Rights
2. Select the works to transfer (individual works or catalog bundles)
3. Specify transfer type (full assignment, partial transfer, license, etc.)
4. Define territories and term
5. Set effective date and payment terms
6. Generate transfer documentation
7. Complete electronic signature process with receiving party
8. Submit registration updates to relevant societies and platforms

The system will automatically update ownership records and redirect future royalties according to the transfer terms.

---

## Support Resources

If you need additional assistance with rights management:

- **Knowledge Base**: Visit [help.tunemantra.com/rights](https://help.tunemantra.com/rights) for detailed tutorials
- **Video Tutorials**: Access step-by-step video guides in the Rights Management Learning Center
- **Rights Support**: Contact our specialized rights team at rights@tunemantra.com
- **Legal Consultations**: Enterprise users can schedule sessions with our music rights attorneys

---

**Document Information:**
- Version: 2.0
- Last Updated: March 25, 2025
- Contact: documentation@tunemantra.com

---

## documentation/user/royalty-management-guide.md

# Royalty Management Guide for TuneMantra

<div align="center">
  <img src="../diagrams/royalty-guide-header.svg" alt="TuneMantra Royalty Management Guide" width="800"/>
</div>

## Introduction

Welcome to TuneMantra's comprehensive Royalty Management Guide. This document provides detailed instructions, workflows, and best practices for tracking, calculating, and distributing royalties within the TuneMantra platform. Effective royalty management is essential for ensuring all rights holders receive accurate and timely compensation for their creative work. Whether you're an independent artist, label executive, publisher, or rights administrator, this guide will help you navigate the complexities of music royalties.

## Table of Contents

- [Royalty Fundamentals](#royalty-fundamentals)
- [Royalty Dashboard](#royalty-dashboard)
- [Royalty Calculation](#royalty-calculation)
- [Split Management](#split-management)
- [Payment Processing](#payment-processing)
- [Statements & Reporting](#statements--reporting)
- [Royalty Analytics](#royalty-analytics)
- [Advanced Royalty Features](#advanced-royalty-features)
- [Accounting Integration](#accounting-integration)
- [Best Practices](#best-practices)
- [FAQ](#frequently-asked-questions)

## Royalty Fundamentals

### Understanding Music Royalties

Music royalties are complex but critical to understand for proper compensation:

<div align="center">
  <img src="../screenshots/royalty-overview.png" alt="Royalty Overview" width="700"/>
</div>

1. **Types of Royalties**
   - Mechanical Royalties: Paid for reproduction of compositions
   - Performance Royalties: Paid when music is performed or broadcast
   - Synchronization Royalties: Paid for use of music in video
   - Digital Performance Royalties: Paid for digital streaming
   - Print Royalties: Paid for sheet music and lyric reproduction
   - Neighboring Rights: Paid to performers and master owners

2. **Royalty Sources**
   - Streaming Platforms (Spotify, Apple Music, etc.)
   - Download Stores (iTunes, Amazon MP3)
   - Performance Rights Organizations (PROs)
   - Mechanical Rights Organizations
   - Digital Service Providers (DSPs)
   - Video Platforms (YouTube, TikTok)
   - Sync Licensing (Film, TV, Commercials)

3. **Royalty Rates**
   - Platform-specific rates
   - Territory-dependent rates
   - Negotiated vs. statutory rates
   - Minimum guarantees
   - Advances and recoupments
   - Rate escalations and tiers

4. **Royalty Flow**
   - From user consumption to rights holder payment
   - Collection points and intermediaries
   - Payment timelines and schedules
   - Currency conversions and exchange rates
   - Administrative fees and deductions

### Royalty Management in TuneMantra

How TuneMantra's royalty system streamlines rights holder compensation:

1. **Platform Capabilities**
   - Centralized royalty tracking
   - Automated calculations based on consumption
   - Split management and distribution
   - Customizable payment processing
   - Comprehensive statements and reporting
   - Advanced analytics and forecasting

2. **Integration Points**
   - Rights management connection
   - Distribution data synchronization
   - Accounting system integration
   - Banking and payment processing
   - Tax compliance and reporting
   - External royalty data import

3. **Royalty Lifecycle**
   - Data collection from platforms
   - Royalty calculation and processing
   - Split application and allocation
   - Statement generation
   - Payment processing
   - Historical tracking and auditing

4. **Key Benefits**
   - Accuracy and transparency
   - Timeliness and efficiency
   - Detailed tracking and auditability
   - Customized workflows and rules
   - Comprehensive reporting
   - Financial insights and forecasting

## Royalty Dashboard

### Dashboard Overview

Central command center for monitoring and managing royalties:

<div align="center">
  <img src="../screenshots/royalty-dashboard.png" alt="Royalty Dashboard" width="700"/>
</div>

1. **Main Components**
   - Royalty Summary (earnings overview)
   - Time Period Selection (current, historical, custom)
   - Source Breakdown (platform, territory, type)
   - Performance Trends (growth, comparison)
   - Action Items (pending approvals, issues)

2. **Key Metrics**
   - Total Earnings (current period)
   - Period-over-Period Growth
   - Source Distribution Visualization
   - Top Earning Works
   - Upcoming Payments
   - Outstanding Balances

3. **Quick Actions**
   - Generate Statements
   - Process Payments
   - Review Calculations
   - Export Data
   - Adjust Settings
   - Access Reports

4. **Filters and Views**
   - Time Period Selection
   - Source Filtering
   - Catalog Segmentation
   - Territory Focus
   - Royalty Type Selection
   - Custom Views

### Navigation and Customization

Efficiently access royalty management features:

1. **Royalty Navigation**
   - Main menu navigation
   - Contextual operation links
   - Related section connections
   - Workflow guidance
   - Hierarchical navigation structure

2. **Dashboard Customization**
   - Widget arrangement
   - Metric selection
   - Chart type preferences
   - Color scheme options
   - Layout templates

3. **Saved Views**
   - Custom view creation
   - View library organization
   - Quick-access favorites
   - Sharing capabilities
   - Default view setting

## Royalty Calculation

### Calculation Engine

How TuneMantra calculates royalties from streaming, sales, and other sources:

<div align="center">
  <img src="../screenshots/royalty-calculation.png" alt="Royalty Calculation Interface" width="700"/>
</div>

1. **Calculation Methods**
   - Per-Stream Calculation
   - Revenue Share Calculation
   - Fixed Rate Calculation
   - Pro-Rata Pool Distribution
   - Minimum Guarantee Application
   - Hybrid Calculation Approaches

2. **Rate Configuration**
   - Platform-Specific Rates
   - Territory-Dependent Adjustments
   - Custom Rate Definition
   - Rate Templates
   - Rate Change Management
   - Historical Rate Preservation

3. **Advanced Parameters**
   - Currency Settings
   - Exchange Rate Handling
   - Rounding Rules
   - Minimum Thresholds
   - Reserve Percentages
   - Administrative Rate Application

4. **Calculation Schedule**
   - Real-Time Estimation
   - Scheduled Calculation Runs
   - Recalculation Triggers
   - Finalization Process
   - Verification Steps
   - Approval Workflow

### Data Import and Processing

Bring royalty data into the system for processing:

1. **Data Sources**
   - Platform Direct Feeds
   - Report Imports
   - Manual Entry
   - API Connections
   - Legacy System Integration
   - Third-Party Services

2. **Import Methods**
   - Automated Imports
   - Manual File Upload
   - API-Based Data Transfer
   - Scheduled Data Synchronization
   - Batch Processing
   - Real-Time Data Streams

3. **Data Validation**
   - Format Verification
   - Completeness Check
   - Duplicate Detection
   - Error Handling
   - Threshold Alerts
   - Anomaly Detection

4. **Processing Pipeline**
   - Data Normalization
   - Mapping to Internal Catalog
   - Rate Application
   - Split Calculation
   - Currency Conversion
   - Aggregation and Summarization

### Custom Calculation Rules

Define specialized rules for unique royalty scenarios:

1. **Rule Builder**
   - Conditional Rule Creation
   - Parameter Definition
   - Calculation Logic
   - Exception Handling
   - Rule Testing and Validation
   - Version Control

2. **Rule Types**
   - Minimum Guarantee Rules
   - Advance Recoupment Rules
   - Escalation Tier Rules
   - Retroactive Rate Rules
   - Special Territory Rules
   - Time-Based Rules

3. **Rule Application**
   - Global Rule Sets
   - Catalog-Specific Rules
   - Contract-Based Rules
   - Artist-Specific Rules
   - Release-Level Rules
   - Track-Level Rules

4. **Rule Management**
   - Rule Organization
   - Conflict Resolution
   - Priority Setting
   - Effective Dating
   - Rule Documentation
   - Audit Logging

## Split Management

### Split Configuration

Define who gets paid what percentage of royalties:

<div align="center">
  <img src="../screenshots/royalty-splits.png" alt="Royalty Split Configuration" width="700"/>
</div>

1. **Split Definition**
   - Percentage-Based Splits
   - Role-Based Splits
   - Point-Based Systems
   - Hierarchical Splits
   - Multi-Level Splits
   - Split Groups

2. **Split Types**
   - Recording Side Splits (Master)
   - Composition Side Splits (Publishing)
   - Producer Splits
   - Featured Artist Splits
   - Sample-Based Splits
   - Administrative Shares

3. **Split Management Interface**
   - Visual Split Editor
   - Bulk Split Application
   - Template-Based Splits
   - Split Inheritance
   - Split Version Control
   - Split History Tracking

4. **Split Validation**
   - Total Verification (100% Check)
   - Minimum Share Validation
   - Conflict Detection
   - Agreement Verification
   - Documentation Linking
   - Approval Workflow

### Recipient Management

Manage individuals and entities who receive royalty payments:

1. **Recipient Types**
   - Individual Artists
   - Bands and Groups
   - Record Labels
   - Publishers
   - Administrators
   - Estates and Trusts
   - Companies and Corporations

2. **Recipient Profiles**
   - Contact Information
   - Tax Information
   - Payment Methods
   - Communication Preferences
   - Default Split Settings
   - Agreement References

3. **Recipient Groups**
   - Group Creation and Management
   - Group Member Administration
   - Internal Split Configuration
   - Group Representative Designation
   - Group Payment Preferences
   - Group Reporting Options

4. **Recipient Analytics**
   - Earnings by Recipient
   - Catalog Contribution
   - Historical Payment Analysis
   - Performance Comparisons
   - Revenue Growth Tracking
   - Catalog Value Estimation

### Split Templates

Streamline split creation for repeated scenarios:

1. **Template Creation**
   - Template Builder Interface
   - Default Participants
   - Percentage Configuration
   - Role-Based Templates
   - Project-Based Templates
   - Custom Template Design

2. **Template Application**
   - New Release Application
   - Bulk Application to Catalog
   - Modified Application
   - Template Overrides
   - Template Combinations
   - Template Versioning

3. **Template Library**
   - Organization and Categories
   - Search and Filtering
   - Template Sharing
   - Favorite Templates
   - Recently Used Templates
   - Template Recommendations

4. **Template Inheritance**
   - Hierarchical Templates
   - Template Nesting
   - Override Rules
   - Inheritance Path Visualization
   - Conflict Resolution
   - Inheritance Tracking

## Payment Processing

### Payment Setup

Configure how and when royalty payments are processed:

<div align="center">
  <img src="../screenshots/payment-setup.png" alt="Payment Setup Interface" width="700"/>
</div>

1. **Payment Methods**
   - Bank Transfers (ACH, Wire)
   - PayPal Integration
   - Digital Wallet Options
   - Check Processing
   - Platform Credits
   - Alternative Payment Methods

2. **Payment Schedule**
   - Monthly Processing
   - Quarterly Payments
   - Custom Schedules
   - Threshold-Based Payments
   - On-Demand Payments
   - Advance Payments

3. **Payment Thresholds**
   - Minimum Payment Amounts
   - Threshold Configuration
   - Balance Accrual
   - Threshold Notifications
   - Override Options
   - Consolidated Thresholds

4. **Payment Settings**
   - Currency Preferences
   - Payment Prioritization
   - Fee Handling
   - Tax Withholding
   - Automated vs. Manual
   - Payment Notifications

### Payment Processing

Execute and track royalty payments to rights holders:

1. **Payment Generation**
   - Payment Batch Creation
   - Recipient Selection
   - Amount Verification
   - Currency Configuration
   - Fee Calculation
   - Payment Method Assignment

2. **Payment Approval**
   - Review Process
   - Approval Levels
   - Approval Documentation
   - Batch vs. Individual Approval
   - Exception Handling
   - Approval Notification

3. **Payment Execution**
   - Bank Integration
   - Payment Gateway Connection
   - Transaction Processing
   - Confirmation Receipt
   - Error Handling
   - Retry Mechanisms

4. **Payment Tracking**
   - Status Monitoring
   - Transaction History
   - Payment Timeline
   - Confirmation Tracking
   - Issue Resolution
   - Audit Trail

### Advanced Payment Features

Specialized payment options for complex scenarios:

1. **Split Payments**
   - Payment Division
   - Multiple Method Distribution
   - Different Currency Payments
   - Partial Payment Processing
   - Priority-Based Allocation
   - Combined Payment Options

2. **Advance Management**
   - Advance Configuration
   - Recoupment Tracking
   - Recoupment Rate Setting
   - Advance Reconciliation
   - Unrecouped Balance Monitoring
   - Advance Reporting

3. **Payment Holds**
   - Hold Configuration
   - Hold Reason Documentation
   - Hold Duration Setting
   - Hold Notification
   - Hold Release Process
   - Hold History Tracking

4. **International Payments**
   - Global Banking Support
   - Currency Exchange
   - International Tax Compliance
   - Cross-Border Requirements
   - Geographic Restrictions
   - International Fee Structure

## Statements & Reporting

### Statement Generation

Create comprehensive royalty statements for rights holders:

<div align="center">
  <img src="../screenshots/statement-generation.png" alt="Statement Generation Interface" width="700"/>
</div>

1. **Statement Types**
   - Detailed Transaction Statements
   - Summary Statements
   - Catalog Performance Reports
   - Source Breakdown Reports
   - Trend Analysis Statements
   - Custom Statement Formats

2. **Statement Components**
   - Header and Overview
   - Period Information
   - Earning Summary
   - Detailed Transaction List
   - Catalog Performance
   - Payment Information
   - Notes and Explanations

3. **Statement Schedule**
   - Monthly Statements
   - Quarterly Reports
   - Annual Summaries
   - Ad-hoc Generation
   - Automated Scheduling
   - Recipient-specific Timing

4. **Statement Delivery**
   - Email Delivery
   - Portal Access
   - Download Options
   - API Access
   - Bulk Distribution
   - Delivery Confirmation

### Statement Customization

Tailor statements to meet specific needs:

1. **Layout Design**
   - Template Selection
   - Section Configuration
   - Column Customization
   - Sorting and Grouping
   - Filtering Options
   - Branding and Styling

2. **Data Inclusion**
   - Transaction Detail Level
   - Trend Visualization
   - Comparative Analysis
   - Projection Inclusion
   - Historical Context
   - Explanation Notes

3. **Recipient Customization**
   - Recipient-Specific Templates
   - Language Preferences
   - Currency Settings
   - Detail Level Preferences
   - Delivery Format Options
   - Notification Settings

4. **Advanced Features**
   - Interactive Statements
   - Drill-Down Capabilities
   - Data Visualization
   - Export Formats
   - API Integration
   - Statement Archives

### Specialized Reports

Generate focused reports for specific royalty scenarios:

1. **Catalog Performance**
   - Track/Release Earnings
   - Catalog Valuation
   - Performance Trends
   - Comparative Analysis
   - Territory Performance
   - Platform Distribution

2. **Financial Reports**
   - Revenue Recognition
   - Accruals and Reserves
   - Tax Documentation
   - Audit Support
   - Reconciliation Reports
   - Budget Comparison

3. **Administrative Reports**
   - Processing Status
   - Error Logs
   - System Performance
   - User Activity
   - Compliance Documentation
   - Operational Metrics

4. **Custom Reporting**
   - Report Builder Interface
   - Custom Metrics
   - Visualization Options
   - Schedule Configuration
   - Distribution Settings
   - Advanced Filtering

## Royalty Analytics

### Performance Analytics

Gain deep insights into royalty earnings and trends:

<div align="center">
  <img src="../screenshots/royalty-analytics.png" alt="Royalty Analytics Dashboard" width="700"/>
</div>

1. **Earnings Analysis**
   - Total Earnings Overview
   - Period-over-Period Comparison
   - Growth Rate Tracking
   - Seasonal Pattern Analysis
   - Earnings Distribution
   - Earning Velocity Metrics

2. **Source Analytics**
   - Platform Contribution Analysis
   - Territory Performance
   - Royalty Type Distribution
   - Revenue Stream Comparison
   - Channel Effectiveness
   - Source Trend Analysis

3. **Catalog Performance**
   - Top Earning Works
   - Catalog Segment Analysis
   - Release Performance Comparison
   - Catalog Age Analysis
   - New vs. Catalog Performance
   - Genre Performance Analysis

4. **Recipient Analytics**
   - Earnings by Recipient
   - Split Effectiveness
   - Recipient Comparison
   - Payment History Analysis
   - Threshold Impact Analysis
   - Recipient Growth Metrics

### Forecasting & Modeling

Project future royalty earnings and test scenarios:

1. **Revenue Forecasting**
   - Trend-Based Projections
   - Seasonality Modeling
   - Growth Pattern Analysis
   - Catalog Aging Factors
   - New Release Impact
   - Market Trend Incorporation

2. **Scenario Modeling**
   - "What-If" Analysis
   - Rate Change Simulation
   - Distribution Strategy Testing
   - New Release Modeling
   - Market Expansion Scenarios
   - Platform Mix Optimization

3. **Catalog Valuation**
   - Current Value Calculation
   - Future Value Projection
   - Risk-Adjusted Valuation
   - Comparable Analysis
   - Acquisition Modeling
   - Investment Return Calculation

4. **Strategic Planning**
   - Resource Allocation Guidance
   - Investment Return Analysis
   - Catalog Development Strategy
   - Market Focus Recommendations
   - Platform Strategy Insights
   - Growth Opportunity Identification

### Comparative Analytics

Benchmark performance against relevant comparisons:

1. **Historical Comparison**
   - Year-over-Year Analysis
   - Quarter-over-Quarter Trends
   - Multi-Year Performance
   - Growth Rate Tracking
   - Seasonal Pattern Identification
   - Long-Term Value Assessment

2. **Peer Comparison**
   - Similar Catalog Benchmarking
   - Genre Performance Standards
   - Market Share Analysis
   - Growth Rate Comparison
   - Platform Performance Benchmarks
   - Territory Penetration Comparison

3. **Market Comparison**
   - Industry Standard Metrics
   - Market Rate Benchmarking
   - Platform Average Comparison
   - Genre Trend Alignment
   - Territory Performance Standards
   - Emerging Market Opportunities

4. **Goal Comparison**
   - Target Achievement Tracking
   - Projection Accuracy Analysis
   - Budget Comparison
   - ROI Measurement
   - KPI Performance
   - Strategic Goal Progress

## Advanced Royalty Features

### Recoupment Management

Track and manage advances against future royalties:

<div align="center">
  <img src="../screenshots/recoupment-management.png" alt="Recoupment Management Interface" width="700"/>
</div>

1. **Advance Configuration**
   - Advance Amount Definition
   - Recoupable Expenses Tracking
   - Recoupment Rate Setting
   - Cross-Collateralization Rules
   - Recoupment Priority Configuration
   - Exclusions and Limitations

2. **Recoupment Tracking**
   - Unrecouped Balance Monitoring
   - Recoupment Progress Visualization
   - Projected Recoupment Timeline
   - Source-Level Recoupment Analysis
   - Partial Recoupment Processing
   - Recoupment History

3. **Multiple Advance Management**
   - Advance Stacking Rules
   - Multiple Advance Prioritization
   - Blended Recoupment Rates
   - Advance Consolidation
   - Tiered Recoupment Structure
   - Advance Repayment Options

4. **Recoupment Reporting**
   - Recoupment Status Reports
   - Balance Statements
   - Recoupment Projections
   - Advance Reconciliation
   - Stakeholder Communication
   - Accounting Integration

### Multi-Tier Royalty Structures

Configure complex royalty rates based on volume or other factors:

1. **Tier Configuration**
   - Volume-Based Tiers
   - Revenue-Based Tiers
   - Time-Based Tiers
   - Performance-Based Tiers
   - Territory-Specific Tiers
   - Platform-Specific Tiers

2. **Rate Structure Design**
   - Escalating Rate Models
   - Sliding Scale Approaches
   - Threshold-Based Rates
   - Hybrid Tier Models
   - Conditional Rate Assignment
   - Override Provisions

3. **Tier Application Logic**
   - Calculation Methodology
   - Tier Boundary Handling
   - Pro-Rating Mechanisms
   - Calculation Period Definition
   - Reset Rules and Timing
   - Exception Processing

4. **Tier Analytics**
   - Tier Performance Analysis
   - Threshold Proximity Tracking
   - Optimization Recommendations
   - Tier Impact Modeling
   - Comparative Tier Analysis
   - Structure Effectiveness Metrics

### Reserve Management

Handle royalty reserves and their eventual release:

1. **Reserve Configuration**
   - Reserve Percentage Setting
   - Reserve Period Definition
   - Platform-Specific Reserves
   - Territory-Specific Reserves
   - Release Schedule Configuration
   - Reserve Exclusions

2. **Reserve Tracking**
   - Current Reserve Balance
   - Reserved Amount by Period
   - Release Schedule Timeline
   - Reserve Aging Analysis
   - Projected Release Amounts
   - Reserve Adjustment History

3. **Release Processing**
   - Scheduled Release Automation
   - Manual Release Options
   - Partial Release Processing
   - Release Verification
   - Release Documentation
   - Payment Integration

4. **Reserve Analytics**
   - Reserve Impact Analysis
   - Reserve Level Optimization
   - Cash Flow Projections
   - Release Timing Strategy
   - Historical Reserve Analysis
   - Reserve Performance Metrics

## Accounting Integration

### Financial System Integration

Connect royalty management with accounting systems:

<div align="center">
  <img src="../screenshots/accounting-integration.png" alt="Accounting Integration" width="700"/>
</div>

1. **Integration Methods**
   - Direct API Connection
   - File-Based Integration
   - Middleware Solutions
   - Real-Time Synchronization
   - Scheduled Data Transfer
   - Manual Export/Import Options

2. **Accounting Systems Support**
   - QuickBooks Integration
   - Xero Connection
   - NetSuite Compatibility
   - Sage Integration
   - Custom ERP Connections
   - Multi-System Support

3. **Data Mapping**
   - Chart of Accounts Mapping
   - Transaction Categorization
   - Entity Relationship Mapping
   - Currency Handling
   - Period Alignment
   - Reconciliation Keys

4. **Integration Configuration**
   - Field Mapping Interface
   - Transformation Rules
   - Validation Criteria
   - Error Handling
   - Logging and Auditing
   - Security Settings

### Revenue Recognition

Manage the accounting treatment of royalty revenue:

1. **Recognition Models**
   - Accrual-Based Recognition
   - Cash-Based Recording
   - Hybrid Recognition Approaches
   - GAAP/IFRS Compliance Options
   - Territory-Specific Standards
   - Multi-Entity Recognition

2. **Recognition Rules**
   - Revenue Recognition Timing
   - Deferral Configuration
   - Amortization Settings
   - Recognition Triggers
   - Period Close Process
   - Adjustment Handling

3. **Recognition Reporting**
   - Recognition Schedule Reports
   - Deferred Revenue Tracking
   - Recognized vs. Received Analysis
   - Projected Recognition Timeline
   - Period Comparison Reports
   - Audit Documentation

4. **Recognition Analytics**
   - Recognition Pattern Analysis
   - Cash Flow Impact Assessment
   - Forecast Accuracy Tracking
   - Accounting Impact Modeling
   - Compliance Risk Assessment
   - Financial Statement Impact

### Tax Management

Handle tax implications of royalty payments:

1. **Tax Configuration**
   - Tax Rate Setup
   - Territory-Specific Rules
   - Tax Treaty Implementation
   - Withholding Requirements
   - Tax ID Management
   - Tax Category Assignment

2. **Withholding Processing**
   - Calculation Methodology
   - Threshold Application
   - Documentation Requirements
   - Exemption Handling
   - Multi-Jurisdiction Withholding
   - Reporting Requirements

3. **Tax Documentation**
   - Form Generation (1099, 1042-S, etc.)
   - Tax Certificate Management
   - Documentation Distribution
   - Compliance Verification
   - Audit Support Materials
   - Regulatory Submissions

4. **Tax Analysis**
   - Withholding Efficiency Analysis
   - Jurisdictional Exposure Assessment
   - Tax Planning Opportunities
   - Compliance Risk Evaluation
   - Treaty Benefit Optimization
   - Tax Position Reporting

## Best Practices

### Royalty Accuracy

Ensure precise royalty calculations and payments:

1. **Data Validation Protocols**
   - Source Data Verification
   - Multiple Data Source Comparison
   - Automated Validation Checks
   - Manual Sampling Reviews
   - Exception Investigation Process
   - Correction Documentation

2. **Calculation Verification**
   - Formula Auditing
   - Test Case Validation
   - Historical Comparison
   - Independent Recalculation
   - Threshold Alert Review
   - Anomaly Investigation

3. **Reconciliation Procedures**
   - Statement Reconciliation Process
   - Platform Data Verification
   - Payment Confirmation Matching
   - Balance Reconciliation
   - Discrepancy Resolution Protocol
   - Documentation Requirements

4. **Quality Assurance**
   - Automated Testing Programs
   - Manual Review Checkpoints
   - Multi-Level Approval Process
   - External Audit Support
   - Continuous Improvement Cycles
   - Error Root Cause Analysis

### Royalty Efficiency

Optimize royalty management operations:

1. **Process Optimization**
   - Workflow Assessment
   - Bottleneck Identification
   - Automation Opportunities
   - Process Standardization
   - Exception Handling Efficiency
   - Continuous Improvement Culture

2. **Resource Allocation**
   - Task Prioritization Framework
   - Effort vs. Impact Analysis
   - Resource Capacity Planning
   - Specialized Role Definition
   - Technology Investment Strategy
   - Outsourcing Evaluation

3. **Technology Leverage**
   - Automation Implementation
   - Integration Optimization
   - Self-Service Capability Enhancement
   - Advanced Analytics Utilization
   - Mobile Accessibility
   - Process Intelligence Tools

4. **Knowledge Management**
   - Documentation Standards
   - Training Program Development
   - Knowledge Base Creation
   - User Support Resources
   - Best Practice Distribution
   - Innovation Sharing

### Compliance and Governance

Maintain legal and contractual compliance:

1. **Contract Compliance**
   - Agreement Term Monitoring
   - Obligation Tracking
   - Payment Compliance Verification
   - Reporting Requirement Fulfillment
   - Audit Right Management
   - Certification Documentation

2. **Regulatory Compliance**
   - Industry Regulation Monitoring
   - Territory-Specific Requirements
   - Tax Compliance Verification
   - Copyright Law Adherence
   - Data Protection Compliance
   - Financial Reporting Standards

3. **Audit Readiness**
   - Documentation Organization
   - Calculation Traceability
   - Transaction History Preservation
   - Change Log Maintenance
   - Supporting Evidence Collection
   - Audit Response Procedures

4. **Governance Framework**
   - Policy and Procedure Development
   - Role and Responsibility Definition
   - Control Implementation
   - Risk Assessment
   - Compliance Monitoring
   - Regular Review Process

## Frequently Asked Questions

### General Royalty Questions

**Q: How are streaming royalties calculated in TuneMantra?**  
A: TuneMantra calculates streaming royalties using a multi-step process:
1. We collect stream counts and revenue data from each platform (Spotify, Apple Music, etc.)
2. For each platform, we apply the appropriate rate structures:
   - Pro-rata share of revenue pools for major platforms
   - Per-stream rates for platforms using fixed rate models
   - Custom formulas for specialized platforms
3. We apply territory-specific adjustments based on where streams occurred
4. The system then applies your specific splits to determine each participant's share
5. Results are aggregated across all platforms and displayed in your royalty dashboard

For detailed platform-specific calculations, you can view the "Calculation Method" tab in the royalty detail view for any earning period.

**Q: When are royalties processed and paid?**  
A: The royalty processing and payment schedule works as follows:
1. Data Collection: Platform data is typically received 30-60 days after the end of each month
2. Processing: Royalties are calculated within 10 business days of receiving complete platform data
3. Statement Generation: Statements are published by the 15th of each month for the period two months prior
4. Payment Processing:
   - Monthly payment option: Payments processed by the 20th of each month
   - Quarterly payment option: Payments processed by the 20th of the month following quarter end
   - Payment receipt typically occurs 3-5 business days after processing, depending on your payment method
   - Minimum payment thresholds apply (configurable in your account settings)

You can view your processing schedule and payment history in the Payments section of your dashboard.

**Q: How do I handle royalty splits for tracks with multiple contributors?**  
A: TuneMantra offers several tools for managing complex splits:
1. Split Manager: The visual split editor allows precise percentage allocation
2. Split Templates: Create and save common split configurations for quick application
3. Split Agreement Generator: Create formal documentation of split arrangements
4. Bulk Split Application: Apply consistent splits across multiple tracks
5. Split Groups: Manage internal splits within collectives or groups
6. Split History: Track changes and maintain a record of all split modifications

For best results, always finalize splits before distribution and ensure all contributors have signed split agreements, which can be uploaded to the platform for documentation.

### Platform-Specific Questions

**Q: Why do I see different royalty rates across different streaming platforms?**  
A: Royalty rates vary by platform due to several factors:
1. Business Model Differences:
   - Subscription vs. ad-supported services
   - User base characteristics and geography
   - Premium vs. free tier distribution
2. Platform-Specific Calculations:
   - Revenue share vs. fixed rate models
   - Negotiated rates vs. statutory rates
   - Territory-specific licensing arrangements
3. Content Usage Factors:
   - Stream duration requirements
   - Auto-play vs. on-demand streams
   - Promotional vs. standard usage

TuneMantra provides platform comparison analytics to help you understand these differences and optimize your distribution strategy for maximum royalty potential.

**Q: How are YouTube royalties handled differently from other streaming platforms?**  
A: YouTube royalties have unique characteristics in TuneMantra:
1. Multiple Revenue Streams:
   - Content ID claims on user-generated content
   - Official music video monetization
   - YouTube Music streaming royalties
   - YouTube Premium subscription revenue
2. Specialized Tracking:
   - View count to monetized view conversion tracking
   - Claim conflict resolution and management
   - Content type segmentation (official, user-generated, etc.)
3. Enhanced Analytics:
   - Viewer demographics and behavior analysis
   - Engagement metrics correlation with revenue
   - Monetization efficiency tracking

YouTube-specific settings can be configured in the Platform Settings section, including Content ID preferences and claim policy defaults.

**Q: How does TuneMantra handle royalties from emerging platforms like TikTok?**  
A: For emerging platforms like TikTok, TuneMantra provides:
1. Specialized Integration:
   - Direct data feeds where available
   - Custom import templates for new platform reports
   - Normalized data processing across platforms
2. Flexible Rate Structures:
   - Configurable calculation models for unique payment structures
   - Support for lump sum license arrangements
   - Minimum guarantee tracking and reconciliation
3. Dynamic Reporting:
   - Platform-specific usage metrics
   - Trend analysis for emerging revenue sources
   - Comparative performance against established platforms

We continually update our platform support as new DSPs emerge and evolve their royalty models.

### Advanced Royalty Questions

**Q: How do I track recoupment of advances against royalties?**  
A: TuneMantra's advance recoupment features include:
1. Advance Setup:
   - Define advance amount and terms
   - Configure recoupable revenue sources
   - Set recoupment rates (100% or partial percentage)
   - Specify exclusions if needed
2. Tracking Tools:
   - Real-time recoupment balance monitoring
   - Source-specific recoupment tracking
   - Projected recoupment timeline
   - Threshold notifications
3. Reporting Options:
   - Detailed recoupment statements
   - Recoupment progress visualization
   - Pre/post-recoupment comparison
   - Stakeholder-specific recoupment reporting

You can manage multiple advances with different terms and track cross-collateralization across releases using the Advanced Recoupment Manager in the Royalty Settings section.

**Q: How are royalty reserves handled and when are they released?**  
A: Royalty reserves are managed through a comprehensive process:
1. Reserve Configuration:
   - Set default reserve percentages (typically 10-20%)
   - Configure platform-specific reserve rates if needed
   - Define reserve holding periods (typically 3-6 months)
2. Reserve Tracking:
   - View current reserved amounts by period
   - Track pending releases with timeline visualization
   - Review historical reserve adjustments
3. Release Processing:
   - Automated release based on configured schedule
   - Manual override options for special situations
   - Release notification and documentation
   - Payment processing integration for released amounts

Reserve settings can be customized in the Financial Settings section, with different policies possible for different catalog segments or release types.

**Q: Can TuneMantra handle international tax withholding for royalty payments?**  
A: Yes, TuneMantra provides comprehensive international tax management:
1. Tax Setup:
   - Configure home country and international tax requirements
   - Upload tax documentation and certificates
   - Set up tax treaty benefits where applicable
   - Configure recipient tax status and exemptions
2. Withholding Processing:
   - Automatic calculation of required withholding
   - Jurisdiction-specific rate application
   - Documentation of withholding compliance
   - Support for multiple tax IDs and entities
3. Tax Reporting:
   - Generation of required tax forms
   - Withholding statements for recipients
   - Tax authority reporting support
   - Year-end tax document compilation

Our tax management system supports over 40 countries with territory-specific compliance features and is regularly updated to reflect changing regulations.

---

## Support Resources

If you need additional assistance with royalty management:

- **Knowledge Base**: Visit [help.tunemantra.com/royalties](https://help.tunemantra.com/royalties) for detailed tutorials
- **Video Tutorials**: Access step-by-step video guides in the Royalty Management Learning Center
- **Royalty Support**: Contact our specialized royalty team at royalties@tunemantra.com
- **Financial Consultations**: Enterprise users can schedule sessions with our royalty specialists

---

**Document Information:**
- Version: 2.0
- Last Updated: March 25, 2025
- Contact: documentation@tunemantra.com

---

## documentation/user/user-guide.md

# TuneMantra User Guide

This guide provides instructions for using the TuneMantra platform for rights management and music distribution.

## Table of Contents

1. [Introduction](#introduction)
2. [Getting Started](#getting-started)
   - [Account Creation](#account-creation)
   - [Dashboard Overview](#dashboard-overview)
3. [Rights Management](#rights-management)
   - [Registering Rights](#registering-rights)
   - [Viewing Rights](#viewing-rights)
   - [Verifying Rights Ownership](#verifying-rights-ownership)
   - [Transferring Rights](#transferring-rights)
   - [Resolving Disputes](#resolving-disputes)
4. [Asset Management](#asset-management)
   - [Uploading Tracks](#uploading-tracks)
   - [Managing Metadata](#managing-metadata)
   - [Creating NFTs](#creating-nfts)
5. [Distribution](#distribution)
   - [Creating Releases](#creating-releases)
   - [Distribution Settings](#distribution-settings)
   - [Monitoring Status](#monitoring-status)
6. [Analytics & Reporting](#analytics--reporting)
   - [Performance Dashboard](#performance-dashboard)
   - [Revenue Reports](#revenue-reports)
   - [Custom Reports](#custom-reports)
7. [Account Management](#account-management)
   - [Profile Settings](#profile-settings)
   - [Team Management](#team-management)
   - [Billing and Subscriptions](#billing-and-subscriptions)
8. [Support & Help](#support--help)
   - [Common Issues](#common-issues)
   - [Contacting Support](#contacting-support)

## Introduction

TuneMantra is a blockchain-powered platform for managing music rights and distribution. The platform provides tools for:

- Secure rights registration and verification using blockchain technology
- NFT creation for music assets
- Distribution to major streaming platforms
- Comprehensive analytics and reporting
- Royalty management and payments

This guide will help you navigate the platform and make the most of its features.

## Getting Started

### Account Creation

1. Visit the TuneMantra website at [https://tunemantra.com](https://tunemantra.com)
2. Click the "Sign Up" button in the top right corner
3. Choose your account type:
   - Artist
   - Label
   - Distributor
   - Rights Holder
4. Fill in your details and click "Create Account"
5. Verify your email address by clicking the link in the verification email
6. Complete your profile with:
   - Profile picture
   - Bio/description
   - Contact information
   - Payment details (for royalty distribution)

### Dashboard Overview

After logging in, you'll see your dashboard with these key sections:

- **Quick Actions**: Common tasks and activities
- **Recent Activity**: Latest updates and changes
- **Performance Metrics**: Key statistics and numbers
- **Navigation Menu**: Access to all platform sections
- **Notifications**: Important updates and alerts

![Dashboard Overview](./images/dashboard.png)

## Rights Management

### Registering Rights

To register rights for a music asset:

1. Navigate to "Rights Management" > "Register Rights"
2. Fill in the rights information:
   - Asset details (title, artist, etc.)
   - Rights type (publishing, master, etc.)
   - Territories covered
   - Effective dates (start and end)
   - Rights ownership percentage
   - Additional metadata
3. Confirm rights ownership by signing the declaration
4. Click "Register Rights"
5. The system will:
   - Create a database record
   - Register the rights on the blockchain network
   - Provide a confirmation with transaction details
   - Issue a rights certificate

After registration, you'll receive a unique Rights ID that can be used to verify and track the rights.

### Viewing Rights

To view your registered rights:

1. Go to "Rights Management" > "My Rights"
2. You'll see a list of all your rights records
3. Use filters to sort by:
   - Date registered
   - Asset type
   - Territory
   - Status
4. Click on any rights record to view details:
   - Rights information
   - Blockchain record
   - Transaction history
   - Verification status

### Verifying Rights Ownership

To verify ownership of rights:

1. Navigate to "Rights Management" > "Verify Rights"
2. Enter the Rights ID you want to verify
3. Sign the verification request using your wallet
4. The system will check:
   - The blockchain record
   - Signature validity
   - Current ownership status
5. A verification report will be displayed showing:
   - Current owner
   - Rights validity
   - Verification status

For third-party verification:

1. Share your Rights ID with the verifying party
2. They can use the public verification tool at [https://verify.tunemantra.com](https://verify.tunemantra.com)
3. The verification will check the blockchain without requiring your credentials

### Transferring Rights

To transfer rights to another user:

1. Navigate to "Rights Management" > "My Rights"
2. Select the rights record you want to transfer
3. Click "Transfer Rights"
4. Enter the recipient's:
   - TuneMantra username or email
   - Or their blockchain wallet address
5. Specify transfer details:
   - Full or partial transfer
   - Effective date
   - Terms and conditions
6. Sign the transfer transaction
7. The recipient will be notified and must accept the transfer
8. The blockchain record will be updated to reflect the new ownership

### Resolving Disputes

If there's a dispute about rights ownership:

1. Navigate to "Rights Management" > "Disputes"
2. Click "File Dispute"
3. Select the rights record in question
4. Provide evidence of your ownership claim:
   - Documentation
   - Contracts
   - Previous registrations
   - Signatures
5. Submit the dispute
6. The dispute resolution process will:
   - Notify all parties
   - Collect evidence
   - Apply resolution rules
   - Update the blockchain record if necessary

## Asset Management

### Uploading Tracks

To upload music tracks:

1. Go to "Asset Management" > "Upload"
2. Drag and drop your audio files or click to browse
3. Supported formats: WAV, FLAC, MP3 (320kbps minimum)
4. Each track will need:
   - Title
   - Artist(s)
   - Genre
   - Release date
   - ISRC code (if available)
   - Cover art (3000x3000px minimum)
5. Click "Upload" to begin the process
6. The system will:
   - Validate audio quality
   - Extract audio fingerprints
   - Process metadata
   - Create preview versions

### Managing Metadata

To manage track metadata:

1. Navigate to "Asset Management" > "My Catalog"
2. Select the track you want to manage
3. Click "Edit Metadata"
4. You can update:
   - Basic information (title, artist, etc.)
   - Advanced metadata (BPM, key, mood, etc.)
   - Contributors (producers, writers, etc.)
   - Lyrics
   - Tags for discovery
5. Click "Save Changes"
6. The system will update all connected services with the new information

### Creating NFTs

To create an NFT for your track:

1. Navigate to "Asset Management" > "NFTs"
2. Click "Create NFT"
3. Select the track you want to tokenize
4. Configure the NFT:
   - Token name
   - Description
   - Custom artwork (optional)
   - Royalty percentage for secondary sales
   - Blockchain network (Mumbai, Ethereum, etc.)
   - Additional perks or benefits
5. Preview the NFT
6. Click "Mint NFT"
7. The system will:
   - Create the NFT metadata
   - Mint the token on the selected blockchain
   - Provide transaction details
   - Add the NFT to your collection

## Distribution

### Creating Releases

To create a new release for distribution:

1. Navigate to "Distribution" > "New Release"
2. Select release type:
   - Single
   - EP
   - Album
   - Compilation
3. Add tracks from your catalog
4. Configure release details:
   - Release title
   - Primary artist
   - Featured artists
   - Release date
   - Pre-save date (if applicable)
   - Cover art
   - UPC/EAN code (if available)
5. Select distribution channels
6. Set pricing options
7. Click "Create Release"

### Distribution Settings

To configure your distribution settings:

1. Navigate to "Distribution" > "Settings"
2. Configure global preferences:
   - Default distribution channels
   - Pricing strategy
   - Release schedule preferences
   - Automatic renewals
3. Set platform-specific options:
   - Promotional materials
   - Editorial pitching
   - Playlist consideration
4. Configure royalty splits for collaborators
5. Save your preferences

### Monitoring Status

To monitor distribution status:

1. Navigate to "Distribution" > "Releases"
2. View all your releases with status indicators:
   - Pending
   - In Review
   - Distributed
   - Needs Attention
   - Rejected
3. Click on any release to see detailed status:
   - Platform-by-platform delivery status
   - Review comments
   - Required actions
   - Release timeline

## Analytics & Reporting

### Performance Dashboard

The performance dashboard provides real-time insights:

1. Navigate to "Analytics" > "Dashboard"
2. View key metrics:
   - Streams by platform
   - Revenue trends
   - Geographic distribution
   - Listener demographics
   - Playlist inclusions
3. Use filters to focus on:
   - Specific releases
   - Date ranges
   - Territories
   - Platforms

### Revenue Reports

To access detailed revenue information:

1. Navigate to "Analytics" > "Revenue"
2. View comprehensive breakdown:
   - Revenue by release
   - Revenue by platform
   - Revenue by territory
   - Historical trends
3. Export reports in multiple formats:
   - CSV
   - Excel
   - PDF
   - JSON

### Custom Reports

To create custom analytics reports:

1. Navigate to "Analytics" > "Custom Reports"
2. Click "New Report"
3. Select metrics to include:
   - Performance metrics
   - Revenue data
   - Audience information
   - Rights activity
4. Configure visualization options
5. Set up automated delivery (email, dashboard, etc.)
6. Save and run the report

## Account Management

### Profile Settings

To manage your account profile:

1. Click your profile icon in the top right
2. Select "Profile Settings"
3. Update your information:
   - Personal/business details
   - Contact information
   - Profile picture
   - Bio/description
4. Manage preferences:
   - Notification settings
   - Privacy options
   - Language and region
5. Save your changes

### Team Management

To manage team access to your account:

1. Navigate to "Account" > "Team"
2. View current team members
3. Click "Add Member" to invite someone new
4. Configure their role and permissions:
   - Admin (full access)
   - Manager (most features, no billing)
   - Artist (limited to specific releases)
   - Analyst (reporting only)
5. Manage existing members:
   - Change permissions
   - Revoke access
   - Review activity logs

### Billing and Subscriptions

To manage billing and subscription:

1. Navigate to "Account" > "Billing"
2. View your current plan and features
3. Manage payment methods
4. View invoice history
5. Change subscription plan:
   - Upgrade for more features
   - Downgrade to reduce costs
   - Add-on services

## Support & Help

### Common Issues

For help with common issues:

1. Visit the Knowledge Base at [https://help.tunemantra.com](https://help.tunemantra.com)
2. Browse by category:
   - Account Issues
   - Rights Management
   - Distribution Problems
   - Payment Questions
   - Technical Difficulties
3. Use the search function to find specific help articles

### Contacting Support

If you need additional help:

1. Navigate to "Support" in the main menu
2. Choose your support option:
   - Live Chat (business hours)
   - Email Support
   - Schedule a Call
3. Provide details about your issue:
   - Description of the problem
   - Steps to reproduce
   - Error messages
   - Screenshots
4. Support team will respond according to your plan's SLA

---

